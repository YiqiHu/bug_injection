public abstract class ITestS3AClientSideEncryption extends AbstractS3ATestBase {  private static final List<Integer> SIZES =      new ArrayList<>(Arrays.asList(0, 1, 255, 4095));  private static final int BIG_FILE_SIZE = 15 * 1024 * 1024;  private static final int SMALL_FILE_SIZE = 1024;    @Test  public void testEncryption() throws Throwable {    describe("Test to verify client-side encryption for different file sizes.");    for (int size : SIZES) {      validateEncryptionForFileSize(size);    }  }    @Test  public void testEncryptionOverRename() throws Throwable {    describe("Test for AWS CSE on Rename Operation.");    maybeSkipTest();    S3AFileSystem fs = getFileSystem();    Path src = path(getMethodName());    byte[] data = dataset(SMALL_FILE_SIZE, 'a', 'z');    writeDataset(fs, src, data, data.length, SMALL_FILE_SIZE,        true, false);    ContractTestUtils.verifyFileContents(fs, src, data);    Path dest = path(src.getName() + "-copy");    fs.rename(src, dest);    ContractTestUtils.verifyFileContents(fs, dest, data);    assertEncrypted(dest);  }    @Test  public void testDirectoryListingFileLengths() throws IOException {    describe("Test to verify directory listing calls gives correct content "        + "lengths");    maybeSkipTest();    S3AFileSystem fs = getFileSystem();    Path parentDir = path(getMethodName());            for (int i : SIZES) {      Path child = new Path(parentDir, getMethodName() + i);      writeThenReadFile(child, i);    }        List<Integer> fileLengthDirListing = new ArrayList<>();    for (FileStatus fileStatus : fs.listStatus(parentDir)) {      fileLengthDirListing.add((int) fileStatus.getLen());    }            Assertions.assertThat(fileLengthDirListing)        .describedAs("File lengths aren't the same "            + "as expected from FileStatus dir. listing")        .containsExactlyInAnyOrderElementsOf(SIZES);        RemoteIterator<LocatedFileStatus> listDir = fs.listFiles(parentDir, true);    List<Integer> fileLengthListLocated = new ArrayList<>();    while (listDir.hasNext()) {      LocatedFileStatus fileStatus = listDir.next();      fileLengthListLocated.add((int) fileStatus.getLen());    }            Assertions.assertThat(fileLengthListLocated)        .describedAs("File lengths isn't same "            + "as expected from LocatedFileStatus dir. listing")        .containsExactlyInAnyOrderElementsOf(SIZES);  }    @Test  public void testBigFilePutAndGet() throws IOException {    maybeSkipTest();    assume("Scale test disabled: to enable set property " +        KEY_SCALE_TESTS_ENABLED, getTestPropertyBool(        getConfiguration(),        KEY_SCALE_TESTS_ENABLED,        DEFAULT_SCALE_TESTS_ENABLED));    S3AFileSystem fs = getFileSystem();    Path filePath = path(getMethodName());    byte[] fileContent = dataset(BIG_FILE_SIZE, 'a', 26);    int offsetSeek = fileContent[BIG_FILE_SIZE - 4];        createFile(fs, filePath, true, fileContent);    LOG.info("Multi-part upload successful...");    try (FSDataInputStream in = fs.open(filePath)) {            in.seek(BIG_FILE_SIZE - 4);      assertEquals("Byte at a specific position not equal to actual byte",          offsetSeek, in.read());      in.seek(0);      assertEquals("Byte at a specific position not equal to actual byte",          'a', in.read());            in.seek(MULTIPART_MIN_SIZE - 1);      int byteBeforeBlockEnd = fileContent[MULTIPART_MIN_SIZE];      assertEquals("Byte before multipart block end mismatch",          byteBeforeBlockEnd - 1, in.read());      assertEquals("Byte at multipart end mismatch",          byteBeforeBlockEnd, in.read());      assertEquals("Byte after multipart end mismatch",          byteBeforeBlockEnd + 1, in.read());            in.seek(BIG_FILE_SIZE + 1);      assertEquals("Byte at eof mismatch",          -1, in.read());            in.readFully(0, fileContent);      verifyFileContents(fs, filePath, fileContent);    }  }    @SuppressWarnings("deprecation")  @Test  public void testEncryptionEnabledAndDisabledFS() throws Exception {    maybeSkipTest();    S3AFileSystem cseDisabledFS = new S3AFileSystem();    Configuration cseDisabledConf = getConfiguration();    S3AFileSystem cseEnabledFS = getFileSystem();    Path unEncryptedFilePath = path(getMethodName());    Path encryptedFilePath = path(getMethodName() + "cse");        removeBaseAndBucketOverrides(getTestBucketName(cseDisabledConf),        cseDisabledConf,        S3_ENCRYPTION_ALGORITHM,        S3_ENCRYPTION_KEY,        SERVER_SIDE_ENCRYPTION_ALGORITHM,        SERVER_SIDE_ENCRYPTION_KEY);    cseDisabledFS.initialize(getFileSystem().getUri(),        cseDisabledConf);        IOStatistics cseDisabledIOStats = cseDisabledFS.getIOStatistics();    IOStatistics cseEnabledIOStatistics = cseEnabledFS.getIOStatistics();    IOStatisticAssertions.assertThatStatisticGauge(cseDisabledIOStats,        Statistic.CLIENT_SIDE_ENCRYPTION_ENABLED.getSymbol()).isEqualTo(0L);    IOStatisticAssertions.assertThatStatisticGauge(cseEnabledIOStatistics,        Statistic.CLIENT_SIDE_ENCRYPTION_ENABLED.getSymbol()).isEqualTo(1L);        try (FSDataOutputStream out = cseDisabledFS.create(unEncryptedFilePath)) {      out.write(new byte[SMALL_FILE_SIZE]);    }        try (FSDataInputStream in = cseEnabledFS.open(unEncryptedFilePath)) {      FileStatus encryptedFSFileStatus =          cseEnabledFS.getFileStatus(unEncryptedFilePath);      assertEquals("Mismatch in content length bytes", SMALL_FILE_SIZE,          encryptedFSFileStatus.getLen());      intercept(SecurityException.class, "",          "SecurityException should be thrown",          () -> {            in.read(new byte[SMALL_FILE_SIZE]);            return "Exception should be raised if unencrypted data is read by "                + "a CSE enabled FS";          });    }        try (FSDataOutputStream out = cseEnabledFS.create(encryptedFilePath)) {      out.write('a');    }        try (FSDataInputStream in = cseDisabledFS.open(encryptedFilePath)) {      FileStatus unEncryptedFSFileStatus =          cseDisabledFS.getFileStatus(encryptedFilePath);                  assertNotEquals("Mismatch in content length", 1,          unEncryptedFSFileStatus.getLen());      Assertions.assertThat(in.read())          .describedAs("Encrypted data shouldn't be equal to actual content "              + "without deciphering")          .isNotEqualTo('a');    }  }  @Override  protected Configuration createConfiguration() {    Configuration conf = super.createConfiguration();    S3ATestUtils.removeBaseAndBucketOverrides(conf, Constants.MULTIPART_SIZE,        Constants.MIN_MULTIPART_THRESHOLD);            conf.set(Constants.MULTIPART_SIZE,        String.valueOf(MULTIPART_MIN_SIZE));    conf.set(Constants.MIN_MULTIPART_THRESHOLD,        String.valueOf(MULTIPART_MIN_SIZE));    return conf;  }    protected void validateEncryptionForFileSize(int len) throws IOException {    maybeSkipTest();    describe("Create an encrypted file of size " + len);        Path path = writeThenReadFile(getMethodName() + len, len);    assertEncrypted(path);    rm(getFileSystem(), path, false, false);  }    protected abstract void maybeSkipTest() throws IOException;    protected abstract void assertEncrypted(Path path) throws IOException;}
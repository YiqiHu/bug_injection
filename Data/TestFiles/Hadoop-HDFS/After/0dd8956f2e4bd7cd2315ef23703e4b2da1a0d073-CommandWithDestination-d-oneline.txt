abstract class CommandWithDestination extends FsCommand {  protected static final Logger LOG = LoggerFactory.getLogger(      CommandWithDestination.class);  protected PathData dst;  private boolean overwrite = false;  private boolean verifyChecksum = true;  private boolean writeChecksum = true;  private boolean lazyPersist = false;  private boolean direct = false;    private static final String RAW = "raw.";    private static final String RESERVED_RAW = "/.reserved/raw";    protected void setOverwrite(boolean flag) {    overwrite = flag;  }    protected void setLazyPersist(boolean flag) {    lazyPersist = flag;  }  protected void setVerifyChecksum(boolean flag) {    verifyChecksum = flag;  }    protected void setWriteChecksum(boolean flag) {    writeChecksum = flag;  }  protected void setDirectWrite(boolean flag) {    direct = flag;  }    protected void setPreserve(boolean preserve) {    if (preserve) {      preserve(FileAttribute.TIMESTAMPS);      preserve(FileAttribute.OWNERSHIP);      preserve(FileAttribute.PERMISSION);    } else {      preserveStatus.clear();    }  }    protected enum FileAttribute {    TIMESTAMPS, OWNERSHIP, PERMISSION, ACL, XATTR;    public static FileAttribute getAttribute(char symbol) {      for (FileAttribute attribute : values()) {        if (attribute.name().charAt(0) == Character.toUpperCase(symbol)) {          return attribute;        }      }      throw new NoSuchElementException("No attribute for " + symbol);    }  }    private EnumSet<FileAttribute> preserveStatus =       EnumSet.noneOf(FileAttribute.class);      private boolean shouldPreserve(FileAttribute attribute) {    return preserveStatus.contains(attribute);  }      protected void preserve(FileAttribute fileAttribute) {    for (FileAttribute attribute : preserveStatus) {      if (attribute.equals(fileAttribute)) {        return;      }    }    preserveStatus.add(fileAttribute);  }    protected void getLocalDestination(LinkedList<String> args)  throws IOException {    String pathString = (args.size() < 2) ? Path.CUR_DIR : args.removeLast();    try {      dst = new PathData(new URI(pathString), getConf());    } catch (URISyntaxException e) {      if (Path.WINDOWS) {                dst = new PathData(pathString, getConf());      } else {        throw new IOException("unexpected URISyntaxException", e);      }    }  }    protected void getRemoteDestination(LinkedList<String> args)  throws IOException {    if (args.size() < 2) {      dst = new PathData(Path.CUR_DIR, getConf());    } else {      String pathString = args.removeLast();            PathData[] items = PathData.expandAsGlob(pathString, getConf());      switch (items.length) {        case 0:          throw new PathNotFoundException(pathString);        case 1:          dst = items[0];          break;        default:          throw new PathIOException(pathString, "Too many matches");      }    }  }  @Override  protected void processArguments(LinkedList<PathData> args)  throws IOException {            if (args.size() > 1) {      if (!dst.exists) {        throw new PathNotFoundException(dst.toString());      }      if (!dst.stat.isDirectory()) {        throw new PathIsNotDirectoryException(dst.toString());      }    } else if (dst.exists) {      if (!dst.stat.isDirectory() && !overwrite) {        LOG.debug("Destination file exists: {}", dst.stat);        throw new PathExistsException(dst.toString());      }    } else if (!dst.parentExists()) {      throw new PathNotFoundException(dst.toString())          .withFullyQualifiedPath(dst.path.toUri().toString());    }    super.processArguments(args);  }  @Override  protected void processPathArgument(PathData src)  throws IOException {    if (src.stat.isDirectory() && src.fs.equals(dst.fs)) {      PathData target = getTargetPath(src);      String srcPath = src.fs.makeQualified(src.path).toString();      String dstPath = dst.fs.makeQualified(target.path).toString();      if (dstPath.equals(srcPath)) {        PathIOException e = new PathIOException(src.toString(),            "are identical");        e.setTargetPath(dstPath.toString());        throw e;      }                  if(!srcPath.endsWith(Path.SEPARATOR)) {        srcPath += Path.SEPARATOR;      }      if(dstPath.startsWith(srcPath)) {        PathIOException e = new PathIOException(src.toString(),            "is a subdirectory of itself");        e.setTargetPath(target.toString());        throw e;      }    }    super.processPathArgument(src);  }  @Override  protected void processPath(PathData src) throws IOException {    processPath(src, getTargetPath(src));  }      protected void processPath(PathData src, PathData dst) throws IOException {    if (src.stat.isSymlink()) {                  throw new PathOperationException(src.toString());            } else if (src.stat.isFile()) {      copyFileToTarget(src, dst);    } else if (src.stat.isDirectory() && !isRecursive()) {      throw new PathIsDirectoryException(src.toString());    }  }  @Override  protected void recursePath(PathData src) throws IOException {    PathData savedDst = dst;    try {                  dst = getTargetPath(src);      final boolean preserveRawXattrs =          checkPathsForReservedRaw(src.path, dst.path);      if (dst.exists) {        if (!dst.stat.isDirectory()) {          throw new PathIsNotDirectoryException(dst.toString());        }      } else {        if (!dst.fs.mkdirs(dst.path)) {                    PathIOException e = new PathIOException(dst.toString());          e.setOperation("mkdir");          throw e;        }            dst.refreshStatus();       }            super.recursePath(src);      if (dst.stat.isDirectory()) {        preserveAttributes(src, dst, preserveRawXattrs);      }    } finally {      dst = savedDst;    }  }    protected PathData getTargetPath(PathData src) throws IOException {    PathData target;            if ((getDepth() > 0) || (dst.exists && dst.stat.isDirectory())) {      target = dst.getPathDataForChild(src);    } else if (dst.representsDirectory()) {       target = dst.getPathDataForChild(src);    } else {      target = dst;    }    return target;  }       protected void copyFileToTarget(PathData src, PathData target)      throws IOException {    final boolean preserveRawXattrs =        checkPathsForReservedRaw(src.path, target.path);    src.fs.setVerifyChecksum(verifyChecksum);    InputStream in = null;    try {      in = src.fs.open(src.path);      copyStreamToTarget(in, target);      preserveAttributes(src, target, preserveRawXattrs);    } finally {      IOUtils.closeStream(in);    }  }      private boolean checkPathsForReservedRaw(Path src, Path target)      throws PathOperationException {    final boolean srcIsRR = Path.getPathWithoutSchemeAndAuthority(src).        toString().startsWith(RESERVED_RAW);    final boolean dstIsRR = Path.getPathWithoutSchemeAndAuthority(target).        toString().startsWith(RESERVED_RAW);    boolean preserveRawXattrs = false;    if (srcIsRR && !dstIsRR) {      final String s = "' copy from '" + RESERVED_RAW + "' to non '" +          RESERVED_RAW + "'. Either both source and target must be in '" +          RESERVED_RAW + "' or neither.";      throw new PathOperationException("'" + src.toString() + s);    } else if (!srcIsRR && dstIsRR) {      final String s = "' copy from non '" + RESERVED_RAW +"' to '" +          RESERVED_RAW + "'. Either both source and target must be in '" +          RESERVED_RAW + "' or neither.";      throw new PathOperationException("'" + dst.toString() + s);    } else if (srcIsRR && dstIsRR) {      preserveRawXattrs = true;    }    return preserveRawXattrs;  }     protected void copyStreamToTarget(InputStream in, PathData target)  throws IOException {    if (target.exists && (target.stat.isDirectory() || !overwrite)) {      throw new PathExistsException(target.toString());    }    TargetFileSystem targetFs = new TargetFileSystem(target.fs);    try {      PathData tempTarget = direct ? target : target.suffix("._COPYING_");      targetFs.setWriteChecksum(writeChecksum);      targetFs.writeStreamToFile(in, tempTarget, lazyPersist, direct);      if (!direct) {        targetFs.rename(tempTarget, target);      }    } finally {      targetFs.close();     }  }    protected void preserveAttributes(PathData src, PathData target,      boolean preserveRawXAttrs)      throws IOException {    if (shouldPreserve(FileAttribute.TIMESTAMPS)) {      target.fs.setTimes(          target.path,          src.stat.getModificationTime(),          src.stat.getAccessTime());    }    if (shouldPreserve(FileAttribute.OWNERSHIP)) {      target.fs.setOwner(          target.path,          src.stat.getOwner(),          src.stat.getGroup());    }    if (shouldPreserve(FileAttribute.PERMISSION) ||        shouldPreserve(FileAttribute.ACL)) {      target.fs.setPermission(          target.path,          src.stat.getPermission());    }    if (shouldPreserve(FileAttribute.ACL)) {      if (src.stat.hasAcl()) {        FsPermission perm = src.stat.getPermission();        List<AclEntry> srcEntries =            src.fs.getAclStatus(src.path).getEntries();        List<AclEntry> srcFullEntries =            AclUtil.getAclFromPermAndEntries(perm, srcEntries);        target.fs.setAcl(target.path, srcFullEntries);      }    }    final boolean preserveXAttrs = shouldPreserve(FileAttribute.XATTR);    if (preserveXAttrs || preserveRawXAttrs) {      Map<String, byte[]> srcXAttrs = src.fs.getXAttrs(src.path);      if (srcXAttrs != null) {        Iterator<Entry<String, byte[]>> iter = srcXAttrs.entrySet().iterator();        while (iter.hasNext()) {          Entry<String, byte[]> entry = iter.next();          final String xattrName = entry.getKey();          if (xattrName.startsWith(RAW) || preserveXAttrs) {            target.fs.setXAttr(target.path, entry.getKey(), entry.getValue());          }        }      }    }  }      private static class TargetFileSystem extends FilterFileSystem {    TargetFileSystem(FileSystem fs) {      super(fs);    }    void writeStreamToFile(InputStream in, PathData target,        boolean lazyPersist, boolean direct)        throws IOException {      FSDataOutputStream out = null;      try {        out = create(target, lazyPersist);        IOUtils.copyBytes(in, out, getConf(), true);      } finally {        if (!direct) {          deleteOnExit(target.path);        }        IOUtils.closeStream(out);       }    }            FSDataOutputStream create(PathData item, boolean lazyPersist)        throws IOException {      if (lazyPersist) {        long defaultBlockSize;        try {          defaultBlockSize = getDefaultBlockSize();        } catch (NotInMountpointException ex) {                                                  defaultBlockSize = getDefaultBlockSize(item.path);        }        EnumSet<CreateFlag> createFlags = EnumSet.of(CREATE, LAZY_PERSIST);        return create(item.path,                      FsPermission.getFileDefault().applyUMask(                          FsPermission.getUMask(getConf())),                      createFlags,                      getConf().getInt(IO_FILE_BUFFER_SIZE_KEY,                          IO_FILE_BUFFER_SIZE_DEFAULT),                      (short) 1,                      defaultBlockSize,                      null,                      null);      } else {        return create(item.path, true);      }    }    void rename(PathData src, PathData target) throws IOException {            if (target.exists && !delete(target.path, false)) {                PathIOException e = new PathIOException(target.toString());        e.setOperation("delete");        throw e;      }      if (!rename(src.path, target.path)) {                PathIOException e = new PathIOException(src.toString());        e.setOperation("rename");        e.setTargetPath(target.toString());        throw e;      }            cancelDeleteOnExit(src.path);    }    @Override    public void close() {            processDeleteOnExit();    }  }}
public class BuiltInGzipDecompressor implements Decompressor {  private static final int GZIP_MAGIC_ID = 0x8b1f;    private static final int GZIP_DEFLATE_METHOD = 8;  private static final int GZIP_FLAGBIT_HEADER_CRC  = 0x02;  private static final int GZIP_FLAGBIT_EXTRA_FIELD = 0x04;  private static final int GZIP_FLAGBIT_FILENAME    = 0x08;  private static final int GZIP_FLAGBIT_COMMENT     = 0x10;  private static final int GZIP_FLAGBITS_RESERVED   = 0xe0;    private Inflater inflater = new Inflater(true);  private byte[] userBuf = null;  private int userBufOff = 0;  private int userBufLen = 0;  private byte[] localBuf = new byte[256];  private int localBufOff = 0;  private int headerBytesRead = 0;  private int trailerBytesRead = 0;  private int numExtraFieldBytesRemaining = -1;  private Checksum crc = DataChecksum.newCrc32();  private boolean hasExtraField = false;  private boolean hasFilename = false;  private boolean hasComment = false;  private boolean hasHeaderCRC = false;  private GzipStateLabel state;    public enum GzipStateLabel {        HEADER_BASIC,        HEADER_EXTRA_FIELD,        HEADER_FILENAME,        HEADER_COMMENT,        HEADER_CRC,        DEFLATE_STREAM,        INFLATE_STREAM,        TRAILER_CRC,        TRAILER_SIZE,        FINISHED,        ENDED;  }    public BuiltInGzipDecompressor() {    state = GzipStateLabel.HEADER_BASIC;    crc.reset();                              }  @Override  public synchronized boolean needsInput() {    if (state == GzipStateLabel.DEFLATE_STREAM) {        return inflater.needsInput();    }            return (state != GzipStateLabel.FINISHED);  }      @Override  public synchronized void setInput(byte[] b, int off, int len) {    if (b == null) {      throw new NullPointerException();    }    if (off < 0 || len < 0 || off > b.length - len) {      throw new ArrayIndexOutOfBoundsException();    }    userBuf = b;    userBufOff = off;    userBufLen = len;    }      @Override  public synchronized int decompress(byte[] b, int off, int len)  throws IOException {    int numAvailBytes = 0;    if (state == GzipStateLabel.ENDED) {      throw new AlreadyClosedException("decompress called on closed decompressor");    }    if (state != GzipStateLabel.DEFLATE_STREAM) {      executeHeaderState();      if (userBufLen <= 0) {        return numAvailBytes;      }    }        if (state == GzipStateLabel.DEFLATE_STREAM) {                              if (userBufLen > 0) {        inflater.setInput(userBuf, userBufOff, userBufLen);        userBufOff += userBufLen;        userBufLen = 0;      }            try {        numAvailBytes = inflater.inflate(b, off, len);      } catch (DataFormatException dfe) {        throw new IOException(dfe.getMessage());      }      crc.update(b, off, numAvailBytes);        if (inflater.finished()) {        state = GzipStateLabel.TRAILER_CRC;        int bytesRemaining = inflater.getRemaining();        assert (bytesRemaining >= 0) :          "logic error: Inflater finished; byte-count is inconsistent";                                      userBufOff -= bytesRemaining;        userBufLen = bytesRemaining;         } else {        return numAvailBytes;        }    }    executeTrailerState();    return numAvailBytes;  }    private void executeHeaderState() throws IOException {            if (userBufLen <= 0) {      return;    }        if (state == GzipStateLabel.HEADER_BASIC) {      int n = Math.min(userBufLen, 10-localBufOff);        checkAndCopyBytesToLocal(n);        if (localBufOff >= 10) {              processBasicHeader();               localBufOff = 0;                    state = GzipStateLabel.HEADER_EXTRA_FIELD;      }    }    if (userBufLen <= 0) {      return;    }        if (state == GzipStateLabel.HEADER_EXTRA_FIELD) {      if (hasExtraField) {                        if (numExtraFieldBytesRemaining < 0) {          int n = Math.min(userBufLen, 2-localBufOff);          checkAndCopyBytesToLocal(n);          if (localBufOff >= 2) {            numExtraFieldBytesRemaining = readUShortLE(localBuf, 0);            localBufOff = 0;          }        }        if (numExtraFieldBytesRemaining > 0 && userBufLen > 0) {          int n = Math.min(userBufLen, numExtraFieldBytesRemaining);          checkAndSkipBytes(n);               numExtraFieldBytesRemaining -= n;        }        if (numExtraFieldBytesRemaining == 0) {          state = GzipStateLabel.HEADER_FILENAME;        }      } else {        state = GzipStateLabel.HEADER_FILENAME;      }    }    if (userBufLen <= 0) {      return;    }    if (state == GzipStateLabel.HEADER_FILENAME) {      if (hasFilename) {        boolean doneWithFilename = checkAndSkipBytesUntilNull();        if (!doneWithFilename) {          return;          }      }      state = GzipStateLabel.HEADER_COMMENT;    }    if (userBufLen <= 0) {      return;    }    if (state == GzipStateLabel.HEADER_COMMENT) {      if (hasComment) {        boolean doneWithComment = checkAndSkipBytesUntilNull();        if (!doneWithComment) {          return;          }      }      state = GzipStateLabel.HEADER_CRC;    }    if (userBufLen <= 0) {      return;    }    if (state == GzipStateLabel.HEADER_CRC) {      if (hasHeaderCRC) {        assert (localBufOff < 2);        int n = Math.min(userBufLen, 2-localBufOff);        copyBytesToLocal(n);        if (localBufOff >= 2) {          long headerCRC = readUShortLE(localBuf, 0);          if (headerCRC != (crc.getValue() & 0xffff)) {            throw new IOException("gzip header CRC failure");          }          localBufOff = 0;          crc.reset();          state = GzipStateLabel.DEFLATE_STREAM;        }      } else {        crc.reset();           state = GzipStateLabel.DEFLATE_STREAM;        }    }  }    private void executeTrailerState() throws IOException {    if (userBufLen <= 0) {      return;    }            if (state == GzipStateLabel.TRAILER_CRC) {                  assert (localBufOff < 4);        int n = Math.min(userBufLen, 4-localBufOff);      copyBytesToLocal(n);      if (localBufOff >= 4) {        long streamCRC = readUIntLE(localBuf, 0);        if (streamCRC != crc.getValue()) {          throw new IOException("gzip stream CRC failure");        }        localBufOff = 0;        crc.reset();        state = GzipStateLabel.TRAILER_SIZE;      }    }    if (userBufLen <= 0) {      return;    }            if (state == GzipStateLabel.TRAILER_SIZE) {      assert (localBufOff < 4);        int n = Math.min(userBufLen, 4-localBufOff);      copyBytesToLocal(n);             if (localBufOff >= 4) {            long inputSize = readUIntLE(localBuf, 0);        if (inputSize != (inflater.getBytesWritten() & 0xffffffffL)) {          throw new IOException(            "stored gzip size doesn't match decompressed size");        }        localBufOff = 0;        state = GzipStateLabel.FINISHED;      }    }    if (state == GzipStateLabel.FINISHED) {      return;    }  }    public synchronized long getBytesRead() {    return headerBytesRead + inflater.getBytesRead() + trailerBytesRead;  }    @Override  public synchronized int getRemaining() {    return userBufLen;  }  @Override  public synchronized boolean needsDictionary() {    return inflater.needsDictionary();  }  @Override  public synchronized void setDictionary(byte[] b, int off, int len) {    inflater.setDictionary(b, off, len);  }    @Override  public synchronized boolean finished() {    return (state == GzipStateLabel.FINISHED);  }    @Override  public synchronized void reset() {        inflater.reset();    state = GzipStateLabel.HEADER_BASIC;    crc.reset();    userBufOff = userBufLen = 0;    localBufOff = 0;    headerBytesRead = 0;    trailerBytesRead = 0;    numExtraFieldBytesRemaining = -1;    hasExtraField = false;    hasFilename = false;    hasComment = false;    hasHeaderCRC = false;  }  @Override  public synchronized void end() {    inflater.end();    state = GzipStateLabel.ENDED;  }      private void processBasicHeader() throws IOException {    if (readUShortLE(localBuf, 0) != GZIP_MAGIC_ID) {      throw new IOException("not a gzip file");    }    if (readUByte(localBuf, 2) != GZIP_DEFLATE_METHOD) {      throw new IOException("gzip data not compressed with deflate method");    }    int flg = readUByte(localBuf, 3);    if ((flg & GZIP_FLAGBITS_RESERVED) != 0) {      throw new IOException("unknown gzip format (reserved flagbits set)");    }    hasExtraField = ((flg & GZIP_FLAGBIT_EXTRA_FIELD) != 0);    hasFilename   = ((flg & GZIP_FLAGBIT_FILENAME)    != 0);    hasComment    = ((flg & GZIP_FLAGBIT_COMMENT)     != 0);    hasHeaderCRC  = ((flg & GZIP_FLAGBIT_HEADER_CRC)  != 0);  }  private void checkAndCopyBytesToLocal(int len) {    System.arraycopy(userBuf, userBufOff, localBuf, localBufOff, len);    localBufOff += len;        crc.update(userBuf, userBufOff, len);    userBufOff += len;    userBufLen -= len;    headerBytesRead += len;  }  private void checkAndSkipBytes(int len) {    crc.update(userBuf, userBufOff, len);    userBufOff += len;    userBufLen -= len;    headerBytesRead += len;  }        private boolean checkAndSkipBytesUntilNull() {    boolean hitNull = false;    if (userBufLen > 0) {      do {        hitNull = (userBuf[userBufOff] == 0);        crc.update(userBuf[userBufOff]);        ++userBufOff;        --userBufLen;        ++headerBytesRead;      } while (userBufLen > 0 && !hitNull);    }    return hitNull;  }      private void copyBytesToLocal(int len) {    System.arraycopy(userBuf, userBufOff, localBuf, localBufOff, len);    localBufOff += len;    userBufOff += len;    userBufLen -= len;    if (state == GzipStateLabel.TRAILER_CRC ||        state == GzipStateLabel.TRAILER_SIZE) {      trailerBytesRead += len;    } else {      headerBytesRead += len;    }  }  private int readUByte(byte[] b, int off) {    return ((int)b[off] & 0xff);  }    private int readUShortLE(byte[] b, int off) {    return ((((b[off+1] & 0xff) << 8) |             ((b[off]   & 0xff)     )) & 0xffff);  }    private long readUIntLE(byte[] b, int off) {    return ((((long)(b[off+3] & 0xff) << 24) |             ((long)(b[off+2] & 0xff) << 16) |             ((long)(b[off+1] & 0xff) <<  8) |             ((long)(b[off]   & 0xff)      )) & 0xffffffffL);  }}
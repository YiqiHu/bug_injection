public class BZip2Codec implements Configurable, SplittableCompressionCodec {  private static final String HEADER = "BZ";  private static final int HEADER_LEN = HEADER.length();  private static final String SUB_HEADER = "h9";  private static final int SUB_HEADER_LEN = SUB_HEADER.length();  private Configuration conf;      @Override  public void setConf(Configuration conf) {    this.conf = conf;  }      @Override  public Configuration getConf() {    return conf;  }      public BZip2Codec() { }    @Override  public CompressionOutputStream createOutputStream(OutputStream out)      throws IOException {    return CompressionCodec.Util.        createOutputStreamWithCodecPool(this, conf, out);  }    @Override  public CompressionOutputStream createOutputStream(OutputStream out,      Compressor compressor) throws IOException {    return Bzip2Factory.isNativeBzip2Loaded(conf) ?      new CompressorStream(out, compressor,                            conf.getInt(IO_FILE_BUFFER_SIZE_KEY,                                   IO_FILE_BUFFER_SIZE_DEFAULT)) :      new BZip2CompressionOutputStream(out);  }    @Override  public Class<? extends Compressor> getCompressorType() {    return Bzip2Factory.getBzip2CompressorType(conf);  }    @Override  public Compressor createCompressor() {    return Bzip2Factory.getBzip2Compressor(conf);  }    @Override  public CompressionInputStream createInputStream(InputStream in)      throws IOException {    return CompressionCodec.Util.        createInputStreamWithCodecPool(this, conf, in);  }    @Override  public CompressionInputStream createInputStream(InputStream in,      Decompressor decompressor) throws IOException {    return Bzip2Factory.isNativeBzip2Loaded(conf) ?       new DecompressorStream(in, decompressor,                             conf.getInt(IO_FILE_BUFFER_SIZE_KEY,                                 IO_FILE_BUFFER_SIZE_DEFAULT)) :      new BZip2CompressionInputStream(              in, 0L, Long.MAX_VALUE, READ_MODE.BYBLOCK);  }    public SplitCompressionInputStream createInputStream(InputStream seekableIn,      Decompressor decompressor, long start, long end, READ_MODE readMode)      throws IOException {    if (!(seekableIn instanceof Seekable)) {      throw new IOException("seekableIn must be an instance of " +          Seekable.class.getName());    }    ((Seekable)seekableIn).seek(start);    return new BZip2CompressionInputStream(seekableIn, start, end, readMode);  }    @Override  public Class<? extends Decompressor> getDecompressorType() {    return Bzip2Factory.getBzip2DecompressorType(conf);  }    @Override  public Decompressor createDecompressor() {    return Bzip2Factory.getBzip2Decompressor(conf);  }    @Override  public String getDefaultExtension() {    return CodecConstants.BZIP2_CODEC_EXTENSION;  }  private static class BZip2CompressionOutputStream extends      CompressionOutputStream {        private CBZip2OutputStream output;    private boolean needsReset;         public BZip2CompressionOutputStream(OutputStream out)        throws IOException {      super(out);      needsReset = true;    }    private void writeStreamHeader() throws IOException {      if (super.out != null) {        writeHeader(out);      }    }    public void finish() throws IOException {      if (needsReset) {                                internalReset();      }      this.output.finish();      needsReset = true;    }    private void internalReset() throws IOException {      if (needsReset) {        needsReset = false;        writeStreamHeader();        this.output = new CBZip2OutputStream(out);      }    }            public void resetState() throws IOException {                  needsReset = true;    }    public void write(int b) throws IOException {      if (needsReset) {        internalReset();      }      this.output.write(b);    }    public void write(byte[] b, int off, int len) throws IOException {      if (needsReset) {        internalReset();      }      this.output.write(b, off, len);    }    public void close() throws IOException {      try {        super.close();      } finally {        output.close();      }    }  }    private static class BZip2CompressionInputStream extends      SplitCompressionInputStream {        private CBZip2InputStream input;    boolean needsReset;    private BufferedInputStream bufferedIn;    private boolean isHeaderStripped = false;    private boolean isSubHeaderStripped = false;    private READ_MODE readMode = READ_MODE.CONTINUOUS;    private long startingPos = 0L;    private boolean didInitialRead;                        private enum POS_ADVERTISEMENT_STATE_MACHINE {      HOLD, ADVERTISE    };    POS_ADVERTISEMENT_STATE_MACHINE posSM = POS_ADVERTISEMENT_STATE_MACHINE.HOLD;    long compressedStreamPosition = 0;        public BZip2CompressionInputStream(InputStream in) throws IOException {      this(in, 0L, Long.MAX_VALUE, READ_MODE.CONTINUOUS);    }    public BZip2CompressionInputStream(InputStream in, long start, long end,        READ_MODE readMode) throws IOException {      super(in, start, end);      needsReset = false;      bufferedIn = new BufferedInputStream(super.in);      this.startingPos = super.getPos();      this.readMode = readMode;      long numSkipped = 0;      if (this.startingPos == 0) {                bufferedIn = readStreamHeader();      } else if (this.readMode == READ_MODE.BYBLOCK  &&          this.startingPos <= HEADER_LEN + SUB_HEADER_LEN) {                                numSkipped = HEADER_LEN + SUB_HEADER_LEN + 1 - this.startingPos;        long skipBytes = numSkipped;        while (skipBytes > 0) {          long s = bufferedIn.skip(skipBytes);          if (s > 0) {            skipBytes -= s;          } else {            if (bufferedIn.read() == -1) {              break;             } else {              skipBytes--;            }          }        }      }      input = new CBZip2InputStream(bufferedIn, readMode);      if (this.isHeaderStripped) {        input.updateReportedByteCount(HEADER_LEN);      }      if (this.isSubHeaderStripped) {        input.updateReportedByteCount(SUB_HEADER_LEN);      }      if (numSkipped > 0) {        input.updateReportedByteCount((int) numSkipped);      }                  if (!(this.readMode == READ_MODE.BYBLOCK && this.startingPos == 0)) {        this.updatePos(false);      }    }    private BufferedInputStream readStreamHeader() throws IOException {                        if (super.in != null) {        bufferedIn.mark(HEADER_LEN);        byte[] headerBytes = new byte[HEADER_LEN];        int actualRead = bufferedIn.read(headerBytes, 0, HEADER_LEN);        if (actualRead != -1) {          String header = new String(headerBytes, StandardCharsets.UTF_8);          if (header.compareTo(HEADER) != 0) {            bufferedIn.reset();          } else {            this.isHeaderStripped = true;                                    if (this.readMode == READ_MODE.BYBLOCK) {              actualRead = bufferedIn.read(headerBytes, 0,                  SUB_HEADER_LEN);              if (actualRead != -1) {                this.isSubHeaderStripped = true;              }            }          }        }      }      if (bufferedIn == null) {        throw new IOException("Failed to read bzip2 stream.");      }      return bufferedIn;    }    public void close() throws IOException {      if (!needsReset) {        try {          input.close();          needsReset = true;        } finally {          super.close();        }      }    }        public int read(byte[] b, int off, int len) throws IOException {      if (b == null) {        throw new NullPointerException();      }      if (off < 0 || len < 0 || len > b.length - off) {        throw new IndexOutOfBoundsException();      }      if (len == 0) {        return 0;      }      if (needsReset) {        internalReset();      }                                          boolean initializedAtEndOfBlock =          !didInitialRead && startingPos > 0 && readMode == READ_MODE.BYBLOCK;      int result = initializedAtEndOfBlock          ? BZip2Constants.END_OF_BLOCK          : this.input.read(b, off, len);      if (result == BZip2Constants.END_OF_BLOCK) {        this.posSM = POS_ADVERTISEMENT_STATE_MACHINE.ADVERTISE;      }      if (this.posSM == POS_ADVERTISEMENT_STATE_MACHINE.ADVERTISE) {        result = this.input.read(b, off, 1);                        this.updatePos(true);        this.posSM = POS_ADVERTISEMENT_STATE_MACHINE.HOLD;      }      didInitialRead = true;      return result;    }    public int read() throws IOException {      byte b[] = new byte[1];      int result = this.read(b, 0, 1);      return (result < 0) ? result : (b[0] & 0xff);    }    private void internalReset() throws IOException {      if (needsReset) {        needsReset = false;        BufferedInputStream bufferedIn = readStreamHeader();        input = new CBZip2InputStream(bufferedIn, this.readMode);        didInitialRead = false;      }    }            public void resetState() throws IOException {                        needsReset = true;    }    public long getPos() {      return this.compressedStreamPosition;      }        private void updatePos(boolean shouldAddOn) {      int addOn = shouldAddOn ? 1 : 0;      this.compressedStreamPosition = this.startingPos          + this.input.getProcessedByteCount() + addOn;    }  }  @VisibleForTesting  public static void writeHeader(OutputStream out) throws IOException {                out.write(HEADER.getBytes(StandardCharsets.UTF_8));  }}
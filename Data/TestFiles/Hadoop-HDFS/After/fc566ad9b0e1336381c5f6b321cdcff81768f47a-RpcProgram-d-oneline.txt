public abstract class RpcProgram extends ChannelInboundHandlerAdapter {  static final Logger LOG = LoggerFactory.getLogger(RpcProgram.class);  public static final int RPCB_PORT = 111;  private final String program;  private final String host;  private int port;   private final int progNumber;  private final int lowProgVersion;  private final int highProgVersion;  protected final boolean allowInsecurePorts;      private final DatagramSocket registrationSocket;    private final int portmapUdpTimeoutMillis;  protected RpcProgram(String program, String host, int port, int progNumber,      int lowProgVersion, int highProgVersion,      DatagramSocket registrationSocket, boolean allowInsecurePorts) {    this(program, host, port, progNumber, lowProgVersion, highProgVersion,            registrationSocket, allowInsecurePorts, 500);  }    protected RpcProgram(String program, String host, int port, int progNumber,      int lowProgVersion, int highProgVersion,      DatagramSocket registrationSocket, boolean allowInsecurePorts,      int portmapUdpTimeoutMillis) {    this.program = program;    this.host = host;    this.port = port;    this.progNumber = progNumber;    this.lowProgVersion = lowProgVersion;    this.highProgVersion = highProgVersion;    this.registrationSocket = registrationSocket;    this.allowInsecurePorts = allowInsecurePorts;    this.portmapUdpTimeoutMillis = portmapUdpTimeoutMillis;    LOG.info("Will " + (allowInsecurePorts ? "" : "not ") + "accept client "        + "connections from unprivileged ports");  }    public void register(int transport, int boundPort) {    if (boundPort != port) {      LOG.info("The bound port is " + boundPort          + ", different with configured port " + port);      port = boundPort;    }        for (int vers = lowProgVersion; vers <= highProgVersion; vers++) {      PortmapMapping mapEntry = new PortmapMapping(progNumber, vers, transport,          port);      register(mapEntry, true);    }  }      public void unregister(int transport, int boundPort) {    if (boundPort != port) {      LOG.info("The bound port is " + boundPort          + ", different with configured port " + port);      port = boundPort;    }        for (int vers = lowProgVersion; vers <= highProgVersion; vers++) {      PortmapMapping mapEntry = new PortmapMapping(progNumber, vers, transport,          port);      register(mapEntry, false);    }  }      protected void register(PortmapMapping mapEntry, boolean set) {    XDR mappingRequest = PortmapRequest.create(mapEntry, set);    SimpleUdpClient registrationClient = new SimpleUdpClient(host, RPCB_PORT,        mappingRequest, true, registrationSocket, portmapUdpTimeoutMillis);    try {      registrationClient.run();    } catch (IOException e) {      String request = set ? "Registration" : "Unregistration";      LOG.error(request + " failure with " + host + ":" + port          + ", portmap entry: " + mapEntry);      throw new RuntimeException(request + " failure", e);    }  }    public void startDaemons() {}  public void stopDaemons() {}    @Override  public void channelRead(ChannelHandlerContext ctx, Object msg)      throws Exception {    RpcInfo info = (RpcInfo) msg;    RpcCall call = (RpcCall) info.header();        SocketAddress remoteAddress = info.remoteAddress();    if (LOG.isTraceEnabled()) {      LOG.trace(program + " procedure #" + call.getProcedure());    }        if (this.progNumber != call.getProgram()) {      LOG.warn("Invalid RPC call program " + call.getProgram());      sendAcceptedReply(call, remoteAddress, AcceptState.PROG_UNAVAIL, ctx);      return;    }    int ver = call.getVersion();    if (ver < lowProgVersion || ver > highProgVersion) {      LOG.warn("Invalid RPC call version " + ver);      sendAcceptedReply(call, remoteAddress, AcceptState.PROG_MISMATCH, ctx);      return;    }        handleInternal(ctx, info);  }    public boolean doPortMonitoring(SocketAddress remoteAddress) {    if (!allowInsecurePorts) {      if (LOG.isTraceEnabled()) {        LOG.trace("Will not allow connections from unprivileged ports. "            + "Checking for valid client port...");      }      if (remoteAddress instanceof InetSocketAddress) {        InetSocketAddress inetRemoteAddress = (InetSocketAddress) remoteAddress;        if (inetRemoteAddress.getPort() > 1023) {          LOG.warn("Connection attempted from '" + inetRemoteAddress + "' "              + "which is an unprivileged port. Rejecting connection.");          return false;        }      } else {        LOG.warn("Could not determine remote port of socket address '"            + remoteAddress + "'. Rejecting connection.");        return false;      }    }    return true;  }    private void sendAcceptedReply(RpcCall call, SocketAddress remoteAddress,      AcceptState acceptState, ChannelHandlerContext ctx) {    RpcAcceptedReply reply = RpcAcceptedReply.getInstance(call.getXid(),        acceptState, VerifierNone.INSTANCE);    XDR out = new XDR();    reply.write(out);    if (acceptState == AcceptState.PROG_MISMATCH) {      out.writeInt(lowProgVersion);      out.writeInt(highProgVersion);    }    ByteBuf b = Unpooled.wrappedBuffer(out.asReadOnlyWrap()        .buffer());    RpcResponse rsp = new RpcResponse(b, remoteAddress);    RpcUtil.sendRpcResponse(ctx, rsp);  }    protected static void sendRejectedReply(RpcCall call,      SocketAddress remoteAddress, ChannelHandlerContext ctx) {    XDR out = new XDR();    RpcDeniedReply reply = new RpcDeniedReply(call.getXid(),        RpcReply.ReplyState.MSG_DENIED,        RpcDeniedReply.RejectState.AUTH_ERROR, new VerifierNone());    reply.write(out);    ByteBuf buf = Unpooled.wrappedBuffer(out.asReadOnlyWrap()        .buffer());    RpcResponse rsp = new RpcResponse(buf, remoteAddress);    RpcUtil.sendRpcResponse(ctx, rsp);  }  protected abstract void handleInternal(ChannelHandlerContext ctx, RpcInfo info);    @Override  public String toString() {    return "Rpc program: " + program + " at " + host + ":" + port;  }    protected abstract boolean isIdempotent(RpcCall call);    public int getPort() {    return port;  }  @VisibleForTesting  public int getPortmapUdpTimeoutMillis() {    return portmapUdpTimeoutMillis;  }}
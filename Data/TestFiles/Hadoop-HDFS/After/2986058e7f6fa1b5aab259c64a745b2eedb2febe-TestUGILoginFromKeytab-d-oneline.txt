public class TestUGILoginFromKeytab {  private MiniKdc kdc;  private File workDir;  private ExecutorService executor;  @Rule  public final TemporaryFolder folder = new TemporaryFolder();  @Before  public void startMiniKdc() throws Exception {            Configuration conf = new Configuration();    conf.set(CommonConfigurationKeys.HADOOP_SECURITY_AUTHENTICATION,        "kerberos");    UserGroupInformation.setConfiguration(conf);    UserGroupInformation.setShouldRenewImmediatelyForTests(true);    workDir = folder.getRoot();    kdc = new MiniKdc(MiniKdc.createConf(), workDir);    kdc.start();    executor = Executors.newCachedThreadPool();  }  @After  public void stopMiniKdc() {    if (kdc != null) {      kdc.stop();    }    if (executor != null) {      executor.shutdownNow();    }  }    @Test  public void testUGILoginFromKeytab() throws Exception {    long beforeLogin = Time.now();    String principal = "foo";    File keytab = new File(workDir, "foo.keytab");    kdc.createPrincipal(keytab, principal);    UserGroupInformation.loginUserFromKeytab(principal, keytab.getPath());    UserGroupInformation ugi = UserGroupInformation.getLoginUser();    Assert.assertTrue("UGI should be configured to login from keytab",        ugi.isFromKeytab());    User user = getUser(ugi.getSubject());    Assert.assertNotNull(user.getLogin());     Assert.assertTrue("User login time is less than before login time, "        + "beforeLoginTime:" + beforeLogin + " userLoginTime:" + user.getLastLogin(),            user.getLastLogin() > beforeLogin);  }    @Test  public void testUGIReLoginFromKeytab() throws Exception {    String principal = "foo";    File keytab = new File(workDir, "foo.keytab");    kdc.createPrincipal(keytab, principal);    UserGroupInformation.loginUserFromKeytab(principal, keytab.getPath());    UserGroupInformation ugi = UserGroupInformation.getLoginUser();    Assert.assertTrue("UGI should be configured to login from keytab",        ugi.isFromKeytab());        User user = getUser(ugi.getSubject());    final long firstLogin = user.getLastLogin();    final LoginContext login1 = user.getLogin();    Assert.assertNotNull(login1);        Thread.sleep(2000);    ugi.reloginFromKeytab();    final long secondLogin = user.getLastLogin();    final LoginContext login2 = user.getLogin();    Assert.assertTrue("User should have been able to relogin from keytab",        secondLogin > firstLogin);    Assert.assertNotNull(login2);    Assert.assertNotSame(login1, login2);  }  @Test  public void testGetUGIFromKnownSubject() throws Exception {    KerberosPrincipal principal = new KerberosPrincipal("user");    File keytab = new File(workDir, "user.keytab");    kdc.createPrincipal(keytab, principal.getName());    UserGroupInformation ugi1 =      UserGroupInformation.loginUserFromKeytabAndReturnUGI(        principal.getName(), keytab.getPath());    Subject subject = ugi1.getSubject();    User user = getUser(subject);    Assert.assertNotNull(user);    LoginContext login = user.getLogin();    Assert.assertNotNull(login);        UserGroupInformation ugi2 = UserGroupInformation.getUGIFromSubject(subject);    Assert.assertSame(user, getUser(ugi2.getSubject()));    Assert.assertSame(login, user.getLogin());  }  @Test  public void testGetUGIFromExternalSubject() throws Exception {    KerberosPrincipal principal = new KerberosPrincipal("user");    File keytab = new File(workDir, "user.keytab");    kdc.createPrincipal(keytab, principal.getName());    UserGroupInformation ugi =      UserGroupInformation.loginUserFromKeytabAndReturnUGI(        principal.getName(), keytab.getPath());    Subject subject = ugi.getSubject();    removeUser(subject);            UserGroupInformation ugi1 = UserGroupInformation.getUGIFromSubject(subject);    Assert.assertSame(subject, ugi1.getSubject());    User user = getUser(subject);    Assert.assertNotNull(user);    Assert.assertEquals(principal.getName(), user.getName());    Assert.assertNull(user.getLogin());        UserGroupInformation ugi2 = UserGroupInformation.getUGIFromSubject(subject);    Assert.assertSame(subject, ugi2.getSubject());    Assert.assertSame(user, getUser(ugi2.getSubject()));    Assert.assertNull(user.getLogin());  }  @Test  public void testGetUGIFromExternalSubjectWithLogin() throws Exception {    KerberosPrincipal principal = new KerberosPrincipal("user");    File keytab = new File(workDir, "user.keytab");    kdc.createPrincipal(keytab, principal.getName());            UserGroupInformation ugi =      UserGroupInformation.loginUserFromKeytabAndReturnUGI(        principal.getName(), keytab.getPath());    Subject subject = ugi.getSubject();    User user = getUser(subject);    final LoginContext dummyLogin = Mockito.mock(LoginContext.class);    user.setLogin(dummyLogin);        UserGroupInformation ugi2 = UserGroupInformation.getUGIFromSubject(subject);    Assert.assertSame(subject, ugi2.getSubject());    Assert.assertSame(user, getUser(ugi2.getSubject()));    Assert.assertSame(dummyLogin, user.getLogin());  }  @Test  public void testUGIRefreshFromKeytab() throws Exception {    final Configuration conf = new Configuration();    conf.setBoolean(HADOOP_KERBEROS_KEYTAB_LOGIN_AUTORENEWAL_ENABLED, true);    SecurityUtil.setAuthenticationMethod(            UserGroupInformation.AuthenticationMethod.KERBEROS, conf);    UserGroupInformation.setConfiguration(conf);    String principal = "bar";    File keytab = new File(workDir, "bar.keytab");    kdc.createPrincipal(keytab, principal);    UserGroupInformation.loginUserFromKeytab(principal, keytab.getPath());    UserGroupInformation ugi = UserGroupInformation.getLoginUser();    Assert.assertEquals(UserGroupInformation.AuthenticationMethod.KERBEROS,        ugi.getAuthenticationMethod());    Assert.assertTrue(ugi.isFromKeytab());    Assert.assertTrue(            UserGroupInformation.isKerberosKeyTabLoginRenewalEnabled());    Assert.assertTrue(            UserGroupInformation.getKerberosLoginRenewalExecutor()                    .isPresent());  }  @Test  public void testUGIRefreshFromKeytabDisabled() throws Exception {    GenericTestUtils.setLogLevel(UserGroupInformation.LOG, Level.DEBUG);    final Configuration conf = new Configuration();    conf.setLong(HADOOP_KERBEROS_MIN_SECONDS_BEFORE_RELOGIN, 1);    conf.setBoolean(HADOOP_KERBEROS_KEYTAB_LOGIN_AUTORENEWAL_ENABLED, false);    SecurityUtil.setAuthenticationMethod(            UserGroupInformation.AuthenticationMethod.KERBEROS, conf);    UserGroupInformation.setConfiguration(conf);    String principal = "bar";    File keytab = new File(workDir, "bar.keytab");    kdc.createPrincipal(keytab, principal);    UserGroupInformation.loginUserFromKeytab(principal, keytab.getPath());    UserGroupInformation ugi = UserGroupInformation.getLoginUser();    Assert.assertEquals(UserGroupInformation.AuthenticationMethod.KERBEROS,            ugi.getAuthenticationMethod());    Assert.assertTrue(ugi.isFromKeytab());    Assert.assertFalse(            UserGroupInformation.isKerberosKeyTabLoginRenewalEnabled());    Assert.assertFalse(            UserGroupInformation.getKerberosLoginRenewalExecutor()                    .isPresent());  }  private static KerberosTicket getTicket(UserGroupInformation ugi) {    Set<KerberosTicket> tickets =        ugi.getSubject().getPrivateCredentials(KerberosTicket.class);    return tickets.isEmpty() ? null : tickets.iterator().next();  }      private static KerberosTicket checkTicketAndKeytab(UserGroupInformation ugi,      KerberosPrincipal principal, boolean expectIsKeytab) {    Assert.assertEquals("wrong principal",      principal.getName(), ugi.getUserName());    Assert.assertEquals("is not keytab",      expectIsKeytab, ugi.isFromKeytab());    KerberosTicket ticket = getTicket(ugi);    Assert.assertNotNull("no ticket", ticket);    Assert.assertEquals("wrong principal", principal, ticket.getClient());    return ticket;  }  @Test  public void testReloginForUGIFromSubject() throws Exception {    KerberosPrincipal principal1 = new KerberosPrincipal("user1");    File keytab1 = new File(workDir, "user1.keytab");    kdc.createPrincipal(keytab1, principal1.getName());    KerberosPrincipal principal2 = new KerberosPrincipal("user2");    File keytab2 = new File(workDir, "user2.keytab");    kdc.createPrincipal(keytab2, principal2.getName());            final Subject extSubject =      UserGroupInformation.loginUserFromKeytabAndReturnUGI(        principal2.getName(), keytab2.getPath()).getSubject();    removeUser(extSubject);        UserGroupInformation.loginUserFromKeytab(        principal1.getName(), keytab1.getPath());    final UserGroupInformation loginUser = UserGroupInformation.getLoginUser();    loginUser.doAs(new PrivilegedExceptionAction<Void>() {      @Override      public Void run() throws IOException {        KerberosTicket loginTicket =            checkTicketAndKeytab(loginUser, principal1, true);                UserGroupInformation extSubjectUser =            UserGroupInformation.getUGIFromSubject(extSubject);        KerberosTicket ticket =          checkTicketAndKeytab(extSubjectUser, principal2, false);                loginUser.reloginFromKeytab();        KerberosTicket newLoginTicket =            checkTicketAndKeytab(loginUser, principal1, true);        Assert.assertNotEquals(loginTicket.getAuthTime(),            newLoginTicket.getAuthTime());                extSubjectUser.reloginFromKeytab();        Assert.assertSame(ticket,            checkTicketAndKeytab(extSubjectUser, principal2, false));                Assert.assertSame(newLoginTicket,            checkTicketAndKeytab(loginUser, principal1, true));        return null;      }    });  }  @Test  public void testReloginForLoginFromSubject() throws Exception {    KerberosPrincipal principal1 = new KerberosPrincipal("user1");    File keytab1 = new File(workDir, "user1.keytab");    kdc.createPrincipal(keytab1, principal1.getName());    KerberosPrincipal principal2 = new KerberosPrincipal("user2");    File keytab2 = new File(workDir, "user2.keytab");    kdc.createPrincipal(keytab2, principal2.getName());        UserGroupInformation.loginUserFromKeytab(        principal1.getName(), keytab1.getPath());    final UserGroupInformation originalLoginUser =        UserGroupInformation.getLoginUser();    Assert.assertNotNull(getUser(originalLoginUser.getSubject()).getLogin());    originalLoginUser.doAs(new PrivilegedExceptionAction<Void>() {      @Override      public Void run() throws IOException {        KerberosTicket originalLoginUserTicket =            checkTicketAndKeytab(originalLoginUser, principal1, true);                        final Subject subject =          UserGroupInformation.loginUserFromKeytabAndReturnUGI(            principal2.getName(), keytab2.getPath()).getSubject();        removeUser(subject);                UserGroupInformation.loginUserFromSubject(subject);        Assert.assertNull(getUser(subject).getLogin());        UserGroupInformation extLoginUser =          UserGroupInformation.getLoginUser();        KerberosTicket extLoginUserTicket =            checkTicketAndKeytab(extLoginUser, principal2, false);                        extLoginUser.reloginFromKeytab();        Assert.assertSame(extLoginUserTicket,          checkTicketAndKeytab(extLoginUser, principal2, false));        Assert.assertSame(originalLoginUserTicket,          checkTicketAndKeytab(originalLoginUser, principal1, true));                        originalLoginUser.reloginFromKeytab();        Assert.assertNotSame(originalLoginUserTicket,            checkTicketAndKeytab(originalLoginUser, principal1, true));        Assert.assertSame(extLoginUserTicket,            checkTicketAndKeytab(extLoginUser, principal2, false));        return null;      }    });  }  @Test  public void testReloginAfterFailedRelogin() throws Exception {    KerberosPrincipal principal = new KerberosPrincipal("user1");    File keytab = new File(workDir, "user1.keytab");    File keytabBackup = new File(keytab + ".backup");    kdc.createPrincipal(keytab, principal.getName());    UserGroupInformation.loginUserFromKeytab(        principal.getName(), keytab.getPath());    final UserGroupInformation loginUser = UserGroupInformation.getLoginUser();    checkTicketAndKeytab(loginUser, principal, true);        Assert.assertTrue(keytab.renameTo(keytabBackup));    try {      loginUser.reloginFromKeytab();      Assert.fail("relogin should fail");    } catch (KerberosAuthException kae) {          }        Assert.assertTrue(loginUser.isFromKeytab());    Assert.assertNull(getTicket(loginUser));        Assert.assertTrue(keytabBackup.renameTo(keytab));    loginUser.reloginFromKeytab();    checkTicketAndKeytab(loginUser, principal, true);  }      @Test(timeout=180000)  public void testConcurrentRelogin() throws Exception {    final CyclicBarrier barrier = new CyclicBarrier(2);    final CountDownLatch latch = new CountDownLatch(1);    assertTrue(UserGroupInformation.isSecurityEnabled());    KerberosPrincipal principal = new KerberosPrincipal("testUser");    File keytab = new File(workDir, "user1.keytab");    kdc.createPrincipal(keytab, principal.getName());        final UserGroupInformation loginUgi =        UserGroupInformation.loginUserFromKeytabAndReturnUGI(          principal.getName(), keytab.getPath());    assertEquals(AuthenticationMethod.KERBEROS,        loginUgi.getAuthenticationMethod());    assertTrue(loginUgi.isFromKeytab());        final UserGroupInformation clonedUgi =        UserGroupInformation.getUGIFromSubject(loginUgi.getSubject());    assertEquals(AuthenticationMethod.KERBEROS,        clonedUgi.getAuthenticationMethod());    assertTrue(clonedUgi.isFromKeytab());            User user = getUser(loginUgi.getSubject());    final LoginContext spyLogin = Mockito.spy(user.getLogin());    user.setLogin(spyLogin);    Mockito.doAnswer(new Answer<Void>(){      @Override      public Void answer(InvocationOnMock invocation)          throws Throwable {        invocation.callRealMethod();        latch.countDown();        barrier.await();        return null;      }    }).when(spyLogin).logout();    Future<Void> relogin = executor.submit(        new Callable<Void>(){          @Override          public Void call() throws Exception {            Thread.currentThread().setName("relogin");            loginUgi.reloginFromKeytab();            return null;          }        });            assertTrue("first relogin didn't block",      latch.await(2, TimeUnit.SECONDS));            assertTrue(clonedUgi.isFromKeytab());        Mockito.doNothing().when(spyLogin).logout();    Mockito.doNothing().when(spyLogin).login();    Future<UserGroupInformation> clonedRelogin = executor.submit(        new Callable<UserGroupInformation>(){          @Override          public UserGroupInformation call() throws Exception {            Thread.currentThread().setName("clonedRelogin");            clonedUgi.reloginFromKeytab();            return clonedUgi;          }        });    try {      clonedRelogin.get(2, TimeUnit.SECONDS);      fail("second relogin didn't block!");    } catch (TimeoutException te) {          }            loginUgi.doAs(new PrivilegedExceptionAction<Void>(){      @Override      public Void run() throws Exception {        UserGroupInformation ugi = UserGroupInformation.getCurrentUser();        assertEquals(principal.getName(), ugi.getUserName());        assertTrue(ugi.isFromKeytab());        return null;      }    });    clonedUgi.doAs(new PrivilegedExceptionAction<Void>(){      @Override      public Void run() throws Exception {        UserGroupInformation ugi = UserGroupInformation.getCurrentUser();        assertEquals(principal.getName(), ugi.getUserName());        assertTrue(ugi.isFromKeytab());        return null;      }    });            assertFalse(clonedRelogin.isDone());    barrier.await();    relogin.get();    clonedRelogin.get();  }  private User getUser(Subject subject) {    Iterator<User> iter = subject.getPrincipals(User.class).iterator();    return iter.hasNext() ? iter.next() : null;  }  private void removeUser(Subject subject) {        for (Iterator<Principal> iter = subject.getPrincipals().iterator();         iter.hasNext(); ) {      if (iter.next() instanceof User) {        iter.remove();      }    }  }}
public class TestViewfsFileStatus {  private static final File TEST_DIR = GenericTestUtils.getTestDir(      TestViewfsFileStatus.class.getSimpleName());  @Before  public void setUp() {    FileUtil.fullyDelete(TEST_DIR);    assertTrue(TEST_DIR.mkdirs());  }  @After  public void tearDown() throws IOException {    FileUtil.fullyDelete(TEST_DIR);  }  @Test  public void testFileStatusSerialziation()      throws IOException, URISyntaxException {    String testfilename = "testFileStatusSerialziation";    TEST_DIR.mkdirs();    File infile = new File(TEST_DIR, testfilename);    final byte[] content = "dingos".getBytes();    try (FileOutputStream fos =  new FileOutputStream(infile)) {      fos.write(content);    }    assertEquals((long)content.length, infile.length());    Configuration conf = new Configuration();    ConfigUtil.addLink(conf, "/foo/bar/baz", TEST_DIR.toURI());    try (FileSystem vfs = FileSystem.get(FsConstants.VIEWFS_URI, conf)) {      assertEquals(ViewFileSystem.class, vfs.getClass());      Path path = new Path("/foo/bar/baz", testfilename);      FileStatus stat = vfs.getFileStatus(path);      assertEquals(content.length, stat.getLen());      ContractTestUtils.assertNotErasureCoded(vfs, path);      assertTrue(path + " should have erasure coding unset in " +          "FileStatus#toString(): " + stat,          stat.toString().contains("isErasureCoded=false"));            DataOutputBuffer dob = new DataOutputBuffer();      stat.write(dob);      DataInputBuffer dib = new DataInputBuffer();      dib.reset(dob.getData(), 0, dob.getLength());      FileStatus deSer = new FileStatus();      deSer.readFields(dib);      assertEquals(content.length, deSer.getLen());      assertFalse(deSer.isErasureCoded());    }  }    @Test  public void testListStatusACL() throws IOException {    String testfilename = "testFileACL";    String childDirectoryName = "testDirectoryACL";    TEST_DIR.mkdirs();    File infile = new File(TEST_DIR, testfilename);    final byte[] content = "dingos".getBytes();    try (FileOutputStream fos =  new FileOutputStream(infile)) {      fos.write(content);    }    assertEquals(content.length, infile.length());    File childDir = new File(TEST_DIR, childDirectoryName);    childDir.mkdirs();    Configuration conf = new Configuration();    ConfigUtil.addLink(conf, "/file", infile.toURI());    ConfigUtil.addLink(conf, "/dir", childDir.toURI());    try (FileSystem vfs = FileSystem.get(FsConstants.VIEWFS_URI, conf)) {      assertEquals(ViewFileSystem.class, vfs.getClass());      FileStatus[] statuses = vfs.listStatus(new Path("/"));      FileSystem localFs = FileSystem.getLocal(conf);      FileStatus fileStat = localFs.getFileStatus(new Path(infile.getPath()));      FileStatus dirStat = localFs.getFileStatus(new Path(childDir.getPath()));      for (FileStatus status : statuses) {        if (status.getPath().getName().equals("file")) {          assertEquals(fileStat.getPermission(), status.getPermission());        } else {          assertEquals(dirStat.getPermission(), status.getPermission());        }      }      localFs.setPermission(new Path(infile.getPath()),          FsPermission.valueOf("-rwxr--r--"));      localFs.setPermission(new Path(childDir.getPath()),          FsPermission.valueOf("-r--rwxr--"));      statuses = vfs.listStatus(new Path("/"));      for (FileStatus status : statuses) {        if (status.getPath().getName().equals("file")) {          assertEquals(FsPermission.valueOf("-rwxr--r--"),              status.getPermission());        } else {          assertEquals(FsPermission.valueOf("-r--rwxr--"),              status.getPermission());        }      }    }  }      @Test  public void testGetFileChecksum() throws IOException {    final Path path = new Path("/tmp/someFile");    FileSystem mockFS = Mockito.mock(FileSystem.class);    InodeTree.ResolveResult<FileSystem> res =      new InodeTree.ResolveResult<FileSystem>(null, mockFS , null,        new Path("someFile"));    @SuppressWarnings("unchecked")    InodeTree<FileSystem> fsState = Mockito.mock(InodeTree.class);    Mockito.when(fsState.resolve(path.toString(), true)).thenReturn(res);    ViewFileSystem vfs = Mockito.mock(ViewFileSystem.class);    vfs.fsState = fsState;    Mockito.when(vfs.getFileChecksum(path)).thenCallRealMethod();    Mockito.when(vfs.getUriPath(path)).thenCallRealMethod();    vfs.getFileChecksum(path);    Mockito.verify(mockFS).getFileChecksum(new Path("someFile"));  }  @AfterClass  public static void cleanup() throws IOException {    FileUtil.fullyDelete(TEST_DIR);  }}
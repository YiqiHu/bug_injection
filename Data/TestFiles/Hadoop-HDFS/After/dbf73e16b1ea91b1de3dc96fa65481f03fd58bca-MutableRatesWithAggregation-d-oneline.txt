public class MutableRatesWithAggregation extends MutableMetric {  static final Logger LOG =      LoggerFactory.getLogger(MutableRatesWithAggregation.class);  private final Map<String, MutableRate> globalMetrics =      new ConcurrentHashMap<>();  private final Set<Class<?>> protocolCache = new HashSet<>();  private final ConcurrentLinkedDeque<WeakReference<ConcurrentMap<String, ThreadSafeSampleStat>>>      weakReferenceQueue = new ConcurrentLinkedDeque<>();  private final ThreadLocal<ConcurrentMap<String, ThreadSafeSampleStat>>      threadLocalMetricsMap = new ThreadLocal<>();    private String typePrefix = "";    public void init(Class<?> protocol) {    if (protocolCache.contains(protocol)) {      return;    }    protocolCache.add(protocol);    for (Method method : protocol.getMethods()) {      String name = method.getName();      LOG.debug(name);      addMetricIfNotExists(name);    }  }    public void init(String[] names) {    for (String name : names) {      addMetricIfNotExists(name);    }  }    public void add(String name, long elapsed) {    ConcurrentMap<String, ThreadSafeSampleStat> localStats =        threadLocalMetricsMap.get();    if (localStats == null) {      localStats = new ConcurrentHashMap<>();      threadLocalMetricsMap.set(localStats);      weakReferenceQueue.add(new WeakReference<>(localStats));    }    ThreadSafeSampleStat stat = localStats.get(name);    if (stat == null) {      stat = new ThreadSafeSampleStat();      localStats.put(name, stat);    }    stat.add(elapsed);  }  @Override  public synchronized void snapshot(MetricsRecordBuilder rb, boolean all) {    Iterator<WeakReference<ConcurrentMap<String, ThreadSafeSampleStat>>> iter =        weakReferenceQueue.iterator();    while (iter.hasNext()) {      ConcurrentMap<String, ThreadSafeSampleStat> map = iter.next().get();      if (map == null) {                iter.remove();      } else {        aggregateLocalStatesToGlobalMetrics(map);      }    }    for (MutableRate globalMetric : globalMetrics.values()) {      globalMetric.snapshot(rb, all);    }  }    synchronized void collectThreadLocalStates() {    final ConcurrentMap<String, ThreadSafeSampleStat> localStats =        threadLocalMetricsMap.get();    if (localStats != null) {      aggregateLocalStatesToGlobalMetrics(localStats);    }  }    private void aggregateLocalStatesToGlobalMetrics(      final ConcurrentMap<String, ThreadSafeSampleStat> localStats) {    for (Map.Entry<String, ThreadSafeSampleStat> entry : localStats        .entrySet()) {      String name = entry.getKey();      MutableRate globalMetric = addMetricIfNotExists(name);      entry.getValue().snapshotInto(globalMetric);    }  }  Map<String, MutableRate> getGlobalMetrics() {    return globalMetrics;  }  private synchronized MutableRate addMetricIfNotExists(String name) {    MutableRate metric = globalMetrics.get(name);    if (metric == null) {      metric = new MutableRate(name + typePrefix, name + typePrefix, false);      metric.setUpdateTimeStamp(true);      globalMetrics.put(name, metric);    }    return metric;  }  private static class ThreadSafeSampleStat {    private SampleStat stat = new SampleStat();    synchronized void add(double x) {      stat.add(x);    }    synchronized void snapshotInto(MutableRate metric) {      if (stat.numSamples() > 0) {        metric.add(stat.numSamples(), Math.round(stat.total()));        stat.reset();      }    }  }  public void init(Class<?> protocol, String prefix) {    this.typePrefix = prefix;    init(protocol);  }}
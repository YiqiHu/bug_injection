public class SinglePendingCommit extends PersistentCommitData    implements Iterable<String> {    private static final long serialVersionUID = 0x10000 + VERSION;    private int version = VERSION;    private String filename;    private String uri = "";    private String uploadId;    private String bucket;    private String destinationKey;    private long created;    private long saved;    private String date;    private String jobId = "";    private String taskId = "";    private String text = "";    private List<String> etags;    private Map<String, String> extraData = new HashMap<>(0);    private long length;  public SinglePendingCommit() {  }    public static JsonSerialization<SinglePendingCommit> serializer() {    return new JsonSerialization<>(SinglePendingCommit.class, false, true);  }    public static SinglePendingCommit load(FileSystem fs, Path path)      throws IOException {    SinglePendingCommit instance = serializer().load(fs, path);    instance.filename = path.toString();    instance.validate();    return instance;  }    private void readObject(ObjectInputStream inStream) throws IOException,      ClassNotFoundException {    inStream.defaultReadObject();    validate();  }    public void touch(long millis) {    created = millis;    saved = millis;    date = new Date(millis).toString();  }    public void bindCommitData(List<PartETag> parts) throws ValidationFailure {    etags = new ArrayList<>(parts.size());    int counter = 1;    for (PartETag part : parts) {      verify(part.getPartNumber() == counter,          "Expected part number %s but got %s", counter, part.getPartNumber());      etags.add(part.getETag());      counter++;    }  }  @Override  public void validate() throws ValidationFailure {    verify(version == VERSION, "Wrong version: %s", version);    verify(StringUtils.isNotEmpty(bucket), "Empty bucket");    verify(StringUtils.isNotEmpty(destinationKey),        "Empty destination");    verify(StringUtils.isNotEmpty(uploadId), "Empty uploadId");    verify(length >= 0, "Invalid length: " + length);    destinationPath();    verify(etags != null, "No etag list");    validateCollectionClass(etags, String.class);    for (String etag : etags) {      verify(StringUtils.isNotEmpty(etag), "Empty etag");    }    if (extraData != null) {      validateCollectionClass(extraData.keySet(), String.class);      validateCollectionClass(extraData.values(), String.class);    }  }  @Override  public String toString() {    final StringBuilder sb = new StringBuilder(        "DelayedCompleteData{");    sb.append("version=").append(version);    sb.append(", uri='").append(uri).append('\'');    sb.append(", destination='").append(destinationKey).append('\'');    sb.append(", uploadId='").append(uploadId).append('\'');    sb.append(", created=").append(created);    sb.append(", saved=").append(saved);    sb.append(", size=").append(length);    sb.append(", date='").append(date).append('\'');    sb.append(", jobId='").append(jobId).append('\'');    sb.append(", taskId='").append(taskId).append('\'');    sb.append(", notes='").append(text).append('\'');    if (etags != null) {      sb.append(", etags=[");      sb.append(join(",", etags));      sb.append(']');    } else {      sb.append(", etags=null");    }    sb.append('}');    return sb.toString();  }  @Override  public byte[] toBytes() throws IOException {    validate();    return serializer().toBytes(this);  }  @Override  public void save(FileSystem fs, Path path, boolean overwrite)      throws IOException {    serializer().save(fs, path, this, overwrite);  }    public Path destinationPath() {    Preconditions.checkState(StringUtils.isNotEmpty(uri), "Empty uri");    try {      return new Path(new URI(uri));    } catch (URISyntaxException e) {      throw new IllegalStateException("Cannot parse URI " + uri);    }  }    public int getPartCount() {    return etags.size();  }    @Override  public Iterator<String> iterator() {    return etags.iterator();  }    public int getVersion() {    return version;  }  public void setVersion(int version) {    this.version = version;  }    public String getFilename() {    return filename;  }  public void setFilename(String filename) {    this.filename = filename;  }    public String getUri() {    return uri;  }  public void setUri(String uri) {    this.uri = uri;  }    public String getUploadId() {    return uploadId;  }  public void setUploadId(String uploadId) {    this.uploadId = uploadId;  }    public String getBucket() {    return bucket;  }  public void setBucket(String bucket) {    this.bucket = bucket;  }    public String getDestinationKey() {    return destinationKey;  }  public void setDestinationKey(String destinationKey) {    this.destinationKey = destinationKey;  }    public long getCreated() {    return created;  }  public void setCreated(long created) {    this.created = created;  }    public long getSaved() {    return saved;  }  public void setSaved(long saved) {    this.saved = saved;  }    public String getDate() {    return date;  }  public void setDate(String date) {    this.date = date;  }    public String getJobId() {    return jobId;  }  public void setJobId(String jobId) {    this.jobId = jobId;  }    public String getTaskId() {    return taskId;  }  public void setTaskId(String taskId) {    this.taskId = taskId;  }    public String getText() {    return text;  }  public void setText(String text) {    this.text = text;  }    public List<String> getEtags() {    return etags;  }  public void setEtags(List<String> etags) {    this.etags = etags;  }    public Map<String, String> getExtraData() {    return extraData;  }  public void setExtraData(Map<String, String> extraData) {    this.extraData = extraData;  }    public void putExtraData(String key, String value) {    extraData.put(key, value);  }    public long getLength() {    return length;  }  public void setLength(long length) {    this.length = length;  }}
public class TestFileUtil {  private static final Logger LOG = LoggerFactory.getLogger(TestFileUtil.class);  @Rule  public TemporaryFolder testFolder = new TemporaryFolder();  private static final String FILE = "x";  private static final String LINK = "y";  private static final String DIR = "dir";  private static final String FILE_1_NAME = "file1";  private File del;  private File tmp;  private File dir1;  private File dir2;  private File partitioned;  private File xSubDir;  private File xSubSubDir;  private File ySubDir;  private File file2;  private File file22;  private File file3;  private File zlink;  private InetAddress inet1;  private InetAddress inet2;  private InetAddress inet3;  private InetAddress inet4;  private InetAddress inet5;  private InetAddress inet6;  private URI uri1;  private URI uri2;  private URI uri3;  private URI uri4;  private URI uri5;  private URI uri6;  private FileSystem fs1;  private FileSystem fs2;  private FileSystem fs3;  private FileSystem fs4;  private FileSystem fs5;  private FileSystem fs6;    @Before  public void setup() throws IOException {    del = testFolder.newFolder("del");    tmp = testFolder.newFolder("tmp");    partitioned = testFolder.newFolder("partitioned");    zlink = new File(del, "zlink");    xSubDir = new File(del, "xSubDir");    xSubSubDir = new File(xSubDir, "xSubSubDir");    ySubDir = new File(del, "ySubDir");    file2 = new File(xSubDir, "file2");    file22 = new File(xSubSubDir, "file22");    file3 = new File(ySubDir, "file3");    dir1 = new File(del, DIR + "1");    dir2 = new File(del, DIR + "2");    FileUtils.forceMkdir(dir1);    FileUtils.forceMkdir(dir2);    new File(del, FILE).createNewFile();    File tmpFile = new File(tmp, FILE);    tmpFile.createNewFile();        new File(dir1, FILE).createNewFile();    new File(dir2, FILE).createNewFile();        File link = new File(del, LINK);    FileUtil.symLink(tmpFile.toString(), link.toString());        File linkDir = new File(del, "tmpDir");    FileUtil.symLink(tmp.toString(), linkDir.toString());    Assert.assertEquals(5, del.listFiles().length);        createFile(partitioned, "part-r-00000", "foo");    createFile(partitioned, "part-r-00001", "bar");        FileUtil.symLink(del.toString(), dir1.toString() + "/cycle");  }  @After  public void tearDown() throws IOException {    testFolder.delete();  }    private File createFile(File directory, String name, String contents)      throws IOException {    File newFile = new File(directory, name);    PrintWriter pw = new PrintWriter(newFile);    try {      pw.println(contents);    }    finally {      pw.close();    }    return newFile;  }  @Test (timeout = 30000)  public void testListFiles() throws IOException {        File[] files = FileUtil.listFiles(partitioned);    Assert.assertEquals(2, files.length);        File newDir = new File(tmp.getPath(),"test");    newDir.mkdir();    Assert.assertTrue("Failed to create test dir", newDir.exists());    files = FileUtil.listFiles(newDir);    Assert.assertEquals(0, files.length);    newDir.delete();    Assert.assertFalse("Failed to delete test dir", newDir.exists());                try {      files = FileUtil.listFiles(newDir);      Assert.fail("IOException expected on listFiles() for non-existent dir "      		+ newDir.toString());    } catch(IOException ioe) {    	    }  }  @Test (timeout = 30000)  public void testListAPI() throws IOException {        String[] files = FileUtil.list(partitioned);    Assert.assertEquals("Unexpected number of pre-existing files", 2, files.length);        File newDir = new File(tmp.getPath(),"test");    newDir.mkdir();    Assert.assertTrue("Failed to create test dir", newDir.exists());    files = FileUtil.list(newDir);    Assert.assertEquals("New directory unexpectedly contains files", 0, files.length);    newDir.delete();    Assert.assertFalse("Failed to delete test dir", newDir.exists());                try {      files = FileUtil.list(newDir);      Assert.fail("IOException expected on list() for non-existent dir "          + newDir.toString());    } catch(IOException ioe) {          }  }  @Test (timeout = 30000)  public void testFullyDelete() throws IOException {    boolean ret = FileUtil.fullyDelete(del);    Assert.assertTrue(ret);    Assert.assertFalse(del.exists());    validateTmpDir();  }    @Test (timeout = 30000)  public void testFullyDeleteSymlinks() throws IOException {    File link = new File(del, LINK);    Assert.assertEquals(5, del.list().length);            boolean ret = FileUtil.fullyDelete(link);    Assert.assertTrue(ret);    Assert.assertFalse(link.exists());    Assert.assertEquals(4, del.list().length);    validateTmpDir();    File linkDir = new File(del, "tmpDir");            ret = FileUtil.fullyDelete(linkDir);    Assert.assertTrue(ret);    Assert.assertFalse(linkDir.exists());    Assert.assertEquals(3, del.list().length);    validateTmpDir();  }    @Test (timeout = 30000)  public void testFullyDeleteDanglingSymlinks() throws IOException {            boolean ret = FileUtil.fullyDelete(tmp);    Assert.assertTrue(ret);    Assert.assertFalse(tmp.exists());        File link = new File(del, LINK);    Assert.assertEquals(5, del.list().length);            ret = FileUtil.fullyDelete(link);    Assert.assertTrue(ret);    Assert.assertEquals(4, del.list().length);        File linkDir = new File(del, "tmpDir");            ret = FileUtil.fullyDelete(linkDir);    Assert.assertTrue(ret);    Assert.assertEquals(3, del.list().length);  }  @Test (timeout = 30000)  public void testFullyDeleteContents() throws IOException {    boolean ret = FileUtil.fullyDeleteContents(del);    Assert.assertTrue(ret);    Assert.assertTrue(del.exists());    Assert.assertEquals(0, del.listFiles().length);    validateTmpDir();  }  private void validateTmpDir() {    Assert.assertTrue(tmp.exists());    Assert.assertEquals(1, tmp.listFiles().length);    Assert.assertTrue(new File(tmp, FILE).exists());  }    private void setupDirsAndNonWritablePermissions() throws IOException {    new MyFile(del, FILE_1_NAME).createNewFile();        xSubDir.mkdirs();    file2.createNewFile();    xSubSubDir.mkdirs();    file22.createNewFile();    revokePermissions(file22);    revokePermissions(xSubSubDir);    revokePermissions(file2);    revokePermissions(xSubDir);    ySubDir.mkdirs();    file3.createNewFile();    File tmpFile = new File(tmp, FILE);    tmpFile.createNewFile();    FileUtil.symLink(tmpFile.toString(), zlink.toString());  }  private static void grantPermissions(final File f) {    FileUtil.setReadable(f, true);    FileUtil.setWritable(f, true);    FileUtil.setExecutable(f, true);  }    private static void revokePermissions(final File f) {     FileUtil.setWritable(f, false);     FileUtil.setExecutable(f, false);     FileUtil.setReadable(f, false);  }        private void validateAndSetWritablePermissions(      final boolean expectedRevokedPermissionDirsExist, final boolean ret) {    grantPermissions(xSubDir);    grantPermissions(xSubSubDir);        Assert.assertFalse("The return value should have been false.", ret);    Assert.assertTrue("The file file1 should not have been deleted.",        new File(del, FILE_1_NAME).exists());        Assert.assertEquals(        "The directory xSubDir *should* not have been deleted.",        expectedRevokedPermissionDirsExist, xSubDir.exists());    Assert.assertEquals("The file file2 *should* not have been deleted.",        expectedRevokedPermissionDirsExist, file2.exists());    Assert.assertEquals(        "The directory xSubSubDir *should* not have been deleted.",        expectedRevokedPermissionDirsExist, xSubSubDir.exists());    Assert.assertEquals("The file file22 *should* not have been deleted.",        expectedRevokedPermissionDirsExist, file22.exists());        Assert.assertFalse("The directory ySubDir should have been deleted.",        ySubDir.exists());    Assert.assertFalse("The link zlink should have been deleted.",        zlink.exists());  }  @Test (timeout = 30000)  public void testFailFullyDelete() throws IOException {        assumeNotWindows();    LOG.info("Running test to verify failure of fullyDelete()");    setupDirsAndNonWritablePermissions();    boolean ret = FileUtil.fullyDelete(new MyFile(del));    validateAndSetWritablePermissions(true, ret);  }  @Test (timeout = 30000)  public void testFailFullyDeleteGrantPermissions() throws IOException {    setupDirsAndNonWritablePermissions();    boolean ret = FileUtil.fullyDelete(new MyFile(del), true);        validateAndSetWritablePermissions(false, ret);  }    @Test (timeout = 30000)  public void testFailFullyDeleteDirSymlinks() throws IOException {    File linkDir = new File(del, "tmpDir");    FileUtil.setWritable(del, false);            boolean ret = FileUtil.fullyDelete(linkDir);        Assert.assertFalse(ret);    Assert.assertTrue(linkDir.exists());    Assert.assertEquals(5, del.list().length);        validateTmpDir();        FileUtil.setWritable(del, true);    ret = FileUtil.fullyDelete(linkDir);        Assert.assertTrue(ret);    Assert.assertFalse(linkDir.exists());    Assert.assertEquals(4, del.list().length);        validateTmpDir();  }    public static class MyFile extends File {    private static final long serialVersionUID = 1L;    public MyFile(File f) {      super(f.getAbsolutePath());    }    public MyFile(File parent, String child) {      super(parent, child);    }        @Override    public boolean delete() {      LOG.info("Trying to delete myFile " + getAbsolutePath());      boolean bool = false;      if (getName().equals(FILE_1_NAME)) {        bool = false;      } else {        bool = super.delete();      }      if (bool) {        LOG.info("Deleted " + getAbsolutePath() + " successfully");      } else {        LOG.info("Cannot delete " + getAbsolutePath());      }      return bool;    }        @Override    public File[] listFiles() {      final File[] files = super.listFiles();      if (files == null) {         return null;      }      List<File> filesList = Arrays.asList(files);      Collections.sort(filesList);      File[] myFiles = new MyFile[files.length];      int i=0;      for(File f : filesList) {        myFiles[i++] = new MyFile(f);      }      return myFiles;    }  }  @Test (timeout = 30000)  public void testFailFullyDeleteContents() throws IOException {        assumeNotWindows();    LOG.info("Running test to verify failure of fullyDeleteContents()");    setupDirsAndNonWritablePermissions();    boolean ret = FileUtil.fullyDeleteContents(new MyFile(del));    validateAndSetWritablePermissions(true, ret);  }  @Test (timeout = 30000)  public void testFailFullyDeleteContentsGrantPermissions() throws IOException {    setupDirsAndNonWritablePermissions();    boolean ret = FileUtil.fullyDeleteContents(new MyFile(del), true);        validateAndSetWritablePermissions(false, ret);  }    @Test (timeout = 30000)  public void testGetDU() throws Exception {    long du = FileUtil.getDU(testFolder.getRoot());            final long expected = 2 * (3 + System.getProperty("line.separator").length());    Assert.assertEquals(expected, du);            final File doesNotExist = new File(tmp, "QuickBrownFoxJumpsOverTheLazyDog");    long duDoesNotExist = FileUtil.getDU(doesNotExist);    assertEquals(0, duDoesNotExist);            File notADirectory = new File(partitioned, "part-r-00000");    long duNotADirectoryActual = FileUtil.getDU(notADirectory);    long duNotADirectoryExpected = 3 + System.getProperty("line.separator").length();    assertEquals(duNotADirectoryExpected, duNotADirectoryActual);        try {                  try {        FileUtil.chmod(notADirectory.getAbsolutePath(), "0000");      } catch (InterruptedException ie) {                assertNull(ie);        }      assertFalse(FileUtil.canRead(notADirectory));      final long du3 = FileUtil.getDU(partitioned);      assertEquals(expected, du3);            try {        FileUtil.chmod(partitioned.getAbsolutePath(), "0000");      } catch (InterruptedException ie) {                assertNull(ie);        }      assertFalse(FileUtil.canRead(partitioned));      final long du4 = FileUtil.getDU(partitioned);      assertEquals(0, du4);    } finally {                  FileUtil.chmod(partitioned.getAbsolutePath(), "0777", true);    }  }    @Test (timeout = 30000)  public void testUnTar() throws IOException {        final File simpleTar = new File(del, FILE);    OutputStream os = new FileOutputStream(simpleTar);     TarOutputStream tos = new TarOutputStream(os);    try {      TarEntry te = new TarEntry("/bar/foo");      byte[] data = "some-content".getBytes("UTF-8");      te.setSize(data.length);      tos.putNextEntry(te);      tos.write(data);      tos.closeEntry();      tos.flush();      tos.finish();    } finally {      tos.close();    }        FileUtil.unTar(simpleTar, tmp);        assertTrue(new File(tmp, "/bar/foo").exists());    assertEquals(12, new File(tmp, "/bar/foo").length());        final File regularFile = new File(tmp, "QuickBrownFoxJumpsOverTheLazyDog");    regularFile.createNewFile();    assertTrue(regularFile.exists());    try {      FileUtil.unTar(simpleTar, regularFile);      assertTrue("An IOException expected.", false);    } catch (IOException ioe) {          }  }    @Test (timeout = 30000)  public void testReplaceFile() throws IOException {    final File srcFile = new File(tmp, "src");            srcFile.createNewFile();    assertTrue(srcFile.exists());    final File targetFile = new File(tmp, "target");    assertTrue(!targetFile.exists());    FileUtil.replaceFile(srcFile, targetFile);    assertTrue(!srcFile.exists());    assertTrue(targetFile.exists());        srcFile.createNewFile();    assertTrue(srcFile.exists());    FileUtil.replaceFile(srcFile, targetFile);    assertTrue(!srcFile.exists());    assertTrue(targetFile.exists());            srcFile.createNewFile();    assertTrue(srcFile.exists());    targetFile.delete();    targetFile.mkdirs();    File obstacle = new File(targetFile, "obstacle");    obstacle.createNewFile();    assertTrue(obstacle.exists());    assertTrue(targetFile.exists() && targetFile.isDirectory());    try {      FileUtil.replaceFile(srcFile, targetFile);      assertTrue(false);    } catch (IOException ioe) {          }        assertTrue(srcFile.exists());    assertTrue(targetFile.exists() && targetFile.isDirectory());    assertTrue(obstacle.exists());  }    @Test (timeout = 30000)  public void testCreateLocalTempFile() throws IOException {    final File baseFile = new File(tmp, "base");    File tmp1 = FileUtil.createLocalTempFile(baseFile, "foo", false);    File tmp2 = FileUtil.createLocalTempFile(baseFile, "foo", true);    assertFalse(tmp1.getAbsolutePath().equals(baseFile.getAbsolutePath()));    assertFalse(tmp2.getAbsolutePath().equals(baseFile.getAbsolutePath()));    assertTrue(tmp1.exists() && tmp2.exists());    assertTrue(tmp1.canWrite() && tmp2.canWrite());    assertTrue(tmp1.canRead() && tmp2.canRead());    tmp1.delete();    tmp2.delete();    assertTrue(!tmp1.exists() && !tmp2.exists());  }    @Test (timeout = 30000)  public void testUnZip() throws IOException {        final File simpleZip = new File(del, FILE);    OutputStream os = new FileOutputStream(simpleZip);     ZipOutputStream tos = new ZipOutputStream(os);    try {      ZipEntry ze = new ZipEntry("foo");      byte[] data = "some-content".getBytes("UTF-8");      ze.setSize(data.length);      tos.putNextEntry(ze);      tos.write(data);      tos.closeEntry();      tos.flush();      tos.finish();    } finally {      tos.close();    }            FileUtil.unZip(simpleZip, tmp);        assertTrue(new File(tmp, "foo").exists());    assertEquals(12, new File(tmp, "foo").length());        final File regularFile = new File(tmp, "QuickBrownFoxJumpsOverTheLazyDog");    regularFile.createNewFile();    assertTrue(regularFile.exists());    try {      FileUtil.unZip(simpleZip, regularFile);      assertTrue("An IOException expected.", false);    } catch (IOException ioe) {          }  }  @Test (timeout = 30000)  public void testUnZip2() throws IOException {        final File simpleZip = new File(del, FILE);    OutputStream os = new FileOutputStream(simpleZip);    try (ZipOutputStream tos = new ZipOutputStream(os)) {            ZipEntry ze = new ZipEntry("../foo");      byte[] data = "some-content".getBytes(StandardCharsets.UTF_8);      ze.setSize(data.length);      tos.putNextEntry(ze);      tos.write(data);      tos.closeEntry();      tos.flush();      tos.finish();    }        try {      FileUtil.unZip(simpleZip, tmp);      fail("unZip should throw IOException.");    } catch (IOException e) {      GenericTestUtils.assertExceptionContains(          "would create file outside of", e);    }  }  @Test (timeout = 30000)    public void testCopy5() throws IOException {    URI uri = tmp.toURI();    Configuration conf = new Configuration();    FileSystem fs = FileSystem.newInstance(uri, conf);    final String content = "some-content";    File srcFile = createFile(tmp, "src", content);    Path srcPath = new Path(srcFile.toURI());            final File dest = new File(del, "dest");    boolean result = FileUtil.copy(fs, srcPath, dest, false, conf);    assertTrue(result);    assertTrue(dest.exists());    assertEquals(content.getBytes().length         + System.getProperty("line.separator").getBytes().length, dest.length());    assertTrue(srcFile.exists());             dest.delete();    assertTrue(!dest.exists());    result = FileUtil.copy(fs, srcPath, dest, true, conf);    assertTrue(result);    assertTrue(dest.exists());    assertEquals(content.getBytes().length         + System.getProperty("line.separator").getBytes().length, dest.length());    assertTrue(!srcFile.exists());             dest.delete();    assertTrue(!dest.exists());    srcPath = new Path(partitioned.toURI());    result = FileUtil.copy(fs, srcPath, dest, true, conf);    assertTrue(result);    assertTrue(dest.exists() && dest.isDirectory());    File[] files = dest.listFiles();    assertTrue(files != null);    assertEquals(2, files.length);    for (File f: files) {      assertEquals(3           + System.getProperty("line.separator").getBytes().length, f.length());    }    assertTrue(!partitioned.exists());   }    @Test (timeout = 30000)  public void testStat2Paths1() {    assertNull(FileUtil.stat2Paths(null));        FileStatus[] fileStatuses = new FileStatus[0];     Path[] paths = FileUtil.stat2Paths(fileStatuses);    assertEquals(0, paths.length);        Path path1 = new Path("file://foo");    Path path2 = new Path("file://moo");    fileStatuses = new FileStatus[] {         new FileStatus(3, false, 0, 0, 0, path1),         new FileStatus(3, false, 0, 0, 0, path2)         };    paths = FileUtil.stat2Paths(fileStatuses);    assertEquals(2, paths.length);    assertEquals(paths[0], path1);    assertEquals(paths[1], path2);  }    @Test (timeout = 30000)  public void testStat2Paths2()  {    Path defaultPath = new Path("file://default");    Path[] paths = FileUtil.stat2Paths(null, defaultPath);    assertEquals(1, paths.length);    assertEquals(defaultPath, paths[0]);    paths = FileUtil.stat2Paths(null, null);    assertTrue(paths != null);    assertEquals(1, paths.length);    assertEquals(null, paths[0]);        Path path1 = new Path("file://foo");    Path path2 = new Path("file://moo");    FileStatus[] fileStatuses = new FileStatus[] {         new FileStatus(3, false, 0, 0, 0, path1),         new FileStatus(3, false, 0, 0, 0, path2)         };    paths = FileUtil.stat2Paths(fileStatuses, defaultPath);    assertEquals(2, paths.length);    assertEquals(paths[0], path1);    assertEquals(paths[1], path2);  }  @Test (timeout = 30000)  public void testSymlink() throws Exception {    byte[] data = "testSymLink".getBytes();    File file = new File(del, FILE);    File link = new File(del, "_link");        FileOutputStream os = new FileOutputStream(file);    os.write(data);    os.close();        FileUtil.symLink(file.getAbsolutePath(), link.getAbsolutePath());        Assert.assertEquals(data.length, file.length());    Assert.assertEquals(data.length, link.length());        FileInputStream in = new FileInputStream(link);    long len = 0;    while (in.read() > 0) {      len++;    }    in.close();    Assert.assertEquals(data.length, len);  }      @Test (timeout = 30000)  public void testSymlinkRenameTo() throws Exception {    File file = new File(del, FILE);    file.createNewFile();    File link = new File(del, "_link");        FileUtil.symLink(file.getAbsolutePath(), link.getAbsolutePath());    Assert.assertTrue(file.exists());    Assert.assertTrue(link.exists());    File link2 = new File(del, "_link2");        Assert.assertTrue(link.renameTo(link2));                Assert.assertTrue(file.exists());    Assert.assertTrue(link2.exists());    Assert.assertFalse(link.exists());  }    @Test (timeout = 30000)  public void testSymlinkDelete() throws Exception {    File file = new File(del, FILE);    file.createNewFile();    File link = new File(del, "_link");        FileUtil.symLink(file.getAbsolutePath(), link.getAbsolutePath());    Assert.assertTrue(file.exists());    Assert.assertTrue(link.exists());        Assert.assertTrue(link.delete());    Assert.assertFalse(link.exists());    Assert.assertTrue(file.exists());  }    @Test (timeout = 30000)  public void testSymlinkLength() throws Exception {    byte[] data = "testSymLinkData".getBytes();    File file = new File(del, FILE);    File link = new File(del, "_link");        FileOutputStream os = new FileOutputStream(file);    os.write(data);    os.close();    Assert.assertEquals(0, link.length());        FileUtil.symLink(file.getAbsolutePath(), link.getAbsolutePath());        Assert.assertEquals(data.length, file.length());    Assert.assertEquals(data.length, link.length());    file.delete();    Assert.assertFalse(file.exists());    Assert.assertEquals(0, link.length());    link.delete();    Assert.assertFalse(link.exists());  }    @Test  public void testSymlinkWithNullInput() throws IOException {    File file = new File(del, FILE);    File link = new File(del, "_link");            int result = FileUtil.symLink(null, null);    Assert.assertEquals(1, result);            result = FileUtil.symLink(file.getAbsolutePath(), null);    Assert.assertEquals(1, result);            result = FileUtil.symLink(null, link.getAbsolutePath());    Assert.assertEquals(1, result);  }    @Test  public void testSymlinkFileAlreadyExists() throws IOException {    File file = new File(del, FILE);    File link = new File(del, "_link");            int result1 =        FileUtil.symLink(file.getAbsolutePath(), link.getAbsolutePath());    Assert.assertEquals(0, result1);            result1 = FileUtil.symLink(file.getAbsolutePath(), link.getAbsolutePath());    Assert.assertEquals(1, result1);  }    @Test  public void testSymlinkSameFile() throws IOException {    File file = new File(del, FILE);    file.delete();            int result =        FileUtil.symLink(file.getAbsolutePath(), file.getAbsolutePath());    Assert.assertEquals(0, result);  }    @Test  public void testSymlink2DifferentFile() throws IOException {    File file = new File(del, FILE);    File fileSecond = new File(del, FILE + "_1");    File link = new File(del, "_link");            int result =        FileUtil.symLink(file.getAbsolutePath(), link.getAbsolutePath());    Assert.assertEquals(0, result);        result =        FileUtil.symLink(fileSecond.getAbsolutePath(), link.getAbsolutePath());    Assert.assertEquals(1, result);  }    @Test  public void testSymlink2DifferentLinks() throws IOException {    File file = new File(del, FILE);    File link = new File(del, "_link");    File linkSecond = new File(del, "_link_1");            int result =        FileUtil.symLink(file.getAbsolutePath(), link.getAbsolutePath());    Assert.assertEquals(0, result);        result =        FileUtil.symLink(file.getAbsolutePath(), linkSecond.getAbsolutePath());    Assert.assertEquals(0, result);  }  private void doUntarAndVerify(File tarFile, File untarDir)                                  throws IOException {    if (untarDir.exists() && !FileUtil.fullyDelete(untarDir)) {      throw new IOException("Could not delete directory '" + untarDir + "'");    }    FileUtil.unTar(tarFile, untarDir);    String parentDir = untarDir.getCanonicalPath() + Path.SEPARATOR + "name";    File testFile = new File(parentDir + Path.SEPARATOR + "version");    Assert.assertTrue(testFile.exists());    Assert.assertTrue(testFile.length() == 0);    String imageDir = parentDir + Path.SEPARATOR + "image";    testFile = new File(imageDir + Path.SEPARATOR + "fsimage");    Assert.assertTrue(testFile.exists());    Assert.assertTrue(testFile.length() == 157);    String currentDir = parentDir + Path.SEPARATOR + "current";    testFile = new File(currentDir + Path.SEPARATOR + "fsimage");    Assert.assertTrue(testFile.exists());    Assert.assertTrue(testFile.length() == 4331);    testFile = new File(currentDir + Path.SEPARATOR + "edits");    Assert.assertTrue(testFile.exists());    Assert.assertTrue(testFile.length() == 1033);    testFile = new File(currentDir + Path.SEPARATOR + "fstime");    Assert.assertTrue(testFile.exists());    Assert.assertTrue(testFile.length() == 8);  }  @Test (timeout = 30000)  public void testUntar() throws IOException {    String tarGzFileName = System.getProperty("test.cache.data",        "target/test/cache") + "/test-untar.tgz";    String tarFileName = System.getProperty("test.cache.data",        "build/test/cache") + "/test-untar.tar";    File dataDir = GenericTestUtils.getTestDir();    File untarDir = new File(dataDir, "untarDir");    doUntarAndVerify(new File(tarGzFileName), untarDir);    doUntarAndVerify(new File(tarFileName), untarDir);  }  @Test (timeout = 30000)  public void testCreateJarWithClassPath() throws Exception {        List<File> wildcardMatches = Arrays.asList(new File(tmp, "wildcard1.jar"),      new File(tmp, "wildcard2.jar"), new File(tmp, "wildcard3.JAR"),      new File(tmp, "wildcard4.JAR"));    for (File wildcardMatch: wildcardMatches) {      Assert.assertTrue("failure creating file: " + wildcardMatch,        wildcardMatch.createNewFile());    }        Assert.assertTrue(new File(tmp, "text.txt").createNewFile());    Assert.assertTrue(new File(tmp, "executable.exe").createNewFile());    Assert.assertTrue(new File(tmp, "README").createNewFile());        String wildcardPath = tmp.getCanonicalPath() + File.separator + "*";    String nonExistentSubdir = tmp.getCanonicalPath() + Path.SEPARATOR + "subdir"      + Path.SEPARATOR;    List<String> classPaths = Arrays.asList("", "cp1.jar", "cp2.jar", wildcardPath,      "cp3.jar", nonExistentSubdir);    String inputClassPath = StringUtils.join(File.pathSeparator, classPaths);    String[] jarCp = FileUtil.createJarWithClassPath(inputClassPath + File.pathSeparator + "unexpandedwildcard/*",      new Path(tmp.getCanonicalPath()), System.getenv());    String classPathJar = jarCp[0];    assertNotEquals("Unexpanded wildcard was not placed in extra classpath", jarCp[1].indexOf("unexpanded"), -1);        JarFile jarFile = null;    try {      jarFile = new JarFile(classPathJar);      Manifest jarManifest = jarFile.getManifest();      Assert.assertNotNull(jarManifest);      Attributes mainAttributes = jarManifest.getMainAttributes();      Assert.assertNotNull(mainAttributes);      Assert.assertTrue(mainAttributes.containsKey(Attributes.Name.CLASS_PATH));      String classPathAttr = mainAttributes.getValue(Attributes.Name.CLASS_PATH);      Assert.assertNotNull(classPathAttr);      List<String> expectedClassPaths = new ArrayList<String>();      for (String classPath: classPaths) {        if (classPath.length() == 0) {          continue;        }        if (wildcardPath.equals(classPath)) {                    for (File wildcardMatch: wildcardMatches) {            expectedClassPaths.add(wildcardMatch.toURI().toURL()              .toExternalForm());          }        } else {          File fileCp = null;          if(!new Path(classPath).isAbsolute()) {            fileCp = new File(tmp, classPath);          }          else {            fileCp = new File(classPath);          }          if (nonExistentSubdir.equals(classPath)) {                                    expectedClassPaths.add(fileCp.toURI().toURL()              .toExternalForm() + Path.SEPARATOR);          } else {            expectedClassPaths.add(fileCp.toURI().toURL()              .toExternalForm());          }        }      }      List<String> actualClassPaths = Arrays.asList(classPathAttr.split(" "));      Collections.sort(expectedClassPaths);      Collections.sort(actualClassPaths);      Assert.assertEquals(expectedClassPaths, actualClassPaths);    } finally {      if (jarFile != null) {        try {          jarFile.close();        } catch (IOException e) {          LOG.warn("exception closing jarFile: " + classPathJar, e);        }      }    }  }  @Test  public void testGetJarsInDirectory() throws Exception {    List<Path> jars = FileUtil.getJarsInDirectory("/foo/bar/bogus/");    assertTrue("no jars should be returned for a bogus path",        jars.isEmpty());        File jar1 = new File(tmp, "wildcard1.jar");    File jar2 = new File(tmp, "wildcard2.JAR");    List<File> matches = Arrays.asList(jar1, jar2);    for (File match: matches) {      assertTrue("failure creating file: " + match, match.createNewFile());    }        assertTrue(new File(tmp, "text.txt").createNewFile());    assertTrue(new File(tmp, "executable.exe").createNewFile());    assertTrue(new File(tmp, "README").createNewFile());        String directory = tmp.getCanonicalPath();    jars = FileUtil.getJarsInDirectory(directory);    assertEquals("there should be 2 jars", 2, jars.size());    for (Path jar: jars) {      URL url = jar.toUri().toURL();      assertTrue("the jar should match either of the jars",          url.equals(jar1.toURI().toURL()) || url.equals(jar2.toURI().toURL()));    }  }  @Ignore  public void setupCompareFs() {        String host1 = "1.2.3.4";    String host2 = "2.3.4.5";    int port1 = 7000;    int port2 = 7001;    String uris1 = "hdfs://" + host1 + ":" + Integer.toString(port1) + "/tmp/foo";    String uris2 = "hdfs://" + host1 + ":" + Integer.toString(port2) + "/tmp/foo";    String uris3 = "hdfs://" + host2 + ":" + Integer.toString(port2) + "/tmp/foo";    String uris4 = "hdfs://" + host2 + ":" + Integer.toString(port2) + "/tmp/foo";    String uris5 = "file:///" + host1 + ":" + Integer.toString(port1) + "/tmp/foo";    String uris6 = "hdfs:///" + host1 + "/tmp/foo";        try {      uri1 = new URI(uris1);      uri2 = new URI(uris2);      uri3 = new URI(uris3);      uri4 = new URI(uris4);      uri5 = new URI(uris5);      uri6 = new URI(uris6);    } catch (URISyntaxException use) {    }        inet1 = mock(InetAddress.class);    when(inet1.getCanonicalHostName()).thenReturn(host1);    inet2 = mock(InetAddress.class);    when(inet2.getCanonicalHostName()).thenReturn(host1);    inet3 = mock(InetAddress.class);    when(inet3.getCanonicalHostName()).thenReturn(host2);    inet4 = mock(InetAddress.class);    when(inet4.getCanonicalHostName()).thenReturn(host2);    inet5 = mock(InetAddress.class);    when(inet5.getCanonicalHostName()).thenReturn(host1);    inet6 = mock(InetAddress.class);    when(inet6.getCanonicalHostName()).thenReturn(host1);        try {      when(InetAddress.getByName(uris1)).thenReturn(inet1);      when(InetAddress.getByName(uris2)).thenReturn(inet2);      when(InetAddress.getByName(uris3)).thenReturn(inet3);      when(InetAddress.getByName(uris4)).thenReturn(inet4);      when(InetAddress.getByName(uris5)).thenReturn(inet5);    } catch (UnknownHostException ue) {    }    fs1 = mock(FileSystem.class);    when(fs1.getUri()).thenReturn(uri1);    fs2 = mock(FileSystem.class);    when(fs2.getUri()).thenReturn(uri2);    fs3 = mock(FileSystem.class);    when(fs3.getUri()).thenReturn(uri3);    fs4 = mock(FileSystem.class);    when(fs4.getUri()).thenReturn(uri4);    fs5 = mock(FileSystem.class);    when(fs5.getUri()).thenReturn(uri5);    fs6 = mock(FileSystem.class);    when(fs6.getUri()).thenReturn(uri6);  }  @Test  public void testCompareFsNull() throws Exception {    setupCompareFs();    assertEquals(FileUtil.compareFs(null,fs1),false);    assertEquals(FileUtil.compareFs(fs1,null),false);  }  @Test  public void testCompareFsDirectories() throws Exception {    setupCompareFs();    assertEquals(FileUtil.compareFs(fs1,fs1),true);    assertEquals(FileUtil.compareFs(fs1,fs2),false);    assertEquals(FileUtil.compareFs(fs1,fs5),false);    assertEquals(FileUtil.compareFs(fs3,fs4),true);    assertEquals(FileUtil.compareFs(fs1,fs6),false);  }  @Test(timeout = 8000)  public void testCreateSymbolicLinkUsingJava() throws IOException {    final File simpleTar = new File(del, FILE);    OutputStream os = new FileOutputStream(simpleTar);    TarArchiveOutputStream tos = new TarArchiveOutputStream(os);    File untarFile = null;    try {            final String tmpDir = "tmp/test";      File tmpDir1 = new File(tmpDir, "dir1/");      File tmpDir2 = new File(tmpDir, "dir2/");            tmpDir1.mkdirs();      tmpDir2.mkdirs();      java.nio.file.Path symLink = FileSystems          .getDefault().getPath(tmpDir1.getPath() + "/sl");            Files.createSymbolicLink(symLink,          FileSystems.getDefault().getPath(tmpDir2.getPath())).toString();      assertTrue(Files.isSymbolicLink(symLink.toAbsolutePath()));            putEntriesInTar(tos, tmpDir1.getParentFile());      tos.close();      untarFile = new File(tmpDir, "2");            FileUtil.unTarUsingJava(simpleTar, untarFile, false);            assertTrue(Files.exists(untarFile.toPath()));      assertTrue(Files.exists(FileSystems.getDefault().getPath(untarFile          .getPath(), tmpDir)));      assertTrue(Files.isSymbolicLink(FileSystems.getDefault().getPath(untarFile          .getPath().toString(), symLink.toString())));    } finally {      FileUtils.deleteDirectory(new File("tmp"));      tos.close();    }  }  private void putEntriesInTar(TarArchiveOutputStream tos, File f)      throws IOException {    if (Files.isSymbolicLink(f.toPath())) {      TarArchiveEntry tarEntry = new TarArchiveEntry(f.getPath(),          TarArchiveEntry.LF_SYMLINK);      tarEntry.setLinkName(Files.readSymbolicLink(f.toPath()).toString());      tos.putArchiveEntry(tarEntry);      tos.closeArchiveEntry();      return;    }    if (f.isDirectory()) {      tos.putArchiveEntry(new TarArchiveEntry(f));      tos.closeArchiveEntry();      for (File child : f.listFiles()) {        putEntriesInTar(tos, child);      }    }    if (f.isFile()) {      tos.putArchiveEntry(new TarArchiveEntry(f));      BufferedInputStream origin = new BufferedInputStream(          new FileInputStream(f));      int count;      byte[] data = new byte[2048];      while ((count = origin.read(data)) != -1) {        tos.write(data, 0, count);      }      tos.flush();      tos.closeArchiveEntry();      origin.close();    }  }    @Test  public void testReadSymlinkWithNullInput() {    String result = FileUtil.readLink(null);    Assert.assertEquals("", result);  }    @Test  public void testReadSymlink() throws IOException {    File file = new File(del, FILE);    File link = new File(del, "_link");        FileUtil.symLink(file.getAbsolutePath(), link.getAbsolutePath());    String result = FileUtil.readLink(link);    Assert.assertEquals(file.getAbsolutePath(), result);  }    @Test  public void testReadSymlinkWithAFileAsInput() throws IOException {    File file = new File(del, FILE);    String result = FileUtil.readLink(file);    Assert.assertEquals("", result);    file.delete();  }    @Test  public void testWriteBytesFileSystem() throws IOException {    URI uri = tmp.toURI();    Configuration conf = new Configuration();    FileSystem fs = FileSystem.get(uri, conf);    Path testPath = new Path(new Path(uri), "writebytes.out");    byte[] write = new byte[] {0x00, 0x01, 0x02, 0x03};    FileUtil.write(fs, testPath, write);    byte[] read = FileUtils.readFileToByteArray(new File(testPath.toUri()));    assertArrayEquals(write, read);  }    @Test  public void testWriteStringsFileSystem() throws IOException {    URI uri = tmp.toURI();    Configuration conf = new Configuration();    FileSystem fs = FileSystem.get(uri, conf);    Path testPath = new Path(new Path(uri), "writestrings.out");    Collection<String> write = Arrays.asList("over", "the", "lazy", "dog");    FileUtil.write(fs, testPath, write, StandardCharsets.UTF_8);    List<String> read =        FileUtils.readLines(new File(testPath.toUri()), StandardCharsets.UTF_8);    assertEquals(write, read);  }    @Test  public void testWriteStringFileSystem() throws IOException {    URI uri = tmp.toURI();    Configuration conf = new Configuration();    FileSystem fs = FileSystem.get(uri, conf);    Path testPath = new Path(new Path(uri), "writestring.out");    String write = "A" + "\u00ea" + "\u00f1" + "\u00fc" + "C";    FileUtil.write(fs, testPath, write, StandardCharsets.UTF_8);    String read = FileUtils.readFileToString(new File(testPath.toUri()),        StandardCharsets.UTF_8);    assertEquals(write, read);  }    @Test  public void testWriteStringNoCharSetFileSystem() throws IOException {    URI uri = tmp.toURI();    Configuration conf = new Configuration();    FileSystem fs = FileSystem.get(uri, conf);    Path testPath = new Path(new Path(uri), "writestring.out");    String write = "A" + "\u00ea" + "\u00f1" + "\u00fc" + "C";    FileUtil.write(fs, testPath, write);    String read = FileUtils.readFileToString(new File(testPath.toUri()),        StandardCharsets.UTF_8);    assertEquals(write, read);  }    @Test  public void testWriteBytesFileContext() throws IOException {    URI uri = tmp.toURI();    Configuration conf = new Configuration();    FileContext fc = FileContext.getFileContext(uri, conf);    Path testPath = new Path(new Path(uri), "writebytes.out");    byte[] write = new byte[] {0x00, 0x01, 0x02, 0x03};    FileUtil.write(fc, testPath, write);    byte[] read = FileUtils.readFileToByteArray(new File(testPath.toUri()));    assertArrayEquals(write, read);  }    @Test  public void testWriteStringsFileContext() throws IOException {    URI uri = tmp.toURI();    Configuration conf = new Configuration();    FileContext fc = FileContext.getFileContext(uri, conf);    Path testPath = new Path(new Path(uri), "writestrings.out");    Collection<String> write = Arrays.asList("over", "the", "lazy", "dog");    FileUtil.write(fc, testPath, write, StandardCharsets.UTF_8);    List<String> read =        FileUtils.readLines(new File(testPath.toUri()), StandardCharsets.UTF_8);    assertEquals(write, read);  }    @Test  public void testWriteStringFileContext() throws IOException {    URI uri = tmp.toURI();    Configuration conf = new Configuration();    FileContext fc = FileContext.getFileContext(uri, conf);    Path testPath = new Path(new Path(uri), "writestring.out");    String write = "A" + "\u00ea" + "\u00f1" + "\u00fc" + "C";    FileUtil.write(fc, testPath, write, StandardCharsets.UTF_8);    String read = FileUtils.readFileToString(new File(testPath.toUri()),        StandardCharsets.UTF_8);    assertEquals(write, read);  }    @Test  public void testWriteStringNoCharSetFileContext() throws IOException {    URI uri = tmp.toURI();    Configuration conf = new Configuration();    FileContext fc = FileContext.getFileContext(uri, conf);    Path testPath = new Path(new Path(uri), "writestring.out");    String write = "A" + "\u00ea" + "\u00f1" + "\u00fc" + "C";    FileUtil.write(fc, testPath, write);    String read = FileUtils.readFileToString(new File(testPath.toUri()),        StandardCharsets.UTF_8);    assertEquals(write, read);  }    public static int getCacheSize() {    return FileSystem.cacheSize();  }}
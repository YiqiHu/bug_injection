public class ReflectionUtils {      private static final Class<?>[] EMPTY_ARRAY = new Class[]{};  volatile private static SerializationFactory serialFactory = null;    private static final Map<Class<?>, Constructor<?>> CONSTRUCTOR_CACHE =     new ConcurrentHashMap<Class<?>, Constructor<?>>();    public static void setConf(Object theObject, Configuration conf) {    if (conf != null) {      if (theObject instanceof Configurable) {        ((Configurable) theObject).setConf(conf);      }      setJobConf(theObject, conf);    }  }      private static void setJobConf(Object theObject, Configuration conf) {                    try {      Class<?> jobConfClass =         conf.getClassByNameOrNull("org.apache.hadoop.mapred.JobConf");      if (jobConfClass == null) {        return;      }            Class<?> jobConfigurableClass =         conf.getClassByNameOrNull("org.apache.hadoop.mapred.JobConfigurable");      if (jobConfigurableClass == null) {        return;      }      if (jobConfClass.isAssignableFrom(conf.getClass()) &&            jobConfigurableClass.isAssignableFrom(theObject.getClass())) {        Method configureMethod =           jobConfigurableClass.getMethod("configure", jobConfClass);        configureMethod.invoke(theObject, conf);      }    } catch (Exception e) {      throw new RuntimeException("Error in configuring object", e);    }  }    @SuppressWarnings("unchecked")  public static <T> T newInstance(Class<T> theClass, Configuration conf) {    T result;    try {      Constructor<T> meth = (Constructor<T>) CONSTRUCTOR_CACHE.get(theClass);      if (meth == null) {        meth = theClass.getDeclaredConstructor(EMPTY_ARRAY);        meth.setAccessible(true);        CONSTRUCTOR_CACHE.put(theClass, meth);      }      result = meth.newInstance();    } catch (Exception e) {      throw new RuntimeException(e);    }    setConf(result, conf);    return result;  }  static private ThreadMXBean threadBean =     ManagementFactory.getThreadMXBean();      public static void setContentionTracing(boolean val) {    threadBean.setThreadContentionMonitoringEnabled(val);  }      private static String getTaskName(long id, String name) {    if (name == null) {      return Long.toString(id);    }    return id + " (" + name + ")";  }        public synchronized static void printThreadInfo(PrintStream stream,                                     String title) {    final int STACK_DEPTH = 20;    boolean contention = threadBean.isThreadContentionMonitoringEnabled();    long[] threadIds = threadBean.getAllThreadIds();    stream.println("Process Thread Dump: " + title);    stream.println(threadIds.length + " active threads");    for (long tid: threadIds) {      ThreadInfo info = threadBean.getThreadInfo(tid, STACK_DEPTH);      if (info == null) {        stream.println("  Inactive");        continue;      }      stream.println("Thread " +                      getTaskName(info.getThreadId(),                                 info.getThreadName()) + ":");      Thread.State state = info.getThreadState();      stream.println("  State: " + state);      stream.println("  Blocked count: " + info.getBlockedCount());      stream.println("  Waited count: " + info.getWaitedCount());      if (contention) {        stream.println("  Blocked time: " + info.getBlockedTime());        stream.println("  Waited time: " + info.getWaitedTime());      }      if (state == Thread.State.WAITING) {        stream.println("  Waiting on " + info.getLockName());      } else  if (state == Thread.State.BLOCKED) {        stream.println("  Blocked on " + info.getLockName());        stream.println("  Blocked by " +                        getTaskName(info.getLockOwnerId(),                                   info.getLockOwnerName()));      }      stream.println("  Stack:");      for (StackTraceElement frame: info.getStackTrace()) {        stream.println("    " + frame.toString());      }    }    stream.flush();  }      private static long previousLogTime = 0;        public static void logThreadInfo(Log log,                                   String title,                                   long minInterval) {    boolean dumpStack = false;    if (log.isInfoEnabled()) {      synchronized (ReflectionUtils.class) {        long now = Time.monotonicNow();        if (now - previousLogTime >= minInterval * 1000) {          previousLogTime = now;          dumpStack = true;        }      }      if (dumpStack) {        try {          ByteArrayOutputStream buffer = new ByteArrayOutputStream();          printThreadInfo(new PrintStream(buffer, false, "UTF-8"), title);          log.info(buffer.toString(Charset.defaultCharset().name()));        } catch (UnsupportedEncodingException ignored) {        }      }    }  }    public static void logThreadInfo(Logger log,                                   String title,                                   long minInterval) {    boolean dumpStack = false;    if (log.isInfoEnabled()) {      synchronized (ReflectionUtils.class) {        long now = Time.monotonicNow();        if (now - previousLogTime >= minInterval * 1000) {          previousLogTime = now;          dumpStack = true;        }      }      if (dumpStack) {        try {          ByteArrayOutputStream buffer = new ByteArrayOutputStream();          printThreadInfo(new PrintStream(buffer, false, "UTF-8"), title);          log.info(buffer.toString(Charset.defaultCharset().name()));        } catch (UnsupportedEncodingException ignored) {        }      }    }  }    @SuppressWarnings("unchecked")  public static <T> Class<T> getClass(T o) {    return (Class<T>)o.getClass();  }      static void clearCache() {    CONSTRUCTOR_CACHE.clear();  }      static int getCacheSize() {    return CONSTRUCTOR_CACHE.size();  }    private static class CopyInCopyOutBuffer {    DataOutputBuffer outBuffer = new DataOutputBuffer();    DataInputBuffer inBuffer = new DataInputBuffer();        void moveData() {      inBuffer.reset(outBuffer.getData(), outBuffer.getLength());    }  }      private static final ThreadLocal<CopyInCopyOutBuffer> CLONE_BUFFERS      = new ThreadLocal<CopyInCopyOutBuffer>() {      @Override      protected synchronized CopyInCopyOutBuffer initialValue() {        return new CopyInCopyOutBuffer();      }    };  private static SerializationFactory getFactory(Configuration conf) {    if (serialFactory == null) {      serialFactory = new SerializationFactory(conf);    }    return serialFactory;  }      @SuppressWarnings("unchecked")  public static <T> T copy(Configuration conf,                                 T src, T dst) throws IOException {    CopyInCopyOutBuffer buffer = CLONE_BUFFERS.get();    buffer.outBuffer.reset();    SerializationFactory factory = getFactory(conf);    Class<T> cls = (Class<T>) src.getClass();    Serializer<T> serializer = factory.getSerializer(cls);    serializer.open(buffer.outBuffer);    serializer.serialize(src);    buffer.moveData();    Deserializer<T> deserializer = factory.getDeserializer(cls);    deserializer.open(buffer.inBuffer);    dst = deserializer.deserialize(dst);    return dst;  }  @Deprecated  public static void cloneWritableInto(Writable dst,                                        Writable src) throws IOException {    CopyInCopyOutBuffer buffer = CLONE_BUFFERS.get();    buffer.outBuffer.reset();    src.write(buffer.outBuffer);    buffer.moveData();    dst.readFields(buffer.inBuffer);  }      public static List<Field> getDeclaredFieldsIncludingInherited(Class<?> clazz) {    List<Field> fields = new ArrayList<Field>();    while (clazz != null) {      Field[] sortedFields = clazz.getDeclaredFields();      Arrays.sort(sortedFields, new Comparator<Field>() {        public int compare(Field a, Field b) {          return a.getName().compareTo(b.getName());        }      });      for (Field field : sortedFields) {        fields.add(field);      }      clazz = clazz.getSuperclass();    }        return fields;  }      public static List<Method> getDeclaredMethodsIncludingInherited(Class<?> clazz) {    List<Method> methods = new ArrayList<Method>();    while (clazz != null) {      for (Method method : clazz.getDeclaredMethods()) {        methods.add(method);      }      clazz = clazz.getSuperclass();    }        return methods;  }}
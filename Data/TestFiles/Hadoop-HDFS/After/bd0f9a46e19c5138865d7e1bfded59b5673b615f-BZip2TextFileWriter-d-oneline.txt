public final class BZip2TextFileWriter implements Closeable {      private static final int BLOCK_SIZE_100K = MIN_BLOCKSIZE;    public static final int BLOCK_SIZE =                              CBZip2OutputStream.getAllowableBlockSize(BLOCK_SIZE_100K) + 1;  private final CBZip2OutputStream out;  public BZip2TextFileWriter(Path path, Configuration conf) throws IOException {    this(path.getFileSystem(conf).create(path));  }  public BZip2TextFileWriter(OutputStream rawOut) throws IOException {    try {      BZip2Codec.writeHeader(rawOut);      out = new CBZip2OutputStream(rawOut, BLOCK_SIZE_100K);    } catch (Throwable e) {      rawOut.close();      throw e;    }  }  public void writeManyRecords(int totalSize, int numRecords, byte[] delimiter)      throws IOException {    checkArgument(numRecords > 0);    checkArgument(delimiter.length > 0);    int minRecordSize = totalSize / numRecords;    checkArgument(minRecordSize >= delimiter.length);    int lastRecordExtraSize = totalSize % numRecords;    for (int i = 0; i < numRecords - 1; i++) {      writeRecord(minRecordSize, delimiter);    }    writeRecord(minRecordSize + lastRecordExtraSize, delimiter);  }  public void writeRecord(int totalSize, byte[] delimiter) throws IOException {    checkArgument(delimiter.length > 0);    checkArgument(totalSize >= delimiter.length);    int contentSize = totalSize - delimiter.length;    for (int i = 0; i < contentSize; i++) {                                    out.write(i % 2 == 0 ? 'a' : 'b');    }    write(delimiter);  }  public void write(String bytes) throws IOException {    write(bytes.getBytes(StandardCharsets.UTF_8));  }  public void write(byte[] bytes) throws IOException {    out.write(bytes);  }  @Override  public void close() throws IOException {    out.close();  }}
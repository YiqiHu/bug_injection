public class WeakReferenceMap<K, V> {  private static final Logger LOG =      LoggerFactory.getLogger(WeakReferenceMap.class);    private final Map<K, WeakReference<V>> map = new ConcurrentHashMap<>();    private final Function<? super K, ? extends V> factory;    private final Consumer<? super K> referenceLost;    private final AtomicLong referenceLostCount = new AtomicLong();    private final AtomicLong entriesCreatedCount = new AtomicLong();    private final LogExactlyOnce referenceLostDuringCreation = new LogExactlyOnce(LOG);    public WeakReferenceMap(      Function<? super K, ? extends V> factory,      @Nullable final Consumer<? super K> referenceLost) {    this.factory = requireNonNull(factory);    this.referenceLost = referenceLost;  }  @Override  public String toString() {    return "WeakReferenceMap{" +        "size=" + size() +        ", referenceLostCount=" + referenceLostCount +        ", entriesCreatedCount=" + entriesCreatedCount +        '}';  }    public int size() {    return map.size();  }    public void clear() {    map.clear();  }    public WeakReference<V> lookup(K key) {    return map.get(key);  }    public V get(K key) {    final WeakReference<V> currentWeakRef = lookup(key);        V strongVal = resolve(currentWeakRef);    if (strongVal != null) {            return  strongVal;    }        if (currentWeakRef != null) {                              map.remove(key, currentWeakRef);            noteLost(key);    }        return create(key);  }    public V create(K key) {    entriesCreatedCount.incrementAndGet();        final V strongRef = requireNonNull(factory.apply(key),        "factory returned a null instance");    V resolvedStrongRef;    do {      WeakReference<V> newWeakRef = new WeakReference<>(strongRef);            map.put(key, newWeakRef);            WeakReference<V> retrievedWeakRef = map.get(key);                  resolvedStrongRef = resolve(retrievedWeakRef);      if (resolvedStrongRef == null) {        referenceLostDuringCreation.warn("reference to %s lost during creation", key);        noteLost(key);      }    } while (resolvedStrongRef == null);            if (strongRef != resolvedStrongRef) {      LOG.debug("Created instance for key {}: {} overwritten by {}",          key, strongRef, resolvedStrongRef);    }    return resolvedStrongRef;  }    public V put(K key, V value) {    return resolve(map.put(key, new WeakReference<>(value)));  }    public V remove(K key) {    return resolve(map.remove(key));  }    public boolean containsKey(K key) {    final WeakReference<V> current = lookup(key);    return resolve(current) != null;  }    protected V resolve(WeakReference<V> r) {    return r == null ? null : r.get();  }    public int prune() {    int count = 0;    final Iterator<Map.Entry<K, WeakReference<V>>> it = map.entrySet().iterator();    while (it.hasNext()) {      final Map.Entry<K, WeakReference<V>> next = it.next();      if (next.getValue().get() == null) {        it.remove();        count++;        noteLost(next.getKey());      }    }    return count;  }    private void noteLost(final K key) {        referenceLostCount.incrementAndGet();        if (referenceLost != null) {      referenceLost.accept(key);    }  }    public final long getReferenceLostCount() {    return referenceLostCount.get();  }    public final long getEntriesCreatedCount() {    return entriesCreatedCount.get();  }}
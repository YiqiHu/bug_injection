public class ThrottledAsyncChecker<K, V> implements AsyncChecker<K, V> {  public static final Logger LOG =      LoggerFactory.getLogger(ThrottledAsyncChecker.class);  private final Timer timer;    private final ListeningExecutorService executorService;  private final ScheduledExecutorService scheduledExecutorService;    private final long minMsBetweenChecks;  private final long diskCheckTimeout;    private final Map<Checkable, ListenableFuture<V>> checksInProgress;    private final Map<Checkable, LastCheckResult<V>> completedChecks;  public ThrottledAsyncChecker(final Timer timer,                        final long minMsBetweenChecks,                        final long diskCheckTimeout,                        final ExecutorService executorService) {    this.timer = timer;    this.minMsBetweenChecks = minMsBetweenChecks;    this.diskCheckTimeout = diskCheckTimeout;    this.executorService = MoreExecutors.listeningDecorator(executorService);    this.checksInProgress = new HashMap<>();    this.completedChecks = new WeakHashMap<>();    if (this.diskCheckTimeout > 0) {      ScheduledThreadPoolExecutor scheduledThreadPoolExecutor = new          ScheduledThreadPoolExecutor(1);      this.scheduledExecutorService = MoreExecutors          .getExitingScheduledExecutorService(scheduledThreadPoolExecutor);    } else {      this.scheduledExecutorService = null;    }  }    @Override  public synchronized Optional<ListenableFuture<V>> schedule(      Checkable<K, V> target, K context) {    if (checksInProgress.containsKey(target)) {      return Optional.empty();    }    final LastCheckResult<V> result = completedChecks.get(target);    if (result != null) {      final long msSinceLastCheck = timer.monotonicNow() - result.completedAt;      if (msSinceLastCheck < minMsBetweenChecks) {        LOG.debug("Skipped checking {}. Time since last check {}ms " +                "is less than the min gap {}ms.",            target, msSinceLastCheck, minMsBetweenChecks);        return Optional.empty();      }    }    LOG.info("Scheduling a check for {}", target);    final ListenableFuture<V> lfWithoutTimeout = executorService.submit(        new Callable<V>() {          @Override          public V call() throws Exception {            return target.check(context);          }        });    final ListenableFuture<V> lf;    if (diskCheckTimeout > 0) {      lf = TimeoutFuture          .create(lfWithoutTimeout, diskCheckTimeout, TimeUnit.MILLISECONDS,              scheduledExecutorService);    } else {      lf = lfWithoutTimeout;    }    checksInProgress.put(target, lf);    addResultCachingCallback(target, lf);    return Optional.of(lf);  }    private void addResultCachingCallback(      Checkable<K, V> target, ListenableFuture<V> lf) {    Futures.addCallback(lf, new FutureCallback<V>() {      @Override      public void onSuccess(V result) {        synchronized (ThrottledAsyncChecker.this) {          checksInProgress.remove(target);          completedChecks.put(target, new LastCheckResult<>(              result, timer.monotonicNow()));        }      }      @Override      public void onFailure(@Nonnull Throwable t) {        synchronized (ThrottledAsyncChecker.this) {          checksInProgress.remove(target);          completedChecks.put(target, new LastCheckResult<>(              t, timer.monotonicNow()));        }      }    }, MoreExecutors.directExecutor());  }    @Override  public void shutdownAndWait(long timeout, TimeUnit timeUnit)      throws InterruptedException {    if (scheduledExecutorService != null) {      scheduledExecutorService.shutdownNow();      scheduledExecutorService.awaitTermination(timeout, timeUnit);    }    executorService.shutdownNow();    executorService.awaitTermination(timeout, timeUnit);  }    private static final class LastCheckResult<V> {        private final long completedAt;        @Nullable    private final V result;        private final Throwable exception;         private LastCheckResult(V result, long completedAt) {      this.result = result;      this.exception = null;      this.completedAt = completedAt;    }        private LastCheckResult(Throwable t, long completedAt) {      this.result = null;      this.exception = t;      this.completedAt = completedAt;    }  }}
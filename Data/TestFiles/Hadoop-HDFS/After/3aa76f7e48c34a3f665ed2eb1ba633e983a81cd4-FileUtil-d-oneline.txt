public class FileUtil {  private static final Logger LOG = LoggerFactory.getLogger(FileUtil.class);    public static final int SYMLINK_NO_PRIVILEGE = 2;    private static final int BUFFER_SIZE = 8_192;    public static Path[] stat2Paths(FileStatus[] stats) {    if (stats == null)      return null;    Path[] ret = new Path[stats.length];    for (int i = 0; i < stats.length; ++i) {      ret[i] = stats[i].getPath();    }    return ret;  }    public static Path[] stat2Paths(FileStatus[] stats, Path path) {    if (stats == null)      return new Path[]{path};    else      return stat2Paths(stats);  }    public static void fullyDeleteOnExit(final File file) {    file.deleteOnExit();    if (file.isDirectory()) {      File[] files = file.listFiles();      if (files != null) {        for (File child : files) {          fullyDeleteOnExit(child);        }      }    }  }    public static boolean fullyDelete(final File dir) {    return fullyDelete(dir, false);  }    public static boolean fullyDelete(final File dir, boolean tryGrantPermissions) {    if (tryGrantPermissions) {            File parent = dir.getParentFile();      grantPermissions(parent);    }    if (deleteImpl(dir, false)) {                  return true;    }        if (!FileUtils.isSymlink(dir) && !fullyDeleteContents(dir, tryGrantPermissions)) {      return false;    }    return deleteImpl(dir, true);  }    public static String readLink(File f) {        if (f == null) {      LOG.warn("Can not read a null symLink");      return "";    }    try {      return Shell.execCommand(          Shell.getReadlinkCommand(f.toString())).trim();    } catch (IOException x) {      return "";    }  }    private static void grantPermissions(final File f) {      FileUtil.setExecutable(f, true);      FileUtil.setReadable(f, true);      FileUtil.setWritable(f, true);  }  private static boolean deleteImpl(final File f, final boolean doLog) {    if (f == null) {      LOG.warn("null file argument.");      return false;    }    final boolean wasDeleted = f.delete();    if (wasDeleted) {      return true;    }    final boolean ex = f.exists();    if (doLog && ex) {      LOG.warn("Failed to delete file or dir ["          + f.getAbsolutePath() + "]: it still exists.");    }    return !ex;  }    public static boolean fullyDeleteContents(final File dir) {    return fullyDeleteContents(dir, false);  }    public static boolean fullyDeleteContents(final File dir, final boolean tryGrantPermissions) {    if (tryGrantPermissions) {                  grantPermissions(dir);    }    boolean deletionSucceeded = true;    final File[] contents = dir.listFiles();    if (contents != null) {      for (int i = 0; i < contents.length; i++) {        if (contents[i].isFile()) {          if (!deleteImpl(contents[i], true)) {            deletionSucceeded = false;            continue;           }        } else {                              boolean b = false;          b = deleteImpl(contents[i], false);          if (b){                        continue;          }                              if (!fullyDelete(contents[i], tryGrantPermissions)) {            deletionSucceeded = false;                      }        }      }    }    return deletionSucceeded;  }    @Deprecated  public static void fullyDelete(FileSystem fs, Path dir)  throws IOException {    fs.delete(dir, true);  }          private static void checkDependencies(FileSystem srcFS,                                        Path src,                                        FileSystem dstFS,                                        Path dst)                                        throws IOException {    if (srcFS == dstFS) {      String srcq = srcFS.makeQualified(src).toString() + Path.SEPARATOR;      String dstq = dstFS.makeQualified(dst).toString() + Path.SEPARATOR;      if (dstq.startsWith(srcq)) {        if (srcq.length() == dstq.length()) {          throw new IOException("Cannot copy " + src + " to itself.");        } else {          throw new IOException("Cannot copy " + src + " to its subdirectory " +                                dst);        }      }    }  }    public static boolean copy(FileSystem srcFS, Path src,                             FileSystem dstFS, Path dst,                             boolean deleteSource,                             Configuration conf) throws IOException {    return copy(srcFS, src, dstFS, dst, deleteSource, true, conf);  }  public static boolean copy(FileSystem srcFS, Path[] srcs,                             FileSystem dstFS, Path dst,                             boolean deleteSource,                             boolean overwrite, Configuration conf)                             throws IOException {    boolean gotException = false;    boolean returnVal = true;    StringBuilder exceptions = new StringBuilder();    if (srcs.length == 1)      return copy(srcFS, srcs[0], dstFS, dst, deleteSource, overwrite, conf);        try {      FileStatus sdst = dstFS.getFileStatus(dst);      if (!sdst.isDirectory())        throw new IOException("copying multiple files, but last argument `" +                              dst + "' is not a directory");    } catch (FileNotFoundException e) {      throw new IOException(          "`" + dst + "': specified destination directory " +              "does not exist", e);    }    for (Path src : srcs) {      try {        if (!copy(srcFS, src, dstFS, dst, deleteSource, overwrite, conf))          returnVal = false;      } catch (IOException e) {        gotException = true;        exceptions.append(e.getMessage())            .append("\n");      }    }    if (gotException) {      throw new IOException(exceptions.toString());    }    return returnVal;  }    public static boolean copy(FileSystem srcFS, Path src,                             FileSystem dstFS, Path dst,                             boolean deleteSource,                             boolean overwrite,                             Configuration conf) throws IOException {    FileStatus fileStatus = srcFS.getFileStatus(src);    return copy(srcFS, fileStatus, dstFS, dst, deleteSource, overwrite, conf);  }    public static boolean copy(FileSystem srcFS, FileStatus srcStatus,                             FileSystem dstFS, Path dst,                             boolean deleteSource,                             boolean overwrite,                             Configuration conf) throws IOException {    Path src = srcStatus.getPath();    dst = checkDest(src.getName(), dstFS, dst, overwrite);    if (srcFS.makeQualified(src).equals(dstFS.makeQualified(dst))) {      throw new PathOperationException("Source (" + src + ") and destination " +          "(" + dst + ") are equal in the copy command.");    }    if (srcStatus.isDirectory()) {      checkDependencies(srcFS, src, dstFS, dst);      if (!dstFS.mkdirs(dst)) {        return false;      }      FileStatus contents[] = srcFS.listStatus(src);      for (int i = 0; i < contents.length; i++) {        copy(srcFS, contents[i], dstFS,             new Path(dst, contents[i].getPath().getName()),             deleteSource, overwrite, conf);      }    } else {      InputStream in=null;      OutputStream out = null;      try {        in = srcFS.open(src);        out = dstFS.create(dst, overwrite);        IOUtils.copyBytes(in, out, conf, true);      } catch (IOException e) {        IOUtils.closeStream(out);        IOUtils.closeStream(in);        throw e;      }    }    if (deleteSource) {      return srcFS.delete(src, true);    } else {      return true;    }  }    public static boolean copy(File src,                             FileSystem dstFS, Path dst,                             boolean deleteSource,                             Configuration conf) throws IOException {    dst = checkDest(src.getName(), dstFS, dst, false);    if (src.isDirectory()) {      if (!dstFS.mkdirs(dst)) {        return false;      }      File contents[] = listFiles(src);      for (int i = 0; i < contents.length; i++) {        copy(contents[i], dstFS, new Path(dst, contents[i].getName()),             deleteSource, conf);      }    } else if (src.isFile()) {      InputStream in = null;      OutputStream out =null;      try {        in = Files.newInputStream(src.toPath());        out = dstFS.create(dst);        IOUtils.copyBytes(in, out, conf);      } catch (IOException e) {        IOUtils.closeStream( out );        IOUtils.closeStream( in );        throw e;      }    } else if (!src.canRead()) {      throw new IOException(src.toString() +                            ": Permission denied");    } else {      throw new IOException(src.toString() +                            ": No such file or directory");    }    if (deleteSource) {      return FileUtil.fullyDelete(src);    } else {      return true;    }  }    public static boolean copy(FileSystem srcFS, Path src,                             File dst, boolean deleteSource,                             Configuration conf) throws IOException {    FileStatus filestatus = srcFS.getFileStatus(src);    return copy(srcFS, filestatus, dst, deleteSource, conf);  }    private static boolean copy(FileSystem srcFS, FileStatus srcStatus,                              File dst, boolean deleteSource,                              Configuration conf) throws IOException {    Path src = srcStatus.getPath();    if (srcStatus.isDirectory()) {      if (!dst.mkdirs()) {        return false;      }      FileStatus contents[] = srcFS.listStatus(src);      for (int i = 0; i < contents.length; i++) {        copy(srcFS, contents[i],             new File(dst, contents[i].getPath().getName()),             deleteSource, conf);      }    } else {      InputStream in = srcFS.open(src);      IOUtils.copyBytes(in, Files.newOutputStream(dst.toPath()), conf);    }    if (deleteSource) {      return srcFS.delete(src, true);    } else {      return true;    }  }  private static Path checkDest(String srcName, FileSystem dstFS, Path dst,      boolean overwrite) throws IOException {    FileStatus sdst;    try {      sdst = dstFS.getFileStatus(dst);    } catch (FileNotFoundException e) {      sdst = null;    }    if (null != sdst) {      if (sdst.isDirectory()) {        if (null == srcName) {          if (overwrite) {            return dst;          }          throw new PathIsDirectoryException(dst.toString());        }        return checkDest(null, dstFS, new Path(dst, srcName), overwrite);      } else if (!overwrite) {        throw new PathExistsException(dst.toString(),            "Target " + dst + " already exists");      }    }    return dst;  }    public static String makeShellPath(String filename) throws IOException {    return filename;  }    public static String makeShellPath(File file) throws IOException {    return makeShellPath(file, false);  }    public static String makeSecureShellPath(File file) throws IOException {    if (Shell.WINDOWS) {            throw new UnsupportedOperationException("Not implemented for Windows");    } else {      return makeShellPath(file, false).replace("'", "'\\''");    }  }    public static String makeShellPath(File file, boolean makeCanonicalPath)  throws IOException {    if (makeCanonicalPath) {      return makeShellPath(file.getCanonicalPath());    } else {      return makeShellPath(file.toString());    }  }    public static long getDU(File dir) {    long size = 0;    if (!dir.exists())      return 0;    if (!dir.isDirectory()) {      return dir.length();    } else {      File[] allFiles = dir.listFiles();      if (allFiles != null) {        for (File f : allFiles) {          if (!org.apache.commons.io.FileUtils.isSymlink(f)) {            size += getDU(f);          }        }      }      return size;    }  }    public static void unZip(InputStream inputStream, File toDir)      throws IOException {    try (ZipInputStream zip = new ZipInputStream(inputStream)) {      int numOfFailedLastModifiedSet = 0;      String targetDirPath = toDir.getCanonicalPath() + File.separator;      for(ZipEntry entry = zip.getNextEntry();          entry != null;          entry = zip.getNextEntry()) {        if (!entry.isDirectory()) {          File file = new File(toDir, entry.getName());          if (!file.getCanonicalPath().startsWith(targetDirPath)) {            throw new IOException("expanding " + entry.getName()                + " would create file outside of " + toDir);          }          File parent = file.getParentFile();          if (!parent.mkdirs() &&              !parent.isDirectory()) {            throw new IOException("Mkdirs failed to create " +                parent.getAbsolutePath());          }          try (OutputStream out = Files.newOutputStream(file.toPath())) {            IOUtils.copyBytes(zip, out, BUFFER_SIZE);          }          if (!file.setLastModified(entry.getTime())) {            numOfFailedLastModifiedSet++;          }        }      }      if (numOfFailedLastModifiedSet > 0) {        LOG.warn("Could not set last modfied time for {} file(s)",            numOfFailedLastModifiedSet);      }    }  }    public static void unZip(File inFile, File unzipDir) throws IOException {    Enumeration<? extends ZipEntry> entries;    ZipFile zipFile = new ZipFile(inFile);    try {      entries = zipFile.entries();      String targetDirPath = unzipDir.getCanonicalPath() + File.separator;      while (entries.hasMoreElements()) {        ZipEntry entry = entries.nextElement();        if (!entry.isDirectory()) {          InputStream in = zipFile.getInputStream(entry);          try {            File file = new File(unzipDir, entry.getName());            if (!file.getCanonicalPath().startsWith(targetDirPath)) {              throw new IOException("expanding " + entry.getName()                  + " would create file outside of " + unzipDir);            }            if (!file.getParentFile().mkdirs()) {              if (!file.getParentFile().isDirectory()) {                throw new IOException("Mkdirs failed to create " +                                      file.getParentFile().toString());              }            }            OutputStream out = Files.newOutputStream(file.toPath());            try {              byte[] buffer = new byte[8192];              int i;              while ((i = in.read(buffer)) != -1) {                out.write(buffer, 0, i);              }            } finally {              out.close();            }          } finally {            in.close();          }        }      }    } finally {      zipFile.close();    }  }    private static void runCommandOnStream(      InputStream inputStream, String command)      throws IOException, InterruptedException, ExecutionException {    ExecutorService executor = null;    ProcessBuilder builder = new ProcessBuilder();    builder.command(        Shell.WINDOWS ? "cmd" : "bash",        Shell.WINDOWS ? "/c" : "-c",        command);    Process process = builder.start();    int exitCode;    try {            executor = Executors.newFixedThreadPool(2);      Future output = executor.submit(() -> {        try {                    if (LOG.isDebugEnabled()) {                        try (BufferedReader reader =                     new BufferedReader(                         new InputStreamReader(process.getInputStream(),                             Charset.forName("UTF-8")))) {              String line;              while((line = reader.readLine()) != null) {                LOG.debug(line);              }            }          } else {            org.apache.commons.io.IOUtils.copy(                process.getInputStream(),                new IOUtils.NullOutputStream());          }        } catch (IOException e) {          LOG.debug(e.getMessage());        }      });      Future error = executor.submit(() -> {        try {                    if (LOG.isDebugEnabled()) {                        try (BufferedReader reader =                     new BufferedReader(                         new InputStreamReader(process.getErrorStream(),                             Charset.forName("UTF-8")))) {              String line;              while((line = reader.readLine()) != null) {                LOG.debug(line);              }            }          } else {            org.apache.commons.io.IOUtils.copy(                process.getErrorStream(),                new IOUtils.NullOutputStream());          }        } catch (IOException e) {          LOG.debug(e.getMessage());        }      });            try {        org.apache.commons.io.IOUtils.copy(            inputStream, process.getOutputStream());      } finally {        process.getOutputStream().close();      }            error.get();      output.get();    } finally {            if (executor != null) {        executor.shutdown();      }            exitCode = process.waitFor();    }    if (exitCode != 0) {      throw new IOException(          String.format(              "Error executing command. %s " +                  "Process exited with exit code %d.",              command, exitCode));    }  }    public static void unTar(InputStream inputStream, File untarDir,                           boolean gzipped)      throws IOException, InterruptedException, ExecutionException {    if (!untarDir.mkdirs()) {      if (!untarDir.isDirectory()) {        throw new IOException("Mkdirs failed to create " + untarDir);      }    }    if(Shell.WINDOWS) {                  unTarUsingJava(inputStream, untarDir, gzipped);    } else {                  unTarUsingTar(inputStream, untarDir, gzipped);    }  }    public static void unTar(File inFile, File untarDir) throws IOException {    if (!untarDir.mkdirs()) {      if (!untarDir.isDirectory()) {        throw new IOException("Mkdirs failed to create " + untarDir);      }    }    boolean gzipped = inFile.toString().endsWith("gz");    if(Shell.WINDOWS) {                  unTarUsingJava(inFile, untarDir, gzipped);    }    else {                  unTarUsingTar(inFile, untarDir, gzipped);    }  }  private static void unTarUsingTar(InputStream inputStream, File untarDir,                                    boolean gzipped)      throws IOException, InterruptedException, ExecutionException {    StringBuilder untarCommand = new StringBuilder();    if (gzipped) {      untarCommand.append("gzip -dc | (");    }    untarCommand.append("cd '")        .append(FileUtil.makeSecureShellPath(untarDir))        .append("' && ")        .append("tar -x ");    if (gzipped) {      untarCommand.append(")");    }    runCommandOnStream(inputStream, untarCommand.toString());  }  private static void unTarUsingTar(File inFile, File untarDir,      boolean gzipped) throws IOException {    StringBuffer untarCommand = new StringBuffer();    if (gzipped) {      untarCommand.append(" gzip -dc '")          .append(FileUtil.makeSecureShellPath(inFile))          .append("' | (");    }    untarCommand.append("cd '")        .append(FileUtil.makeSecureShellPath(untarDir))        .append("' && ")        .append("tar -xf ");    if (gzipped) {      untarCommand.append(" -)");    } else {      untarCommand.append(FileUtil.makeSecureShellPath(inFile));    }    String[] shellCmd = { "bash", "-c", untarCommand.toString() };    ShellCommandExecutor shexec = new ShellCommandExecutor(shellCmd);    shexec.execute();    int exitcode = shexec.getExitCode();    if (exitcode != 0) {      throw new IOException("Error untarring file " + inFile +                  ". Tar process exited with exit code " + exitcode);    }  }  static void unTarUsingJava(File inFile, File untarDir,      boolean gzipped) throws IOException {    InputStream inputStream = null;    TarArchiveInputStream tis = null;    try {      if (gzipped) {        inputStream =            new GZIPInputStream(Files.newInputStream(inFile.toPath()));      } else {        inputStream = Files.newInputStream(inFile.toPath());      }      inputStream = new BufferedInputStream(inputStream);      tis = new TarArchiveInputStream(inputStream);      for (TarArchiveEntry entry = tis.getNextTarEntry(); entry != null;) {        unpackEntries(tis, entry, untarDir);        entry = tis.getNextTarEntry();      }    } finally {      IOUtils.cleanupWithLogger(LOG, tis, inputStream);    }  }  private static void unTarUsingJava(InputStream inputStream, File untarDir,                                     boolean gzipped) throws IOException {    TarArchiveInputStream tis = null;    try {      if (gzipped) {        inputStream = new GZIPInputStream(inputStream);      }      inputStream = new BufferedInputStream(inputStream);      tis = new TarArchiveInputStream(inputStream);      for (TarArchiveEntry entry = tis.getNextTarEntry(); entry != null;) {        unpackEntries(tis, entry, untarDir);        entry = tis.getNextTarEntry();      }    } finally {      IOUtils.cleanupWithLogger(LOG, tis, inputStream);    }  }  private static void unpackEntries(TarArchiveInputStream tis,      TarArchiveEntry entry, File outputDir) throws IOException {    String targetDirPath = outputDir.getCanonicalPath() + File.separator;    File outputFile = new File(outputDir, entry.getName());    if (!outputFile.getCanonicalPath().startsWith(targetDirPath)) {      throw new IOException("expanding " + entry.getName()          + " would create entry outside of " + outputDir);    }    if (entry.isDirectory()) {      File subDir = new File(outputDir, entry.getName());      if (!subDir.mkdirs() && !subDir.isDirectory()) {        throw new IOException("Mkdirs failed to create tar internal dir "            + outputDir);      }      for (TarArchiveEntry e : entry.getDirectoryEntries()) {        unpackEntries(tis, e, subDir);      }      return;    }    if (entry.isSymbolicLink()) {            Files.createSymbolicLink(FileSystems.getDefault()              .getPath(outputDir.getPath(), entry.getName()),          FileSystems.getDefault().getPath(entry.getLinkName()));      return;    }    if (!outputFile.getParentFile().exists()) {      if (!outputFile.getParentFile().mkdirs()) {        throw new IOException("Mkdirs failed to create tar internal dir "            + outputDir);      }    }    if (entry.isLink()) {      File src = new File(outputDir, entry.getLinkName());      HardLink.createHardLink(src, outputFile);      return;    }    org.apache.commons.io.FileUtils.copyToFile(tis, outputFile);  }    @Deprecated  public static class HardLink extends org.apache.hadoop.fs.HardLink {              }    public static int symLink(String target, String linkname) throws IOException{    if (target == null || linkname == null) {      LOG.warn("Can not create a symLink with a target = " + target          + " and link =" + linkname);      return 1;    }            File targetFile = new File(        Path.getPathWithoutSchemeAndAuthority(new Path(target)).toString());    File linkFile = new File(        Path.getPathWithoutSchemeAndAuthority(new Path(linkname)).toString());    String[] cmd = Shell.getSymlinkCommand(        targetFile.toString(),        linkFile.toString());    ShellCommandExecutor shExec;    try {      if (Shell.WINDOWS &&          linkFile.getParentFile() != null &&          !new Path(target).isAbsolute()) {                                        shExec = new ShellCommandExecutor(cmd, linkFile.getParentFile());      } else {        shExec = new ShellCommandExecutor(cmd);      }      shExec.execute();    } catch (Shell.ExitCodeException ec) {      int returnVal = ec.getExitCode();      if (Shell.WINDOWS && returnVal == SYMLINK_NO_PRIVILEGE) {        LOG.warn("Fail to create symbolic links on Windows. "            + "The default security settings in Windows disallow non-elevated "            + "administrators and all non-administrators from creating symbolic links. "            + "This behavior can be changed in the Local Security Policy management console");      } else if (returnVal != 0) {        LOG.warn("Command '" + StringUtils.join(" ", cmd) + "' failed "            + returnVal + " with: " + ec.getMessage());      }      return returnVal;    } catch (IOException e) {      if (LOG.isDebugEnabled()) {        LOG.debug("Error while create symlink " + linkname + " to " + target            + "." + " Exception: " + StringUtils.stringifyException(e));      }      throw e;    }    return shExec.getExitCode();  }    public static int chmod(String filename, String perm                          ) throws IOException, InterruptedException {    return chmod(filename, perm, false);  }    public static int chmod(String filename, String perm, boolean recursive)                            throws IOException {    String [] cmd = Shell.getSetPermissionCommand(perm, recursive);    String[] args = new String[cmd.length + 1];    System.arraycopy(cmd, 0, args, 0, cmd.length);    args[cmd.length] = new File(filename).getPath();    ShellCommandExecutor shExec = new ShellCommandExecutor(args);    try {      shExec.execute();    }catch(IOException e) {      if(LOG.isDebugEnabled()) {        LOG.debug("Error while changing permission : " + filename                  +" Exception: " + StringUtils.stringifyException(e));      }    }    return shExec.getExitCode();  }    public static void setOwner(File file, String username,      String groupname) throws IOException {    if (username == null && groupname == null) {      throw new IOException("username == null && groupname == null");    }    String arg = (username == null ? "" : username)        + (groupname == null ? "" : ":" + groupname);    String [] cmd = Shell.getSetOwnerCommand(arg);    execCommand(file, cmd);  }    public static boolean setReadable(File f, boolean readable) {    if (Shell.WINDOWS) {      try {        String permission = readable ? "u+r" : "u-r";        FileUtil.chmod(f.getCanonicalPath(), permission, false);        return true;      } catch (IOException ex) {        return false;      }    } else {      return f.setReadable(readable);    }  }    public static boolean setWritable(File f, boolean writable) {    if (Shell.WINDOWS) {      try {        String permission = writable ? "u+w" : "u-w";        FileUtil.chmod(f.getCanonicalPath(), permission, false);        return true;      } catch (IOException ex) {        return false;      }    } else {      return f.setWritable(writable);    }  }    public static boolean setExecutable(File f, boolean executable) {    if (Shell.WINDOWS) {      try {        String permission = executable ? "u+x" : "u-x";        FileUtil.chmod(f.getCanonicalPath(), permission, false);        return true;      } catch (IOException ex) {        return false;      }    } else {      return f.setExecutable(executable);    }  }    public static boolean canRead(File f) {    if (Shell.WINDOWS) {      try {        return NativeIO.Windows.access(f.getCanonicalPath(),            NativeIO.Windows.AccessRight.ACCESS_READ);      } catch (IOException e) {        return false;      }    } else {      return f.canRead();    }  }    public static boolean canWrite(File f) {    if (Shell.WINDOWS) {      try {        return NativeIO.Windows.access(f.getCanonicalPath(),            NativeIO.Windows.AccessRight.ACCESS_WRITE);      } catch (IOException e) {        return false;      }    } else {      return f.canWrite();    }  }    public static boolean canExecute(File f) {    if (Shell.WINDOWS) {      try {        return NativeIO.Windows.access(f.getCanonicalPath(),            NativeIO.Windows.AccessRight.ACCESS_EXECUTE);      } catch (IOException e) {        return false;      }    } else {      return f.canExecute();    }  }    public static void setPermission(File f, FsPermission permission                                   ) throws IOException {    FsAction user = permission.getUserAction();    FsAction group = permission.getGroupAction();    FsAction other = permission.getOtherAction();            if (group != other || NativeIO.isAvailable() || Shell.WINDOWS) {      execSetPermission(f, permission);      return;    }    boolean rv = true;        rv = f.setReadable(group.implies(FsAction.READ), false);    checkReturnValue(rv, f, permission);    if (group.implies(FsAction.READ) != user.implies(FsAction.READ)) {      rv = f.setReadable(user.implies(FsAction.READ), true);      checkReturnValue(rv, f, permission);    }        rv = f.setWritable(group.implies(FsAction.WRITE), false);    checkReturnValue(rv, f, permission);    if (group.implies(FsAction.WRITE) != user.implies(FsAction.WRITE)) {      rv = f.setWritable(user.implies(FsAction.WRITE), true);      checkReturnValue(rv, f, permission);    }        rv = f.setExecutable(group.implies(FsAction.EXECUTE), false);    checkReturnValue(rv, f, permission);    if (group.implies(FsAction.EXECUTE) != user.implies(FsAction.EXECUTE)) {      rv = f.setExecutable(user.implies(FsAction.EXECUTE), true);      checkReturnValue(rv, f, permission);    }  }  private static void checkReturnValue(boolean rv, File p,                                       FsPermission permission                                       ) throws IOException {    if (!rv) {      throw new IOException("Failed to set permissions of path: " + p +                            " to " +                            String.format("%04o", permission.toShort()));    }  }  private static void execSetPermission(File f,                                        FsPermission permission                                       )  throws IOException {    if (NativeIO.isAvailable()) {      NativeIO.POSIX.chmod(f.getCanonicalPath(), permission.toShort());    } else {      execCommand(f, Shell.getSetPermissionCommand(                  String.format("%04o", permission.toShort()), false));    }  }  static String execCommand(File f, String... cmd) throws IOException {    String[] args = new String[cmd.length + 1];    System.arraycopy(cmd, 0, args, 0, cmd.length);    args[cmd.length] = f.getCanonicalPath();    String output = Shell.execCommand(args);    return output;  }    public static final File createLocalTempFile(final File basefile,                                               final String prefix,                                               final boolean isDeleteOnExit)    throws IOException {    File tmp = File.createTempFile(prefix + basefile.getName(),                                   "", basefile.getParentFile());    if (isDeleteOnExit) {      tmp.deleteOnExit();    }    return tmp;  }    public static void replaceFile(File src, File target) throws IOException {        if (!src.renameTo(target)) {      int retries = 5;      while (target.exists() && !target.delete() && retries-- >= 0) {        try {          Thread.sleep(1000);        } catch (InterruptedException e) {          throw new IOException("replaceFile interrupted.");        }      }      if (!src.renameTo(target)) {        throw new IOException("Unable to rename " + src +                              " to " + target);      }    }  }    public static File[] listFiles(File dir) throws IOException {    File[] files = dir.listFiles();    if(files == null) {      throw new IOException("Invalid directory or I/O error occurred for dir: "                + dir.toString());    }    return files;  }    public static String[] list(File dir) throws IOException {    if (!canRead(dir)) {      throw new AccessDeniedException(dir.toString(), null,          FSExceptionMessages.PERMISSION_DENIED);    }    String[] fileNames = dir.list();    if(fileNames == null) {      throw new IOException("Invalid directory or I/O error occurred for dir: "                + dir.toString());    }    return fileNames;  }  public static String[] createJarWithClassPath(String inputClassPath, Path pwd,      Map<String, String> callerEnv) throws IOException {    return createJarWithClassPath(inputClassPath, pwd, pwd, callerEnv);  }    public static String[] createJarWithClassPath(String inputClassPath, Path pwd,      Path targetDir,      Map<String, String> callerEnv) throws IOException {        @SuppressWarnings("unchecked")    Map<String, String> env = Shell.WINDOWS ? new CaseInsensitiveMap(callerEnv) :      callerEnv;    String[] classPathEntries = inputClassPath.split(File.pathSeparator);    for (int i = 0; i < classPathEntries.length; ++i) {      classPathEntries[i] = StringUtils.replaceTokens(classPathEntries[i],        StringUtils.ENV_VAR_PATTERN, env);    }    File workingDir = new File(pwd.toString());    if (!workingDir.mkdirs()) {                              LOG.debug("mkdirs false for " + workingDir + ", execution will continue");    }    StringBuilder unexpandedWildcardClasspath = new StringBuilder();        List<String> classPathEntryList = new ArrayList<String>(      classPathEntries.length);    for (String classPathEntry: classPathEntries) {      if (classPathEntry.length() == 0) {        continue;      }      if (classPathEntry.endsWith("*")) {                List<Path> jars = getJarsInDirectory(classPathEntry);        if (!jars.isEmpty()) {          for (Path jar: jars) {            classPathEntryList.add(jar.toUri().toURL().toExternalForm());          }        } else {          unexpandedWildcardClasspath.append(File.pathSeparator)              .append(classPathEntry);        }      } else {                File fileCpEntry = null;        if(!new Path(classPathEntry).isAbsolute()) {          fileCpEntry = new File(targetDir.toString(), classPathEntry);        }        else {          fileCpEntry = new File(classPathEntry);        }        String classPathEntryUrl = fileCpEntry.toURI().toURL()          .toExternalForm();                                                                if (classPathEntry.endsWith(Path.SEPARATOR) &&            !classPathEntryUrl.endsWith(Path.SEPARATOR)) {          classPathEntryUrl = classPathEntryUrl + Path.SEPARATOR;        }        classPathEntryList.add(classPathEntryUrl);      }    }    String jarClassPath = StringUtils.join(" ", classPathEntryList);        Manifest jarManifest = new Manifest();    jarManifest.getMainAttributes().putValue(        Attributes.Name.MANIFEST_VERSION.toString(), "1.0");    jarManifest.getMainAttributes().putValue(        Attributes.Name.CLASS_PATH.toString(), jarClassPath);        File classPathJar = File.createTempFile("classpath-", ".jar", workingDir);    try (OutputStream fos = Files.newOutputStream(classPathJar.toPath());         BufferedOutputStream bos = new BufferedOutputStream(fos)) {      JarOutputStream jos = new JarOutputStream(bos, jarManifest);      jos.close();    }    String[] jarCp = {classPathJar.getCanonicalPath(),                        unexpandedWildcardClasspath.toString()};    return jarCp;  }    public static List<Path> getJarsInDirectory(String path) {    return getJarsInDirectory(path, true);  }    public static List<Path> getJarsInDirectory(String path, boolean useLocal) {    List<Path> paths = new ArrayList<>();    try {            if (!path.endsWith("*")) {        path += File.separator + "*";      }      Path globPath = new Path(path).suffix("{.jar,.JAR}");      FileContext context = useLocal ?          FileContext.getLocalFSFileContext() :          FileContext.getFileContext(globPath.toUri());      FileStatus[] files = context.util().globStatus(globPath);      if (files != null) {        for (FileStatus file: files) {          paths.add(file.getPath());        }      }    } catch (IOException ignore) {}     return paths;  }  public static boolean compareFs(FileSystem srcFs, FileSystem destFs) {    if (srcFs==null || destFs==null) {      return false;    }    URI srcUri = srcFs.getUri();    URI dstUri = destFs.getUri();    if (srcUri.getScheme()==null) {      return false;    }    if (!srcUri.getScheme().equals(dstUri.getScheme())) {      return false;    }    String srcHost = srcUri.getHost();    String dstHost = dstUri.getHost();    if ((srcHost!=null) && (dstHost!=null)) {      if (srcHost.equals(dstHost)) {        return srcUri.getPort()==dstUri.getPort();      }      try {        srcHost = InetAddress.getByName(srcHost).getCanonicalHostName();        dstHost = InetAddress.getByName(dstHost).getCanonicalHostName();      } catch (UnknownHostException ue) {        if (LOG.isDebugEnabled()) {          LOG.debug("Could not compare file-systems. Unknown host: ", ue);        }        return false;      }      if (!srcHost.equals(dstHost)) {        return false;      }    } else if (srcHost==null && dstHost!=null) {      return false;    } else if (srcHost!=null) {      return false;    }        return srcUri.getPort()==dstUri.getPort();  }    public static FileSystem write(final FileSystem fs, final Path path,      final byte[] bytes) throws IOException {    Objects.requireNonNull(path);    Objects.requireNonNull(bytes);    try (FSDataOutputStream out = fs.createFile(path).overwrite(true).build()) {      out.write(bytes);    }    return fs;  }    public static FileContext write(final FileContext fileContext,      final Path path, final byte[] bytes) throws IOException {    Objects.requireNonNull(path);    Objects.requireNonNull(bytes);    try (FSDataOutputStream out =        fileContext.create(path).overwrite(true).build()) {      out.write(bytes);    }    return fileContext;  }    public static FileSystem write(final FileSystem fs, final Path path,      final Iterable<? extends CharSequence> lines, final Charset cs)      throws IOException {    Objects.requireNonNull(path);    Objects.requireNonNull(lines);    Objects.requireNonNull(cs);    CharsetEncoder encoder = cs.newEncoder();    try (FSDataOutputStream out = fs.createFile(path).overwrite(true).build();        BufferedWriter writer =            new BufferedWriter(new OutputStreamWriter(out, encoder))) {      for (CharSequence line : lines) {        writer.append(line);        writer.newLine();      }    }    return fs;  }    public static FileContext write(final FileContext fileContext,      final Path path, final Iterable<? extends CharSequence> lines,      final Charset cs) throws IOException {    Objects.requireNonNull(path);    Objects.requireNonNull(lines);    Objects.requireNonNull(cs);    CharsetEncoder encoder = cs.newEncoder();    try (FSDataOutputStream out = fileContext.create(path).overwrite(true).build();        BufferedWriter writer =            new BufferedWriter(new OutputStreamWriter(out, encoder))) {      for (CharSequence line : lines) {        writer.append(line);        writer.newLine();      }    }    return fileContext;  }    public static FileSystem write(final FileSystem fs, final Path path,      final CharSequence charseq, final Charset cs) throws IOException {    Objects.requireNonNull(path);    Objects.requireNonNull(charseq);    Objects.requireNonNull(cs);    CharsetEncoder encoder = cs.newEncoder();    try (FSDataOutputStream out = fs.createFile(path).overwrite(true).build();        BufferedWriter writer =            new BufferedWriter(new OutputStreamWriter(out, encoder))) {      writer.append(charseq);    }    return fs;  }    public static FileContext write(final FileContext fs, final Path path,      final CharSequence charseq, final Charset cs) throws IOException {    Objects.requireNonNull(path);    Objects.requireNonNull(charseq);    Objects.requireNonNull(cs);    CharsetEncoder encoder = cs.newEncoder();    try (FSDataOutputStream out = fs.create(path).overwrite(true).build();        BufferedWriter writer =            new BufferedWriter(new OutputStreamWriter(out, encoder))) {      writer.append(charseq);    }    return fs;  }    public static FileSystem write(final FileSystem fs, final Path path,      final CharSequence charseq) throws IOException {    return write(fs, path, charseq, StandardCharsets.UTF_8);  }    public static FileContext write(final FileContext fileContext,      final Path path, final CharSequence charseq) throws IOException {    return write(fileContext, path, charseq, StandardCharsets.UTF_8);  }  @InterfaceAudience.LimitedPrivate({"ViewDistributedFileSystem"})  @InterfaceStability.Unstable    @SuppressWarnings("deprecation")  public static void rename(FileSystem srcFs, Path src, Path dst,      final Options.Rename... options) throws IOException {    srcFs.rename(src, dst, options);  }}
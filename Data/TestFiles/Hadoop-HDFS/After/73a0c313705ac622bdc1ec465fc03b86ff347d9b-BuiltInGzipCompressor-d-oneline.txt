public class BuiltInGzipCompressor implements Compressor {    private final byte[] gzipHeader = new byte[]{      0x1f, (byte) 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};    private final byte[] gzipTrailer = new byte[]{      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};  private final int gzipHeaderLen = gzipHeader.length;  private final int gzipTrailerLen = gzipTrailer.length;  private Deflater deflater;  private int headerOff = 0;  private int trailerOff = 0;  private int numExtraBytesWritten = 0;  private int currentBufLen = 0;  private int accuBufLen = 0;  private final Checksum crc = DataChecksum.newCrc32();  private BuiltInGzipDecompressor.GzipStateLabel state;  public BuiltInGzipCompressor(Configuration conf) {    init(conf);  }  @Override  public boolean finished() {        return state == BuiltInGzipDecompressor.GzipStateLabel.FINISHED && deflater.finished();  }  @Override  public boolean needsInput() {    return deflater.needsInput() && state != BuiltInGzipDecompressor.GzipStateLabel.TRAILER_CRC;  }  @Override  public int compress(byte[] b, int off, int len) throws IOException {    if (finished()) {      throw new IOException("compress called on finished compressor");    }    int compressedBytesWritten = 0;    if (currentBufLen <= 0) {      return compressedBytesWritten;    }        if (state == BuiltInGzipDecompressor.GzipStateLabel.HEADER_BASIC) {      int outputHeaderSize = writeHeader(b, off, len);      numExtraBytesWritten += outputHeaderSize;      compressedBytesWritten += outputHeaderSize;      if (outputHeaderSize == len) {        return compressedBytesWritten;      }      off += outputHeaderSize;      len -= outputHeaderSize;    }    if (state == BuiltInGzipDecompressor.GzipStateLabel.INFLATE_STREAM) {            int deflated = deflater.deflate(b, off, len);      compressedBytesWritten += deflated;      off += deflated;      len -= deflated;            if (deflater.finished()) {        state = BuiltInGzipDecompressor.GzipStateLabel.TRAILER_CRC;        fillTrailer();      } else {        return compressedBytesWritten;      }    }    if (state == BuiltInGzipDecompressor.GzipStateLabel.TRAILER_CRC) {      int outputTrailerSize = writeTrailer(b, off, len);      numExtraBytesWritten += outputTrailerSize;      compressedBytesWritten += outputTrailerSize;    }    return compressedBytesWritten;  }  @Override  public long getBytesRead() {    return deflater.getTotalIn();  }  @Override  public long getBytesWritten() {    return numExtraBytesWritten + deflater.getTotalOut();  }  @Override  public void end() {    deflater.end();  }  @Override  public void finish() {    deflater.finish();  }  private void init(Configuration conf) {    ZlibCompressor.CompressionLevel level = ZlibFactory.getCompressionLevel(conf);    ZlibCompressor.CompressionStrategy strategy = ZlibFactory.getCompressionStrategy(conf);        deflater = new Deflater(level.compressionLevel(), true);    deflater.setStrategy(strategy.compressionStrategy());    state = BuiltInGzipDecompressor.GzipStateLabel.HEADER_BASIC;  }  @Override  public void reinit(Configuration conf) {    init(conf);    numExtraBytesWritten = 0;    currentBufLen = 0;    headerOff = 0;    trailerOff = 0;    crc.reset();    accuBufLen = 0;  }  @Override  public void reset() {    deflater.reset();    state = BuiltInGzipDecompressor.GzipStateLabel.HEADER_BASIC;    numExtraBytesWritten = 0;    currentBufLen = 0;    headerOff = 0;    trailerOff = 0;    crc.reset();    accuBufLen = 0;  }  @Override  public void setDictionary(byte[] b, int off, int len) {    deflater.setDictionary(b, off, len);  }  @Override  public void setInput(byte[] b, int off, int len) {    if (b == null) {      throw new NullPointerException();    }    if (off < 0 || len < 0 || off > b.length - len) {      throw new ArrayIndexOutOfBoundsException();    }    deflater.setInput(b, off, len);    crc.update(b, off, len);      currentBufLen = len;    accuBufLen += currentBufLen;  }  private int writeHeader(byte[] b, int off, int len) {    if (len <= 0) {      return 0;    }    int n = Math.min(len, gzipHeaderLen - headerOff);    System.arraycopy(gzipHeader, headerOff, b, off, n);    headerOff += n;        if (headerOff == gzipHeaderLen) {      state = BuiltInGzipDecompressor.GzipStateLabel.INFLATE_STREAM;    }    return n;  }  private void fillTrailer() {    if (state == BuiltInGzipDecompressor.GzipStateLabel.TRAILER_CRC) {      int streamCrc = (int) crc.getValue();      gzipTrailer[0] = (byte) (streamCrc & 0x000000ff);      gzipTrailer[1] = (byte) ((streamCrc & 0x0000ff00) >> 8);      gzipTrailer[2] = (byte) ((streamCrc & 0x00ff0000) >> 16);      gzipTrailer[3] = (byte) ((streamCrc & 0xff000000) >> 24);      gzipTrailer[4] = (byte) (accuBufLen & 0x000000ff);      gzipTrailer[5] = (byte) ((accuBufLen & 0x0000ff00) >> 8);      gzipTrailer[6] = (byte) ((accuBufLen & 0x00ff0000) >> 16);      gzipTrailer[7] = (byte) ((accuBufLen & 0xff000000) >> 24);      crc.reset();      accuBufLen = 0;    }  }  private int writeTrailer(byte[] b, int off, int len) {    if (len <= 0) {      return 0;    }    int n = Math.min(len, gzipTrailerLen - trailerOff);    System.arraycopy(gzipTrailer, trailerOff, b, off, n);    trailerOff += n;    if (trailerOff == gzipTrailerLen) {      state = BuiltInGzipDecompressor.GzipStateLabel.FINISHED;      currentBufLen = 0;      headerOff = 0;      trailerOff = 0;    }    return n;  }}
public final class S3AUtils {  private static final Logger LOG = LoggerFactory.getLogger(S3AUtils.class);  static final String CONSTRUCTOR_EXCEPTION = "constructor exception";  static final String INSTANTIATION_EXCEPTION      = "instantiation exception";  static final String NOT_AWS_PROVIDER =      "does not implement AWSCredentialsProvider";  static final String ABSTRACT_PROVIDER =      "is abstract and therefore cannot be created";  static final String ENDPOINT_KEY = "Endpoint";    static final String E_FS_CLOSED = "FileSystem is closed!";    static final String CREDENTIAL_PROVIDER_PATH =      "hadoop.security.credential.provider.path";    public static final String SSE_C_NO_KEY_ERROR =      S3AEncryptionMethods.SSE_C.getMethod()          + " is enabled but no encryption key was declared in "          + SERVER_SIDE_ENCRYPTION_KEY;    public static final String SSE_S3_WITH_KEY_ERROR =      S3AEncryptionMethods.SSE_S3.getMethod()          + " is enabled but an encryption key was set in "          + SERVER_SIDE_ENCRYPTION_KEY;  private static final String EOF_MESSAGE_IN_XML_PARSER      = "Failed to sanitize XML document destined for handler class";  private static final String BUCKET_PATTERN = FS_S3A_BUCKET_PREFIX + "%s.%s";    @VisibleForTesting  public static final String E_FORBIDDEN_AWS_PROVIDER      = "AWS provider class cannot be used";  private S3AUtils() {  }    public static IOException translateException(String operation,      Path path,      AmazonClientException exception) {    return translateException(operation, path.toString(), exception);  }    @SuppressWarnings("ThrowableInstanceNeverThrown")  public static IOException translateException(@Nullable String operation,      String path,      SdkBaseException exception) {    String message = String.format("%s%s: %s",        operation,        StringUtils.isNotEmpty(path)? (" on " + path) : "",        exception);    if (!(exception instanceof AmazonServiceException)) {      Exception innerCause = containsInterruptedException(exception);      if (innerCause != null) {                return translateInterruptedException(exception, innerCause, message);      }      if (signifiesConnectionBroken(exception)) {                return (EOFException)new EOFException(message).initCause(exception);      }      if (exception instanceof CredentialInitializationException) {                                return (AccessDeniedException)new AccessDeniedException(path, null,            exception.toString()).initCause(exception);      }      return new AWSClientIOException(message, exception);    } else {      if (exception instanceof AmazonDynamoDBException) {                return translateDynamoDBException(path, message,            (AmazonDynamoDBException)exception);      }      IOException ioe;      AmazonServiceException ase = (AmazonServiceException) exception;            AmazonS3Exception s3Exception = ase instanceof AmazonS3Exception          ? (AmazonS3Exception) ase          : null;      int status = ase.getStatusCode();      message = message + ":" + ase.getErrorCode();      switch (status) {      case 301:      case 307:        if (s3Exception != null) {          if (s3Exception.getAdditionalDetails() != null &&              s3Exception.getAdditionalDetails().containsKey(ENDPOINT_KEY)) {            message = String.format("Received permanent redirect response to "                + "endpoint %s.  This likely indicates that the S3 endpoint "                + "configured in %s does not match the AWS region containing "                + "the bucket.",                s3Exception.getAdditionalDetails().get(ENDPOINT_KEY), ENDPOINT);          }          ioe = new AWSRedirectException(message, s3Exception);        } else {          ioe = new AWSRedirectException(message, ase);        }        break;      case 400:        ioe = new AWSBadRequestException(message, ase);        break;            case 401:      case 403:        ioe = new AccessDeniedException(path, null, message);        ioe.initCause(ase);        break;            case 404:        if (isUnknownBucket(ase)) {                    ioe = new UnknownStoreException(path, message, ase);        } else {                    ioe = new FileNotFoundException(message);          ioe.initCause(ase);        }        break;                  case 410:        ioe = new FileNotFoundException(message);        ioe.initCause(ase);        break;                  case 405:        ioe = new AWSBadRequestException(message, s3Exception);        break;                  case 416:        ioe = new EOFException(message);        ioe.initCause(ase);        break;                        case 443:      case 444:        ioe = new AWSNoResponseException(message, ase);        break;            case 503:        ioe = new AWSServiceThrottledException(message, ase);        break;            case 500:        ioe = new AWSStatus500Exception(message, ase);        break;      case 200:        if (exception instanceof MultiObjectDeleteException) {                    return translateDeleteException(message,              (MultiObjectDeleteException) exception);        }              default:                        ioe = s3Exception != null            ? new AWSS3IOException(message, s3Exception)            : new AWSServiceIOException(message, ase);        break;      }      return ioe;    }  }    public static IOException extractException(String operation,      String path,      ExecutionException ee) {    IOException ioe;    Throwable cause = ee.getCause();    if (cause instanceof AmazonClientException) {      ioe = translateException(operation, path, (AmazonClientException) cause);    } else if (cause instanceof IOException) {      ioe = (IOException) cause;    } else {      ioe = new IOException(operation + " failed: " + cause, cause);    }    return ioe;  }    static Exception containsInterruptedException(Throwable thrown) {    if (thrown == null) {      return null;    }    if (thrown instanceof InterruptedException ||        thrown instanceof InterruptedIOException ||        thrown instanceof AbortedException) {      return (Exception)thrown;    }        return containsInterruptedException(thrown.getCause());  }    private static InterruptedIOException translateInterruptedException(      SdkBaseException exception,      final Exception innerCause,      String message) {    InterruptedIOException ioe;    if (innerCause instanceof SocketTimeoutException) {      ioe = new SocketTimeoutException(message);    } else {      String name = innerCause.getClass().getName();      if (name.endsWith(".ConnectTimeoutException")          || name.endsWith("$ConnectTimeoutException")) {                        ioe = new ConnectTimeoutException(message);      } else {                ioe = new InterruptedIOException(message);      }    }    ioe.initCause(exception);    return ioe;  }    public static boolean isThrottleException(Exception ex) {    return ex instanceof AWSServiceThrottledException        || ex instanceof ProvisionedThroughputExceededException        || ex instanceof LimitExceededException        || (ex instanceof AmazonServiceException            && 503  == ((AmazonServiceException)ex).getStatusCode())        || (ex instanceof SdkBaseException            && RetryUtils.isThrottlingException((SdkBaseException) ex));  }    public static boolean signifiesConnectionBroken(SdkBaseException ex) {    return ex.toString().contains(EOF_MESSAGE_IN_XML_PARSER);  }    public static IOException translateDynamoDBException(final String path,      final String message,      final AmazonDynamoDBException ddbException) {    if (isThrottleException(ddbException)) {      return new AWSServiceThrottledException(message, ddbException);    }    if (ddbException instanceof ResourceNotFoundException) {      return (FileNotFoundException) new FileNotFoundException(message)          .initCause(ddbException);    }    final int statusCode = ddbException.getStatusCode();    final String errorCode = ddbException.getErrorCode();    IOException result = null;        if (statusCode == 400) {      switch (errorCode) {      case "AccessDeniedException":        result = (IOException) new AccessDeniedException(            path,            null,            ddbException.toString())            .initCause(ddbException);        break;      default:        result = new AWSBadRequestException(message, ddbException);      }    }    if (result ==  null) {      result = new AWSServiceIOException(message, ddbException);    }    return result;  }    public static String stringify(AmazonServiceException e) {    StringBuilder builder = new StringBuilder(        String.format("%s: %s error %d: %s; %s%s%n",            e.getErrorType(),            e.getServiceName(),            e.getStatusCode(),            e.getErrorCode(),            e.getErrorMessage(),            (e.isRetryable() ? " (retryable)": "")        ));    String rawResponseContent = e.getRawResponseContent();    if (rawResponseContent != null) {      builder.append(rawResponseContent);    }    return builder.toString();  }    public static String stringify(AmazonS3Exception e) {        StringBuilder builder = new StringBuilder(        stringify((AmazonServiceException) e));    Map<String, String> details = e.getAdditionalDetails();    if (details != null) {      builder.append('\n');      for (Map.Entry<String, String> d : details.entrySet()) {        builder.append(d.getKey()).append('=')            .append(d.getValue()).append('\n');      }    }    return builder.toString();  }    public static S3AFileStatus createFileStatus(Path keyPath,      S3ObjectSummary summary,      long blockSize,      String owner,      String eTag,      String versionId) {    long size = summary.getSize();    return createFileStatus(keyPath,        objectRepresentsDirectory(summary.getKey(), size),        size, summary.getLastModified(), blockSize, owner, eTag, versionId);  }    public static S3AFileStatus createUploadFileStatus(Path keyPath,      boolean isDir, long size, long blockSize, String owner,      String eTag, String versionId) {    Date date = isDir ? null : new Date();    return createFileStatus(keyPath, isDir, size, date, blockSize, owner,        eTag, versionId);  }    private static S3AFileStatus createFileStatus(Path keyPath, boolean isDir,      long size, Date modified, long blockSize, String owner,      String eTag, String versionId) {    if (isDir) {      return new S3AFileStatus(Tristate.UNKNOWN, keyPath, owner);    } else {      return new S3AFileStatus(size, dateToLong(modified), keyPath, blockSize,          owner, eTag, versionId);    }  }    public static boolean objectRepresentsDirectory(final String name,      final long size) {    return !name.isEmpty()        && name.charAt(name.length() - 1) == '/'        && size == 0L;  }    public static long dateToLong(final Date date) {    if (date == null) {      return 0L;    }    return date.getTime();  }    public static final List<Class<?>>      STANDARD_AWS_PROVIDERS = Collections.unmodifiableList(      Arrays.asList(          TemporaryAWSCredentialsProvider.class,          SimpleAWSCredentialsProvider.class,          EnvironmentVariableCredentialsProvider.class,          IAMInstanceCredentialsProvider.class));    public static AWSCredentialProviderList createAWSCredentialProviderSet(      @Nullable URI binding,      Configuration conf) throws IOException {        S3xLoginHelper.rejectSecretsInURIs(binding);    AWSCredentialProviderList credentials =        buildAWSProviderList(binding,            conf,            AWS_CREDENTIALS_PROVIDER,            STANDARD_AWS_PROVIDERS,            new HashSet<>());        LOG.debug("For URI {}, using credentials {}",        binding, credentials);    return credentials;  }    public static List<Class<?>> loadAWSProviderClasses(Configuration conf,      String key,      Class<?>... defaultValue) throws IOException {    try {      return Arrays.asList(conf.getClasses(key, defaultValue));    } catch (RuntimeException e) {      Throwable c = e.getCause() != null ? e.getCause() : e;      throw new IOException("From option " + key + ' ' + c, c);    }  }    public static AWSCredentialProviderList buildAWSProviderList(      @Nullable final URI binding,      final Configuration conf,      final String key,      final List<Class<?>> defaultValues,      final Set<Class<?>> forbidden) throws IOException {        List<Class<?>> awsClasses = loadAWSProviderClasses(conf,        key,        defaultValues.toArray(new Class[defaultValues.size()]));                if (awsClasses.isEmpty()) {      awsClasses = defaultValues;    }            AWSCredentialProviderList providers = new AWSCredentialProviderList();    for (Class<?> aClass : awsClasses) {      if (forbidden.contains(aClass)) {        throw new IOException(E_FORBIDDEN_AWS_PROVIDER            + " in option " + key + ": " + aClass);      }      providers.add(createAWSCredentialProvider(conf,          aClass, binding));    }    return providers;  }    private static AWSCredentialsProvider createAWSCredentialProvider(      Configuration conf,      Class<?> credClass,      @Nullable URI uri) throws IOException {    AWSCredentialsProvider credentials = null;    String className = credClass.getName();    if (!AWSCredentialsProvider.class.isAssignableFrom(credClass)) {      throw new IOException("Class " + credClass + " " + NOT_AWS_PROVIDER);    }    if (Modifier.isAbstract(credClass.getModifiers())) {      throw new IOException("Class " + credClass + " " + ABSTRACT_PROVIDER);    }    LOG.debug("Credential provider class is {}", className);    try {            Constructor cons = getConstructor(credClass, URI.class,          Configuration.class);      if (cons != null) {        credentials = (AWSCredentialsProvider)cons.newInstance(uri, conf);        return credentials;      }            cons = getConstructor(credClass, Configuration.class);      if (cons != null) {        credentials = (AWSCredentialsProvider)cons.newInstance(conf);        return credentials;      }            Method factory = getFactoryMethod(credClass, AWSCredentialsProvider.class,          "getInstance");      if (factory != null) {        credentials = (AWSCredentialsProvider)factory.invoke(null);        return credentials;      }            cons = getConstructor(credClass);      if (cons != null) {        credentials = (AWSCredentialsProvider)cons.newInstance();        return credentials;      }            throw new IOException(String.format("%s " + CONSTRUCTOR_EXCEPTION          + ".  A class specified in %s must provide a public constructor "          + "of a supported signature, or a public factory method named "          + "getInstance that accepts no arguments.",          className, AWS_CREDENTIALS_PROVIDER));    } catch (InvocationTargetException e) {      Throwable targetException = e.getTargetException();      if (targetException == null) {        targetException =  e;      }      if (targetException instanceof IOException) {        throw (IOException) targetException;      } else if (targetException instanceof SdkBaseException) {        throw translateException("Instantiate " + className, "",            (SdkBaseException) targetException);      } else {                throw new IOException(className + " " + INSTANTIATION_EXCEPTION            + ": " + targetException,            targetException);      }    } catch (ReflectiveOperationException | IllegalArgumentException e) {            throw new IOException(className + " " + INSTANTIATION_EXCEPTION          + ": " + e,          e);    }  }    public static boolean setIfDefined(Configuration config, String key,      String val, String origin) {    if (StringUtils.isNotEmpty(val)) {      config.set(key, val, origin);      return true;    } else {      return false;    }  }    public static S3xLoginHelper.Login getAWSAccessKeys(URI name,      Configuration conf) throws IOException {    S3xLoginHelper.rejectSecretsInURIs(name);    Configuration c = ProviderUtils.excludeIncompatibleCredentialProviders(        conf, S3AFileSystem.class);    String bucket = name != null ? name.getHost() : "";            String accessKey = lookupPassword(bucket, c, ACCESS_KEY);        String secretKey = lookupPassword(bucket, c, SECRET_KEY);    return new S3xLoginHelper.Login(accessKey, secretKey);  }    @Deprecated  public static String lookupPassword(      String bucket,      Configuration conf,      String baseKey,      String overrideVal)      throws IOException {    return lookupPassword(bucket, conf, baseKey, overrideVal, "");  }    public static String lookupPassword(      String bucket,      Configuration conf,      String baseKey)      throws IOException {    return lookupPassword(bucket, conf, baseKey, null, "");  }    public static String lookupPassword(      String bucket,      Configuration conf,      String baseKey,      String overrideVal,      String defVal)      throws IOException {    String initialVal;    Preconditions.checkArgument(baseKey.startsWith(FS_S3A_PREFIX),        "%s does not start with $%s", baseKey, FS_S3A_PREFIX);        if (StringUtils.isNotEmpty(bucket)) {      String subkey = baseKey.substring(FS_S3A_PREFIX.length());      String shortBucketKey = String.format(          BUCKET_PATTERN, bucket, subkey);      String longBucketKey = String.format(          BUCKET_PATTERN, bucket, baseKey);            initialVal = getPassword(conf, longBucketKey, overrideVal);            initialVal = getPassword(conf, shortBucketKey, initialVal);    } else {            initialVal = overrideVal;    }    return getPassword(conf, baseKey, initialVal, defVal);  }    private static String getPassword(Configuration conf, String key, String val)      throws IOException {    return getPassword(conf, key, val, "");  }    private static String getPassword(Configuration conf,      String key,      String val,      String defVal) throws IOException {    return isEmpty(val)        ? lookupPassword(conf, key, defVal)        : val;  }    static String lookupPassword(Configuration conf, String key, String defVal)      throws IOException {    try {      final char[] pass = conf.getPassword(key);      return pass != null ?          new String(pass).trim()          : defVal;    } catch (IOException ioe) {      throw new IOException("Cannot find password option " + key, ioe);    }  }    public static String stringify(S3ObjectSummary summary) {    StringBuilder builder = new StringBuilder(summary.getKey().length() + 100);    builder.append(summary.getKey()).append(' ');    builder.append("size=").append(summary.getSize());    return builder.toString();  }    public static int intOption(Configuration conf, String key, int defVal, int min) {    int v = conf.getInt(key, defVal);    Preconditions.checkArgument(v >= min,        String.format("Value of %s: %d is below the minimum value %d",            key, v, min));    LOG.debug("Value of {} is {}", key, v);    return v;  }    public static long longOption(Configuration conf,      String key,      long defVal,      long min) {    long v = conf.getLong(key, defVal);    Preconditions.checkArgument(v >= min,        String.format("Value of %s: %d is below the minimum value %d",            key, v, min));    LOG.debug("Value of {} is {}", key, v);    return v;  }    public static long longBytesOption(Configuration conf,                             String key,                             long defVal,                             long min) {    long v = conf.getLongBytes(key, defVal);    Preconditions.checkArgument(v >= min,            String.format("Value of %s: %d is below the minimum value %d",                    key, v, min));    LOG.debug("Value of {} is {}", key, v);    return v;  }    public static long getMultipartSizeProperty(Configuration conf,      String property, long defVal) {    long partSize = conf.getLongBytes(property, defVal);    if (partSize < MULTIPART_MIN_SIZE) {      LOG.warn("{} must be at least 5 MB; configured value is {}",          property, partSize);      partSize = MULTIPART_MIN_SIZE;    }    return partSize;  }    public static int ensureOutputParameterInRange(String name, long size) {    if (size > Integer.MAX_VALUE) {      LOG.warn("s3a: {} capped to ~2.14GB" +          " (maximum allowed size with current output mechanism)", name);      return Integer.MAX_VALUE;    } else {      return (int)size;    }  }    private static Constructor<?> getConstructor(Class<?> cl, Class<?>... args) {    try {      Constructor cons = cl.getDeclaredConstructor(args);      return Modifier.isPublic(cons.getModifiers()) ? cons : null;    } catch (NoSuchMethodException | SecurityException e) {      return null;    }  }    private static Method getFactoryMethod(Class<?> cl, Class<?> returnType,      String methodName) {    try {      Method m = cl.getDeclaredMethod(methodName);      if (Modifier.isPublic(m.getModifiers()) &&          Modifier.isStatic(m.getModifiers()) &&          returnType.isAssignableFrom(m.getReturnType())) {        return m;      } else {        return null;      }    } catch (NoSuchMethodException | SecurityException e) {      return null;    }  }    public static Configuration propagateBucketOptions(Configuration source,      String bucket) {    Preconditions.checkArgument(StringUtils.isNotEmpty(bucket), "bucket");    final String bucketPrefix = FS_S3A_BUCKET_PREFIX + bucket +'.';    LOG.debug("Propagating entries under {}", bucketPrefix);    final Configuration dest = new Configuration(source);    for (Map.Entry<String, String> entry : source) {      final String key = entry.getKey();            final String value = entry.getValue();      if (!key.startsWith(bucketPrefix) || bucketPrefix.equals(key)) {        continue;      }            final String stripped = key.substring(bucketPrefix.length());      if (stripped.startsWith("bucket.") || "impl".equals(stripped)) {                LOG.debug("Ignoring bucket option {}", key);      }  else {                                String origin = "[" + StringUtils.join(            source.getPropertySources(key), ", ") +"]";        final String generic = FS_S3A_PREFIX + stripped;        LOG.debug("Updating {} from {}", generic, origin);        dest.set(generic, value, key + " via " + origin);      }    }    return dest;  }    public static void deleteQuietly(FileSystem fs,      Path path,      boolean recursive) {    try {      fs.delete(path, recursive);    } catch (IOException e) {      LOG.debug("Failed to delete {}", path, e);    }  }    public static void deleteWithWarning(FileSystem fs,      Path path,      boolean recursive) {    try {      fs.delete(path, recursive);    } catch (IOException e) {      LOG.warn("Failed to delete {}", path, e);    }  }    @Deprecated  public static ClientConfiguration createAwsConf(Configuration conf,      String bucket)      throws IOException {    return createAwsConf(conf, bucket, null);  }    public static ClientConfiguration createAwsConf(Configuration conf,      String bucket, String awsServiceIdentifier)      throws IOException {    final ClientConfiguration awsConf = new ClientConfiguration();    initConnectionSettings(conf, awsConf);    initProxySupport(conf, bucket, awsConf);    initUserAgent(conf, awsConf);    if (StringUtils.isNotEmpty(awsServiceIdentifier)) {      String configKey = null;      switch (awsServiceIdentifier) {      case AWS_SERVICE_IDENTIFIER_S3:        configKey = SIGNING_ALGORITHM_S3;        break;      case AWS_SERVICE_IDENTIFIER_DDB:        configKey = SIGNING_ALGORITHM_DDB;        break;      case AWS_SERVICE_IDENTIFIER_STS:        configKey = SIGNING_ALGORITHM_STS;        break;      default:              }      if (configKey != null) {        String signerOverride = conf.getTrimmed(configKey, "");        if (!signerOverride.isEmpty()) {          LOG.debug("Signer override for {}} = {}", awsServiceIdentifier,              signerOverride);          awsConf.setSignerOverride(signerOverride);        }      }    }    return awsConf;  }    public static void initConnectionSettings(Configuration conf,      ClientConfiguration awsConf) throws IOException {    awsConf.setMaxConnections(intOption(conf, MAXIMUM_CONNECTIONS,        DEFAULT_MAXIMUM_CONNECTIONS, 1));    initProtocolSettings(conf, awsConf);    awsConf.setMaxErrorRetry(intOption(conf, MAX_ERROR_RETRIES,        DEFAULT_MAX_ERROR_RETRIES, 0));    awsConf.setConnectionTimeout(intOption(conf, ESTABLISH_TIMEOUT,        DEFAULT_ESTABLISH_TIMEOUT, 0));    awsConf.setSocketTimeout(intOption(conf, SOCKET_TIMEOUT,        DEFAULT_SOCKET_TIMEOUT, 0));    int sockSendBuffer = intOption(conf, SOCKET_SEND_BUFFER,        DEFAULT_SOCKET_SEND_BUFFER, 2048);    int sockRecvBuffer = intOption(conf, SOCKET_RECV_BUFFER,        DEFAULT_SOCKET_RECV_BUFFER, 2048);    long requestTimeoutMillis = conf.getTimeDuration(REQUEST_TIMEOUT,        DEFAULT_REQUEST_TIMEOUT, TimeUnit.SECONDS, TimeUnit.MILLISECONDS);    if (requestTimeoutMillis > Integer.MAX_VALUE) {      LOG.debug("Request timeout is too high({} ms). Setting to {} ms instead",          requestTimeoutMillis, Integer.MAX_VALUE);      requestTimeoutMillis = Integer.MAX_VALUE;    }    awsConf.setRequestTimeout((int) requestTimeoutMillis);    awsConf.setSocketBufferSizeHints(sockSendBuffer, sockRecvBuffer);    String signerOverride = conf.getTrimmed(SIGNING_ALGORITHM, "");    if (!signerOverride.isEmpty()) {     LOG.debug("Signer override = {}", signerOverride);      awsConf.setSignerOverride(signerOverride);    }  }    private static void initProtocolSettings(Configuration conf,      ClientConfiguration awsConf) throws IOException {    boolean secureConnections = conf.getBoolean(SECURE_CONNECTIONS,        DEFAULT_SECURE_CONNECTIONS);    awsConf.setProtocol(secureConnections ?  Protocol.HTTPS : Protocol.HTTP);    if (secureConnections) {      NetworkBinding.bindSSLChannelMode(conf, awsConf);    }  }    public static void initProxySupport(Configuration conf,      String bucket,      ClientConfiguration awsConf) throws IllegalArgumentException,      IOException {    String proxyHost = conf.getTrimmed(PROXY_HOST, "");    int proxyPort = conf.getInt(PROXY_PORT, -1);    if (!proxyHost.isEmpty()) {      awsConf.setProxyHost(proxyHost);      if (proxyPort >= 0) {        awsConf.setProxyPort(proxyPort);      } else {        if (conf.getBoolean(SECURE_CONNECTIONS, DEFAULT_SECURE_CONNECTIONS)) {          LOG.warn("Proxy host set without port. Using HTTPS default 443");          awsConf.setProxyPort(443);        } else {          LOG.warn("Proxy host set without port. Using HTTP default 80");          awsConf.setProxyPort(80);        }      }      final String proxyUsername = lookupPassword(bucket, conf, PROXY_USERNAME,          null, null);      final String proxyPassword = lookupPassword(bucket, conf, PROXY_PASSWORD,          null, null);      if ((proxyUsername == null) != (proxyPassword == null)) {        String msg = "Proxy error: " + PROXY_USERNAME + " or " +            PROXY_PASSWORD + " set without the other.";        LOG.error(msg);        throw new IllegalArgumentException(msg);      }      awsConf.setProxyUsername(proxyUsername);      awsConf.setProxyPassword(proxyPassword);      awsConf.setProxyDomain(conf.getTrimmed(PROXY_DOMAIN));      awsConf.setProxyWorkstation(conf.getTrimmed(PROXY_WORKSTATION));      if (LOG.isDebugEnabled()) {        LOG.debug("Using proxy server {}:{} as user {} with password {} on " +                "domain {} as workstation {}", awsConf.getProxyHost(),            awsConf.getProxyPort(),            String.valueOf(awsConf.getProxyUsername()),            awsConf.getProxyPassword(), awsConf.getProxyDomain(),            awsConf.getProxyWorkstation());      }    } else if (proxyPort >= 0) {      String msg =          "Proxy error: " + PROXY_PORT + " set without " + PROXY_HOST;      LOG.error(msg);      throw new IllegalArgumentException(msg);    }  }    private static void initUserAgent(Configuration conf,      ClientConfiguration awsConf) {    String userAgent = "Hadoop " + VersionInfo.getVersion();    String userAgentPrefix = conf.getTrimmed(USER_AGENT_PREFIX, "");    if (!userAgentPrefix.isEmpty()) {      userAgent = userAgentPrefix + ", " + userAgent;    }    LOG.debug("Using User-Agent: {}", userAgent);    awsConf.setUserAgentPrefix(userAgent);  }    public static S3AFileStatus[] iteratorToStatuses(      RemoteIterator<S3AFileStatus> iterator, Set<Path> tombstones)      throws IOException {        RemoteIterator<S3AFileStatus> source = filteringRemoteIterator(iterator,        st -> !tombstones.contains(st.getPath()));    S3AFileStatus[] statuses = RemoteIterators        .toArray(source, new S3AFileStatus[0]);    return statuses;  }    @FunctionalInterface  public interface CallOnLocatedFileStatus {    void call(LocatedFileStatus status) throws IOException;  }    @FunctionalInterface  public interface LocatedFileStatusMap<T> {    T call(LocatedFileStatus status) throws IOException;  }    public static long applyLocatedFiles(      RemoteIterator<? extends LocatedFileStatus> iterator,      CallOnLocatedFileStatus eval) throws IOException {    return RemoteIterators.foreach(iterator, eval::call);  }    public static <T> List<T> mapLocatedFiles(      RemoteIterator<? extends LocatedFileStatus> iterator,      LocatedFileStatusMap<T> eval) throws IOException {    final List<T> results = new ArrayList<>();    applyLocatedFiles(iterator,        (s) -> results.add(eval.call(s)));    return results;  }    public static <T> List<T> flatmapLocatedFiles(      RemoteIterator<LocatedFileStatus> iterator,      LocatedFileStatusMap<Optional<T>> eval) throws IOException {    final List<T> results = new ArrayList<>();    applyLocatedFiles(iterator,        (s) -> eval.call(s).map(r -> results.add(r)));    return results;  }    public static List<LocatedFileStatus> listAndFilter(FileSystem fileSystem,      Path path, boolean recursive, PathFilter filter) throws IOException {    return flatmapLocatedFiles(fileSystem.listFiles(path, recursive),        status -> maybe(filter.accept(status.getPath()), status));  }    public static <T> Optional<T> maybe(boolean include, T value) {    return include ? Optional.of(value) : Optional.empty();  }    static void patchSecurityCredentialProviders(Configuration conf) {    Collection<String> customCredentials = conf.getStringCollection(        S3A_SECURITY_CREDENTIAL_PROVIDER_PATH);    Collection<String> hadoopCredentials = conf.getStringCollection(        CREDENTIAL_PROVIDER_PATH);    if (!customCredentials.isEmpty()) {      List<String> all = Lists.newArrayList(customCredentials);      all.addAll(hadoopCredentials);      String joined = StringUtils.join(all, ',');      LOG.debug("Setting {} to {}", CREDENTIAL_PROVIDER_PATH,          joined);      conf.set(CREDENTIAL_PROVIDER_PATH, joined,          "patch of " + S3A_SECURITY_CREDENTIAL_PROVIDER_PATH);    }  }    public static String getServerSideEncryptionKey(String bucket,      Configuration conf) {    try {      return lookupPassword(bucket, conf, SERVER_SIDE_ENCRYPTION_KEY);    } catch (IOException e) {      LOG.error("Cannot retrieve " + SERVER_SIDE_ENCRYPTION_KEY, e);      return "";    }  }    public static S3AEncryptionMethods getEncryptionAlgorithm(String bucket,      Configuration conf) throws IOException {    S3AEncryptionMethods sse = S3AEncryptionMethods.getMethod(        lookupPassword(bucket, conf,            SERVER_SIDE_ENCRYPTION_ALGORITHM));    String sseKey = getServerSideEncryptionKey(bucket, conf);    int sseKeyLen = StringUtils.isBlank(sseKey) ? 0 : sseKey.length();    String diagnostics = passwordDiagnostics(sseKey, "key");    switch (sse) {    case SSE_C:      LOG.debug("Using SSE-C with {}", diagnostics);      if (sseKeyLen == 0) {        throw new IOException(SSE_C_NO_KEY_ERROR);      }      break;    case SSE_S3:      if (sseKeyLen != 0) {        throw new IOException(SSE_S3_WITH_KEY_ERROR            + " (" + diagnostics + ")");      }      break;    case SSE_KMS:      LOG.debug("Using SSE-KMS with {}",          diagnostics);      break;    case NONE:    default:      LOG.debug("Data is unencrypted");      break;    }    return sse;  }    private static String passwordDiagnostics(String pass, String description) {    if (pass == null) {      return "null " + description;    }    int len = pass.length();    switch (len) {    case 0:      return "empty " + description;    case 1:      return description + " of length 1";    default:      return description + " of length " + len + " ending with "          + pass.charAt(len - 1);    }  }    @Deprecated  public static void closeAll(Logger log,      Closeable... closeables) {    cleanupWithLogger(log, closeables);  }    public static void closeAutocloseables(Logger log,      AutoCloseable... closeables) {    if (log == null) {      log = LOG;    }    for (AutoCloseable c : closeables) {      if (c != null) {        try {          log.debug("Closing {}", c);          c.close();        } catch (Exception e) {          log.debug("Exception in closing {}", c, e);        }      }    }  }    public static void setBucketOption(Configuration conf, String bucket,      String genericKey, String value) {    final String baseKey = genericKey.startsWith(FS_S3A_PREFIX) ?        genericKey.substring(FS_S3A_PREFIX.length())        : genericKey;    conf.set(FS_S3A_BUCKET_PREFIX + bucket + '.' + baseKey, value, "S3AUtils");  }    public static void clearBucketOption(Configuration conf, String bucket,      String genericKey) {    final String baseKey = genericKey.startsWith(FS_S3A_PREFIX) ?        genericKey.substring(FS_S3A_PREFIX.length())        : genericKey;    String k = FS_S3A_BUCKET_PREFIX + bucket + '.' + baseKey;    LOG.debug("Unset {}", k);    conf.unset(k);  }    public static String getBucketOption(Configuration conf, String bucket,      String genericKey) {    final String baseKey = genericKey.startsWith(FS_S3A_PREFIX) ?        genericKey.substring(FS_S3A_PREFIX.length())        : genericKey;    return conf.get(FS_S3A_BUCKET_PREFIX + bucket + '.' + baseKey);  }    public static String maybeAddTrailingSlash(String key) {    if (!key.isEmpty() && !key.endsWith("/")) {      return key + '/';    } else {      return key;    }  }    public static final PathFilter HIDDEN_FILE_FILTER = new PathFilter() {    @Override    public boolean accept(Path path) {      String name = path.getName();      return !name.startsWith("_") && !name.startsWith(".");    }    @Override    public String toString() {      return "HIDDEN_FILE_FILTER";    }  };    public static final PathFilter ACCEPT_ALL = new PathFilter() {    @Override    public boolean accept(Path file) {      return true;    }    @Override    public String toString() {      return "ACCEPT_ALL";    }  };}
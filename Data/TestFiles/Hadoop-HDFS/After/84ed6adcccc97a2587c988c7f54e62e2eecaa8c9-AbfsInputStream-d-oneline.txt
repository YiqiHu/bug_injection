public class AbfsInputStream extends FSInputStream implements CanUnbuffer,        StreamCapabilities {  private static final Logger LOG = LoggerFactory.getLogger(AbfsInputStream.class);  private final AbfsClient client;  private final Statistics statistics;  private final String path;  private final long contentLength;  private final int bufferSize;   private final int readAheadQueueDepth;           private final String eTag;                    private final boolean tolerateOobAppends;   private final boolean readAheadEnabled;     private CachedSASToken cachedSasToken;  private byte[] buffer = null;              private long fCursor = 0;    private long fCursorAfterLastRead = -1;  private int bCursor = 0;     private int limit = 0;         private boolean closed = false;    private final AbfsInputStreamStatistics streamStatistics;  private long bytesFromReadAhead;   private long bytesFromRemoteRead;   public AbfsInputStream(          final AbfsClient client,          final Statistics statistics,          final String path,          final long contentLength,          final AbfsInputStreamContext abfsInputStreamContext,          final String eTag) {    this.client = client;    this.statistics = statistics;    this.path = path;    this.contentLength = contentLength;    this.bufferSize = abfsInputStreamContext.getReadBufferSize();    this.readAheadQueueDepth = abfsInputStreamContext.getReadAheadQueueDepth();    this.tolerateOobAppends = abfsInputStreamContext.isTolerateOobAppends();    this.eTag = eTag;    this.readAheadEnabled = true;    this.cachedSasToken = new CachedSASToken(        abfsInputStreamContext.getSasTokenRenewPeriodForStreamsInSeconds());    this.streamStatistics = abfsInputStreamContext.getStreamStatistics();  }  public String getPath() {    return path;  }  @Override  public int read() throws IOException {    byte[] b = new byte[1];    int numberOfBytesRead = read(b, 0, 1);    if (numberOfBytesRead < 0) {      return -1;    } else {      return (b[0] & 0xFF);    }  }  @Override  public synchronized int read(final byte[] b, final int off, final int len) throws IOException {        if (b != null) {      LOG.debug("read requested b.length = {} offset = {} len = {}", b.length,          off, len);    } else {      LOG.debug("read requested b = null offset = {} len = {}", off, len);    }    int currentOff = off;    int currentLen = len;    int lastReadBytes;    int totalReadBytes = 0;    if (streamStatistics != null) {      streamStatistics.readOperationStarted(off, len);    }    incrementReadOps();    do {      lastReadBytes = readOneBlock(b, currentOff, currentLen);      if (lastReadBytes > 0) {        currentOff += lastReadBytes;        currentLen -= lastReadBytes;        totalReadBytes += lastReadBytes;      }      if (currentLen <= 0 || currentLen > b.length - currentOff) {        break;      }    } while (lastReadBytes > 0);    return totalReadBytes > 0 ? totalReadBytes : lastReadBytes;  }  private int readOneBlock(final byte[] b, final int off, final int len) throws IOException {    if (closed) {      throw new IOException(FSExceptionMessages.STREAM_IS_CLOSED);    }    Preconditions.checkNotNull(b);    LOG.debug("read one block requested b.length = {} off {} len {}", b.length,        off, len);    if (len == 0) {      return 0;    }    if (this.available() == 0) {      return -1;    }    if (off < 0 || len < 0 || len > b.length - off) {      throw new IndexOutOfBoundsException();    }        if (bCursor == limit) {            if (fCursor >= contentLength) {        return -1;      }      long bytesRead = 0;            bCursor = 0;      limit = 0;      if (buffer == null) {        LOG.debug("created new buffer size {}", bufferSize);        buffer = new byte[bufferSize];      }            if (-1 == fCursorAfterLastRead || fCursorAfterLastRead == fCursor || b.length >= bufferSize) {        bytesRead = readInternal(fCursor, buffer, 0, bufferSize, false);      } else {        bytesRead = readInternal(fCursor, buffer, 0, b.length, true);      }      if (bytesRead == -1) {        return -1;      }      limit += bytesRead;      fCursor += bytesRead;      fCursorAfterLastRead = fCursor;    }            int bytesRemaining = limit - bCursor;    int bytesToRead = Math.min(len, bytesRemaining);    System.arraycopy(buffer, bCursor, b, off, bytesToRead);    bCursor += bytesToRead;    if (statistics != null) {      statistics.incrementBytesRead(bytesToRead);    }    if (streamStatistics != null) {            streamStatistics.bytesReadFromBuffer(bytesToRead);      streamStatistics.bytesRead(bytesToRead);    }    return bytesToRead;  }  private int readInternal(final long position, final byte[] b, final int offset, final int length,                           final boolean bypassReadAhead) throws IOException {    if (readAheadEnabled && !bypassReadAhead) {            if (offset != 0) {        throw new IllegalArgumentException("readahead buffers cannot have non-zero buffer offsets");      }      int receivedBytes;            int numReadAheads = this.readAheadQueueDepth;      long nextSize;      long nextOffset = position;      LOG.debug("read ahead enabled issuing readheads num = {}", numReadAheads);      while (numReadAheads > 0 && nextOffset < contentLength) {        nextSize = Math.min((long) bufferSize, contentLength - nextOffset);        LOG.debug("issuing read ahead requestedOffset = {} requested size {}",            nextOffset, nextSize);        ReadBufferManager.getBufferManager().queueReadAhead(this, nextOffset, (int) nextSize);        nextOffset = nextOffset + nextSize;        numReadAheads--;      }            receivedBytes = ReadBufferManager.getBufferManager().getBlock(this, position, length, b);      bytesFromReadAhead += receivedBytes;      if (receivedBytes > 0) {        incrementReadOps();        LOG.debug("Received data from read ahead, not doing remote read");        if (streamStatistics != null) {          streamStatistics.readAheadBytesRead(receivedBytes);        }        return receivedBytes;      }            receivedBytes = readRemote(position, b, offset, length);      return receivedBytes;    } else {      LOG.debug("read ahead disabled, reading remote");      return readRemote(position, b, offset, length);    }  }  int readRemote(long position, byte[] b, int offset, int length) throws IOException {    if (position < 0) {      throw new IllegalArgumentException("attempting to read from negative offset");    }    if (position >= contentLength) {      return -1;      }    if (b == null) {      throw new IllegalArgumentException("null byte array passed in to read() method");    }    if (offset >= b.length) {      throw new IllegalArgumentException("offset greater than length of array");    }    if (length < 0) {      throw new IllegalArgumentException("requested read length is less than zero");    }    if (length > (b.length - offset)) {      throw new IllegalArgumentException("requested read length is more than will fit after requested offset in buffer");    }    final AbfsRestOperation op;    AbfsPerfTracker tracker = client.getAbfsPerfTracker();    try (AbfsPerfInfo perfInfo = new AbfsPerfInfo(tracker, "readRemote", "read")) {      LOG.trace("Trigger client.read for path={} position={} offset={} length={}", path, position, offset, length);      op = client.read(path, position, b, offset, length, tolerateOobAppends ? "*" : eTag, cachedSasToken.get());      cachedSasToken.update(op.getSasToken());      if (streamStatistics != null) {        streamStatistics.remoteReadOperation();      }      LOG.debug("issuing HTTP GET request params position = {} b.length = {} "          + "offset = {} length = {}", position, b.length, offset, length);      perfInfo.registerResult(op.getResult()).registerSuccess(true);      incrementReadOps();    } catch (AzureBlobFileSystemException ex) {      if (ex instanceof AbfsRestOperationException) {        AbfsRestOperationException ere = (AbfsRestOperationException) ex;        if (ere.getStatusCode() == HttpURLConnection.HTTP_NOT_FOUND) {          throw new FileNotFoundException(ere.getMessage());        }      }      throw new IOException(ex);    }    long bytesRead = op.getResult().getBytesReceived();    if (streamStatistics != null) {      streamStatistics.remoteBytesRead(bytesRead);    }    if (bytesRead > Integer.MAX_VALUE) {      throw new IOException("Unexpected Content-Length");    }    LOG.debug("HTTP request read bytes = {}", bytesRead);    bytesFromRemoteRead += bytesRead;    return (int) bytesRead;  }    private void incrementReadOps() {    if (statistics != null) {      statistics.incrementReadOps(1);    }  }    @Override  public synchronized void seek(long n) throws IOException {    LOG.debug("requested seek to position {}", n);    if (closed) {      throw new IOException(FSExceptionMessages.STREAM_IS_CLOSED);    }    if (n < 0) {      throw new EOFException(FSExceptionMessages.NEGATIVE_SEEK);    }    if (n > contentLength) {      throw new EOFException(FSExceptionMessages.CANNOT_SEEK_PAST_EOF);    }    if (streamStatistics != null) {      streamStatistics.seek(n, fCursor);    }    if (n>=fCursor-limit && n<=fCursor) {       bCursor = (int) (n-(fCursor-limit));      if (streamStatistics != null) {        streamStatistics.seekInBuffer();      }      return;    }        fCursor = n;    LOG.debug("set fCursor to {}", fCursor);        limit = 0;    bCursor = 0;  }  @Override  public synchronized long skip(long n) throws IOException {    if (closed) {      throw new IOException(FSExceptionMessages.STREAM_IS_CLOSED);    }    long currentPos = getPos();    if (currentPos == contentLength) {      if (n > 0) {        throw new EOFException(FSExceptionMessages.CANNOT_SEEK_PAST_EOF);      }    }    long newPos = currentPos + n;    if (newPos < 0) {      newPos = 0;      n = newPos - currentPos;    }    if (newPos > contentLength) {      newPos = contentLength;      n = newPos - currentPos;    }    seek(newPos);    return n;  }    @Override  public synchronized int available() throws IOException {    if (closed) {      throw new IOException(          FSExceptionMessages.STREAM_IS_CLOSED);    }    final long remaining = this.contentLength - this.getPos();    return remaining <= Integer.MAX_VALUE        ? (int) remaining : Integer.MAX_VALUE;  }    public long length() throws IOException {    if (closed) {      throw new IOException(FSExceptionMessages.STREAM_IS_CLOSED);    }    return contentLength;  }    @Override  public synchronized long getPos() throws IOException {    if (closed) {      throw new IOException(FSExceptionMessages.STREAM_IS_CLOSED);    }    return fCursor - limit + bCursor;  }    @Override  public boolean seekToNewSource(long l) throws IOException {    return false;  }  @Override  public synchronized void close() throws IOException {    closed = true;    buffer = null;     LOG.debug("Closing {}", this);  }    @Override  public synchronized void mark(int readlimit) {    throw new UnsupportedOperationException("mark()/reset() not supported on this stream");  }    @Override  public synchronized void reset() throws IOException {    throw new UnsupportedOperationException("mark()/reset() not supported on this stream");  }    @Override  public boolean markSupported() {    return false;  }  @Override  public synchronized void unbuffer() {    buffer = null;        fCursor = fCursor - limit + bCursor;    fCursorAfterLastRead = -1;    bCursor = 0;    limit = 0;  }  @Override  public boolean hasCapability(String capability) {    return StreamCapabilities.UNBUFFER.equals(toLowerCase(capability));  }  byte[] getBuffer() {    return buffer;  }  @VisibleForTesting  protected void setCachedSasToken(final CachedSASToken cachedSasToken) {    this.cachedSasToken = cachedSasToken;  }    @VisibleForTesting  public AbfsInputStreamStatistics getStreamStatistics() {    return streamStatistics;  }    @VisibleForTesting  public long getBytesFromReadAhead() {    return bytesFromReadAhead;  }    @VisibleForTesting  public long getBytesFromRemoteRead() {    return bytesFromRemoteRead;  }    @Override  public String toString() {    final StringBuilder sb = new StringBuilder(super.toString());    if (streamStatistics != null) {      sb.append("AbfsInputStream@(").append(this.hashCode()).append("){");      sb.append(streamStatistics.toString());      sb.append("}");    }    return sb.toString();  }}
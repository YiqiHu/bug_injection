public class TestViewFsLinkFallback {  private static FileSystem fsDefault;  private FileSystem fsTarget;  private static MiniDFSCluster cluster;  private static URI viewFsDefaultClusterUri;  private Path targetTestRoot;  @BeforeClass  public static void clusterSetupAtBeginning()      throws IOException, URISyntaxException {    int nameSpacesCount = 3;    int dataNodesCount = 3;    int fsIndexDefault = 0;    Configuration conf = new Configuration();    FileSystem[] fsHdfs = new FileSystem[nameSpacesCount];    conf.setBoolean(DFSConfigKeys.DFS_NAMENODE_DELEGATION_TOKEN_ALWAYS_USE_KEY,        true);    cluster = new MiniDFSCluster.Builder(conf)        .nnTopology(MiniDFSNNTopology.simpleFederatedTopology(            nameSpacesCount))        .numDataNodes(dataNodesCount)        .build();    cluster.waitClusterUp();    for (int i = 0; i < nameSpacesCount; i++) {      fsHdfs[i] = cluster.getFileSystem(i);    }    fsDefault = fsHdfs[fsIndexDefault];    viewFsDefaultClusterUri = new URI(FsConstants.VIEWFS_SCHEME,        Constants.CONFIG_VIEWFS_DEFAULT_MOUNT_TABLE, "/", null, null);  }  @AfterClass  public static void clusterShutdownAtEnd() throws Exception {    if (cluster != null) {      cluster.shutdown();    }  }  @Before  public void setUp() throws Exception {    fsTarget = fsDefault;    initializeTargetTestRoot();  }  private void initializeTargetTestRoot() throws IOException {    targetTestRoot = fsDefault.makeQualified(new Path("/"));    for (FileStatus status : fsDefault.listStatus(targetTestRoot)) {      fsDefault.delete(status.getPath(), true);    }  }    @Test  public void testMkdirOfLinkParentWithFallbackLinkWithSameMountDirectoryTree()      throws Exception {    Configuration conf = new Configuration();    conf.setBoolean(Constants.CONFIG_VIEWFS_MOUNT_LINKS_AS_SYMLINKS, false);    ConfigUtil.addLink(conf, "/user1/hive/warehouse/partition-0",        new Path(targetTestRoot.toString()).toUri());    Path dir1 = new Path(targetTestRoot,        "fallbackDir/user1/hive/warehouse/partition-0");    fsTarget.mkdirs(dir1);    Path fallbackTarget = new Path(targetTestRoot, "fallbackDir");    ConfigUtil.addLinkFallback(conf, fallbackTarget.toUri());    AbstractFileSystem vfs =        AbstractFileSystem.get(viewFsDefaultClusterUri, conf);    Path p = new Path("/user1/hive/warehouse/test");    Path test = Path.mergePaths(fallbackTarget, p);    assertFalse(fsTarget.exists(test));    vfs.mkdir(p, null, true);    assertTrue(fsTarget.exists(test));  }    @Test  public void testMkdirOfRootWithFallbackLinkAndMountWithSameDirTree()      throws Exception {    Configuration conf = new Configuration();    conf.setBoolean(Constants.CONFIG_VIEWFS_MOUNT_LINKS_AS_SYMLINKS, false);    ConfigUtil        .addLink(conf, "/user1", new Path(targetTestRoot.toString()).toUri());    Path dir1 = new Path(targetTestRoot, "fallbackDir/user1");    fsTarget.mkdirs(dir1);    Path fallbackTarget = new Path(targetTestRoot, "fallbackDir");    ConfigUtil.addLinkFallback(conf, fallbackTarget.toUri());    AbstractFileSystem vfs =        AbstractFileSystem.get(viewFsDefaultClusterUri, conf);    Path p = new Path("/");    Path test = Path.mergePaths(fallbackTarget, p);    assertTrue(fsTarget.exists(test));    vfs.mkdir(p, null, true);    assertTrue(fsTarget.exists(test));  }    @Test  public void testMkdirOfNewDirWithOutMatchingToMountOrFallbackDirTree()      throws Exception {    Configuration conf = new Configuration();    conf.setBoolean(Constants.CONFIG_VIEWFS_MOUNT_LINKS_AS_SYMLINKS, false);    ConfigUtil.addLink(conf, "/user1/hive/warehouse/partition-0",        new Path(targetTestRoot.toString()).toUri());    Path fallbackTarget = new Path(targetTestRoot, "fallbackDir");    fsTarget.mkdirs(fallbackTarget);    ConfigUtil.addLinkFallback(conf, fallbackTarget.toUri());    AbstractFileSystem vfs =        AbstractFileSystem.get(viewFsDefaultClusterUri, conf);        Path p = new Path("/user2");    Path test = Path.mergePaths(fallbackTarget, p);    assertFalse(fsTarget.exists(test));    vfs.mkdir(p, null, true);    assertTrue(fsTarget.exists(test));  }    @Test  public void testGetDelegationToken() throws IOException {    Configuration conf = new Configuration();    conf.setBoolean(Constants.CONFIG_VIEWFS_MOUNT_LINKS_AS_SYMLINKS, false);    ConfigUtil.addLink(conf, "/user",        new Path(targetTestRoot.toString(), "user").toUri());    ConfigUtil.addLink(conf, "/data",        new Path(targetTestRoot.toString(), "data").toUri());    ConfigUtil.addLinkFallback(conf, targetTestRoot.toUri());    FileContext fcView =        FileContext.getFileContext(FsConstants.VIEWFS_URI, conf);    List<Token<?>> tokens = fcView.getDelegationTokens(new Path("/"), "tester");        assertEquals(3, tokens.size());  }    @Test  public void testMkdirWithFallbackLinkWithMountPathMatchingDirExist()      throws Exception {    Configuration conf = new Configuration();    conf.setBoolean(Constants.CONFIG_VIEWFS_MOUNT_LINKS_AS_SYMLINKS, false);    ConfigUtil.addLink(conf, "/user1/hive",        new Path(targetTestRoot.toString()).toUri());    Path fallbackTarget = new Path(targetTestRoot, "fallbackDir");    fsTarget.mkdirs(fallbackTarget);    ConfigUtil.addLinkFallback(conf, fallbackTarget.toUri());    AbstractFileSystem vfs =        AbstractFileSystem.get(viewFsDefaultClusterUri, conf);        Path immediateLevelToInternalDir = new Path("/user1/test");    Path test = Path.mergePaths(fallbackTarget, immediateLevelToInternalDir);    assertFalse(fsTarget.exists(test));    vfs.mkdir(immediateLevelToInternalDir, null, true);    assertTrue(fsTarget.exists(test));  }    @Test  public void testMkdirOfDeepTreeWithFallbackLinkAndMountPathMatchingDirExist()      throws Exception {    Configuration conf = new Configuration();    conf.setBoolean(Constants.CONFIG_VIEWFS_MOUNT_LINKS_AS_SYMLINKS, false);    ConfigUtil.addLink(conf, "/user1/hive",        new Path(targetTestRoot.toString()).toUri());    Path fallbackTarget = new Path(targetTestRoot, "fallbackDir");    fsTarget.mkdirs(fallbackTarget);    ConfigUtil.addLinkFallback(conf, fallbackTarget.toUri());    AbstractFileSystem vfs =        AbstractFileSystem.get(viewFsDefaultClusterUri, conf);        Path multipleLevelToInternalDir = new Path("/user1/test/test");    Path test = Path.mergePaths(fallbackTarget, multipleLevelToInternalDir);    assertFalse(fsTarget.exists(test));    vfs.mkdir(multipleLevelToInternalDir, null, true);    assertTrue(fsTarget.exists(test));  }    @Test  public void testMkdirShouldCreateParentDirInFallbackWhenMountDirExist()      throws Exception {    Configuration conf = new Configuration();    conf.setBoolean(Constants.CONFIG_VIEWFS_MOUNT_LINKS_AS_SYMLINKS, false);    ConfigUtil.addLink(conf, "/user1/hive/test",        new Path(targetTestRoot.toString()).toUri());    Path fallbackTarget = new Path(targetTestRoot, "fallbackDir");    fsTarget.mkdirs(fallbackTarget);    ConfigUtil.addLinkFallback(conf, fallbackTarget.toUri());    AbstractFileSystem vfs = AbstractFileSystem.get(viewFsDefaultClusterUri,        conf);        Path multipleLevelToInternalDir = new Path("/user1/hive/test1");    Path test = Path.mergePaths(fallbackTarget, multipleLevelToInternalDir);    assertFalse(fsTarget.exists(test));        assertNotNull(vfs.getFileStatus(new Path("/user1/hive")));        assertFalse(fsTarget.exists(test.getParent()));    vfs.mkdir(multipleLevelToInternalDir, FsPermission.getDirDefault(), false);    assertTrue(fsTarget.exists(test));  }    @Test  public void testMkdirShouldFailWhenFallbackFSNotAvailable()      throws Exception {    Configuration conf = new Configuration();    conf.setBoolean(Constants.CONFIG_VIEWFS_MOUNT_LINKS_AS_SYMLINKS, false);    ConfigUtil.addLink(conf, "/user1/test",        new Path(targetTestRoot.toString()).toUri());    Path fallbackTarget = new Path(targetTestRoot, "fallbackDir");    fsTarget.mkdirs(fallbackTarget);    ConfigUtil.addLinkFallback(conf, fallbackTarget.toUri());    AbstractFileSystem vfs = AbstractFileSystem.get(viewFsDefaultClusterUri,        conf);        Path nextLevelToInternalDir = new Path("/user1/test1");    Path test = Path.mergePaths(fallbackTarget, nextLevelToInternalDir);    assertFalse(fsTarget.exists(test));        assertNotNull(vfs.getFileStatus(new Path("/user1")));        assertFalse(fsTarget.exists(test.getParent()));    cluster.shutdownNameNodes();    try {                  vfs.mkdir(nextLevelToInternalDir, FsPermission.getDirDefault(),          false);      Assert.fail("It should throw IOE when fallback fs not available.");    } catch (IOException e) {      cluster.restartNameNodes();            vfs.mkdir(nextLevelToInternalDir, FsPermission.getDirDefault(),          false);    }    assertTrue(fsTarget.exists(test));  }    @Test  public void testCreateFileOnInternalMountDirWithSameDirTreeExistInFallback()      throws Exception {    Configuration conf = new Configuration();    ConfigUtil.addLink(conf, "/user1/hive/warehouse/partition-0",        new Path(targetTestRoot.toString()).toUri());    Path fallbackTarget = new Path(targetTestRoot, "fallbackDir");    Path dir1 = new Path(fallbackTarget, "user1/hive/warehouse/partition-0");    fsTarget.mkdirs(dir1);    ConfigUtil.addLinkFallback(conf, fallbackTarget.toUri());    AbstractFileSystem vfs =        AbstractFileSystem.get(viewFsDefaultClusterUri, conf);    Path vfsTestFile = new Path("/user1/hive/warehouse/test.file");    Path testFileInFallback = Path.mergePaths(fallbackTarget, vfsTestFile);    assertFalse(fsTarget.exists(testFileInFallback));    assertTrue(fsTarget.exists(testFileInFallback.getParent()));    vfs.create(vfsTestFile, EnumSet.of(CREATE),        Options.CreateOpts.perms(FsPermission.getDefault())).close();    assertTrue(fsTarget.exists(testFileInFallback));  }    @Test  public void testCreateNewFileWithOutMatchingToMountDirOrFallbackDirPath()      throws Exception {    Configuration conf = new Configuration();    ConfigUtil.addLink(conf, "/user1/hive/warehouse/partition-0",        new Path(targetTestRoot.toString()).toUri());    Path fallbackTarget = new Path(targetTestRoot, "fallbackDir");    fsTarget.mkdirs(fallbackTarget);    ConfigUtil.addLinkFallback(conf, fallbackTarget.toUri());    AbstractFileSystem vfs =        AbstractFileSystem.get(viewFsDefaultClusterUri, conf);    Path vfsTestFile = new Path("/user2/test.file");    Path testFileInFallback = Path.mergePaths(fallbackTarget, vfsTestFile);    assertFalse(fsTarget.exists(testFileInFallback));        assertFalse(fsTarget.exists(testFileInFallback.getParent()));    vfs.create(vfsTestFile, EnumSet.of(CREATE),        Options.CreateOpts.perms(FsPermission.getDefault()),        Options.CreateOpts.createParent()).close();        assertTrue(fsTarget.exists(testFileInFallback));  }    @Test  public void testCreateFileOnRootWithFallbackEnabled()      throws Exception {    Configuration conf = new Configuration();    Path fallbackTarget = new Path(targetTestRoot, "fallbackDir");    fsTarget.mkdirs(fallbackTarget);    ConfigUtil.addLink(conf, "/user1/hive/",        new Path(targetTestRoot.toString()).toUri());    ConfigUtil.addLinkFallback(conf, fallbackTarget.toUri());    AbstractFileSystem vfs =        AbstractFileSystem.get(viewFsDefaultClusterUri, conf);    Path vfsTestFile = new Path("/test.file");    Path testFileInFallback = Path.mergePaths(fallbackTarget, vfsTestFile);    assertFalse(fsTarget.exists(testFileInFallback));    vfs.create(vfsTestFile, EnumSet.of(CREATE),        Options.CreateOpts.perms(FsPermission.getDefault())).close();        assertTrue(fsTarget.exists(testFileInFallback));  }    @Test (expected = FileAlreadyExistsException.class)  public void testCreateFileOnRootWithFallbackWithFileAlreadyExist()      throws Exception {    Configuration conf = new Configuration();    Path fallbackTarget = new Path(targetTestRoot, "fallbackDir");    Path testFile = new Path(fallbackTarget, "test.file");        fsTarget.create(testFile).close();    ConfigUtil.addLink(conf, "/user1/hive/",        new Path(targetTestRoot.toString()).toUri());    ConfigUtil.addLinkFallback(conf, fallbackTarget.toUri());    AbstractFileSystem vfs =        AbstractFileSystem.get(viewFsDefaultClusterUri, conf);    Path vfsTestFile = new Path("/test.file");    assertTrue(fsTarget.exists(testFile));    vfs.create(vfsTestFile, EnumSet.of(CREATE),        Options.CreateOpts.perms(FsPermission.getDefault())).close();  }    @Test(expected= FileAlreadyExistsException.class)  public void testCreateFileWhereThePathIsSameAsItsMountLinkPath()      throws Exception {    Configuration conf = new Configuration();    Path fallbackTarget = new Path(targetTestRoot, "fallbackDir");    fsTarget.mkdirs(fallbackTarget);    ConfigUtil.addLink(conf, "/user1/hive/",        new Path(targetTestRoot.toString()).toUri());    ConfigUtil.addLinkFallback(conf, fallbackTarget.toUri());    AbstractFileSystem vfs =        AbstractFileSystem.get(viewFsDefaultClusterUri, conf);    Path vfsTestDir = new Path("/user1/hive");    assertFalse(fsTarget.exists(Path.mergePaths(fallbackTarget, vfsTestDir)));    vfs.create(vfsTestDir, EnumSet.of(CREATE),        Options.CreateOpts.perms(FsPermission.getDefault())).close();  }    @Test(expected = FileAlreadyExistsException.class)  public void testCreateFileSameAsInternalDirPath()      throws Exception {    Configuration conf = new Configuration();    Path fallbackTarget = new Path(targetTestRoot, "fallbackDir");    fsTarget.mkdirs(fallbackTarget);    ConfigUtil.addLink(conf, "/user1/hive/",        new Path(targetTestRoot.toString()).toUri());    ConfigUtil.addLinkFallback(conf, fallbackTarget.toUri());    AbstractFileSystem vfs =        AbstractFileSystem.get(viewFsDefaultClusterUri, conf);    Path vfsTestDir = new Path("/user1");    assertFalse(fsTarget.exists(Path.mergePaths(fallbackTarget, vfsTestDir)));    vfs.create(vfsTestDir, EnumSet.of(CREATE),        Options.CreateOpts.perms(FsPermission.getDefault())).close();  }    @Test  public void testListFiles() throws Exception {    Configuration conf = new Configuration();    Path fallbackTarget = new Path(targetTestRoot, "fallbackDir");    fsTarget.mkdirs(fallbackTarget);    Path fileInFallBackRoot = new Path(fallbackTarget, "GetFileBlockLocations");    fsTarget.create(fileInFallBackRoot).close();    ConfigUtil.addLinkFallback(conf, fallbackTarget.toUri());    FileContext fc = FileContext.getFileContext(viewFsDefaultClusterUri, conf);    RemoteIterator<LocatedFileStatus> iterator =        fc.util().listFiles(new Path("/"), false);    assertTrue(iterator.hasNext());    assertEquals(fileInFallBackRoot.getName(),        iterator.next().getPath().getName());  }  @Test  public void testRenameOnInternalDirWithFallback() throws Exception {    Configuration conf = new Configuration();    Path fallbackTarget = new Path(targetTestRoot, "fallbackDir");    fsTarget.mkdirs(fallbackTarget);    ConfigUtil.addLink(conf, "/user1",        new Path(targetTestRoot.toString() + "/user1").toUri());    ConfigUtil.addLink(conf, "/NewHDFSUser/next",        new Path(targetTestRoot.toString() + "/newUser1").toUri());    ConfigUtil.addLinkFallback(conf, fallbackTarget.toUri());        try (DistributedFileSystem dfs = new DistributedFileSystem()) {      dfs.initialize(fsDefault.getUri(), conf);      dfs.mkdirs(new Path(targetTestRoot.toString() + "/user1"));      dfs.mkdirs(new Path(fallbackTarget.toString() + "/newUser1"));    }    final AbstractFileSystem fs =        AbstractFileSystem.get(viewFsDefaultClusterUri, conf);    Path src = new Path("/newFileOnRoot");    Path dst = new Path("/newFileOnRoot1");    fs.create(src, EnumSet.of(CREATE),        Options.CreateOpts.perms(FsPermission.getDefault())).close();    verifyRename(fs, src, dst);    src = new Path("/newFileOnRoot1");    dst = new Path("/newUser1/newFileOnRoot");    fs.mkdir(dst.getParent(), FsPermission.getDefault(), true);    verifyRename(fs, src, dst);    src = new Path("/newUser1/newFileOnRoot");    dst = new Path("/newUser1/newFileOnRoot1");    verifyRename(fs, src, dst);    src = new Path("/newUser1/newFileOnRoot1");    dst = new Path("/newFileOnRoot");    verifyRename(fs, src, dst);    src = new Path("/user1/newFileOnRoot1");    dst = new Path("/user1/newFileOnRoot");    fs.create(src, EnumSet.of(CREATE),        Options.CreateOpts.perms(FsPermission.getDefault())).close();    verifyRename(fs, src, dst);  }  @Test  public void testRenameWhenDstOnInternalDirWithFallback() throws Exception {    Configuration conf = new Configuration();    Path fallbackTarget = new Path(targetTestRoot, "fallbackDir");    fsTarget.mkdirs(fallbackTarget);    ConfigUtil.addLink(conf, "/InternalDirDoesNotExistInFallback/test",        new Path(targetTestRoot.toString() + "/user1").toUri());    ConfigUtil.addLink(conf, "/NewHDFSUser/next/next1",        new Path(targetTestRoot.toString() + "/newUser1").toUri());    ConfigUtil.addLinkFallback(conf, fallbackTarget.toUri());    try (DistributedFileSystem dfs = new DistributedFileSystem()) {      dfs.initialize(fsDefault.getUri(), conf);      dfs.mkdirs(new Path(targetTestRoot.toString() + "/newUser1"));      dfs.mkdirs(          new Path(fallbackTarget.toString() + "/NewHDFSUser/next/next1"));    }    final AbstractFileSystem fs =        AbstractFileSystem.get(viewFsDefaultClusterUri, conf);    final Path src = new Path("/newFileOnRoot");    final Path dst = new Path("/NewHDFSUser/next");    fs.mkdir(src, FsPermission.getDefault(), true);        LambdaTestUtils.intercept(IOException.class,        () -> fs.rename(src, dst, Options.Rename.OVERWRITE));    final Path src1 = new Path("/newFileOnRoot1");    final Path dst1 = new Path("/NewHDFSUser/next/file");    fs.create(src1, EnumSet.of(CREATE),        Options.CreateOpts.perms(FsPermission.getDefault())).close();    verifyRename(fs, src1, dst1);    final Path src2 = new Path("/newFileOnRoot2");    final Path dst2 = new Path("/InternalDirDoesNotExistInFallback/file");    fs.create(src2, EnumSet.of(CREATE),        Options.CreateOpts.perms(FsPermission.getDefault())).close();        LambdaTestUtils.intercept(FileNotFoundException.class,        () -> fs.rename(src2, dst2, Options.Rename.OVERWRITE));  }  private void verifyRename(AbstractFileSystem fs, Path src, Path dst)      throws Exception {    fs.rename(src, dst, Options.Rename.OVERWRITE);    LambdaTestUtils        .intercept(FileNotFoundException.class, () -> fs.getFileStatus(src));    Assert.assertNotNull(fs.getFileStatus(dst));  }}
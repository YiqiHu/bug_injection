public class TestViewFileSystemOverloadSchemeWithHdfsScheme {  private static final String TEST_STRING = "Hello ViewFSOverloadedScheme!";  private static final String FS_IMPL_PATTERN_KEY = "fs.%s.impl";  private static final String HDFS_SCHEME = "hdfs";  private Configuration conf = null;  private static MiniDFSCluster cluster = null;  private URI defaultFSURI;  private File localTargetDir;  private static final String TEST_ROOT_DIR = PathUtils      .getTestDirName(TestViewFileSystemOverloadSchemeWithHdfsScheme.class);  private static final String HDFS_USER_FOLDER = "/HDFSUser";  private static final String LOCAL_FOLDER = "/local";  @BeforeClass  public static void init() throws IOException {    cluster =        new MiniDFSCluster.Builder(new Configuration()).numDataNodes(2).build();    cluster.waitClusterUp();  }    @Before  public void setUp() throws IOException {    Configuration config = getNewConf();    config.setInt(        CommonConfigurationKeysPublic.IPC_CLIENT_CONNECT_MAX_RETRIES_KEY, 1);    config.set(String.format(FS_IMPL_PATTERN_KEY, HDFS_SCHEME),        ViewFileSystemOverloadScheme.class.getName());    config.setBoolean(CONFIG_VIEWFS_IGNORE_PORT_IN_MOUNT_TABLE_NAME,        CONFIG_VIEWFS_IGNORE_PORT_IN_MOUNT_TABLE_NAME_DEFAULT);    setConf(config);    defaultFSURI =        URI.create(config.get(CommonConfigurationKeys.FS_DEFAULT_NAME_KEY));    localTargetDir = new File(TEST_ROOT_DIR, "/root/");    localTargetDir.mkdirs();    Assert.assertEquals(HDFS_SCHEME, defaultFSURI.getScheme());   }  @After  public void cleanUp() throws IOException {    if (cluster != null) {      FileSystem fs = new DistributedFileSystem();      fs.initialize(defaultFSURI, conf);      try {        FileStatus[] statuses = fs.listStatus(new Path("/"));        for (FileStatus st : statuses) {          Assert.assertTrue(fs.delete(st.getPath(), true));        }      } finally {        fs.close();      }      FileSystem.closeAll();    }  }  @AfterClass  public static void tearDown() throws IOException {    if (cluster != null) {      FileSystem.closeAll();      cluster.shutdown();    }  }    void addMountLinks(String mountTable, String[] sources, String[] targets,      Configuration config) throws IOException, URISyntaxException {    ViewFsTestSetup.addMountLinksToConf(mountTable, sources, targets, config);  }    @Test(timeout = 30000)  public void testMountLinkWithLocalAndHDFS() throws Exception {    final Path hdfsTargetPath = new Path(defaultFSURI + HDFS_USER_FOLDER);    final Path localTragetPath = new Path(localTargetDir.toURI());    addMountLinks(defaultFSURI.getAuthority(),        new String[] {HDFS_USER_FOLDER, LOCAL_FOLDER },        new String[] {hdfsTargetPath.toUri().toString(),            localTargetDir.toURI().toString() },        conf);        Path hdfsFile = new Path(HDFS_USER_FOLDER + "/testfile");        Path localDir = new Path(LOCAL_FOLDER + "/test");    try (FileSystem fs        =  FileSystem.get(conf)) {      Assert.assertEquals(2, fs.getChildFileSystems().length);      fs.createNewFile(hdfsFile);       fs.mkdirs(localDir);     }        try (DistributedFileSystem dfs = new DistributedFileSystem()) {      dfs.initialize(defaultFSURI, conf);      Assert.assertTrue(dfs.exists(          new Path(Path.getPathWithoutSchemeAndAuthority(hdfsTargetPath),              hdfsFile.getName())));       Assert.assertFalse(dfs.exists(          new Path(Path.getPathWithoutSchemeAndAuthority(localTragetPath),              localDir.getName())));     }    try (RawLocalFileSystem lfs = new RawLocalFileSystem()) {      lfs.initialize(localTragetPath.toUri(), conf);      Assert.assertFalse(lfs.exists(          new Path(Path.getPathWithoutSchemeAndAuthority(hdfsTargetPath),              hdfsFile.getName())));       Assert.assertTrue(lfs.exists(          new Path(Path.getPathWithoutSchemeAndAuthority(localTragetPath),              localDir.getName())));     }  }    @Test(timeout = 30000)  public void testMountLinkWithNonExistentLink() throws Exception {    testMountLinkWithNonExistentLink(true);  }  public void testMountLinkWithNonExistentLink(boolean expectFsInitFailure)      throws Exception {    final String userFolder = "/User";    final Path nonExistTargetPath =        new Path("nonexistent://NonExistent" + userFolder);        addMountLinks(defaultFSURI.getAuthority(), new String[] {userFolder},        new String[] {nonExistTargetPath.toUri().toString()}, conf);    if (expectFsInitFailure) {      LambdaTestUtils.intercept(IOException.class, () -> {        FileSystem fs = FileSystem.get(conf);        fs.resolvePath(new Path(userFolder));      });    } else {      try (FileSystem fs = FileSystem.get(conf)) {        Assert.assertEquals("hdfs", fs.getScheme());      }    }  }    @Test(timeout = 30000)  public void testListStatusOnRootShouldListAllMountLinks() throws Exception {    final Path hdfsTargetPath = new Path(defaultFSURI + HDFS_USER_FOLDER);    addMountLinks(defaultFSURI.getAuthority(),        new String[] {HDFS_USER_FOLDER, LOCAL_FOLDER },        new String[] {hdfsTargetPath.toUri().toString(),            localTargetDir.toURI().toString() },        conf);    try (DistributedFileSystem dfs = new DistributedFileSystem()) {      dfs.initialize(defaultFSURI, conf);      dfs.mkdirs(hdfsTargetPath);    }    try (RawLocalFileSystem lfs = new RawLocalFileSystem()) {      lfs.initialize(localTargetDir.toURI(), conf);      lfs.mkdirs(new Path(localTargetDir.toURI()));    }    try (FileSystem fs = FileSystem.get(conf)) {      fs.mkdirs(hdfsTargetPath);      FileStatus[] ls = fs.listStatus(new Path("/"));      Assert.assertEquals(2, ls.length);      String lsPath1 =          Path.getPathWithoutSchemeAndAuthority(ls[0].getPath()).toString();      String lsPath2 =          Path.getPathWithoutSchemeAndAuthority(ls[1].getPath()).toString();      Assert.assertTrue(          HDFS_USER_FOLDER.equals(lsPath1) || LOCAL_FOLDER.equals(lsPath1));      Assert.assertTrue(          HDFS_USER_FOLDER.equals(lsPath2) || LOCAL_FOLDER.equals(lsPath2));    }  }    @Test(expected = IOException.class, timeout = 30000)  public void testListStatusOnNonMountedPath() throws Exception {    final Path hdfsTargetPath = new Path(defaultFSURI + HDFS_USER_FOLDER);    addMountLinks(defaultFSURI.getAuthority(),        new String[] {HDFS_USER_FOLDER, LOCAL_FOLDER },        new String[] {hdfsTargetPath.toUri().toString(),            localTargetDir.toURI().toString() },        conf);    try (FileSystem fs = FileSystem.get(conf)) {      fs.listStatus(new Path("/nonMount"));      Assert.fail("It should fail as no mount link with /nonMount");    }  }    @Test  public void testAccessViewFsPathWithoutAuthority() throws Exception {    final Path hdfsTargetPath = new Path(defaultFSURI + HDFS_USER_FOLDER);    addMountLinks(defaultFSURI.getAuthority(),        new String[] {HDFS_USER_FOLDER, LOCAL_FOLDER },        new String[] {hdfsTargetPath.toUri().toString(),            localTargetDir.toURI().toString() },        conf);        Path hdfsDir = new Path(HDFS_USER_FOLDER, "test");        Path localDir = new Path(LOCAL_FOLDER, "test");    FileStatus[] expectedStatus;    try (FileSystem fs = FileSystem.get(conf)) {      fs.mkdirs(hdfsDir);       fs.mkdirs(localDir);       expectedStatus = fs.listStatus(new Path("/"));    }        Path viewFsRootPath = new Path("viewfs:/");    LambdaTestUtils.intercept(IOException.class,        "Empty Mount table in config for viewfs://default", () -> {          viewFsRootPath.getFileSystem(conf);        });            conf.set(Constants.CONFIG_VIEWFS_DEFAULT_MOUNT_TABLE_NAME_KEY,        defaultFSURI.getAuthority());    try (FileSystem fs = viewFsRootPath.getFileSystem(conf)) {      FileStatus[] status = fs.listStatus(viewFsRootPath);                  List<String> expectedPaths = Arrays.stream(expectedStatus)          .map(s -> s.getPath().getName()).sorted()          .collect(Collectors.toList());      List<String> paths = Arrays.stream(status)          .map(s -> s.getPath().getName()).sorted()          .collect(Collectors.toList());      assertEquals(expectedPaths, paths);    }  }    @Test(timeout = 30000)  public void testWithLinkFallBack() throws Exception {    final Path hdfsTargetPath = new Path(defaultFSURI + HDFS_USER_FOLDER);    addMountLinks(defaultFSURI.getAuthority(),        new String[] {HDFS_USER_FOLDER, LOCAL_FOLDER,            Constants.CONFIG_VIEWFS_LINK_FALLBACK },        new String[] {hdfsTargetPath.toUri().toString(),            localTargetDir.toURI().toString(),            hdfsTargetPath.toUri().toString() },        conf);    try (FileSystem fs = FileSystem.get(conf)) {      fs.createNewFile(new Path("/nonMount/myfile"));      FileStatus[] ls = fs.listStatus(new Path("/nonMount"));      Assert.assertEquals(1, ls.length);      Assert.assertEquals(          Path.getPathWithoutSchemeAndAuthority(ls[0].getPath()).getName(),          "myfile");    }  }    @Test(timeout = 30000)  public void testCreateOnRoot() throws Exception {    testCreateOnRoot(false);  }  public void testCreateOnRoot(boolean fallbackExist) throws Exception {    final Path hdfsTargetPath = new Path(defaultFSURI + HDFS_USER_FOLDER);    addMountLinks(defaultFSURI.getAuthority(),        new String[] {HDFS_USER_FOLDER, LOCAL_FOLDER},        new String[] {hdfsTargetPath.toUri().toString(),            localTargetDir.toURI().toString()}, conf);    try (FileSystem fs = FileSystem.get(conf)) {      if (fallbackExist) {        Assert.assertTrue(fs.createNewFile(new Path("/newFileOnRoot")));      } else {        LambdaTestUtils.intercept(NotInMountpointException.class, () -> {          fs.createNewFile(new Path("/newFileOnRoot"));        });      }    }  }    @Test(expected = IOException.class, timeout = 30000)  public void testInvalidOverloadSchemeTargetFS() throws Exception {    final Path hdfsTargetPath = new Path(defaultFSURI + HDFS_USER_FOLDER);    String mountTableIfSet = conf.get(Constants.CONFIG_VIEWFS_MOUNTTABLE_PATH);    conf = new Configuration();    if (mountTableIfSet != null) {      conf.set(Constants.CONFIG_VIEWFS_MOUNTTABLE_PATH, mountTableIfSet);    }    addMountLinks(defaultFSURI.getHost(),        new String[] {HDFS_USER_FOLDER, LOCAL_FOLDER,            Constants.CONFIG_VIEWFS_LINK_FALLBACK },        new String[] {hdfsTargetPath.toUri().toString(),            localTargetDir.toURI().toString(),            hdfsTargetPath.toUri().toString() },        conf);    conf.set(CommonConfigurationKeys.FS_DEFAULT_NAME_KEY,        defaultFSURI.toString());    conf.set(String.format(FS_IMPL_PATTERN_KEY, HDFS_SCHEME),        ViewFileSystemOverloadScheme.class.getName());    conf.unset(String.format(        FsConstants.FS_VIEWFS_OVERLOAD_SCHEME_TARGET_FS_IMPL_PATTERN,        HDFS_SCHEME));    try (FileSystem fs = FileSystem.get(conf)) {      fs.createNewFile(new Path("/onRootWhenFallBack"));      Assert.fail("OverloadScheme target fs should be valid.");    }  }    @Test(timeout = 30000)  public void testViewFsOverloadSchemeWhenInnerCacheDisabled()      throws Exception {    final Path hdfsTargetPath = new Path(defaultFSURI + HDFS_USER_FOLDER);    addMountLinks(defaultFSURI.getAuthority(),        new String[] {HDFS_USER_FOLDER, LOCAL_FOLDER },        new String[] {hdfsTargetPath.toUri().toString(),            localTargetDir.toURI().toString(), },        conf);    conf.setBoolean(Constants.CONFIG_VIEWFS_ENABLE_INNER_CACHE, false);    try (FileSystem fs = FileSystem.get(conf)) {      Path testFile = new Path(HDFS_USER_FOLDER + "/testFile");      fs.createNewFile(testFile);      Assert.assertTrue(fs.exists(testFile));    }  }    @Test(timeout = 30000)  public void testViewFsOverloadSchemeWithInnerCache()      throws Exception {    final Path hdfsTargetPath = new Path(defaultFSURI + HDFS_USER_FOLDER);    addMountLinks(defaultFSURI.getAuthority(),        new String[] {HDFS_USER_FOLDER + 0, HDFS_USER_FOLDER + 1 },        new String[] {hdfsTargetPath.toUri().toString(),            hdfsTargetPath.toUri().toString() },        conf);        try (FileSystem vfs = FileSystem.get(conf)) {      Assert.assertEquals(1, vfs.getChildFileSystems().length);    }        conf.setBoolean(Constants.CONFIG_VIEWFS_ENABLE_INNER_CACHE, false);    try (FileSystem vfs = FileSystem.get(conf)) {      Assert.assertEquals(isFallBackExist(conf) ? 3 : 2,          vfs.getChildFileSystems().length);    }  }      private boolean isFallBackExist(Configuration config) {    return config.get(ConfigUtil.getConfigViewFsPrefix(defaultFSURI        .getAuthority()) + "." + Constants.CONFIG_VIEWFS_LINK_FALLBACK) != null;  }    @Test(timeout = 3000)  public void testViewFsOverloadSchemeWithNoInnerCacheAndHdfsTargets()      throws Exception {    final Path hdfsTargetPath = new Path(defaultFSURI + HDFS_USER_FOLDER);    addMountLinks(defaultFSURI.getAuthority(),        new String[] {HDFS_USER_FOLDER + 0, HDFS_USER_FOLDER + 1 },        new String[] {hdfsTargetPath.toUri().toString(),            hdfsTargetPath.toUri().toString() },        conf);    conf.setBoolean(Constants.CONFIG_VIEWFS_ENABLE_INNER_CACHE, false);        try (FileSystem vfs = FileSystem.get(conf)) {      Assert.assertEquals(isFallBackExist(conf) ? 3 : 2,          vfs.getChildFileSystems().length);    }  }    @Test(timeout = 3000)  public void testViewFsOverloadSchemeWithNoInnerCacheAndLocalSchemeTargets()      throws Exception {    final Path localTragetPath = new Path(localTargetDir.toURI());    addMountLinks(defaultFSURI.getAuthority(),        new String[] {LOCAL_FOLDER + 0, LOCAL_FOLDER + 1 },        new String[] {localTragetPath.toUri().toString(),            localTragetPath.toUri().toString() },        conf);            conf.setBoolean(Constants.CONFIG_VIEWFS_ENABLE_INNER_CACHE, false);    try (FileSystem vfs = FileSystem.get(conf)) {      Assert.assertEquals(isFallBackExist(conf) ? 2 : 1,          vfs.getChildFileSystems().length);    }  }    @Test(timeout = 3000)  public void testNflyRename() throws Exception {    final Path hdfsTargetPath1 = new Path(defaultFSURI + HDFS_USER_FOLDER);    final Path hdfsTargetPath2 = new Path(defaultFSURI + HDFS_USER_FOLDER + 1);    final URI uri1 = hdfsTargetPath1.toUri();    final URI uri2 = hdfsTargetPath2.toUri();    final Path nflyRoot = new Path("/nflyroot");    final String nflyLinkKey = Constants.CONFIG_VIEWFS_LINK_NFLY        + ".minReplication=2." + nflyRoot.toString();    addMountLinks(defaultFSURI.getAuthority(), new String[] {nflyLinkKey },        new String[] {uri1.toString() + "," + uri2.toString() }, conf);    final FileSystem nfly = FileSystem.get(defaultFSURI, conf);    final Path testDir = new Path("/nflyroot/testdir1/sub1/sub3");    final Path testDirTmp = new Path("/nflyroot/testdir1/sub1/sub3_temp");    assertTrue(testDir + ": Failed to create!", nfly.mkdirs(testDir));        assertTrue(nfly.rename(testDir, testDirTmp));    assertTrue(nfly.rename(testDirTmp, testDir));    final URI[] testUris = new URI[] {uri1, uri2 };    for (final URI testUri : testUris) {      final FileSystem fs = FileSystem.get(testUri, conf);      assertTrue(testDir + " should exist!", fs.exists(testDir));    }  }    @Test(timeout = 3000)  public void testNflyWriteRead() throws Exception {    final Path hdfsTargetPath1 = new Path(defaultFSURI + HDFS_USER_FOLDER);    final Path hdfsTargetPath2 = new Path(defaultFSURI + HDFS_USER_FOLDER + 1);    final URI uri1 = hdfsTargetPath1.toUri();    final URI uri2 = hdfsTargetPath2.toUri();    final Path nflyRoot = new Path("/nflyroot");    final String nflyLinkKey = Constants.CONFIG_VIEWFS_LINK_NFLY        + ".minReplication=2." + nflyRoot.toString();    addMountLinks(defaultFSURI.getAuthority(), new String[] {nflyLinkKey },        new String[] {uri1.toString() + "," + uri2.toString() }, conf);    final FileSystem nfly = FileSystem.get(defaultFSURI, conf);    final Path testFile = new Path("/nflyroot/test.txt");    writeString(nfly, TEST_STRING, testFile);    final URI[] testUris = new URI[] {uri1, uri2 };    for (final URI testUri : testUris) {      try (FileSystem fs = FileSystem.get(testUri, conf)) {        readString(fs, testFile, TEST_STRING, testUri);      }    }  }    @Test(timeout = 3000)  public void testNflyRepair() throws Exception {    final NflyFSystem.NflyKey repairKey = NflyFSystem.NflyKey.repairOnRead;    final Path hdfsTargetPath1 = new Path(defaultFSURI + HDFS_USER_FOLDER);    final Path hdfsTargetPath2 = new Path(defaultFSURI + HDFS_USER_FOLDER + 1);    final URI uri1 = hdfsTargetPath1.toUri();    final URI uri2 = hdfsTargetPath2.toUri();    final Path nflyRoot = new Path("/nflyroot");    final String nflyLinkKey = Constants.CONFIG_VIEWFS_LINK_NFLY        + ".minReplication=2," + repairKey + "=true." + nflyRoot.toString();    addMountLinks(defaultFSURI.getAuthority(), new String[] {nflyLinkKey },        new String[] {uri1.toString() + "," + uri2.toString() }, conf);    try (FileSystem nfly = FileSystem.get(defaultFSURI, conf)) {            final Path testFilePath = new Path("/nflyroot/test.txt");      writeString(nfly, TEST_STRING, testFilePath);      final URI[] testUris = new URI[] {uri1, uri2 };            FsGetter getter = new ViewFileSystemOverloadScheme.ChildFsGetter("hdfs");      try (FileSystem fs1 = getter.getNewInstance(testUris[0], conf)) {                String testFile = "/test.txt";        assertTrue(            fs1.delete(new Path(testUris[0].toString() + testFile), false));        assertFalse(fs1.exists(new Path(testUris[0].toString() + testFile)));                readString(nfly, testFilePath, TEST_STRING, testUris[0]);                assertTrue(fs1.exists(new Path(testUris[0].toString() + testFile)));      }    }  }    @Test(timeout = 30000)  public void testMountTableNameShouldIgnorePortFromURI() throws Exception {    final Path hdfsTargetPath = new Path(defaultFSURI + HDFS_USER_FOLDER);    conf = new Configuration(getConf());    addMountLinks(defaultFSURI.getHost(),        new String[] {HDFS_USER_FOLDER, LOCAL_FOLDER,            Constants.CONFIG_VIEWFS_LINK_FALLBACK},        new String[] {hdfsTargetPath.toUri().toString(),            localTargetDir.toURI().toString(),            hdfsTargetPath.toUri().toString()}, conf);    conf.set(CommonConfigurationKeys.FS_DEFAULT_NAME_KEY,        defaultFSURI.toString());    conf.set(String.format(FS_IMPL_PATTERN_KEY, HDFS_SCHEME),        ViewFileSystemOverloadScheme.class.getName());    conf.set(String        .format(FsConstants.FS_VIEWFS_OVERLOAD_SCHEME_TARGET_FS_IMPL_PATTERN,            HDFS_SCHEME), DistributedFileSystem.class.getName());    conf.setBoolean(CONFIG_VIEWFS_IGNORE_PORT_IN_MOUNT_TABLE_NAME, true);    Path testDirOnRoot = new Path("/test");    URI uriWithoutPort = new URI("hdfs://" + defaultFSURI.getHost());        try (FileSystem fs = FileSystem        .get(uriWithoutPort, conf)) {      fs.mkdirs(testDirOnRoot);      fs.delete(testDirOnRoot, true);    }        try (FileSystem fs = FileSystem.get(defaultFSURI, conf)) {      fs.mkdirs(testDirOnRoot);      fs.delete(testDirOnRoot, true);    }  }  private void writeString(final FileSystem nfly, final String testString,      final Path testFile) throws IOException {    try (FSDataOutputStream fsDos = nfly.create(testFile)) {      fsDos.writeUTF(testString);    }  }  private void readString(final FileSystem nfly, final Path testFile,      final String testString, final URI testUri) throws IOException {    try (FSDataInputStream fsDis = nfly.open(testFile)) {      assertEquals("Wrong file content", testString, fsDis.readUTF());    }  }    public Configuration getConf() {    return this.conf;  }    public Configuration getNewConf() {    return new Configuration(cluster.getConfiguration(0));  }    public void setConf(Configuration config) {    conf = config;  }}
public class MagicS3GuardCommitter extends AbstractS3ACommitter {  private static final Logger LOG =      LoggerFactory.getLogger(MagicS3GuardCommitter.class);    public static final String NAME = CommitConstants.COMMITTER_NAME_MAGIC;    public MagicS3GuardCommitter(Path outputPath,      TaskAttemptContext context) throws IOException {    super(outputPath, context);    setWorkPath(getTaskAttemptPath(context));    verifyIsMagicCommitPath(getDestS3AFS(), getWorkPath());    LOG.debug("Task attempt {} has work path {}",        context.getTaskAttemptID(),        getWorkPath());  }  @Override  public String getName() {    return NAME;  }    @Override  protected boolean requiresDelayedCommitOutputInFileSystem() {    return true;  }  @Override  public void setupJob(JobContext context) throws IOException {    try (DurationInfo d = new DurationInfo(LOG,        "Setup Job %s", jobIdString(context))) {      Path jobAttemptPath = getJobAttemptPath(context);      getDestinationFS(jobAttemptPath,          context.getConfiguration()).mkdirs(jobAttemptPath);    }  }    protected ActiveCommit listPendingUploadsToCommit(      JobContext context)      throws IOException {    FileSystem fs = getDestFS();    return ActiveCommit.fromStatusList(fs,        listAndFilter(fs, getJobAttemptPath(context), false,            CommitOperations.PENDINGSET_FILTER));  }    public void cleanupStagingDirs() {    Path path = magicSubdir(getOutputPath());    try(DurationInfo ignored = new DurationInfo(LOG, true,        "Deleting magic directory %s", path)) {      Invoker.ignoreIOExceptions(LOG, "cleanup magic directory", path.toString(),          () -> deleteWithWarning(getDestFS(), path, true));    }  }  @Override  public void setupTask(TaskAttemptContext context) throws IOException {    try (DurationInfo d = new DurationInfo(LOG,        "Setup Task %s", context.getTaskAttemptID())) {      Path taskAttemptPath = getTaskAttemptPath(context);      FileSystem fs = taskAttemptPath.getFileSystem(getConf());      fs.mkdirs(taskAttemptPath);    }  }    @Override  public boolean needsTaskCommit(TaskAttemptContext context)      throws IOException {    Path taskAttemptPath = getTaskAttemptPath(context);    try (DurationInfo d = new DurationInfo(LOG,        "needsTaskCommit task %s", context.getTaskAttemptID())) {      return taskAttemptPath.getFileSystem(          context.getConfiguration())          .exists(taskAttemptPath);    }  }  @Override  public void commitTask(TaskAttemptContext context) throws IOException {    try (DurationInfo d = new DurationInfo(LOG,        "Commit task %s", context.getTaskAttemptID())) {      PendingSet commits = innerCommitTask(context);      LOG.info("Task {} committed {} files", context.getTaskAttemptID(),          commits.size());    } catch (IOException e) {      getCommitOperations().taskCompleted(false);      throw e;    } finally {            deleteTaskAttemptPathQuietly(context);      destroyThreadPool();    }    getCommitOperations().taskCompleted(true);  }    private PendingSet innerCommitTask(      TaskAttemptContext context) throws IOException {    Path taskAttemptPath = getTaskAttemptPath(context);        CommitOperations actions = getCommitOperations();    Pair<PendingSet, List<Pair<LocatedFileStatus, IOException>>>        loaded = actions.loadSinglePendingCommits(            taskAttemptPath, true);    PendingSet pendingSet = loaded.getKey();    List<Pair<LocatedFileStatus, IOException>> failures = loaded.getValue();    if (!failures.isEmpty()) {                  LOG.error("At least one commit file could not be read: failing");      abortPendingUploads(context, pendingSet.getCommits(), true);      throw failures.get(0).getValue();    }        String jobId = String.valueOf(context.getJobID());    String taskId = String.valueOf(context.getTaskAttemptID());    for (SinglePendingCommit commit : pendingSet.getCommits()) {      commit.setJobId(jobId);      commit.setTaskId(taskId);    }    pendingSet.putExtraData(TASK_ATTEMPT_ID, taskId);    Path jobAttemptPath = getJobAttemptPath(context);    TaskAttemptID taskAttemptID = context.getTaskAttemptID();    Path taskOutcomePath = new Path(jobAttemptPath,        taskAttemptID.getTaskID().toString() +        CommitConstants.PENDINGSET_SUFFIX);    LOG.info("Saving work of {} to {}", taskAttemptID, taskOutcomePath);    try {            pendingSet.save(getDestFS(), taskOutcomePath, true);    } catch (IOException e) {      LOG.warn("Failed to save task commit data to {} ",          taskOutcomePath, e);      abortPendingUploads(context, pendingSet.getCommits(), true);      throw e;    }    return pendingSet;  }    @Override  public void abortTask(TaskAttemptContext context) throws IOException {    Path attemptPath = getTaskAttemptPath(context);    try (DurationInfo d = new DurationInfo(LOG,        "Abort task %s", context.getTaskAttemptID())) {      getCommitOperations().abortAllSinglePendingCommits(attemptPath, true);    } finally {      deleteQuietly(          attemptPath.getFileSystem(context.getConfiguration()),          attemptPath, true);      destroyThreadPool();    }  }    protected Path getJobAttemptPath(int appAttemptId) {    return getMagicJobAttemptPath(appAttemptId, getOutputPath());  }    public Path getTaskAttemptPath(TaskAttemptContext context) {    return getMagicTaskAttemptPath(context, getOutputPath());  }  @Override  protected Path getBaseTaskAttemptPath(TaskAttemptContext context) {    return getBaseMagicTaskAttemptPath(context, getOutputPath());  }    public Path getTempTaskAttemptPath(TaskAttemptContext context) {    return CommitUtilsWithMR.getTempTaskAttemptPath(context, getOutputPath());  }  @Override  public String toString() {    final StringBuilder sb = new StringBuilder(        "MagicCommitter{");    sb.append('}');    return sb.toString();  }}
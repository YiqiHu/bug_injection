
package org.apache.hadoop.security.ssl;

import org.apache.hadoop.fs.FileUtil;
import org.apache.hadoop.test.GenericTestUtils;
import org.junit.BeforeClass;
import org.junit.Test;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.nio.file.Paths;
import java.security.KeyPair;
import java.security.cert.X509Certificate;
import java.util.Timer;
import java.util.concurrent.TimeoutException;
import java.util.function.Supplier;

import static org.apache.hadoop.security.ssl.KeyStoreTestUtil.*;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;

public class TestReloadingX509KeyManager {

    private static final String BASEDIR = GenericTestUtils.getTempPath(
            TestReloadingX509TrustManager.class.getSimpleName());

    private final GenericTestUtils.LogCapturer reloaderLog = GenericTestUtils.LogCapturer.captureLogs(
            FileMonitoringTimerTask.LOG);

    @BeforeClass
    public static void setUp() throws Exception {
        File base = new File(BASEDIR);
        FileUtil.fullyDelete(base);
        base.mkdirs();
    }

    @Test(expected = IOException.class)
    public void testLoadMissingKeyStore() throws Exception {
        String keystoreLocation = BASEDIR + "/testmissing.jks";

        ReloadingX509KeystoreManager tm =
                new ReloadingX509KeystoreManager("jks", keystoreLocation,
                        "password",
                        "password");
    }

    @Test(expected = IOException.class)
    public void testLoadCorruptKeyStore() throws Exception {
        String keystoreLocation = BASEDIR + "/testcorrupt.jks";
        OutputStream os = new FileOutputStream(keystoreLocation);
        os.write(1);
        os.close();

        ReloadingX509KeystoreManager tm =
                new ReloadingX509KeystoreManager("jks", keystoreLocation,
                        "password",
                        "password");
    }

    @Test (timeout = 3000000)
    public void testReload() throws Exception {
        KeyPair kp = generateKeyPair("RSA");
        X509Certificate sCert = generateCertificate("CN=localhost, O=server", kp, 30,
                        "SHA1withRSA");
        String keystoreLocation = BASEDIR + "/testreload.jks";
        createKeyStore(keystoreLocation, "password", "cert1", kp.getPrivate(), sCert);

        long reloadInterval = 10;
        Timer fileMonitoringTimer = new Timer(FileBasedKeyStoresFactory.SSL_MONITORING_THREAD_NAME, true);
        ReloadingX509KeystoreManager tm =
                new ReloadingX509KeystoreManager("jks", keystoreLocation,
                        "password",
                        "password");
        try {
            fileMonitoringTimer.schedule(new FileMonitoringTimerTask(
                    Paths.get(keystoreLocation), tm::loadFrom,null), reloadInterval, reloadInterval);
            assertEquals(kp.getPrivate(), tm.getPrivateKey("cert1"));

            
            Thread.sleep((reloadInterval+ 1000));

            
            final KeyPair anotherKP = generateKeyPair("RSA");
            sCert = KeyStoreTestUtil.generateCertificate("CN=localhost, O=server", anotherKP, 30,
                            "SHA1withRSA");
            createKeyStore(keystoreLocation, "password", "cert1", anotherKP.getPrivate(), sCert);

            GenericTestUtils.waitFor(new Supplier<Boolean>() {
                @Override
                public Boolean get() {
                    return tm.getPrivateKey("cert1").equals(kp.getPrivate());
                }
            }, (int) reloadInterval, 100000);
        } finally {
            fileMonitoringTimer.cancel();
        }
    }

    @Test (timeout = 30000)
    public void testReloadMissingTrustStore() throws Exception {
        KeyPair kp = generateKeyPair("RSA");
        X509Certificate cert1 = generateCertificate("CN=Cert1", kp, 30, "SHA1withRSA");
        String keystoreLocation = BASEDIR + "/testmissing.jks";
        createKeyStore(keystoreLocation, "password", "cert1", kp.getPrivate(), cert1);

        long reloadInterval = 10;
        Timer fileMonitoringTimer = new Timer(FileBasedKeyStoresFactory.SSL_MONITORING_THREAD_NAME, true);
        ReloadingX509KeystoreManager tm =
                new ReloadingX509KeystoreManager("jks", keystoreLocation,
                        "password",
                        "password");
        try {
            fileMonitoringTimer.schedule(new FileMonitoringTimerTask(
                    Paths.get(keystoreLocation), tm::loadFrom,null), reloadInterval, reloadInterval);
            assertEquals(kp.getPrivate(), tm.getPrivateKey("cert1"));

            assertFalse(reloaderLog.getOutput().contains(
                    FileMonitoringTimerTask.PROCESS_ERROR_MESSAGE));

            
            Thread.sleep((reloadInterval+ 1000));

            new File(keystoreLocation).delete();

            
            Thread.sleep((reloadInterval+ 1000));

            waitForFailedReloadAtLeastOnce((int) reloadInterval);

            assertEquals(kp.getPrivate(), tm.getPrivateKey("cert1"));
        } finally {
            reloaderLog.stopCapturing();
            fileMonitoringTimer.cancel();
        }
    }


    @Test (timeout = 30000)
    public void testReloadCorruptTrustStore() throws Exception {
        KeyPair kp = generateKeyPair("RSA");
        X509Certificate cert1 = generateCertificate("CN=Cert1", kp, 30, "SHA1withRSA");
        String keystoreLocation = BASEDIR + "/testmissing.jks";
        createKeyStore(keystoreLocation, "password", "cert1", kp.getPrivate(), cert1);

        long reloadInterval = 10;
        Timer fileMonitoringTimer = new Timer(FileBasedKeyStoresFactory.SSL_MONITORING_THREAD_NAME, true);
        ReloadingX509KeystoreManager tm =
                new ReloadingX509KeystoreManager("jks", keystoreLocation,
                        "password",
                        "password");
        try {
            fileMonitoringTimer.schedule(new FileMonitoringTimerTask(
                    Paths.get(keystoreLocation), tm::loadFrom,null), reloadInterval, reloadInterval);
            assertEquals(kp.getPrivate(), tm.getPrivateKey("cert1"));

            
            Thread.sleep((reloadInterval + 1000));

            assertFalse(reloaderLog.getOutput().contains(
                    FileMonitoringTimerTask.PROCESS_ERROR_MESSAGE));
            OutputStream os = new FileOutputStream(keystoreLocation);
            os.write(1);
            os.close();

            waitForFailedReloadAtLeastOnce((int) reloadInterval);

            assertEquals(kp.getPrivate(), tm.getPrivateKey("cert1"));
        } finally {
            reloaderLog.stopCapturing();
            fileMonitoringTimer.cancel();
        }
    }

    
    private void waitForFailedReloadAtLeastOnce(int reloadInterval)
            throws InterruptedException, TimeoutException {
        GenericTestUtils.waitFor(new Supplier<Boolean>() {
            @Override
            public Boolean get() {
                return reloaderLog.getOutput().contains(
                        FileMonitoringTimerTask.PROCESS_ERROR_MESSAGE);
            }
        }, reloadInterval, 10 * 1000);
    }
}

public class UserGroupInformation {  @VisibleForTesting  static final Logger LOG = LoggerFactory.getLogger(      UserGroupInformation.class);    private static final float TICKET_RENEW_WINDOW = 0.80f;  private static boolean shouldRenewImmediatelyForTests = false;  static final String HADOOP_USER_NAME = "HADOOP_USER_NAME";  static final String HADOOP_PROXY_USER = "HADOOP_PROXY_USER";    @VisibleForTesting  public static void setShouldRenewImmediatelyForTests(boolean immediate) {    shouldRenewImmediatelyForTests = immediate;  }    @Metrics(about="User and group related metrics", context="ugi")  static class UgiMetrics {    final MetricsRegistry registry = new MetricsRegistry("UgiMetrics");    @Metric("Rate of successful kerberos logins and latency (milliseconds)")    MutableRate loginSuccess;    @Metric("Rate of failed kerberos logins and latency (milliseconds)")    MutableRate loginFailure;    @Metric("GetGroups") MutableRate getGroups;    MutableQuantiles[] getGroupsQuantiles;    @Metric("Renewal failures since startup")    private MutableGaugeLong renewalFailuresTotal;    @Metric("Renewal failures since last successful login")    private MutableGaugeInt renewalFailures;    static UgiMetrics create() {      return DefaultMetricsSystem.instance().register(new UgiMetrics());    }    static void reattach() {      metrics = UgiMetrics.create();    }    void addGetGroups(long latency) {      getGroups.add(latency);      if (getGroupsQuantiles != null) {        for (MutableQuantiles q : getGroupsQuantiles) {          q.add(latency);        }      }    }    MutableGaugeInt getRenewalFailures() {      return renewalFailures;    }  }      @InterfaceAudience.Private  public static class HadoopLoginModule implements LoginModule {    private Subject subject;    @Override    public boolean abort() throws LoginException {      return true;    }    private <T extends Principal> T getCanonicalUser(Class<T> cls) {      for(T user: subject.getPrincipals(cls)) {        return user;      }      return null;    }    @Override    public boolean commit() throws LoginException {      LOG.debug("hadoop login commit");            if (!subject.getPrincipals(User.class).isEmpty()) {        LOG.debug("Using existing subject: {}", subject.getPrincipals());        return true;      }      Principal user = getCanonicalUser(KerberosPrincipal.class);      if (user != null) {        LOG.debug("Using kerberos user: {}", user);      }                  if (!isSecurityEnabled() && (user == null)) {        String envUser = System.getenv(HADOOP_USER_NAME);        if (envUser == null) {          envUser = System.getProperty(HADOOP_USER_NAME);        }        user = envUser == null ? null : new User(envUser);      }            if (user == null) {        user = getCanonicalUser(OS_PRINCIPAL_CLASS);        LOG.debug("Using local user: {}", user);      }            if (user != null) {        LOG.debug("Using user: \"{}\" with name: {}", user, user.getName());        User userEntry = null;        try {                              AuthenticationMethod authMethod = (user instanceof KerberosPrincipal)            ? AuthenticationMethod.KERBEROS : AuthenticationMethod.SIMPLE;          userEntry = new User(user.getName(), authMethod, null);        } catch (Exception e) {          throw (LoginException)(new LoginException(e.toString()).initCause(e));        }        LOG.debug("User entry: \"{}\"", userEntry);        subject.getPrincipals().add(userEntry);        return true;      }      throw new LoginException("Failed to find user in name " + subject);    }    @Override    public void initialize(Subject subject, CallbackHandler callbackHandler,                           Map<String, ?> sharedState, Map<String, ?> options) {      this.subject = subject;    }    @Override    public boolean login() throws LoginException {      LOG.debug("Hadoop login");      return true;    }    @Override    public boolean logout() throws LoginException {      LOG.debug("Hadoop logout");      return true;    }  }    public static void reattachMetrics() {    UgiMetrics.reattach();  }    static UgiMetrics metrics = UgiMetrics.create();    private static AuthenticationMethod authenticationMethod;    private static Groups groups;    private static long kerberosMinSecondsBeforeRelogin;    private static boolean kerberosKeyTabLoginRenewalEnabled;    private static Optional<ExecutorService> kerberosLoginRenewalExecutor =          Optional.empty();    private static Configuration conf;      public static final String HADOOP_TOKEN_FILE_LOCATION =       "HADOOP_TOKEN_FILE_LOCATION";    public static final String HADOOP_TOKEN = "HADOOP_TOKEN";    public static boolean isInitialized() {    return conf != null;  }    private static void ensureInitialized() {    if (!isInitialized()) {      synchronized(UserGroupInformation.class) {        if (!isInitialized()) {           initialize(new Configuration(), false);        }      }    }  }    private static synchronized void initialize(Configuration conf,                                              boolean overrideNameRules) {    authenticationMethod = SecurityUtil.getAuthenticationMethod(conf);    if (overrideNameRules || !HadoopKerberosName.hasRulesBeenSet()) {      try {        HadoopKerberosName.setConfiguration(conf);      } catch (IOException ioe) {        throw new RuntimeException(            "Problem with Kerberos auth_to_local name configuration", ioe);      }    }    try {        kerberosMinSecondsBeforeRelogin = 1000L * conf.getLong(                HADOOP_KERBEROS_MIN_SECONDS_BEFORE_RELOGIN,                HADOOP_KERBEROS_MIN_SECONDS_BEFORE_RELOGIN_DEFAULT);    }    catch(NumberFormatException nfe) {        throw new IllegalArgumentException("Invalid attribute value for " +                HADOOP_KERBEROS_MIN_SECONDS_BEFORE_RELOGIN + " of " +                conf.get(HADOOP_KERBEROS_MIN_SECONDS_BEFORE_RELOGIN));    }    kerberosKeyTabLoginRenewalEnabled = conf.getBoolean(            HADOOP_KERBEROS_KEYTAB_LOGIN_AUTORENEWAL_ENABLED,            HADOOP_KERBEROS_KEYTAB_LOGIN_AUTORENEWAL_ENABLED_DEFAULT);        if (!(groups instanceof TestingGroups)) {      groups = Groups.getUserToGroupsMappingService(conf);    }    UserGroupInformation.conf = conf;    if (metrics.getGroupsQuantiles == null) {      int[] intervals = conf.getInts(HADOOP_USER_GROUP_METRICS_PERCENTILES_INTERVALS);      if (intervals != null && intervals.length > 0) {        final int length = intervals.length;        MutableQuantiles[] getGroupsQuantiles = new MutableQuantiles[length];        for (int i = 0; i < length; i++) {          getGroupsQuantiles[i] = metrics.registry.newQuantiles(            "getGroups" + intervals[i] + "s",            "Get groups", "ops", "latency", intervals[i]);        }        metrics.getGroupsQuantiles = getGroupsQuantiles;      }    }  }    @InterfaceAudience.Public  @InterfaceStability.Evolving  public static void setConfiguration(Configuration conf) {    initialize(conf, true);  }  @InterfaceAudience.Private  @VisibleForTesting  public static void reset() {    authenticationMethod = null;    conf = null;    groups = null;    kerberosMinSecondsBeforeRelogin = 0;    kerberosKeyTabLoginRenewalEnabled = false;    kerberosLoginRenewalExecutor = Optional.empty();    setLoginUser(null);    HadoopKerberosName.setRules(null);  }      public static boolean isSecurityEnabled() {    return !isAuthenticationMethodEnabled(AuthenticationMethod.SIMPLE);  }    @InterfaceAudience.Private  @InterfaceStability.Evolving  private static boolean isAuthenticationMethodEnabled(AuthenticationMethod method) {    ensureInitialized();    return (authenticationMethod == method);  }  @InterfaceAudience.Private  @InterfaceStability.Evolving  @VisibleForTesting  static boolean isKerberosKeyTabLoginRenewalEnabled() {    ensureInitialized();    return kerberosKeyTabLoginRenewalEnabled;  }  @InterfaceAudience.Private  @InterfaceStability.Evolving  @VisibleForTesting  static Optional<ExecutorService> getKerberosLoginRenewalExecutor() {    ensureInitialized();    return kerberosLoginRenewalExecutor;  }    private static final AtomicReference<UserGroupInformation> loginUserRef =    new AtomicReference<>();  private final Subject subject;    private final User user;  private static String OS_LOGIN_MODULE_NAME;  private static Class<? extends Principal> OS_PRINCIPAL_CLASS;    private static final boolean windows =      System.getProperty("os.name").startsWith("Windows");      private static String getOSLoginModuleName() {    if (IBM_JAVA) {      return "com.ibm.security.auth.module.JAASLoginModule";    } else {      return windows ? "com.sun.security.auth.module.NTLoginModule"        : "com.sun.security.auth.module.UnixLoginModule";    }  }      @SuppressWarnings("unchecked")  private static Class<? extends Principal> getOsPrincipalClass() {    ClassLoader cl = ClassLoader.getSystemClassLoader();    try {      String principalClass = null;      if (IBM_JAVA) {        principalClass = "com.ibm.security.auth.UsernamePrincipal";      } else {        principalClass = windows ? "com.sun.security.auth.NTUserPrincipal"            : "com.sun.security.auth.UnixPrincipal";      }      return (Class<? extends Principal>) cl.loadClass(principalClass);    } catch (ClassNotFoundException e) {      LOG.error("Unable to find JAAS classes:" + e.getMessage());    }    return null;  }  static {    OS_LOGIN_MODULE_NAME = getOSLoginModuleName();    OS_PRINCIPAL_CLASS = getOsPrincipalClass();  }  private static class RealUser implements Principal {    private final UserGroupInformation realUser;        RealUser(UserGroupInformation realUser) {      this.realUser = realUser;    }        @Override    public String getName() {      return realUser.getUserName();    }        public UserGroupInformation getRealUser() {      return realUser;    }        @Override    public boolean equals(Object o) {      if (this == o) {        return true;      } else if (o == null || getClass() != o.getClass()) {        return false;      } else {        return realUser.equals(((RealUser) o).realUser);      }    }        @Override    public int hashCode() {      return realUser.hashCode();    }        @Override    public String toString() {      return realUser.toString();    }  }  private static HadoopLoginContext  newLoginContext(String appName, Subject subject,                  HadoopConfiguration loginConf)      throws LoginException {                Thread t = Thread.currentThread();    ClassLoader oldCCL = t.getContextClassLoader();    t.setContextClassLoader(HadoopLoginModule.class.getClassLoader());    try {      return new HadoopLoginContext(appName, subject, loginConf);    } finally {      t.setContextClassLoader(oldCCL);    }  }      private HadoopLoginContext getLogin() {    LoginContext login = user.getLogin();    return (login instanceof HadoopLoginContext)      ? (HadoopLoginContext)login : null;  }  private void setLogin(LoginContext login) {    user.setLogin(login);  }    private void setLastLogin(long loginTime) {    user.setLastLogin(loginTime);  }    UserGroupInformation(Subject subject) {    this.subject = subject;                this.user = subject.getPrincipals(User.class).iterator().next();    if (user == null || user.getName() == null) {      throw new IllegalStateException("Subject does not contain a valid User");    }  }    public boolean hasKerberosCredentials() {    return user.getAuthenticationMethod() == AuthenticationMethod.KERBEROS;  }    @InterfaceAudience.Public  @InterfaceStability.Evolving  public static UserGroupInformation getCurrentUser() throws IOException {    ensureInitialized();    AccessControlContext context = AccessController.getContext();    Subject subject = Subject.getSubject(context);    if (subject == null || subject.getPrincipals(User.class).isEmpty()) {      return getLoginUser();    } else {      return new UserGroupInformation(subject);    }  }     public static UserGroupInformation getBestUGI(      String ticketCachePath, String user) throws IOException {    if (ticketCachePath != null) {      return getUGIFromTicketCache(ticketCachePath, user);    } else if (user == null) {      return getCurrentUser();    } else {      return createRemoteUser(user);    }      }    @InterfaceAudience.Public  @InterfaceStability.Evolving  public static UserGroupInformation getUGIFromTicketCache(            String ticketCache, String user) throws IOException {    if (!isAuthenticationMethodEnabled(AuthenticationMethod.KERBEROS)) {      return getBestUGI(null, user);    }    LoginParams params = new LoginParams();    params.put(LoginParam.PRINCIPAL, user);    params.put(LoginParam.CCACHE, ticketCache);    return doSubjectLogin(null, params);  }    public static UserGroupInformation getUGIFromSubject(Subject subject)      throws IOException {    if (subject == null) {      throw new KerberosAuthException(SUBJECT_MUST_NOT_BE_NULL);    }    if (subject.getPrincipals(KerberosPrincipal.class).isEmpty()) {      throw new KerberosAuthException(SUBJECT_MUST_CONTAIN_PRINCIPAL);    }            return doSubjectLogin(subject, null);  }    @InterfaceAudience.Public  @InterfaceStability.Evolving  public static UserGroupInformation getLoginUser() throws IOException {    ensureInitialized();    UserGroupInformation loginUser = loginUserRef.get();                    if (loginUser == null) {      UserGroupInformation newLoginUser = createLoginUser(null);      do {                                if (loginUserRef.compareAndSet(null, newLoginUser)) {          loginUser = newLoginUser;                    loginUser.spawnAutoRenewalThreadForUserCreds(false);        } else {          loginUser = loginUserRef.get();        }      } while (loginUser == null);    }    return loginUser;  }    public static String trimLoginMethod(String userName) {    int spaceIndex = userName.indexOf(' ');    if (spaceIndex >= 0) {      userName = userName.substring(0, spaceIndex);    }    return userName;  }    @InterfaceAudience.Public  @InterfaceStability.Evolving  public static void loginUserFromSubject(Subject subject) throws IOException {    setLoginUser(createLoginUser(subject));  }  private static  UserGroupInformation createLoginUser(Subject subject) throws IOException {    UserGroupInformation realUser = doSubjectLogin(subject, null);    UserGroupInformation loginUser = null;    try {                  String proxyUser = System.getenv(HADOOP_PROXY_USER);      if (proxyUser == null) {        proxyUser = System.getProperty(HADOOP_PROXY_USER);      }      loginUser = proxyUser == null ? realUser : createProxyUser(proxyUser, realUser);            final Collection<String> tokenFileLocations = new LinkedHashSet<>();      tokenFileLocations.addAll(getTrimmedStringCollection(          System.getProperty(HADOOP_TOKEN_FILES)));      tokenFileLocations.addAll(getTrimmedStringCollection(          conf.get(HADOOP_TOKEN_FILES)));      tokenFileLocations.addAll(getTrimmedStringCollection(          System.getenv(HADOOP_TOKEN_FILE_LOCATION)));      for (String tokenFileLocation : tokenFileLocations) {        if (tokenFileLocation != null && tokenFileLocation.length() > 0) {          File tokenFile = new File(tokenFileLocation);          LOG.debug("Reading credentials from location {}",              tokenFile.getCanonicalPath());          if (tokenFile.exists() && tokenFile.isFile()) {            Credentials cred = Credentials.readTokenStorageFile(                tokenFile, conf);            LOG.debug("Loaded {} tokens from {}", cred.numberOfTokens(),                tokenFile.getCanonicalPath());            loginUser.addCredentials(cred);          } else {            LOG.info("Token file {} does not exist",                tokenFile.getCanonicalPath());          }        }      }            final Collection<String> tokensBase64 = new LinkedHashSet<>();      tokensBase64.addAll(getTrimmedStringCollection(          System.getProperty(HADOOP_TOKENS)));      tokensBase64.addAll(getTrimmedStringCollection(          conf.get(HADOOP_TOKENS)));      tokensBase64.addAll(getTrimmedStringCollection(          System.getenv(HADOOP_TOKEN)));      int numTokenBase64 = 0;      for (String tokenBase64 : tokensBase64) {        if (tokenBase64 != null && tokenBase64.length() > 0) {          try {            Token<TokenIdentifier> token = new Token<>();            token.decodeFromUrlString(tokenBase64);            Credentials cred = new Credentials();            cred.addToken(token.getService(), token);            loginUser.addCredentials(cred);            numTokenBase64++;          } catch (IOException ioe) {            LOG.error("Cannot add token {}: {}",                tokenBase64, ioe.getMessage());          }        }      }      if (numTokenBase64 > 0) {        LOG.debug("Loaded {} base64 tokens", numTokenBase64);      }    } catch (IOException ioe) {      LOG.debug("Failure to load login credentials", ioe);      throw ioe;    }    LOG.debug("UGI loginUser: {}", loginUser);    return loginUser;  }  @InterfaceAudience.Private  @InterfaceStability.Unstable  @VisibleForTesting  public static void setLoginUser(UserGroupInformation ugi) {            loginUserRef.set(ugi);  }    private String getKeytab() {    HadoopLoginContext login = getLogin();    return (login != null)      ? login.getConfiguration().getParameters().get(LoginParam.KEYTAB)      : null;  }    private boolean isHadoopLogin() {        return getLogin() != null;  }    public boolean isFromKeytab() {            return hasKerberosCredentials() && isHadoopLogin() && getKeytab() != null;  }      private boolean isFromTicket() {    return hasKerberosCredentials() && isHadoopLogin() && getKeytab() == null;  }    private KerberosTicket getTGT() {    Set<KerberosTicket> tickets = subject        .getPrivateCredentials(KerberosTicket.class);    for (KerberosTicket ticket : tickets) {      if (SecurityUtil.isOriginalTGT(ticket)) {        return ticket;      }    }    return null;  }    private long getRefreshTime(KerberosTicket tgt) {    long start = tgt.getStartTime().getTime();    long end = tgt.getEndTime().getTime();    return start + (long) ((end - start) * TICKET_RENEW_WINDOW);  }  @InterfaceAudience.Private  @InterfaceStability.Unstable  public boolean shouldRelogin() {    return hasKerberosCredentials() && isHadoopLogin();  }    @InterfaceAudience.Private  @InterfaceStability.Unstable  @VisibleForTesting  void spawnAutoRenewalThreadForUserCreds(boolean force) {    if (!force && (!shouldRelogin() || isFromKeytab())) {      return;    }        KerberosTicket tgt = getTGT();    if (tgt == null) {      return;    }    String cmd = conf.get("hadoop.kerberos.kinit.command", "kinit");    long nextRefresh = getRefreshTime(tgt);    executeAutoRenewalTask(getUserName(),            new TicketCacheRenewalRunnable(tgt, cmd, nextRefresh));  }    private void spawnAutoRenewalThreadForKeytab() {    if (!shouldRelogin() || isFromTicket()) {      return;    }        KerberosTicket tgt = getTGT();    if (tgt == null) {      return;    }    long nextRefresh = getRefreshTime(tgt);    executeAutoRenewalTask(getUserName(),            new KeytabRenewalRunnable(tgt, nextRefresh));  }    private void executeAutoRenewalTask(final String userName,                                      AutoRenewalForUserCredsRunnable task) {    kerberosLoginRenewalExecutor = Optional.of(            Executors.newSingleThreadExecutor(                  new ThreadFactory() {                    @Override                    public Thread newThread(Runnable r) {                      Thread t = new Thread(r);                      t.setDaemon(true);                      t.setName("TGT Renewer for " + userName);                      return t;                    }                  }            ));    kerberosLoginRenewalExecutor.get().submit(task);  }    @InterfaceAudience.Private  @InterfaceStability.Unstable  @VisibleForTesting  abstract class AutoRenewalForUserCredsRunnable implements Runnable {    private KerberosTicket tgt;    private RetryPolicy rp;    private long nextRefresh;    private boolean runRenewalLoop = true;    AutoRenewalForUserCredsRunnable(KerberosTicket tgt, long nextRefresh) {      this.tgt = tgt;      this.nextRefresh = nextRefresh;      this.rp = null;    }    public void setRunRenewalLoop(boolean runRenewalLoop) {      this.runRenewalLoop = runRenewalLoop;    }        protected abstract void relogin() throws IOException;    @Override    public void run() {      do {        try {          long now = Time.now();          LOG.debug("Current time is {}, next refresh is {}", now, nextRefresh);          if (now < nextRefresh) {            Thread.sleep(nextRefresh - now);          }          relogin();          tgt = getTGT();          if (tgt == null) {            LOG.warn("No TGT after renewal. Aborting renew thread for " +                getUserName());            return;          }          nextRefresh = Math.max(getRefreshTime(tgt),              now + kerberosMinSecondsBeforeRelogin);          metrics.renewalFailures.set(0);          rp = null;        } catch (InterruptedException ie) {          LOG.warn("Terminating renewal thread");          return;        } catch (IOException ie) {          metrics.renewalFailuresTotal.incr();          final long now = Time.now();          if (tgt.isDestroyed()) {            LOG.error(String.format("TGT is destroyed. " +                    "Aborting renew thread for %s.", getUserName()), ie);            return;          }          long tgtEndTime;                                                  try {            tgtEndTime = tgt.getEndTime().getTime();          } catch (NullPointerException npe) {            LOG.error("NPE thrown while getting KerberosTicket endTime. "                + "Aborting renew thread for {}.", getUserName(), ie);            return;          }          LOG.warn(              "Exception encountered while running the "                  + "renewal command for {}. "                  + "(TGT end time:{}, renewalFailures: {}, "                  + "renewalFailuresTotal: {})",              getUserName(), tgtEndTime, metrics.renewalFailures.value(),              metrics.renewalFailuresTotal.value(), ie);          if (rp == null) {                                                            rp = RetryPolicies.exponentialBackoffRetry(Long.SIZE - 2,                kerberosMinSecondsBeforeRelogin, TimeUnit.MILLISECONDS);          }          try {            nextRefresh = getNextTgtRenewalTime(tgtEndTime, now, rp);          } catch (Exception e) {            LOG.error("Exception when calculating next tgt renewal time", e);            return;          }          metrics.renewalFailures.incr();                    if (now > nextRefresh) {            LOG.error("TGT is expired. Aborting renew thread for {}.",                getUserName());            return;          }        }      } while (runRenewalLoop);    }  }    @InterfaceAudience.Private  @InterfaceStability.Unstable  @VisibleForTesting  final class TicketCacheRenewalRunnable      extends AutoRenewalForUserCredsRunnable {    private String kinitCmd;    TicketCacheRenewalRunnable(KerberosTicket tgt, String kinitCmd,        long nextRefresh) {      super(tgt, nextRefresh);      this.kinitCmd = kinitCmd;    }    @Override    public void relogin() throws IOException {      String output = Shell.execCommand(kinitCmd, "-R");      LOG.debug("Renewed ticket. kinit output: {}", output);      reloginFromTicketCache();    }  }    @InterfaceAudience.Private  @InterfaceStability.Unstable  @VisibleForTesting  final class KeytabRenewalRunnable extends AutoRenewalForUserCredsRunnable {    KeytabRenewalRunnable(KerberosTicket tgt, long nextRefresh) {      super(tgt, nextRefresh);    }    @Override    public void relogin() throws IOException {      reloginFromKeytab();    }  }    @VisibleForTesting  static long getNextTgtRenewalTime(final long tgtEndTime, final long now,      final RetryPolicy rp) throws Exception {    final long lastRetryTime = tgtEndTime - kerberosMinSecondsBeforeRelogin;    final RetryPolicy.RetryAction ra = rp.shouldRetry(null,        metrics.renewalFailures.value(), 0, false);    return Math.min(lastRetryTime, now + ra.delayMillis);  }    @InterfaceAudience.Public  @InterfaceStability.Evolving  public  static void loginUserFromKeytab(String user,                                  String path                                  ) throws IOException {    if (!isSecurityEnabled())      return;    UserGroupInformation u = loginUserFromKeytabAndReturnUGI(user, path);    if (isKerberosKeyTabLoginRenewalEnabled()) {      u.spawnAutoRenewalThreadForKeytab();    }    setLoginUser(u);    LOG.info("Login successful for user {} using keytab file {}. Keytab auto" +            " renewal enabled : {}",            user, path, isKerberosKeyTabLoginRenewalEnabled());  }    @InterfaceAudience.Public  @InterfaceStability.Evolving  public void logoutUserFromKeytab() throws IOException {    if (!hasKerberosCredentials()) {      return;    }        if (getKerberosLoginRenewalExecutor().isPresent()) {      getKerberosLoginRenewalExecutor().get().shutdownNow();    }    HadoopLoginContext login = getLogin();    String keytabFile = getKeytab();    if (login == null || keytabFile == null) {      throw new KerberosAuthException(MUST_FIRST_LOGIN_FROM_KEYTAB);    }    try {      LOG.debug("Initiating logout for {}", getUserName());            login.logout();    } catch (LoginException le) {      KerberosAuthException kae = new KerberosAuthException(LOGOUT_FAILURE, le);      kae.setUser(user.toString());      kae.setKeytabFile(keytabFile);      throw kae;    }    LOG.info("Logout successful for user " + getUserName()        + " using keytab file " + keytabFile);  }      public void checkTGTAndReloginFromKeytab() throws IOException {    reloginFromKeytab(true);  }        @VisibleForTesting  void fixKerberosTicketOrder() {    Set<Object> creds = getSubject().getPrivateCredentials();    synchronized (creds) {      for (Iterator<Object> iter = creds.iterator(); iter.hasNext();) {        Object cred = iter.next();        if (cred instanceof KerberosTicket) {          KerberosTicket ticket = (KerberosTicket) cred;          if (ticket.isDestroyed() || ticket.getServer() == null) {            LOG.warn("Ticket is already destroyed, remove it.");            iter.remove();          } else if (!ticket.getServer().getName().startsWith("krbtgt")) {            LOG.warn(                "The first kerberos ticket is not TGT"                    + "(the server principal is {}), remove and destroy it.",                ticket.getServer());            iter.remove();            try {              ticket.destroy();            } catch (DestroyFailedException e) {              LOG.warn("destroy ticket failed", e);            }          } else {            return;          }        }      }    }    LOG.warn("Warning, no kerberos ticket found while attempting to renew ticket");  }    @InterfaceAudience.Public  @InterfaceStability.Evolving  public void reloginFromKeytab() throws IOException {    reloginFromKeytab(false);  }    @InterfaceAudience.Public  @InterfaceStability.Evolving  public void forceReloginFromKeytab() throws IOException {    reloginFromKeytab(false, true);  }  private void reloginFromKeytab(boolean checkTGT) throws IOException {    reloginFromKeytab(checkTGT, false);  }  private void reloginFromKeytab(boolean checkTGT, boolean ignoreLastLoginTime)      throws IOException {    if (!shouldRelogin() || !isFromKeytab()) {      return;    }    HadoopLoginContext login = getLogin();    if (login == null) {      throw new KerberosAuthException(MUST_FIRST_LOGIN_FROM_KEYTAB);    }    if (checkTGT) {      KerberosTicket tgt = getTGT();      if (tgt != null && !shouldRenewImmediatelyForTests &&        Time.now() < getRefreshTime(tgt)) {        return;      }    }    relogin(login, ignoreLastLoginTime);  }    @InterfaceAudience.Public  @InterfaceStability.Evolving  public void reloginFromTicketCache() throws IOException {    if (!shouldRelogin() || !isFromTicket()) {      return;    }    HadoopLoginContext login = getLogin();    if (login == null) {      throw new KerberosAuthException(MUST_FIRST_LOGIN);    }    relogin(login, false);  }  private void relogin(HadoopLoginContext login, boolean ignoreLastLoginTime)      throws IOException {                synchronized(login.getSubjectLock()) {            if (login == getLogin()) {        unprotectedRelogin(login, ignoreLastLoginTime);      }    }  }  private void unprotectedRelogin(HadoopLoginContext login,      boolean ignoreLastLoginTime) throws IOException {    assert Thread.holdsLock(login.getSubjectLock());    long now = Time.now();    if (!hasSufficientTimeElapsed(now) && !ignoreLastLoginTime) {      return;    }        user.setLastLogin(now);    try {      LOG.debug("Initiating logout for {}", getUserName());                        login.logout();                  login = newLoginContext(        login.getAppName(), login.getSubject(), login.getConfiguration());      LOG.debug("Initiating re-login for {}", getUserName());      login.login();                  fixKerberosTicketOrder();      setLogin(login);    } catch (LoginException le) {      KerberosAuthException kae = new KerberosAuthException(LOGIN_FAILURE, le);      kae.setUser(getUserName());      throw kae;    }  }    public  static UserGroupInformation loginUserFromKeytabAndReturnUGI(String user,                                  String path                                  ) throws IOException {    if (!isSecurityEnabled())      return UserGroupInformation.getCurrentUser();    LoginParams params = new LoginParams();    params.put(LoginParam.PRINCIPAL, user);    params.put(LoginParam.KEYTAB, path);    return doSubjectLogin(null, params);  }  private boolean hasSufficientTimeElapsed(long now) {    if (!shouldRenewImmediatelyForTests &&        now - user.getLastLogin() < kerberosMinSecondsBeforeRelogin ) {      LOG.warn("Not attempting to re-login since the last re-login was " +          "attempted less than " + (kerberosMinSecondsBeforeRelogin/1000) +          " seconds before. Last Login=" + user.getLastLogin());      return false;    }    return true;  }      @InterfaceAudience.Public  @InterfaceStability.Evolving  public static boolean isLoginKeytabBased() throws IOException {    return getLoginUser().isFromKeytab();  }    public static boolean isLoginTicketBased()  throws IOException {    return getLoginUser().isFromTicket();  }    @InterfaceAudience.Public  @InterfaceStability.Evolving  public static UserGroupInformation createRemoteUser(String user) {    return createRemoteUser(user, AuthMethod.SIMPLE);  }      @InterfaceAudience.Public  @InterfaceStability.Evolving  public static UserGroupInformation createRemoteUser(String user, AuthMethod authMethod) {    if (user == null || user.isEmpty()) {      throw new IllegalArgumentException("Null user");    }    Subject subject = new Subject();    subject.getPrincipals().add(new User(user));    UserGroupInformation result = new UserGroupInformation(subject);    result.setAuthenticationMethod(authMethod);    return result;  }    @InterfaceAudience.Public  @InterfaceStability.Evolving  public enum AuthenticationMethod {            SIMPLE(AuthMethod.SIMPLE,        HadoopConfiguration.SIMPLE_CONFIG_NAME),    KERBEROS(AuthMethod.KERBEROS,        HadoopConfiguration.KERBEROS_CONFIG_NAME),    TOKEN(AuthMethod.TOKEN),    CERTIFICATE(null),    KERBEROS_SSL(null),    PROXY(null);        private final AuthMethod authMethod;    private final String loginAppName;        private AuthenticationMethod(AuthMethod authMethod) {      this(authMethod, null);    }    private AuthenticationMethod(AuthMethod authMethod, String loginAppName) {      this.authMethod = authMethod;      this.loginAppName = loginAppName;    }        public AuthMethod getAuthMethod() {      return authMethod;    }        String getLoginAppName() {      if (loginAppName == null) {        throw new UnsupportedOperationException(            this + " login authentication is not supported");      }      return loginAppName;    }        public static AuthenticationMethod valueOf(AuthMethod authMethod) {      for (AuthenticationMethod value : values()) {        if (value.getAuthMethod() == authMethod) {          return value;        }      }      throw new IllegalArgumentException(          "no authentication method for " + authMethod);    }  };    @InterfaceAudience.Public  @InterfaceStability.Evolving  public static UserGroupInformation createProxyUser(String user,      UserGroupInformation realUser) {    if (user == null || user.isEmpty()) {      throw new IllegalArgumentException("Null user");    }    if (realUser == null) {      throw new IllegalArgumentException("Null real user");    }    Subject subject = new Subject();    Set<Principal> principals = subject.getPrincipals();    principals.add(new User(user, AuthenticationMethod.PROXY, null));    principals.add(new RealUser(realUser));    return new UserGroupInformation(subject);  }    @InterfaceAudience.Public  @InterfaceStability.Evolving  public UserGroupInformation getRealUser() {    for (RealUser p: subject.getPrincipals(RealUser.class)) {      return p.getRealUser();    }    return null;  }      private static class TestingGroups extends Groups {    private final Map<String, Set<String>> userToGroupsMapping =        new HashMap<>();    private Groups underlyingImplementation;        private TestingGroups(Groups underlyingImplementation) {      super(new org.apache.hadoop.conf.Configuration());      this.underlyingImplementation = underlyingImplementation;    }        @Override    public List<String> getGroups(String user) throws IOException {      return new ArrayList<>(getGroupsSet(user));    }    @Override    public Set<String> getGroupsSet(String user) throws IOException {      Set<String> result = userToGroupsMapping.get(user);      if (result == null) {        result = underlyingImplementation.getGroupsSet(user);      }      return result;    }    private void setUserGroups(String user, String[] groups) {      Set<String> groupsSet = new LinkedHashSet<>();      Collections.addAll(groupsSet, groups);      userToGroupsMapping.put(user, groupsSet);    }  }    @InterfaceAudience.Public  @InterfaceStability.Evolving  public static UserGroupInformation createUserForTesting(String user,                                                           String[] userGroups) {    ensureInitialized();    UserGroupInformation ugi = createRemoteUser(user);        if (!(groups instanceof TestingGroups)) {      groups = new TestingGroups(groups);    }        ((TestingGroups) groups).setUserGroups(ugi.getShortUserName(), userGroups);    return ugi;  }    public static UserGroupInformation createProxyUserForTesting(String user,      UserGroupInformation realUser, String[] userGroups) {    ensureInitialized();    UserGroupInformation ugi = createProxyUser(user, realUser);        if (!(groups instanceof TestingGroups)) {      groups = new TestingGroups(groups);    }        ((TestingGroups) groups).setUserGroups(ugi.getShortUserName(), userGroups);    return ugi;  }      public String getShortUserName() {    return user.getShortName();  }  public String getPrimaryGroupName() throws IOException {    Set<String> groupsSet = getGroupsSet();    if (groupsSet.isEmpty()) {      throw new IOException("There is no primary group for UGI " + this);    }    return groupsSet.iterator().next();  }    @InterfaceAudience.Public  @InterfaceStability.Evolving  public String getUserName() {    return user.getName();  }    public synchronized boolean addTokenIdentifier(TokenIdentifier tokenId) {    return subject.getPublicCredentials().add(tokenId);  }    public synchronized Set<TokenIdentifier> getTokenIdentifiers() {    return subject.getPublicCredentials(TokenIdentifier.class);  }      public boolean addToken(Token<? extends TokenIdentifier> token) {    return (token != null) ? addToken(token.getService(), token) : false;  }    public boolean addToken(Text alias, Token<? extends TokenIdentifier> token) {    synchronized (subject) {      getCredentialsInternal().addToken(alias, token);      return true;    }  }      public Collection<Token<? extends TokenIdentifier>> getTokens() {    synchronized (subject) {      return Collections.unmodifiableCollection(          new ArrayList<Token<?>>(getCredentialsInternal().getAllTokens()));    }  }    public Credentials getCredentials() {    synchronized (subject) {      Credentials creds = new Credentials(getCredentialsInternal());      Iterator<Token<?>> iter = creds.getAllTokens().iterator();      while (iter.hasNext()) {        if (iter.next().isPrivate()) {          iter.remove();        }      }      return creds;    }  }      public void addCredentials(Credentials credentials) {    synchronized (subject) {      getCredentialsInternal().addAll(credentials);    }  }  private synchronized Credentials getCredentialsInternal() {    final Credentials credentials;    final Set<Credentials> credentialsSet =      subject.getPrivateCredentials(Credentials.class);    if (!credentialsSet.isEmpty()){      credentials = credentialsSet.iterator().next();    } else {      credentials = new Credentials();      subject.getPrivateCredentials().add(credentials);    }    return credentials;  }    public String[] getGroupNames() {    Collection<String> groupsSet = getGroupsSet();    return groupsSet.toArray(new String[groupsSet.size()]);  }    @Deprecated  public List<String> getGroups() {    ensureInitialized();    try {      return groups.getGroups(getShortUserName());    } catch (IOException ie) {      LOG.debug("Failed to get groups for user {}", getShortUserName(), ie);      return Collections.emptyList();    }  }    public Set<String> getGroupsSet() {    ensureInitialized();    try {      return groups.getGroupsSet(getShortUserName());    } catch (IOException ie) {      LOG.debug("Failed to get groups for user {}", getShortUserName(), ie);      return Collections.emptySet();    }  }    @Override  public String toString() {    StringBuilder sb = new StringBuilder(getUserName());    sb.append(" (auth:"+getAuthenticationMethod()+")");    if (getRealUser() != null) {      sb.append(" via ").append(getRealUser().toString());    }    return sb.toString();  }    public synchronized   void setAuthenticationMethod(AuthenticationMethod authMethod) {    user.setAuthenticationMethod(authMethod);  }    public void setAuthenticationMethod(AuthMethod authMethod) {    user.setAuthenticationMethod(AuthenticationMethod.valueOf(authMethod));  }    public synchronized AuthenticationMethod getAuthenticationMethod() {    return user.getAuthenticationMethod();  }    public synchronized AuthenticationMethod getRealAuthenticationMethod() {    UserGroupInformation ugi = getRealUser();    if (ugi == null) {      ugi = this;    }    return ugi.getAuthenticationMethod();  }    public static AuthenticationMethod getRealAuthenticationMethod(      UserGroupInformation ugi) {    AuthenticationMethod authMethod = ugi.getAuthenticationMethod();    if (authMethod == AuthenticationMethod.PROXY) {      authMethod = ugi.getRealUser().getAuthenticationMethod();    }    return authMethod;  }    @Override  public boolean equals(Object o) {    if (o == this) {      return true;    } else if (o == null || getClass() != o.getClass()) {      return false;    } else {      return subject == ((UserGroupInformation) o).subject;    }  }    @Override  public int hashCode() {    return System.identityHashCode(subject);  }    protected Subject getSubject() {    return subject;  }    @InterfaceAudience.Public  @InterfaceStability.Evolving  public <T> T doAs(PrivilegedAction<T> action) {    if (LOG.isDebugEnabled()) {      LOG.debug("PrivilegedAction [as: {}][action: {}]", this, action,          new Exception());    }    return Subject.doAs(subject, action);  }      @InterfaceAudience.Public  @InterfaceStability.Evolving  public <T> T doAs(PrivilegedExceptionAction<T> action                    ) throws IOException, InterruptedException {    try {      if (LOG.isDebugEnabled()) {        LOG.debug("PrivilegedAction [as: {}][action: {}]", this, action,            new Exception());      }      return Subject.doAs(subject, action);    } catch (PrivilegedActionException pae) {      Throwable cause = pae.getCause();      LOG.debug("PrivilegedActionException as: {}", this, cause);      if (cause == null) {        throw new RuntimeException("PrivilegedActionException with no " +                "underlying cause. UGI [" + this + "]" +": " + pae, pae);      } else if (cause instanceof IOException) {        throw (IOException) cause;      } else if (cause instanceof Error) {        throw (Error) cause;      } else if (cause instanceof RuntimeException) {        throw (RuntimeException) cause;      } else if (cause instanceof InterruptedException) {        throw (InterruptedException) cause;      } else {        throw new UndeclaredThrowableException(cause);      }    }  }    @InterfaceAudience.LimitedPrivate({"HDFS", "KMS"})  @InterfaceStability.Unstable  public static void logUserInfo(Logger log, String caption,      UserGroupInformation ugi) {    if (log.isDebugEnabled()) {      log.debug(caption + " UGI: " + ugi);      for (Map.Entry<Text, Token<? extends TokenIdentifier>> kv :          ugi.getCredentials().getTokenMap().entrySet()) {        log.debug("+token: {} -> {}", kv.getKey(), kv.getValue());      }    }  }    @InterfaceAudience.LimitedPrivate({"HDFS", "KMS"})  @InterfaceStability.Unstable  public static void logAllUserInfo(Logger log, UserGroupInformation ugi) throws      IOException {    if (log.isDebugEnabled()) {      logUserInfo(log, "Current", ugi.getCurrentUser());      if (ugi.getRealUser() != null) {        logUserInfo(log, "Real", ugi.getRealUser());      }      logUserInfo(log, "Login", ugi.getLoginUser());    }  }    public static void logAllUserInfo(UserGroupInformation ugi) throws      IOException {    logAllUserInfo(LOG, ugi);  }  private void print() throws IOException {    System.out.println("User: " + getUserName());    System.out.print("Group Ids: ");    System.out.println();    String[] groups = getGroupNames();    System.out.print("Groups: ");    for(int i=0; i < groups.length; i++) {      System.out.print(groups[i] + " ");    }    System.out.println();      }    private static UserGroupInformation doSubjectLogin(      Subject subject, LoginParams params) throws IOException {    ensureInitialized();        if (subject == null && params == null) {      params = LoginParams.getDefaults();    }    HadoopConfiguration loginConf = new HadoopConfiguration(params);    try {      HadoopLoginContext login = newLoginContext(        authenticationMethod.getLoginAppName(), subject, loginConf);      login.login();      UserGroupInformation ugi = new UserGroupInformation(login.getSubject());                  if (subject == null) {        params.put(LoginParam.PRINCIPAL, ugi.getUserName());        ugi.setLogin(login);        ugi.setLastLogin(Time.now());      }      return ugi;    } catch (LoginException le) {      KerberosAuthException kae =        new KerberosAuthException(FAILURE_TO_LOGIN, le);      if (params != null) {        kae.setPrincipal(params.get(LoginParam.PRINCIPAL));        kae.setKeytabFile(params.get(LoginParam.KEYTAB));        kae.setTicketCacheFile(params.get(LoginParam.CCACHE));      }      throw kae;    }  }      enum LoginParam {    PRINCIPAL,    KEYTAB,    CCACHE,  }    private static class LoginParams extends EnumMap<LoginParam,String>      implements Parameters {    LoginParams() {      super(LoginParam.class);    }        @Override    public String put(LoginParam param, String val) {      boolean add = val != null && !containsKey(param);      return add ? super.put(param, val) : null;    }    static LoginParams getDefaults() {      LoginParams params = new LoginParams();      params.put(LoginParam.PRINCIPAL, System.getenv("KRB5PRINCIPAL"));      params.put(LoginParam.KEYTAB, System.getenv("KRB5KEYTAB"));      params.put(LoginParam.CCACHE, System.getenv("KRB5CCNAME"));      return params;    }  }      private static class HadoopLoginContext extends LoginContext {    private final String appName;    private final HadoopConfiguration conf;    private AtomicBoolean isLoggedIn = new AtomicBoolean();    HadoopLoginContext(String appName, Subject subject,                       HadoopConfiguration conf) throws LoginException {      super(appName, subject, null, conf);      this.appName = appName;      this.conf = conf;    }    String getAppName() {      return appName;    }    HadoopConfiguration getConfiguration() {      return conf;    }            Object getSubjectLock() {      Subject subject = getSubject();                  return (subject == null) ? this : subject.getPrivateCredentials();    }    @Override    public void login() throws LoginException {      synchronized(getSubjectLock()) {        MutableRate metric = metrics.loginFailure;        long start = Time.monotonicNow();        try {          super.login();          isLoggedIn.set(true);          metric = metrics.loginSuccess;        } finally {          metric.add(Time.monotonicNow() - start);        }      }    }    @Override    public void logout() throws LoginException {      synchronized(getSubjectLock()) {        if (isLoggedIn.compareAndSet(true, false)) {          super.logout();        }      }    }  }    @InterfaceAudience.Private  @InterfaceStability.Unstable  private static class HadoopConfiguration  extends javax.security.auth.login.Configuration {    static final String KRB5_LOGIN_MODULE =        KerberosUtil.getKrb5LoginModuleName();    static final String SIMPLE_CONFIG_NAME = "hadoop-simple";    static final String KERBEROS_CONFIG_NAME = "hadoop-kerberos";    private static final Map<String, String> BASIC_JAAS_OPTIONS =        new HashMap<String,String>();    static {      if ("true".equalsIgnoreCase(System.getenv("HADOOP_JAAS_DEBUG"))) {        BASIC_JAAS_OPTIONS.put("debug", "true");      }    }    static final AppConfigurationEntry OS_SPECIFIC_LOGIN =        new AppConfigurationEntry(            OS_LOGIN_MODULE_NAME,            LoginModuleControlFlag.REQUIRED,            BASIC_JAAS_OPTIONS);    static final AppConfigurationEntry HADOOP_LOGIN =        new AppConfigurationEntry(            HadoopLoginModule.class.getName(),            LoginModuleControlFlag.REQUIRED,            BASIC_JAAS_OPTIONS);    private final LoginParams params;    HadoopConfiguration(LoginParams params) {      this.params = params;    }    @Override    public LoginParams getParameters() {      return params;    }    @Override    public AppConfigurationEntry[] getAppConfigurationEntry(String appName) {      ArrayList<AppConfigurationEntry> entries = new ArrayList<>();                        if (params == null || appName.equals(SIMPLE_CONFIG_NAME)) {        entries.add(OS_SPECIFIC_LOGIN);      } else if (appName.equals(KERBEROS_CONFIG_NAME)) {                                if (!params.containsKey(LoginParam.PRINCIPAL)) {          entries.add(OS_SPECIFIC_LOGIN);        }        entries.add(getKerberosEntry());      }      entries.add(HADOOP_LOGIN);      return entries.toArray(new AppConfigurationEntry[0]);    }    private AppConfigurationEntry getKerberosEntry() {      final Map<String,String> options = new HashMap<>(BASIC_JAAS_OPTIONS);      LoginModuleControlFlag controlFlag = LoginModuleControlFlag.OPTIONAL;                        final String principal = params.get(LoginParam.PRINCIPAL);      if (principal != null) {        options.put("principal", principal);        controlFlag = LoginModuleControlFlag.REQUIRED;      }            if (IBM_JAVA) {        if (params.containsKey(LoginParam.KEYTAB)) {          final String keytab = params.get(LoginParam.KEYTAB);          if (keytab != null) {            options.put("useKeytab", prependFileAuthority(keytab));          } else {            options.put("useDefaultKeytab", "true");          }          options.put("credsType", "both");        } else {          String ticketCache = params.get(LoginParam.CCACHE);          if (ticketCache != null) {            options.put("useCcache", prependFileAuthority(ticketCache));          } else {            options.put("useDefaultCcache", "true");          }          options.put("renewTGT", "true");        }      } else {        if (params.containsKey(LoginParam.KEYTAB)) {          options.put("useKeyTab", "true");          final String keytab = params.get(LoginParam.KEYTAB);          if (keytab != null) {            options.put("keyTab", keytab);          }          options.put("storeKey", "true");        } else {          options.put("useTicketCache", "true");          String ticketCache = params.get(LoginParam.CCACHE);          if (ticketCache != null) {            options.put("ticketCache", ticketCache);          }          options.put("renewTGT", "true");        }        options.put("doNotPrompt", "true");      }      options.put("refreshKrb5Config", "true");      return new AppConfigurationEntry(          KRB5_LOGIN_MODULE, controlFlag, options);    }    private static String prependFileAuthority(String keytabPath) {      return keytabPath.startsWith("file://")          ? keytabPath          : "file://" + keytabPath;    }  }    public static void main(String [] args) throws Exception {  System.out.println("Getting UGI for current user");    UserGroupInformation ugi = getCurrentUser();    ugi.print();    System.out.println("UGI: " + ugi);    System.out.println("Auth method " + ugi.user.getAuthenticationMethod());    System.out.println("Keytab " + ugi.isFromKeytab());    System.out.println("============================================================");        if (args.length == 2) {      System.out.println("Getting UGI from keytab....");      loginUserFromKeytab(args[0], args[1]);      getCurrentUser().print();      System.out.println("Keytab: " + ugi);      UserGroupInformation loginUgi = getLoginUser();      System.out.println("Auth method " + loginUgi.getAuthenticationMethod());      System.out.println("Keytab " + loginUgi.isFromKeytab());    }  }}
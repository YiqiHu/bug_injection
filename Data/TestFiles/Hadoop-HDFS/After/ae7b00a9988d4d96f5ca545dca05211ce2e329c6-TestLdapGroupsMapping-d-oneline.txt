public class TestLdapGroupsMapping extends TestLdapGroupsMappingBase {  private static final Logger LOG = LoggerFactory.getLogger(      TestLdapGroupsMapping.class);    private static final byte[] AUTHENTICATE_SUCCESS_MSG =      {48, 12, 2, 1, 1, 97, 7, 10, 1, 0, 4, 0, 4, 0};  private final String userDN = "CN=some_user,DC=test,DC=com";  private static final String TEST_LDAP_URL = "ldap://test";  @Before  public void setupMocks() {    when(getUserSearchResult().getNameInNamespace()).        thenReturn(userDN);  }    @Test  public void testGetGroups() throws NamingException {            when(getContext().search(anyString(), anyString(), any(Object[].class),        any(SearchControls.class)))        .thenReturn(getUserNames(), getGroupNames());    doTestGetGroups(Arrays.asList(getTestGroups()), 2);  }  @Test  public void testGetGroupsWithDifferentBaseDNs() throws Exception {    Configuration conf = getBaseConf(TEST_LDAP_URL);    String userBaseDN = "ou=Users,dc=xxx,dc=com ";    String groupBaseDN = " ou=Groups,dc=xxx,dc=com";    conf.set(LdapGroupsMapping.USER_BASE_DN_KEY, userBaseDN);    conf.set(LdapGroupsMapping.GROUP_BASE_DN_KEY, groupBaseDN);    doTestGetGroupsWithBaseDN(conf, userBaseDN.trim(), groupBaseDN.trim());  }  @Test  public void testGetGroupsWithDefaultBaseDN() throws Exception {    Configuration conf = getBaseConf(TEST_LDAP_URL);    String baseDN = " dc=xxx,dc=com ";    conf.set(LdapGroupsMapping.BASE_DN_KEY, baseDN);    doTestGetGroupsWithBaseDN(conf, baseDN.trim(), baseDN.trim());  }    private void doTestGetGroupsWithBaseDN(Configuration conf, String userBaseDN,      String groupBaseDN) throws NamingException {    final LdapGroupsMapping groupsMapping = getGroupsMapping();    groupsMapping.setConf(conf);    final String userName = "some_user";            when(getContext().search(anyString(), anyString(), any(Object[].class),        any(SearchControls.class)))        .thenReturn(getUserNames(), getGroupNames());    List<String> groups = groupsMapping.getGroups(userName);    Assert.assertEquals(Arrays.asList(getTestGroups()), groups);        verify(getContext(), times(1)).search(userBaseDN,        LdapGroupsMapping.USER_SEARCH_FILTER_DEFAULT,        new Object[]{userName},        LdapGroupsMapping.SEARCH_CONTROLS);    verify(getContext(), times(1)).search(groupBaseDN,        "(&" + LdapGroupsMapping.GROUP_SEARCH_FILTER_DEFAULT + "(" +            LdapGroupsMapping.GROUP_MEMBERSHIP_ATTR_DEFAULT + "={0}))",        new Object[]{userDN},        LdapGroupsMapping.SEARCH_CONTROLS);  }  @Test  public void testGetGroupsWithHierarchy() throws NamingException {                        when(getContext().search(anyString(), anyString(), any(Object[].class),        any(SearchControls.class)))        .thenReturn(getUserNames(), getGroupNames());    when(getContext().search(anyString(), anyString(),        any(SearchControls.class)))        .thenReturn(getParentGroupNames());    doTestGetGroupsWithParent(Arrays.asList(getTestParentGroups()), 2, 1);  }  @Test  public void testGetGroupsWithConnectionClosed() throws NamingException {            when(getContext().search(anyString(), anyString(), any(Object[].class),        any(SearchControls.class)))        .thenThrow(new CommunicationException("Connection is closed"))        .thenReturn(getUserNames(), getGroupNames());                    doTestGetGroups(Arrays.asList(getTestGroups()), 1 + 2);  }  @Test  public void testGetGroupsWithLdapDown() throws NamingException {        when(getContext().search(anyString(), anyString(), any(Object[].class),        any(SearchControls.class)))        .thenThrow(new CommunicationException("Connection is closed"));            doTestGetGroups(Arrays.asList(new String[] {}), 4);  }    private void doTestGetGroups(List<String> expectedGroups, int searchTimes)      throws NamingException {    Configuration conf = getBaseConf(TEST_LDAP_URL);    conf.setInt(LDAP_NUM_ATTEMPTS_KEY, searchTimes);    LdapGroupsMapping groupsMapping = getGroupsMapping();    groupsMapping.setConf(conf);            List<String> groups = groupsMapping.getGroups("some_user");        Assert.assertEquals(expectedGroups, groups);            verify(getContext(), times(searchTimes)).search(anyString(),        anyString(), any(Object[].class), any(SearchControls.class));  }  private void doTestGetGroupsWithParent(List<String> expectedGroups,      int searchTimesGroup, int searchTimesParentGroup) throws NamingException {    Configuration conf = getBaseConf(TEST_LDAP_URL);        conf.setInt(LdapGroupsMapping.GROUP_HIERARCHY_LEVELS_KEY, 1);    LdapGroupsMapping groupsMapping = getGroupsMapping();    groupsMapping.setConf(conf);            List<String> groups = groupsMapping.getGroups("some_user");        Assert.assertEquals(new HashSet<>(expectedGroups), new HashSet<>(groups));        verify(getContext(), times(searchTimesGroup)).search(anyString(),        anyString(), any(Object[].class), any(SearchControls.class));        verify(getContext(), times(searchTimesParentGroup)).search(        anyString(), anyString(), any(SearchControls.class));  }  @Test  public void testExtractPassword() throws IOException {    File testDir = GenericTestUtils.getTestDir();    testDir.mkdirs();    File secretFile = new File(testDir, "secret.txt");    Writer writer = new FileWriter(secretFile);    writer.write("hadoop");    writer.close();        LdapGroupsMapping mapping = new LdapGroupsMapping();    Assert.assertEquals("hadoop",        mapping.extractPassword(secretFile.getPath()));  }  @Test  public void testConfGetPassword() throws Exception {    File testDir = GenericTestUtils.getTestDir();    Configuration conf = getBaseConf();    final Path jksPath = new Path(testDir.toString(), "test.jks");    final String ourUrl =        JavaKeyStoreProvider.SCHEME_NAME + "://file" + jksPath.toUri();    File file = new File(testDir, "test.jks");    file.delete();    conf.set(CredentialProviderFactory.CREDENTIAL_PROVIDER_PATH, ourUrl);    CredentialProvider provider =        CredentialProviderFactory.getProviders(conf).get(0);    char[] bindpass = {'b', 'i', 'n', 'd', 'p', 'a', 's', 's'};    char[] storepass = {'s', 't', 'o', 'r', 'e', 'p', 'a', 's', 's'};        assertNull(provider.getCredentialEntry(        LdapGroupsMapping.BIND_PASSWORD_KEY));    assertNull(provider.getCredentialEntry(        LdapGroupsMapping.LDAP_KEYSTORE_PASSWORD_KEY));        try {      provider.createCredentialEntry(          LdapGroupsMapping.BIND_PASSWORD_KEY, bindpass);      provider.createCredentialEntry(          LdapGroupsMapping.LDAP_KEYSTORE_PASSWORD_KEY, storepass);      provider.flush();    } catch (Exception e) {      e.printStackTrace();      throw e;    }        assertArrayEquals(bindpass, provider.getCredentialEntry(        LdapGroupsMapping.BIND_PASSWORD_KEY).getCredential());    assertArrayEquals(storepass, provider.getCredentialEntry(        LdapGroupsMapping.LDAP_KEYSTORE_PASSWORD_KEY).getCredential());    LdapGroupsMapping mapping = new LdapGroupsMapping();    Assert.assertEquals("bindpass",        mapping.getPassword(conf, LdapGroupsMapping.BIND_PASSWORD_KEY, ""));    Assert.assertEquals("storepass",        mapping.getPassword(conf, LdapGroupsMapping.LDAP_KEYSTORE_PASSWORD_KEY,            ""));                Assert.assertEquals("", mapping.getPassword(conf,"invalid-alias", ""));  }  @Test  public void testConfGetPasswordUsingAlias() throws Exception {    File testDir = GenericTestUtils.getTestDir();    Configuration conf = getBaseConf();    final Path jksPath = new Path(testDir.toString(), "test.jks");    final String ourUrl =        JavaKeyStoreProvider.SCHEME_NAME + "://file" + jksPath.toUri();    File file = new File(testDir, "test.jks");    file.delete();    conf.set(CredentialProviderFactory.CREDENTIAL_PROVIDER_PATH, ourUrl);        String bindpassAlias = "bindpassAlias";    conf.set(LdapGroupsMapping.BIND_PASSWORD_ALIAS_KEY, bindpassAlias);    CredentialProvider provider =        CredentialProviderFactory.getProviders(conf).get(0);    char[] bindpass = "bindpass".toCharArray();        assertNull(provider.getCredentialEntry(bindpassAlias));        provider.createCredentialEntry(bindpassAlias, bindpass);    provider.flush();        assertArrayEquals(bindpass, provider.getCredentialEntry(        bindpassAlias).getCredential());    LdapGroupsMapping mapping = new LdapGroupsMapping();    Assert.assertEquals("bindpass",        mapping.getPasswordFromCredentialProviders(conf, bindpassAlias, ""));        Assert.assertEquals("", mapping.getPasswordFromCredentialProviders(        conf, "invalid-alias", ""));  }    @Test (timeout = 30000)  public void testLdapConnectionTimeout()      throws IOException, InterruptedException {    final int connectionTimeoutMs = 3 * 1000;     try (ServerSocket serverSock = new ServerSocket(0)) {      final CountDownLatch finLatch = new CountDownLatch(1);                        final Thread ldapServer = new Thread(new Runnable() {        @Override        public void run() {          try {            try (Socket ignored = serverSock.accept()) {              finLatch.await();            }          } catch (Exception e) {            e.printStackTrace();          }        }      });      ldapServer.start();      final LdapGroupsMapping mapping = new LdapGroupsMapping();      String ldapUrl = "ldap://localhost:" + serverSock.getLocalPort();      final Configuration conf = getBaseConf(ldapUrl, null);      conf.setInt(CONNECTION_TIMEOUT, connectionTimeoutMs);      mapping.setConf(conf);      try {        mapping.doGetGroups("hadoop", 1);        fail("The LDAP query should have timed out!");      } catch (NamingException ne) {        LOG.debug("Got the exception while LDAP querying: ", ne);        assertExceptionContains("LDAP response read timed out, timeout used",            ne);        assertExceptionContains("" + connectionTimeoutMs, ne);        assertFalse(ne.getMessage().contains("remaining name"));      } finally {        finLatch.countDown();      }      ldapServer.join();    }  }    @Test(timeout = 30000)  public void testLdapReadTimeout() throws IOException, InterruptedException {    final int readTimeoutMs = 4 * 1000;     try (ServerSocket serverSock = new ServerSocket(0)) {      final CountDownLatch finLatch = new CountDownLatch(1);                              final Thread ldapServer = new Thread(new Runnable() {        @Override        public void run() {          try {            try (Socket clientSock = serverSock.accept()) {              IOUtils.skipFully(clientSock.getInputStream(), 1);              clientSock.getOutputStream().write(AUTHENTICATE_SUCCESS_MSG);              finLatch.await();            }          } catch (Exception e) {            e.printStackTrace();          }        }      });      ldapServer.start();      final LdapGroupsMapping mapping = new LdapGroupsMapping();      String ldapUrl = "ldap://localhost:" + serverSock.getLocalPort();      final Configuration conf = getBaseConf(ldapUrl, null);      conf.setInt(READ_TIMEOUT, readTimeoutMs);      mapping.setConf(conf);      try {        mapping.doGetGroups("hadoop", 1);        fail("The LDAP query should have timed out!");      } catch (NamingException ne) {        LOG.debug("Got the exception while LDAP querying: ", ne);        assertExceptionContains("LDAP response read timed out, timeout used",            ne);        assertExceptionContains(""+ readTimeoutMs, ne);        assertExceptionContains("remaining name", ne);      } finally {        finLatch.countDown();      }      ldapServer.join();    }  }    @Test(timeout = 10000)  public void testSetConf() throws Exception {    Configuration conf = getBaseConf(TEST_LDAP_URL);    Configuration mockConf = Mockito.spy(conf);    when(mockConf.getPassword(anyString()))        .thenThrow(new IOException("injected IOException"));    LdapGroupsMapping groupsMapping = getGroupsMapping();    groupsMapping.setConf(mockConf);  }}
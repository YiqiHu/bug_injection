public class DecayRpcScheduler implements RpcScheduler,    DecayRpcSchedulerMXBean, MetricsSource {    public static final String IPC_SCHEDULER_DECAYSCHEDULER_PERIOD_KEY =      "decay-scheduler.period-ms";  public static final long IPC_SCHEDULER_DECAYSCHEDULER_PERIOD_DEFAULT =      5000;  @Deprecated  public static final String IPC_FCQ_DECAYSCHEDULER_PERIOD_KEY =    "faircallqueue.decay-scheduler.period-ms";    public static final String IPC_SCHEDULER_DECAYSCHEDULER_FACTOR_KEY =      "decay-scheduler.decay-factor";  public static final double IPC_SCHEDULER_DECAYSCHEDULER_FACTOR_DEFAULT =      0.5;  @Deprecated  public static final String IPC_FCQ_DECAYSCHEDULER_FACTOR_KEY =    "faircallqueue.decay-scheduler.decay-factor";   public static final String IPC_DECAYSCHEDULER_THRESHOLDS_KEY =      "decay-scheduler.thresholds";  @Deprecated  public static final String IPC_FCQ_DECAYSCHEDULER_THRESHOLDS_KEY =      "faircallqueue.decay-scheduler.thresholds";    public static final String IPC_DECAYSCHEDULER_SERVICE_USERS_KEY =      "decay-scheduler.service-users";      public static final String DECAYSCHEDULER_UNKNOWN_IDENTITY =      "IdentityProvider.Unknown";  public static final String      IPC_DECAYSCHEDULER_BACKOFF_RESPONSETIME_ENABLE_KEY =      "decay-scheduler.backoff.responsetime.enable";  public static final Boolean      IPC_DECAYSCHEDULER_BACKOFF_RESPONSETIME_ENABLE_DEFAULT = false;      public static final String      IPC_DECAYSCHEDULER_BACKOFF_RESPONSETIME_THRESHOLDS_KEY =      "decay-scheduler.backoff.responsetime.thresholds";      public static final String DECAYSCHEDULER_METRICS_TOP_USER_COUNT =      "decay-scheduler.metrics.top.user.count";  public static final int DECAYSCHEDULER_METRICS_TOP_USER_COUNT_DEFAULT = 10;  public static final Logger LOG =      LoggerFactory.getLogger(DecayRpcScheduler.class);  private static final ObjectWriter WRITER = new ObjectMapper().writer();        private final ConcurrentHashMap<Object, List<AtomicLong>> callCosts =      new ConcurrentHashMap<Object, List<AtomicLong>>();      private final AtomicLong totalDecayedCallCost = new AtomicLong();    private final AtomicLong totalRawCallCost = new AtomicLong();    private final AtomicLong totalServiceUserDecayedCallCost = new AtomicLong();    private final AtomicLong totalServiceUserRawCallCost = new AtomicLong();    private final AtomicLongArray responseTimeCountInCurrWindow;  private final AtomicLongArray responseTimeTotalInCurrWindow;    private final AtomicDoubleArray responseTimeAvgInLastWindow;  private final AtomicLongArray responseTimeCountInLastWindow;    private final DecayRpcSchedulerDetailedMetrics      decayRpcSchedulerDetailedMetrics;      private final AtomicReference<Map<Object, Integer>> scheduleCacheRef =    new AtomicReference<Map<Object, Integer>>();    private final long decayPeriodMillis;   private final double decayFactor;   private final int numLevels;  private final double[] thresholds;  private final IdentityProvider identityProvider;  private final boolean backOffByResponseTimeEnabled;  private final long[] backOffResponseTimeThresholds;  private final String namespace;  private final int topUsersCount;   private static final double PRECISION = 0.0001;  private MetricsProxy metricsProxy;  private final CostProvider costProvider;  private final Map<String, Integer> staticPriorities = new HashMap<>();  private Set<String> serviceUserNames;    public static class DecayTask extends TimerTask {    private WeakReference<DecayRpcScheduler> schedulerRef;    private Timer timer;    public DecayTask(DecayRpcScheduler scheduler, Timer timer) {      this.schedulerRef = new WeakReference<DecayRpcScheduler>(scheduler);      this.timer = timer;    }    @Override    public void run() {      DecayRpcScheduler sched = schedulerRef.get();      if (sched != null) {        sched.decayCurrentCosts();      } else {                        timer.cancel();        timer.purge();      }    }  }    public DecayRpcScheduler(int numLevels, String ns, Configuration conf) {    if(numLevels < 1) {      throw new IllegalArgumentException("Number of Priority Levels must be " +          "at least 1");    }    this.numLevels = numLevels;    this.namespace = ns;    this.decayFactor = parseDecayFactor(ns, conf);    this.decayPeriodMillis = parseDecayPeriodMillis(ns, conf);    this.identityProvider = this.parseIdentityProvider(ns, conf);    this.costProvider = this.parseCostProvider(ns, conf);    this.thresholds = parseThresholds(ns, conf, numLevels);    this.backOffByResponseTimeEnabled = parseBackOffByResponseTimeEnabled(ns,        conf);    this.backOffResponseTimeThresholds =        parseBackOffResponseTimeThreshold(ns, conf, numLevels);    this.serviceUserNames = this.parseServiceUserNames(ns, conf);        responseTimeTotalInCurrWindow = new AtomicLongArray(numLevels);    responseTimeCountInCurrWindow = new AtomicLongArray(numLevels);    responseTimeAvgInLastWindow = new AtomicDoubleArray(numLevels);    responseTimeCountInLastWindow = new AtomicLongArray(numLevels);    topUsersCount =        conf.getInt(DECAYSCHEDULER_METRICS_TOP_USER_COUNT,            DECAYSCHEDULER_METRICS_TOP_USER_COUNT_DEFAULT);    Preconditions.checkArgument(topUsersCount > 0,        "the number of top users for scheduler metrics must be at least 1");    decayRpcSchedulerDetailedMetrics =        DecayRpcSchedulerDetailedMetrics.create(ns);    decayRpcSchedulerDetailedMetrics.init(numLevels);        Timer timer = new Timer(true);    DecayTask task = new DecayTask(this, timer);    timer.scheduleAtFixedRate(task, decayPeriodMillis, decayPeriodMillis);    metricsProxy = MetricsProxy.getInstance(ns, numLevels, this);    recomputeScheduleCache();  }  private CostProvider parseCostProvider(String ns, Configuration conf) {    List<CostProvider> providers = conf.getInstances(        ns + "." + CommonConfigurationKeys.IPC_COST_PROVIDER_KEY,        CostProvider.class);    if (providers.size() < 1) {      LOG.info("CostProvider not specified, defaulting to DefaultCostProvider");      return new DefaultCostProvider();    } else if (providers.size() > 1) {      LOG.warn("Found multiple CostProviders; using: {}",          providers.get(0).getClass());    }    CostProvider provider = providers.get(0);     provider.init(ns, conf);    return provider;  }    private IdentityProvider parseIdentityProvider(String ns,      Configuration conf) {    List<IdentityProvider> providers = conf.getInstances(      ns + "." + CommonConfigurationKeys.IPC_IDENTITY_PROVIDER_KEY,      IdentityProvider.class);    if (providers.size() < 1) {      LOG.info("IdentityProvider not specified, " +        "defaulting to UserIdentityProvider");      return new UserIdentityProvider();    }    return providers.get(0);   }  private static double parseDecayFactor(String ns, Configuration conf) {    double factor = conf.getDouble(ns + "." +        IPC_FCQ_DECAYSCHEDULER_FACTOR_KEY, 0.0);    if (factor == 0.0) {      factor = conf.getDouble(ns + "." +          IPC_SCHEDULER_DECAYSCHEDULER_FACTOR_KEY,          IPC_SCHEDULER_DECAYSCHEDULER_FACTOR_DEFAULT);    } else if ((factor > 0.0) && (factor < 1)) {      LOG.warn(IPC_FCQ_DECAYSCHEDULER_FACTOR_KEY +          " is deprecated. Please use " +          IPC_SCHEDULER_DECAYSCHEDULER_FACTOR_KEY + ".");    }    if (factor <= 0 || factor >= 1) {      throw new IllegalArgumentException("Decay Factor " +        "must be between 0 and 1");    }    return factor;  }  private static long parseDecayPeriodMillis(String ns, Configuration conf) {    long period = conf.getLong(ns + "." +        IPC_FCQ_DECAYSCHEDULER_PERIOD_KEY,        0);    if (period == 0) {      period = conf.getLong(ns + "." +          IPC_SCHEDULER_DECAYSCHEDULER_PERIOD_KEY,          IPC_SCHEDULER_DECAYSCHEDULER_PERIOD_DEFAULT);    } else if (period > 0) {      LOG.warn((IPC_FCQ_DECAYSCHEDULER_PERIOD_KEY +          " is deprecated. Please use " +          IPC_SCHEDULER_DECAYSCHEDULER_PERIOD_KEY));    }    if (period <= 0) {      throw new IllegalArgumentException("Period millis must be >= 0");    }    return period;  }  private static double[] parseThresholds(String ns, Configuration conf,      int numLevels) {    int[] percentages = conf.getInts(ns + "." +        IPC_FCQ_DECAYSCHEDULER_THRESHOLDS_KEY);    if (percentages.length == 0) {      percentages = conf.getInts(ns + "." + IPC_DECAYSCHEDULER_THRESHOLDS_KEY);      if (percentages.length == 0) {        return getDefaultThresholds(numLevels);      }    } else {      LOG.warn(IPC_FCQ_DECAYSCHEDULER_THRESHOLDS_KEY +          " is deprecated. Please use " +          IPC_DECAYSCHEDULER_THRESHOLDS_KEY);    }    if (percentages.length != numLevels-1) {      throw new IllegalArgumentException("Number of thresholds should be " +        (numLevels-1) + ". Was: " + percentages.length);    }        double[] decimals = new double[percentages.length];    for (int i = 0; i < percentages.length; i++) {      decimals[i] = percentages[i] / 100.0;    }    return decimals;  }  private Set<String> parseServiceUserNames(String ns, Configuration conf) {    Collection<String> collection = conf.getStringCollection(        ns + "." + IPC_DECAYSCHEDULER_SERVICE_USERS_KEY);    return new HashSet<>(collection);  }    private static double[] getDefaultThresholds(int numLevels) {    double[] ret = new double[numLevels - 1];    double div = Math.pow(2, numLevels - 1);    for (int i = 0; i < ret.length; i++) {      ret[i] = Math.pow(2, i)/div;    }    return ret;  }  private static long[] parseBackOffResponseTimeThreshold(String ns,      Configuration conf, int numLevels) {    long[] responseTimeThresholds = conf.getTimeDurations(ns + "." +            IPC_DECAYSCHEDULER_BACKOFF_RESPONSETIME_THRESHOLDS_KEY,        TimeUnit.MILLISECONDS);        if (responseTimeThresholds.length == 0) {      return getDefaultBackOffResponseTimeThresholds(numLevels);    }        if (responseTimeThresholds.length != numLevels) {      throw new IllegalArgumentException(          "responseTimeThresholds must match with the number of priority " +          "levels");    }        for (long responseTimeThreshold: responseTimeThresholds) {      if (responseTimeThreshold <= 0) {        throw new IllegalArgumentException(            "responseTimeThreshold millis must be >= 0");      }    }    return responseTimeThresholds;  }    private static long[] getDefaultBackOffResponseTimeThresholds(int numLevels) {    long[] ret = new long[numLevels];    for (int i = 0; i < ret.length; i++) {      ret[i] = 10000*(i+1);    }    return ret;  }  private static Boolean parseBackOffByResponseTimeEnabled(String ns,      Configuration conf) {    return conf.getBoolean(ns + "." +        IPC_DECAYSCHEDULER_BACKOFF_RESPONSETIME_ENABLE_KEY,        IPC_DECAYSCHEDULER_BACKOFF_RESPONSETIME_ENABLE_DEFAULT);  }    private void decayCurrentCosts() {    LOG.debug("Start to decay current costs.");    try {      long totalDecayedCost = 0;      long totalRawCost = 0;      long totalServiceUserDecayedCost = 0;      long totalServiceUserRawCost = 0;      Iterator<Map.Entry<Object, List<AtomicLong>>> it =          callCosts.entrySet().iterator();      while (it.hasNext()) {        Map.Entry<Object, List<AtomicLong>> entry = it.next();        AtomicLong decayedCost = entry.getValue().get(0);        AtomicLong rawCost = entry.getValue().get(1);                long currentValue = decayedCost.get();        long nextValue = (long) (currentValue * decayFactor);        if (isServiceUser((String) entry.getKey())) {          totalServiceUserRawCost += rawCost.get();          totalServiceUserDecayedCost += nextValue;        } else {          totalRawCost += rawCost.get();          totalDecayedCost += nextValue;        }        decayedCost.set(nextValue);        LOG.debug(            "Decaying costs for the user: {}, its decayedCost: {}, rawCost: {}",            entry.getKey(), nextValue, rawCost.get());        if (nextValue == 0) {          LOG.debug("The decayed cost for the user {} is zero " +              "and being cleaned.", entry.getKey());                                        it.remove();        }      }            totalDecayedCallCost.set(totalDecayedCost);      totalRawCallCost.set(totalRawCost);      totalServiceUserDecayedCallCost.set(totalServiceUserDecayedCost);      totalServiceUserRawCallCost.set(totalServiceUserRawCost);      LOG.debug("After decaying the stored costs, totalDecayedCost: {}, "              + "totalRawCallCost: {}, totalServiceUserDecayedCost: {},"              + " totalServiceUserRawCost: {}.", totalDecayedCost, totalRawCost,          totalServiceUserDecayedCost, totalServiceUserRawCost);            recomputeScheduleCache();            updateAverageResponseTime(true);    } catch (Exception ex) {      LOG.error("decayCurrentCosts exception: " +          ExceptionUtils.getStackTrace(ex));      throw ex;    }  }    private void recomputeScheduleCache() {    Map<Object, Integer> nextCache = new HashMap<Object, Integer>();    for (Map.Entry<Object, List<AtomicLong>> entry : callCosts.entrySet()) {      Object id = entry.getKey();      AtomicLong value = entry.getValue().get(0);      long snapshot = value.get();      int computedLevel = computePriorityLevel(snapshot, id);      nextCache.put(id, computedLevel);    }        scheduleCacheRef.set(Collections.unmodifiableMap(nextCache));  }    private void addCost(Object identity, long costDelta) {        List<AtomicLong> cost = this.callCosts.get(identity);    if (cost == null) {                        cost = new ArrayList<AtomicLong>(2);      cost.add(new AtomicLong(0));      cost.add(new AtomicLong(0));            List<AtomicLong> otherCost = callCosts.putIfAbsent(identity, cost);      if (otherCost != null) {        cost = otherCost;      }    }        if (!isServiceUser((String) identity)) {      totalDecayedCallCost.getAndAdd(costDelta);      totalRawCallCost.getAndAdd(costDelta);    } else {      totalServiceUserDecayedCallCost.getAndAdd(costDelta);      totalServiceUserRawCallCost.getAndAdd(costDelta);    }                cost.get(1).getAndAdd(costDelta);    cost.get(0).getAndAdd(costDelta);  }    private int computePriorityLevel(long cost, Object identity) {        if (isServiceUser((String)identity)) {      return 0;    }    Integer staticPriority = staticPriorities.get(identity);    if (staticPriority != null) {      return staticPriority.intValue();    }    long totalCallSnapshot = totalDecayedCallCost.get();    double proportion = 0;    if (totalCallSnapshot > 0) {      proportion = (double) cost / totalCallSnapshot;    }        for(int i = (numLevels - 1); i > 0; i--) {      if (proportion >= this.thresholds[i - 1]) {        return i;       }    }        return 0;  }    private int cachedOrComputedPriorityLevel(Object identity) {        Map<Object, Integer> scheduleCache = scheduleCacheRef.get();    if (scheduleCache != null) {      Integer priority = scheduleCache.get(identity);      if (priority != null) {        LOG.debug("Cache priority for: {} with priority: {}", identity,            priority);        return priority;      }    }        List<AtomicLong> costList = callCosts.get(identity);    long currentCost = costList == null ? 0 : costList.get(0).get();    int priority = computePriorityLevel(currentCost, identity);    LOG.debug("compute priority for {} priority {}", identity, priority);    return priority;  }  private String getIdentity(Schedulable obj) {    String identity = this.identityProvider.makeIdentity(obj);    if (identity == null) {            identity = DECAYSCHEDULER_UNKNOWN_IDENTITY;    }    return identity;  }    @Override  public int getPriorityLevel(Schedulable obj) {        String identity = getIdentity(obj);            return Math.max(0, cachedOrComputedPriorityLevel(identity));  }  @VisibleForTesting  int getPriorityLevel(UserGroupInformation ugi) {    String identity = getIdentity(newSchedulable(ugi));        return cachedOrComputedPriorityLevel(identity);  }  @VisibleForTesting  void setPriorityLevel(UserGroupInformation ugi, int priority) {    String identity = getIdentity(newSchedulable(ugi));    priority = Math.min(numLevels - 1, priority);    LOG.info("Setting priority for user:" + identity + "=" + priority);    staticPriorities.put(identity, priority);  }    private static Schedulable newSchedulable(UserGroupInformation ugi) {    return new Schedulable() {      @Override      public UserGroupInformation getUserGroupInformation() {        return ugi;      }      @Override      public int getPriorityLevel() {        return 0;      }    };  }  private boolean isServiceUser(String userName) {    return this.serviceUserNames.contains(userName);  }  @Override  public boolean shouldBackOff(Schedulable obj) {    Boolean backOff = false;    if (backOffByResponseTimeEnabled) {      int priorityLevel = obj.getPriorityLevel();      if (LOG.isDebugEnabled()) {        double[] responseTimes = getAverageResponseTime();        LOG.debug("Current Caller: {}  Priority: {} ",            obj.getUserGroupInformation().getUserName(),            obj.getPriorityLevel());        for (int i = 0; i < numLevels; i++) {          LOG.debug("Queue: {} responseTime: {} backoffThreshold: {}", i,              responseTimes[i], backOffResponseTimeThresholds[i]);        }      }            for (int i = 0; i < priorityLevel + 1; i++) {        if (responseTimeAvgInLastWindow.get(i) >            backOffResponseTimeThresholds[i]) {          backOff = true;          break;        }      }    }    return backOff;  }  @Override  public void addResponseTime(String callName, Schedulable schedulable,      ProcessingDetails details) {    String user = identityProvider.makeIdentity(schedulable);    long processingCost = costProvider.getCost(details);    addCost(user, processingCost);    int priorityLevel = schedulable.getPriorityLevel();    long queueTime = details.get(Timing.QUEUE, RpcMetrics.TIMEUNIT);    long processingTime = details.get(Timing.PROCESSING, RpcMetrics.TIMEUNIT);    this.decayRpcSchedulerDetailedMetrics.addQueueTime(        priorityLevel, queueTime);    this.decayRpcSchedulerDetailedMetrics.addProcessingTime(        priorityLevel, processingTime);    responseTimeCountInCurrWindow.getAndIncrement(priorityLevel);    responseTimeTotalInCurrWindow.getAndAdd(priorityLevel,        queueTime+processingTime);    if (LOG.isDebugEnabled()) {      LOG.debug("addResponseTime for call: {}  priority: {} queueTime: {} " +          "processingTime: {} ", callName, priorityLevel, queueTime,          processingTime);    }  }    void updateAverageResponseTime(boolean enableDecay) {    for (int i = 0; i < numLevels; i++) {      double averageResponseTime = 0;      long totalResponseTime = responseTimeTotalInCurrWindow.get(i);      long responseTimeCount = responseTimeCountInCurrWindow.get(i);      if (responseTimeCount > 0) {        averageResponseTime = (double) totalResponseTime / responseTimeCount;      }      final double lastAvg = responseTimeAvgInLastWindow.get(i);      if (lastAvg > PRECISION || averageResponseTime > PRECISION) {        if (enableDecay) {          final double decayed = decayFactor * lastAvg + averageResponseTime;          responseTimeAvgInLastWindow.set(i, decayed);        } else {          responseTimeAvgInLastWindow.set(i, averageResponseTime);        }      } else {        responseTimeAvgInLastWindow.set(i, 0);      }      responseTimeCountInLastWindow.set(i, responseTimeCount);      if (LOG.isDebugEnabled()) {        LOG.debug("updateAverageResponseTime queue: {} Average: {} Count: {}",            i, averageResponseTime, responseTimeCount);      }            responseTimeTotalInCurrWindow.set(i, 0);      responseTimeCountInCurrWindow.set(i, 0);    }  }    @VisibleForTesting  double getDecayFactor() {    return decayFactor;  }  @VisibleForTesting  long getDecayPeriodMillis() {    return decayPeriodMillis;  }  @VisibleForTesting  double[] getThresholds() {    return thresholds;  }  @VisibleForTesting  Set<String> getServiceUserNames() {    return serviceUserNames;  }  @VisibleForTesting  void forceDecay() {    decayCurrentCosts();  }  @VisibleForTesting  Map<Object, Long> getCallCostSnapshot() {    HashMap<Object, Long> snapshot = new HashMap<Object, Long>();    for (Map.Entry<Object, List<AtomicLong>> entry : callCosts.entrySet()) {      snapshot.put(entry.getKey(), entry.getValue().get(0).get());    }    return Collections.unmodifiableMap(snapshot);  }  @VisibleForTesting  long getTotalCallSnapshot() {    return totalDecayedCallCost.get();  }    public static final class MetricsProxy implements DecayRpcSchedulerMXBean,      MetricsSource {        private static final HashMap<String, MetricsProxy> INSTANCES =      new HashMap<String, MetricsProxy>();        private WeakReference<DecayRpcScheduler> delegate;    private double[] averageResponseTimeDefault;    private long[] callCountInLastWindowDefault;    private ObjectName decayRpcSchedulerInfoBeanName;    private MetricsProxy(String namespace, int numLevels,        DecayRpcScheduler drs) {      averageResponseTimeDefault = new double[numLevels];      callCountInLastWindowDefault = new long[numLevels];      setDelegate(drs);      decayRpcSchedulerInfoBeanName =          MBeans.register(namespace, "DecayRpcScheduler", this);      this.registerMetrics2Source(namespace);    }    public static synchronized MetricsProxy getInstance(String namespace,        int numLevels, DecayRpcScheduler drs) {      MetricsProxy mp = INSTANCES.get(namespace);      if (mp == null) {                mp = new MetricsProxy(namespace, numLevels, drs);        INSTANCES.put(namespace, mp);      } else  if (drs != mp.delegate.get()){                mp.setDelegate(drs);      }      return mp;    }    public static synchronized void removeInstance(String namespace) {      MetricsProxy.INSTANCES.remove(namespace);    }    public void setDelegate(DecayRpcScheduler obj) {      this.delegate = new WeakReference<DecayRpcScheduler>(obj);    }    void registerMetrics2Source(String namespace) {      final String name = "DecayRpcSchedulerMetrics2." + namespace;      DefaultMetricsSystem.instance().register(name, name, this);    }    void unregisterSource(String namespace) {      final String name = "DecayRpcSchedulerMetrics2." + namespace;      DefaultMetricsSystem.instance().unregisterSource(name);      if (decayRpcSchedulerInfoBeanName != null) {        MBeans.unregister(decayRpcSchedulerInfoBeanName);      }    }    @Override    public String getSchedulingDecisionSummary() {      DecayRpcScheduler scheduler = delegate.get();      if (scheduler == null) {        return "No Active Scheduler";      } else {        return scheduler.getSchedulingDecisionSummary();      }    }    @Override    public String getCallVolumeSummary() {      DecayRpcScheduler scheduler = delegate.get();      if (scheduler == null) {        return "No Active Scheduler";      } else {        return scheduler.getCallVolumeSummary();      }    }    @Override    public int getUniqueIdentityCount() {      DecayRpcScheduler scheduler = delegate.get();      if (scheduler == null) {        return -1;      } else {        return scheduler.getUniqueIdentityCount();      }    }    @Override    public long getTotalCallVolume() {      DecayRpcScheduler scheduler = delegate.get();      if (scheduler == null) {        return -1;      } else {        return scheduler.getTotalCallVolume();      }    }    @Override    public double[] getAverageResponseTime() {      DecayRpcScheduler scheduler = delegate.get();      if (scheduler == null) {        return averageResponseTimeDefault;      } else {        return scheduler.getAverageResponseTime();      }    }    public long[] getResponseTimeCountInLastWindow() {      DecayRpcScheduler scheduler = delegate.get();      if (scheduler == null) {        return callCountInLastWindowDefault;      } else {        return scheduler.getResponseTimeCountInLastWindow();      }    }    @Override    public void getMetrics(MetricsCollector collector, boolean all) {      DecayRpcScheduler scheduler = delegate.get();      if (scheduler != null) {        scheduler.getMetrics(collector, all);      }    }  }  public int getUniqueIdentityCount() {    return callCosts.size();  }  public long getTotalCallVolume() {    return totalDecayedCallCost.get();  }  public long getTotalRawCallVolume() {    return totalRawCallCost.get();  }  public long getTotalServiceUserCallVolume() {    return totalServiceUserDecayedCallCost.get();  }  public long getTotalServiceUserRawCallVolume() {    return totalServiceUserRawCallCost.get();  }  public long[] getResponseTimeCountInLastWindow() {    long[] ret = new long[responseTimeCountInLastWindow.length()];    for (int i = 0; i < responseTimeCountInLastWindow.length(); i++) {      ret[i] = responseTimeCountInLastWindow.get(i);    }    return ret;  }  @Override  public double[] getAverageResponseTime() {    double[] ret = new double[responseTimeAvgInLastWindow.length()];    for (int i = 0; i < responseTimeAvgInLastWindow.length(); i++) {      ret[i] = responseTimeAvgInLastWindow.get(i);    }    return ret;  }  @Override  public void getMetrics(MetricsCollector collector, boolean all) {        try {      MetricsRecordBuilder rb = collector.addRecord(getClass().getName())          .setContext(namespace);      addDecayedCallVolume(rb);      addUniqueIdentityCount(rb);      addTopNCallerSummary(rb);      addAvgResponseTimePerPriority(rb);      addCallVolumePerPriority(rb);      addRawCallVolume(rb);      addServiceUserDecayedCallVolume(rb);      addServiceUserRawCallVolume(rb);    } catch (Exception e) {      LOG.warn("Exception thrown while metric collection. Exception : "          + e.getMessage());    }  }    private void addUniqueIdentityCount(MetricsRecordBuilder rb) {    rb.addCounter(Interns.info("UniqueCallers", "Total unique callers"),        getUniqueIdentityCount());  }    private void addDecayedCallVolume(MetricsRecordBuilder rb) {    rb.addCounter(Interns.info("DecayedCallVolume", "Decayed Total " +        "incoming Call Volume"), getTotalCallVolume());  }  private void addRawCallVolume(MetricsRecordBuilder rb) {    rb.addCounter(Interns.info("CallVolume", "Raw Total " +        "incoming Call Volume"), getTotalRawCallVolume());  }    private void addServiceUserDecayedCallVolume(MetricsRecordBuilder rb) {    rb.addCounter(Interns.info("ServiceUserDecayedCallVolume",        "Service-user Decayed Total incoming Call Volume"),        getTotalServiceUserCallVolume());  }    private void addServiceUserRawCallVolume(MetricsRecordBuilder rb) {    rb.addCounter(Interns.info("ServiceUserCallVolume",        "Service-user Raw Total incoming Call Volume"),        getTotalServiceUserRawCallVolume());  }    private void addCallVolumePerPriority(MetricsRecordBuilder rb) {    for (int i = 0; i < responseTimeCountInLastWindow.length(); i++) {      rb.addGauge(Interns.info("Priority." + i + ".CompletedCallVolume",          "Completed Call volume " +          "of priority "+ i), responseTimeCountInLastWindow.get(i));    }  }    private void addAvgResponseTimePerPriority(MetricsRecordBuilder rb) {    for (int i = 0; i < responseTimeAvgInLastWindow.length(); i++) {      rb.addGauge(Interns.info("Priority." + i + ".AvgResponseTime", "Average" +          " response time of priority " + i),          responseTimeAvgInLastWindow.get(i));    }  }    private void addTopNCallerSummary(MetricsRecordBuilder rb) {    TopN topNCallers = getTopCallers(topUsersCount);    Map<Object, Integer> decisions = scheduleCacheRef.get();    final int actualCallerCount = topNCallers.size();    for (int i = 0; i < actualCallerCount; i++) {      NameValuePair entry =  topNCallers.poll();      String topCaller = "Caller(" + entry.getName() + ")";      String topCallerVolume = topCaller + ".Volume";      String topCallerPriority = topCaller + ".Priority";      rb.addCounter(Interns.info(topCallerVolume, topCallerVolume),          entry.getValue());      Integer priority = decisions.get(entry.getName());      if (priority != null) {        rb.addCounter(Interns.info(topCallerPriority, topCallerPriority),            priority);      }    }  }    private TopN getTopCallers(int n) {    TopN topNCallers = new TopN(n);    Iterator<Map.Entry<Object, List<AtomicLong>>> it =        callCosts.entrySet().iterator();    while (it.hasNext()) {      Map.Entry<Object, List<AtomicLong>> entry = it.next();      String caller = entry.getKey().toString();      Long cost = entry.getValue().get(1).get();      if (cost > 0) {        topNCallers.offer(new NameValuePair(caller, cost));      }    }    return topNCallers;  }  public String getSchedulingDecisionSummary() {    Map<Object, Integer> decisions = scheduleCacheRef.get();    if (decisions == null) {      return "{}";    } else {      try {        return WRITER.writeValueAsString(decisions);      } catch (Exception e) {        return "Error: " + e.getMessage();      }    }  }  public String getCallVolumeSummary() {    try {      return WRITER.writeValueAsString(getDecayedCallCosts());    } catch (Exception e) {      return "Error: " + e.getMessage();    }  }  private Map<Object, Long> getDecayedCallCosts() {    Map<Object, Long> decayedCallCosts = new HashMap<>(callCosts.size());    Iterator<Map.Entry<Object, List<AtomicLong>>> it =        callCosts.entrySet().iterator();    while (it.hasNext()) {      Map.Entry<Object, List<AtomicLong>> entry = it.next();      Object user = entry.getKey();      Long decayedCost = entry.getValue().get(0).get();      if (decayedCost > 0) {        decayedCallCosts.put(user, decayedCost);      }    }    return decayedCallCosts;  }  @VisibleForTesting  public DecayRpcSchedulerDetailedMetrics      getDecayRpcSchedulerDetailedMetrics() {    return decayRpcSchedulerDetailedMetrics;  }  @Override  public void stop() {    metricsProxy.unregisterSource(namespace);    MetricsProxy.removeInstance(namespace);    decayRpcSchedulerDetailedMetrics.shutdown();  }}
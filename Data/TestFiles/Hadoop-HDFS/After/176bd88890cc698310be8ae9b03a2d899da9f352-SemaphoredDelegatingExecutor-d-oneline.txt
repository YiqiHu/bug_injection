public class SemaphoredDelegatingExecutor extends    ForwardingExecutorService {  private final Semaphore queueingPermits;  private final ExecutorService executorDelegatee;  private final int permitCount;  private final DurationTrackerFactory trackerFactory;    public SemaphoredDelegatingExecutor(      ExecutorService executorDelegatee,      int permitCount,      boolean fair,      DurationTrackerFactory trackerFactory) {    this.permitCount = permitCount;    queueingPermits = new Semaphore(permitCount, fair);    this.executorDelegatee = requireNonNull(executorDelegatee);    this.trackerFactory = trackerFactory != null        ? trackerFactory        : stubDurationTrackerFactory();  }    public SemaphoredDelegatingExecutor(      ExecutorService executorDelegatee,      int permitCount,      boolean fair) {    this(executorDelegatee, permitCount, fair, null);  }  @Override  protected ExecutorService delegate() {    return executorDelegatee;  }  @Override  public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)      throws InterruptedException {    throw new RuntimeException("Not implemented");  }  @Override  public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks,      long timeout, TimeUnit unit) throws InterruptedException {    throw new RuntimeException("Not implemented");  }  @Override  public <T> T invokeAny(Collection<? extends Callable<T>> tasks)      throws InterruptedException, ExecutionException {    throw new RuntimeException("Not implemented");  }  @Override  public <T> T invokeAny(Collection<? extends Callable<T>> tasks, long timeout,      TimeUnit unit)      throws InterruptedException, ExecutionException, TimeoutException {    throw new RuntimeException("Not implemented");  }  @Override  public <T> Future<T> submit(Callable<T> task) {    try (DurationTracker ignored =             trackerFactory.trackDuration(ACTION_EXECUTOR_ACQUIRED)) {      queueingPermits.acquire();    } catch (InterruptedException e) {      Thread.currentThread().interrupt();      return Futures.immediateFailedFuture(e);    }    return super.submit(new CallableWithPermitRelease<>(task));  }  @Override  public <T> Future<T> submit(Runnable task, T result) {    try (DurationTracker ignored =             trackerFactory.trackDuration(ACTION_EXECUTOR_ACQUIRED)) {      queueingPermits.acquire();    } catch (InterruptedException e) {      Thread.currentThread().interrupt();      return Futures.immediateFailedFuture(e);    }    return super.submit(new RunnableWithPermitRelease(task), result);  }  @Override  public Future<?> submit(Runnable task) {    try (DurationTracker ignored =             trackerFactory.trackDuration(ACTION_EXECUTOR_ACQUIRED)) {      queueingPermits.acquire();    } catch (InterruptedException e) {      Thread.currentThread().interrupt();      return Futures.immediateFailedFuture(e);    }    return super.submit(new RunnableWithPermitRelease(task));  }  @Override  public void execute(Runnable command) {    try (DurationTracker ignored =             trackerFactory.trackDuration(ACTION_EXECUTOR_ACQUIRED)) {      queueingPermits.acquire();    } catch (InterruptedException e) {      Thread.currentThread().interrupt();    }    super.execute(new RunnableWithPermitRelease(command));  }    public int getAvailablePermits() {    return queueingPermits.availablePermits();  }    public int getWaitingCount() {    return queueingPermits.getQueueLength();  }    public int getPermitCount() {    return permitCount;  }  @Override  public String toString() {    final StringBuilder sb = new StringBuilder(        "SemaphoredDelegatingExecutor{");    sb.append("permitCount=").append(getPermitCount())        .append(", available=").append(getAvailablePermits())        .append(", waiting=").append(getWaitingCount())        .append('}');    return sb.toString();  }    class RunnableWithPermitRelease implements Runnable {    private Runnable delegatee;    RunnableWithPermitRelease(Runnable delegatee) {      this.delegatee = delegatee;    }    @Override    public void run() {      try {        delegatee.run();      } finally {        queueingPermits.release();      }    }  }    class CallableWithPermitRelease<T> implements Callable<T> {    private Callable<T> delegatee;    CallableWithPermitRelease(Callable<T> delegatee) {      this.delegatee = delegatee;    }    @Override    public T call() throws Exception {      try {        return delegatee.call();      } finally {        queueingPermits.release();      }    }  }}
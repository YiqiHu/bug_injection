public abstract class AbstractS3GuardToolTestBase extends AbstractS3ATestBase {  protected static final String OWNER = "hdfs";  protected static final String DYNAMODB_TABLE = "ireland-team";  protected static final String S3A_THIS_BUCKET_DOES_NOT_EXIST      = "s3a://this-bucket-does-not-exist-00000000000";  private static final int PRUNE_MAX_AGE_SECS = 2;  private MetadataStore ms;  private S3AFileSystem rawFs;    private final List<S3GuardTool> toolsToClose = new ArrayList<>();    @Override  protected int getTestTimeoutMillis() {    return SCALE_TEST_TIMEOUT_SECONDS * 1000;  }    protected <T extends S3GuardTool> T toClose(T tool) {    toolsToClose.add(tool);    return tool;  }  protected static void expectResult(int expected,      String message,      S3GuardTool tool,      String... args) throws Exception {    assertEquals(message, expected, tool.run(args));  }    public static String expectSuccess(      String message,      S3GuardTool tool,      String... args) throws Exception {    ByteArrayOutputStream buf = new ByteArrayOutputStream();    exec(SUCCESS, message, tool, buf, args);    return buf.toString();  }    protected int run(Configuration conf, String... args)      throws Exception {    return S3GuardTool.run(conf, args);  }    protected int run(String... args) throws Exception {    return S3GuardTool.run(getConfiguration(), args);  }    protected void runToFailure(int status, String... args)      throws Exception {    ExitUtil.ExitException ex =        intercept(ExitUtil.ExitException.class,            () -> run(args));    if (ex.status != status) {      throw ex;    }  }  protected MetadataStore getMetadataStore() {    return ms;  }  @Override  public void setup() throws Exception {    super.setup();    S3ATestUtils.assumeS3GuardState(true, getConfiguration());    S3AFileSystem fs = getFileSystem();    ms = fs.getMetadataStore();        Configuration conf = new Configuration(getConfiguration());    clearBucketOption(conf, fs.getBucket(), S3_METADATA_STORE_IMPL);    conf.set(S3_METADATA_STORE_IMPL, S3GUARD_METASTORE_NULL);    URI fsUri = fs.getUri();    S3AUtils.setBucketOption(conf,fsUri.getHost(),        S3_METADATA_STORE_IMPL,        S3GUARD_METASTORE_NULL);    rawFs = (S3AFileSystem) FileSystem.newInstance(fsUri, conf);  }  @Override  public void teardown() throws Exception {    super.teardown();    toolsToClose.forEach(t -> IOUtils.cleanupWithLogger(LOG, t));    IOUtils.cleanupWithLogger(LOG, ms);    IOUtils.closeStream(rawFs);  }  protected void mkdirs(Path path, boolean onS3, boolean onMetadataStore)      throws IOException {    Preconditions.checkArgument(onS3 || onMetadataStore);        S3AFileSystem fs = onMetadataStore ? getFileSystem() : rawFs;    if (onS3) {      fs.mkdirs(path);    } else if (onMetadataStore) {      S3AFileStatus status = new S3AFileStatus(true, path, OWNER);      ms.put(new PathMetadata(status), null);    }  }  protected static void putFile(MetadataStore ms, S3AFileStatus f)      throws IOException {    assertNotNull(f);    try (BulkOperationState bulkWrite =             ms.initiateBulkWrite(                 BulkOperationState.OperationType.Put,                 f.getPath())) {      ms.put(new PathMetadata(f), bulkWrite);      Path parent = f.getPath().getParent();      while (parent != null) {        S3AFileStatus dir = new S3AFileStatus(false, parent, f.getOwner());        ms.put(new PathMetadata(dir), bulkWrite);        parent = parent.getParent();      }    }  }    protected void createFile(Path path, boolean onS3, boolean onMetadataStore)      throws IOException {    Preconditions.checkArgument(onS3 || onMetadataStore);        S3AFileSystem fs = onMetadataStore ? getFileSystem() : rawFs;    if (onS3) {      ContractTestUtils.touch(fs, path);    } else if (onMetadataStore) {      S3AFileStatus status = new S3AFileStatus(100L, System.currentTimeMillis(),          fs.makeQualified(path), 512L, "hdfs", null, null);      putFile(ms, status);    }  }    private void testPruneCommand(Configuration cmdConf, Path parent,      String...args) throws Exception {    Path keepParent = path("prune-cli-keep");    StopWatch timer = new StopWatch();    final S3AFileSystem fs = getFileSystem();    S3GuardTool.Prune cmd = toClose(new S3GuardTool.Prune(cmdConf));    cmd.setMetadataStore(ms);    try {      fs.mkdirs(parent);      fs.mkdirs(keepParent);      createFile(new Path(parent, "stale"), true, true);      createFile(new Path(keepParent, "stale-to-keep"), true, true);      Thread.sleep(TimeUnit.SECONDS.toMillis(PRUNE_MAX_AGE_SECS + 2));      timer.start();      createFile(new Path(parent, "fresh"), true, true);      assertMetastoreListingCount(parent, "Children count before pruning", 2);      exec(cmd, args);      long msecElapsed = timer.now(TimeUnit.MILLISECONDS);      if (msecElapsed >= PRUNE_MAX_AGE_SECS * 1000) {        LOG.warn("Skipping an assertion: Test running too slowly ({} msec)",            msecElapsed);      } else {        assertMetastoreListingCount(parent, "Pruned children count remaining",            1);      }      assertMetastoreListingCount(keepParent,          "This child should have been kept (prefix restriction).", 1);    } finally {      fs.delete(parent, true);      fs.delete(keepParent, true);      ms.prune(MetadataStore.PruneMode.ALL_BY_MODTIME,          Long.MAX_VALUE,          fs.pathToKey(parent));      ms.prune(MetadataStore.PruneMode.ALL_BY_MODTIME,          Long.MAX_VALUE,          fs.pathToKey(keepParent));            cmd.setMetadataStore(new NullMetadataStore());    }  }  private void assertMetastoreListingCount(Path parent,      String message,      int expected) throws IOException {    Collection<PathMetadata> listing = ms.listChildren(parent).getListing();    assertEquals(message +" [" + StringUtils.join(", ", listing) + "]",        expected, listing.size());  }  @Test  public void testPruneCommandCLI() throws Exception {    Path testPath = path("testPruneCommandCLI");    testPruneCommand(getFileSystem().getConf(), testPath,        "prune", "-seconds", String.valueOf(PRUNE_MAX_AGE_SECS),        testPath.toString());  }  @Test  public void testPruneCommandTombstones() throws Exception {    Path testPath = path("testPruneCommandTombstones");    getFileSystem().mkdirs(testPath);    getFileSystem().delete(testPath, true);    S3GuardTool.Prune cmd = toClose(        new S3GuardTool.Prune(getFileSystem().getConf()));    cmd.setMetadataStore(ms);    try {      exec(cmd,          "prune", "-" + S3GuardTool.Prune.TOMBSTONE,          "-seconds", "0",          testPath.toString());      assertNotNull("Command did not create a filesystem",          cmd.getFilesystem());    } finally {            cmd.setMetadataStore(new NullMetadataStore());    }  }    @Test  public void testMaybeInitFilesystem() throws Exception {    Path testPath = path("maybeInitFilesystem");    try (S3GuardTool.Prune cmd =             new S3GuardTool.Prune(getFileSystem().getConf())) {      cmd.maybeInitFilesystem(Collections.singletonList(testPath.toString()));      assertNotNull("Command did not create a filesystem",          cmd.getFilesystem());    }  }    @Test  public void testMaybeInitFilesystemNoPath() throws Exception {    try (S3GuardTool.Prune cmd = new S3GuardTool.Prune(        getFileSystem().getConf())) {      cmd.maybeInitFilesystem(Collections.emptyList());      assertNull("Command should not have created a filesystem",          cmd.getFilesystem());    }  }  @Test  public void testPruneCommandNoPath() throws Exception {    runToFailure(INVALID_ARGUMENT,        S3GuardTool.Prune.NAME,        "-" + S3GuardTool.Prune.TOMBSTONE,        "-seconds", "0");  }  @Test  public void testPruneCommandConf() throws Exception {    getConfiguration().setLong(Constants.S3GUARD_CLI_PRUNE_AGE,        TimeUnit.SECONDS.toMillis(PRUNE_MAX_AGE_SECS));    Path testPath = path("testPruneCommandConf");    testPruneCommand(getConfiguration(), testPath,        "prune", testPath.toString());  }  @Test  public void testSetCapacityFailFastOnReadWriteOfZero() throws Exception{    Configuration conf = getConfiguration();    String bucket = getFileSystem().getBucket();    conf.set(S3GUARD_DDB_TABLE_NAME_KEY, getFileSystem().getBucket());    S3GuardTool.SetCapacity cmdR = toClose(new S3GuardTool.SetCapacity(conf));    String[] argsR =        new String[]{cmdR.getName(), "-read", "0", "s3a://" + bucket};    intercept(IllegalArgumentException.class,        S3GuardTool.SetCapacity.READ_CAP_INVALID, () -> cmdR.run(argsR));    S3GuardTool.SetCapacity cmdW = toClose(new S3GuardTool.SetCapacity(conf));    String[] argsW =        new String[]{cmdW.getName(), "-write", "0", "s3a://" + bucket};    intercept(IllegalArgumentException.class,        S3GuardTool.SetCapacity.WRITE_CAP_INVALID, () -> cmdW.run(argsW));  }  @Test  public void testBucketInfoUnguarded() throws Exception {    final Configuration conf = getConfiguration();    URI fsUri = getFileSystem().getUri();    conf.set(S3GUARD_DDB_TABLE_CREATE_KEY, Boolean.FALSE.toString());    String bucket = fsUri.getHost();    clearBucketOption(conf, bucket,        S3GUARD_DDB_TABLE_CREATE_KEY);    clearBucketOption(conf, bucket, S3_METADATA_STORE_IMPL);    clearBucketOption(conf, bucket, S3GUARD_DDB_TABLE_NAME_KEY);    conf.set(S3_METADATA_STORE_IMPL, S3GUARD_METASTORE_NULL);    conf.set(S3GUARD_DDB_TABLE_NAME_KEY,        "testBucketInfoUnguarded-" + UUID.randomUUID());            S3GuardTool.BucketInfo infocmd = toClose(new S3GuardTool.BucketInfo(conf));    String info = exec(infocmd, S3GuardTool.BucketInfo.NAME,        "-" + S3GuardTool.BucketInfo.UNGUARDED_FLAG,        fsUri.toString());    assertTrue("Output should contain information about S3A client " + info,        info.contains("S3A Client"));  }  @Test  public void testSetCapacityFailFastIfNotGuarded() throws Exception{    Configuration conf = getConfiguration();    bindToNonexistentTable(conf);    String bucket = rawFs.getBucket();    clearBucketOption(conf, bucket, S3_METADATA_STORE_IMPL);    clearBucketOption(conf, bucket, S3GUARD_DDB_TABLE_NAME_KEY);    clearBucketOption(conf, bucket, S3GUARD_DDB_TABLE_CREATE_KEY);    conf.set(S3_METADATA_STORE_IMPL, S3GUARD_METASTORE_NULL);    S3GuardTool.SetCapacity cmdR = toClose(new S3GuardTool.SetCapacity(conf));    String[] argsR = new String[]{        cmdR.getName(),        "s3a://" + getFileSystem().getBucket()    };    intercept(IllegalStateException.class, "unguarded",        () -> cmdR.run(argsR));  }    private void bindToNonexistentTable(final Configuration conf) {    conf.set(S3GUARD_DDB_TABLE_NAME_KEY, UUID.randomUUID().toString());    conf.unset(S3GUARD_DDB_REGION_KEY);    conf.setBoolean(S3GUARD_DDB_TABLE_CREATE_KEY, false);  }    private S3GuardTool makeBindedTool(Class<? extends S3GuardTool> tool)      throws Exception {    Configuration conf = getConfiguration();            bindToNonexistentTable(conf);    return tool.getDeclaredConstructor(Configuration.class).newInstance(conf);  }  @Test  public void testToolsNoBucket() throws Throwable {    List<Class<? extends S3GuardTool>> tools =        Arrays.asList(S3GuardTool.Destroy.class, S3GuardTool.BucketInfo.class,            S3GuardTool.Diff.class, S3GuardTool.Import.class,            S3GuardTool.Prune.class, S3GuardTool.SetCapacity.class,            S3GuardTool.Uploads.class,            S3GuardTool.Authoritative.class);    for (Class<? extends S3GuardTool> tool : tools) {      S3GuardTool cmdR = makeBindedTool(tool);      describe("Calling " + cmdR.getName() + " on a bucket that does not exist.");      String[] argsR = new String[]{          cmdR.getName(),          S3A_THIS_BUCKET_DOES_NOT_EXIST      };      intercept(UnknownStoreException.class,          () -> cmdR.run(argsR));    }  }  @Test  public void testToolsNoArgsForBucketAndDDBTable() throws Throwable {    List<Class<? extends S3GuardTool>> tools =        Arrays.asList(S3GuardTool.Destroy.class, S3GuardTool.Init.class);    for (Class<? extends S3GuardTool> tool : tools) {      S3GuardTool cmdR = makeBindedTool(tool);      describe("Calling " + cmdR.getName() + " without any arguments.");      intercept(ExitUtil.ExitException.class,          "S3 bucket url or DDB table name have to be provided explicitly",          () -> cmdR.run(new String[]{tool.getName()}));    }  }  @Test  public void testToolsNoArgsForBucket() throws Throwable {    List<Class<? extends S3GuardTool>> tools =        Arrays.asList(S3GuardTool.BucketInfo.class, S3GuardTool.Diff.class,            S3GuardTool.Import.class, S3GuardTool.Prune.class,            S3GuardTool.SetCapacity.class, S3GuardTool.Uploads.class,            S3GuardTool.Authoritative.class);    for (Class<? extends S3GuardTool> tool : tools) {      S3GuardTool cmdR = makeBindedTool(tool);      describe("Calling " + cmdR.getName() + " without any arguments.");      assertExitCode(INVALID_ARGUMENT,          intercept(ExitUtil.ExitException.class,              () -> cmdR.run(new String[]{tool.getName()})));    }  }  @Test  public void testProbeForMagic() throws Throwable {    S3AFileSystem fs = getFileSystem();    String name = fs.getUri().toString();    S3GuardTool.BucketInfo cmd = new S3GuardTool.BucketInfo(        getConfiguration());    if (fs.hasPathCapability(fs.getWorkingDirectory(),        CommitConstants.STORE_CAPABILITY_MAGIC_COMMITTER)) {            exec(cmd, S3GuardTool.BucketInfo.MAGIC_FLAG, name);    } else {            assertExitCode(E_BAD_STATE,          intercept(ExitUtil.ExitException.class,              () -> exec(cmd, S3GuardTool.BucketInfo.MAGIC_FLAG, name)));    }  }    protected void assertExitCode(final int expectedErrorCode,      final ExitUtil.ExitException e) {    if (e.getExitCode() != expectedErrorCode) {      throw new AssertionError("Expected error code " +          expectedErrorCode + " in " + e, e);    }  }  @Test  public void testDestroyFailsIfNoBucketNameOrDDBTableSet()      throws Exception {    intercept(ExitUtil.ExitException.class,        () -> run(S3GuardTool.Destroy.NAME));  }  @Test  public void testInitFailsIfNoBucketNameOrDDBTableSet() throws Exception {    intercept(ExitUtil.ExitException.class,        () -> run(S3GuardTool.Init.NAME));  }  @Test  public void  testDiffCommand() throws Exception {    S3AFileSystem fs = getFileSystem();    ms = getMetadataStore();    Set<Path> filesOnS3 = new HashSet<>();     Set<Path> filesOnMS = new HashSet<>();     Path testPath = path("test-diff");        fs.delete(testPath, true);    rawFs.delete(testPath, true);    mkdirs(testPath, true, true);    Path msOnlyPath = new Path(testPath, "ms_only");    mkdirs(msOnlyPath, false, true);    filesOnMS.add(msOnlyPath);    for (int i = 0; i < 5; i++) {      Path file = new Path(msOnlyPath, String.format("file-%d", i));      createFile(file, false, true);      filesOnMS.add(file);    }    Path s3OnlyPath = new Path(testPath, "s3_only");    mkdirs(s3OnlyPath, true, false);    filesOnS3.add(s3OnlyPath);    for (int i = 0; i < 5; i++) {      Path file = new Path(s3OnlyPath, String.format("file-%d", i));      createFile(file, true, false);      filesOnS3.add(file);    }    ByteArrayOutputStream buf = new ByteArrayOutputStream();    S3GuardTool.Diff cmd = toClose(new S3GuardTool.Diff(fs.getConf()));    cmd.setStore(ms);    String table = "dynamo://" + getTestTableName(DYNAMODB_TABLE);    exec(0, "", cmd, buf, "diff", "-meta", table, testPath.toString());    Set<Path> actualOnS3 = new HashSet<>();    Set<Path> actualOnMS = new HashSet<>();    boolean duplicates = false;    try (BufferedReader reader =        new BufferedReader(new InputStreamReader(            new ByteArrayInputStream(buf.toByteArray())))) {      String line;      while ((line = reader.readLine()) != null) {        String[] fields = line.split("\\s");        assertEquals("[" + line + "] does not have enough fields",            4, fields.length);        String where = fields[0];        Path path = new Path(fields[3]);        if (S3GuardTool.Diff.S3_PREFIX.equals(where)) {          duplicates = duplicates || actualOnS3.contains(path);          actualOnS3.add(path);        } else if (S3GuardTool.Diff.MS_PREFIX.equals(where)) {          duplicates = duplicates || actualOnMS.contains(path);          actualOnMS.add(path);        } else {          fail("Unknown prefix: " + where);        }      }    }    String actualOut = buf.toString();    assertEquals("Mismatched metadata store outputs: " + actualOut,        filesOnMS, actualOnMS);    assertEquals("Mismatched s3 outputs: " + actualOut, filesOnS3, actualOnS3);    assertFalse("Diff contained duplicates", duplicates);  }}
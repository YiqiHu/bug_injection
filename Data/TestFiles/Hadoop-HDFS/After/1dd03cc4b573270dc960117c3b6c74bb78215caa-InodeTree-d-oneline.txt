abstract class InodeTree<T> {  private static final Logger LOGGER =      LoggerFactory.getLogger(InodeTree.class.getName());  enum ResultKind {    INTERNAL_DIR,    EXTERNAL_DIR  }  static final Path SlashPath = new Path("/");    private final INode<T> root;    private INodeLink<T> rootFallbackLink;    private final String homedirPrefix;  private List<MountPoint<T>> mountPoints = new ArrayList<MountPoint<T>>();  private List<RegexMountPoint<T>> regexMountPointList =      new ArrayList<RegexMountPoint<T>>();  static class MountPoint<T> {    String src;    INodeLink<T> target;    MountPoint(String srcPath, INodeLink<T> mountLink) {      src = srcPath;      target = mountLink;    }  }    static String[] breakIntoPathComponents(final String path) {    return path == null ? null : path.split(Path.SEPARATOR);  }    abstract static class INode<T> {    final String fullPath;     public INode(String pathToNode, UserGroupInformation aUgi) {      fullPath = pathToNode;    }                    abstract boolean isInternalDir();            boolean isLink() {      return !isInternalDir();    }  }    static class INodeDir<T> extends INode<T> {    private final Map<String, INode<T>> children = new HashMap<>();    private T internalDirFs = null;     private boolean isRoot = false;    private INodeLink<T> fallbackLink = null;    INodeDir(final String pathToNode, final UserGroupInformation aUgi) {      super(pathToNode, aUgi);    }    @Override    boolean isInternalDir() {      return true;    }    T getInternalDirFs() {      return internalDirFs;    }    void setInternalDirFs(T internalDirFs) {      this.internalDirFs = internalDirFs;    }    void setRoot(boolean root) {      isRoot = root;    }    boolean isRoot() {      return isRoot;    }    INodeLink<T> getFallbackLink() {      return fallbackLink;    }    void addFallbackLink(INodeLink<T> link) throws IOException {      if (!isRoot) {        throw new IOException("Fallback link can only be added for root");      }      this.fallbackLink = link;    }    Map<String, INode<T>> getChildren() {      return Collections.unmodifiableMap(children);    }    INode<T> resolveInternal(final String pathComponent) {      return children.get(pathComponent);    }    INodeDir<T> addDir(final String pathComponent,        final UserGroupInformation aUgi) throws FileAlreadyExistsException {      if (children.containsKey(pathComponent)) {        throw new FileAlreadyExistsException();      }      final INodeDir<T> newDir = new INodeDir<T>(fullPath +          (isRoot() ? "" : "/") + pathComponent, aUgi);      children.put(pathComponent, newDir);      return newDir;    }    void addLink(final String pathComponent, final INodeLink<T> link)        throws FileAlreadyExistsException {      if (children.containsKey(pathComponent)) {        throw new FileAlreadyExistsException();      }      children.put(pathComponent, link);    }  }    enum LinkType {        SINGLE,        SINGLE_FALLBACK,        MERGE,        MERGE_SLASH,        NFLY,        REGEX;  }    static class INodeLink<T> extends INode<T> {    final URI[] targetDirLinkList;    private T targetFileSystem;           private Function<URI, T> fileSystemInitMethod;    private final Object lock = new Object();        INodeLink(final String pathToNode, final UserGroupInformation aUgi,        final T targetMergeFs, final URI[] aTargetDirLinkList) {      super(pathToNode, aUgi);      targetFileSystem = targetMergeFs;      targetDirLinkList = aTargetDirLinkList;    }        INodeLink(final String pathToNode, final UserGroupInformation aUgi,        Function<URI, T> createFileSystemMethod,        final URI aTargetDirLink) {      super(pathToNode, aUgi);      targetFileSystem = null;      targetDirLinkList = new URI[1];      targetDirLinkList[0] = aTargetDirLink;      this.fileSystemInitMethod = createFileSystemMethod;    }        Path getTargetLink() {      StringBuilder result = new StringBuilder(targetDirLinkList[0].toString());            for (int i = 1; i < targetDirLinkList.length; ++i) {        result.append(',').append(targetDirLinkList[i].toString());      }      return new Path(result.toString());    }    @Override    boolean isInternalDir() {      return false;    }        public T getTargetFileSystem() throws IOException {      if (targetFileSystem != null) {        return targetFileSystem;      }                  if (targetDirLinkList.length == 1) {        synchronized (lock) {          if (targetFileSystem != null) {            return targetFileSystem;          }          targetFileSystem = fileSystemInitMethod.apply(targetDirLinkList[0]);          if (targetFileSystem == null) {            throw new IOException(                "Could not initialize target File System for URI : " +                    targetDirLinkList[0]);          }        }      }      return targetFileSystem;    }  }  private void createLink(final String src, final String target,      final LinkType linkType, final String settings,      final UserGroupInformation aUgi,      final Configuration config)      throws URISyntaxException, IOException,      FileAlreadyExistsException, UnsupportedFileSystemException {        final Path srcPath = new Path(src);    if (!srcPath.isAbsoluteAndSchemeAuthorityNull()) {      throw new IOException("ViewFs: Non absolute mount name in config:" + src);    }    final String[] srcPaths = breakIntoPathComponents(src);            Preconditions.checkState(root.isInternalDir());    INodeDir<T> curInode = getRootDir();    int i;        for (i = 1; i < srcPaths.length - 1; i++) {      final String iPath = srcPaths[i];      INode<T> nextInode = curInode.resolveInternal(iPath);      if (nextInode == null) {        INodeDir<T> newDir = curInode.addDir(iPath, aUgi);        newDir.setInternalDirFs(getTargetFileSystem(newDir));        nextInode = newDir;      }      if (nextInode.isLink()) {                throw new FileAlreadyExistsException("Path " + nextInode.fullPath +            " already exists as link");      } else {        assert(nextInode.isInternalDir());        curInode = (INodeDir<T>) nextInode;      }    }            String iPath = srcPaths[i];    if (curInode.resolveInternal(iPath) != null) {            StringBuilder strB = new StringBuilder(srcPaths[0]);      for (int j = 1; j <= i; ++j) {        strB.append('/').append(srcPaths[j]);      }      throw new FileAlreadyExistsException("Path " + strB +          " already exists as dir; cannot create link here");    }    final INodeLink<T> newLink;    final String fullPath = curInode.fullPath + (curInode == root ? "" : "/")        + iPath;    switch (linkType) {    case SINGLE:      newLink = new INodeLink<T>(fullPath, aUgi,          initAndGetTargetFs(), new URI(target));      break;    case SINGLE_FALLBACK:    case MERGE_SLASH:                  throw new IllegalArgumentException("Unexpected linkType: " + linkType);    case MERGE:    case NFLY:      final URI[] targetUris = StringUtils.stringToURI(          StringUtils.getStrings(target));      newLink = new INodeLink<T>(fullPath, aUgi,            getTargetFileSystem(settings, targetUris), targetUris);      break;    default:      throw new IllegalArgumentException(linkType + ": Infeasible linkType");    }    curInode.addLink(iPath, newLink);    mountPoints.add(new MountPoint<T>(src, newLink));  }    protected abstract Function<URI, T> initAndGetTargetFs();  protected abstract T getTargetFileSystem(INodeDir<T> dir)      throws URISyntaxException, IOException;  protected abstract T getTargetFileSystem(String settings, URI[] mergeFsURIs)      throws UnsupportedFileSystemException, URISyntaxException, IOException;  private INodeDir<T> getRootDir() {    Preconditions.checkState(root.isInternalDir());    return (INodeDir<T>)root;  }  private INodeLink<T> getRootLink() {    Preconditions.checkState(root.isLink());    return (INodeLink<T>)root;  }  private boolean hasFallbackLink() {    return rootFallbackLink != null;  }    protected boolean isRootInternalDir() {    return root.isInternalDir();  }  protected INodeLink<T> getRootFallbackLink() {    Preconditions.checkState(root.isInternalDir());    return rootFallbackLink;  }    private static class LinkEntry {    private final String src;    private final String target;    private final LinkType linkType;    private final String settings;    private final UserGroupInformation ugi;    private final Configuration config;    LinkEntry(String src, String target, LinkType linkType, String settings,        UserGroupInformation ugi, Configuration config) {      this.src = src;      this.target = target;      this.linkType = linkType;      this.settings = settings;      this.ugi = ugi;      this.config = config;    }    String getSrc() {      return src;    }    String getTarget() {      return target;    }    LinkType getLinkType() {      return linkType;    }    boolean isLinkType(LinkType type) {      return this.linkType == type;    }    String getSettings() {      return settings;    }    UserGroupInformation getUgi() {      return ugi;    }    Configuration getConfig() {      return config;    }  }    protected InodeTree(final Configuration config, final String viewName,      final URI theUri, boolean initingUriAsFallbackOnNoMounts)      throws UnsupportedFileSystemException, URISyntaxException,      FileAlreadyExistsException, IOException {    String mountTableName = viewName;    if (mountTableName == null) {      mountTableName = ConfigUtil.getDefaultMountTableName(config);    }    homedirPrefix = ConfigUtil.getHomeDirValue(config, mountTableName);    boolean isMergeSlashConfigured = false;    String mergeSlashTarget = null;    List<LinkEntry> linkEntries = new LinkedList<>();    final String mountTablePrefix =        Constants.CONFIG_VIEWFS_PREFIX + "." + mountTableName + ".";    final String linkPrefix = Constants.CONFIG_VIEWFS_LINK + ".";    final String linkFallbackPrefix = Constants.CONFIG_VIEWFS_LINK_FALLBACK;    final String linkMergePrefix = Constants.CONFIG_VIEWFS_LINK_MERGE + ".";    final String linkMergeSlashPrefix =        Constants.CONFIG_VIEWFS_LINK_MERGE_SLASH;    boolean gotMountTableEntry = false;    final UserGroupInformation ugi = UserGroupInformation.getCurrentUser();    for (Entry<String, String> si : config) {      final String key = si.getKey();      if (!key.startsWith(mountTablePrefix)) {        continue;      }      gotMountTableEntry = true;      LinkType linkType;      String src = key.substring(mountTablePrefix.length());      String settings = null;      if (src.startsWith(linkPrefix)) {        src = src.substring(linkPrefix.length());        if (src.equals(SlashPath.toString())) {          throw new UnsupportedFileSystemException("Unexpected mount table "              + "link entry '" + key + "'. Use "              + Constants.CONFIG_VIEWFS_LINK_MERGE_SLASH  + " instead!");        }        linkType = LinkType.SINGLE;      } else if (src.startsWith(linkFallbackPrefix)) {        checkMntEntryKeyEqualsTarget(src, linkFallbackPrefix);        linkType = LinkType.SINGLE_FALLBACK;      } else if (src.startsWith(linkMergePrefix)) {         src = src.substring(linkMergePrefix.length());        linkType = LinkType.MERGE;      } else if (src.startsWith(linkMergeSlashPrefix)) {                        checkMntEntryKeyEqualsTarget(src, linkMergeSlashPrefix);        linkType = LinkType.MERGE_SLASH;      } else if (src.startsWith(Constants.CONFIG_VIEWFS_LINK_NFLY)) {                src = src.substring(Constants.CONFIG_VIEWFS_LINK_NFLY.length() + 1);                settings = src.substring(0, src.indexOf('.'));                        src = src.substring(settings.length() + 1);                linkType = LinkType.NFLY;      } else if (src.startsWith(Constants.CONFIG_VIEWFS_LINK_REGEX)) {        linkEntries.add(            buildLinkRegexEntry(config, ugi, src, si.getValue()));        continue;      } else if (src.startsWith(Constants.CONFIG_VIEWFS_HOMEDIR)) {                continue;      } else {        throw new IOException("ViewFs: Cannot initialize: Invalid entry in " +            "Mount table in config: " + src);      }      final String target = si.getValue();      if (linkType != LinkType.MERGE_SLASH) {        if (isMergeSlashConfigured) {          throw new IOException("Mount table " + mountTableName              + " has already been configured with a merge slash link. "              + "A regular link should not be added.");        }        linkEntries.add(            new LinkEntry(src, target, linkType, settings, ugi, config));      } else {        if (!linkEntries.isEmpty()) {          throw new IOException("Mount table " + mountTableName              + " has already been configured with regular links. "              + "A merge slash link should not be configured.");        }        if (isMergeSlashConfigured) {          throw new IOException("Mount table " + mountTableName              + " has already been configured with a merge slash link. "              + "Multiple merge slash links for the same mount table is "              + "not allowed.");        }        isMergeSlashConfigured = true;        mergeSlashTarget = target;      }    }     if (isMergeSlashConfigured) {      Preconditions.checkNotNull(mergeSlashTarget);      root = new INodeLink<T>(mountTableName, ugi,          initAndGetTargetFs(),          new URI(mergeSlashTarget));      mountPoints.add(new MountPoint<T>("/", (INodeLink<T>) root));      rootFallbackLink = null;    } else {      root = new INodeDir<T>("/", UserGroupInformation.getCurrentUser());      getRootDir().setInternalDirFs(getTargetFileSystem(getRootDir()));      getRootDir().setRoot(true);      INodeLink<T> fallbackLink = null;      for (LinkEntry le : linkEntries) {        switch (le.getLinkType()) {        case SINGLE_FALLBACK:          if (fallbackLink != null) {            throw new IOException("Mount table " + mountTableName                + " has already been configured with a link fallback. "                + "Multiple fallback links for the same mount table is "                + "not allowed.");          }          fallbackLink = new INodeLink<T>(mountTableName, ugi,              initAndGetTargetFs(), new URI(le.getTarget()));          continue;        case REGEX:          addRegexMountEntry(le);          continue;        default:          createLink(le.getSrc(), le.getTarget(), le.getLinkType(),              le.getSettings(), le.getUgi(), le.getConfig());        }      }      rootFallbackLink = fallbackLink;      getRootDir().addFallbackLink(rootFallbackLink);    }    if (!gotMountTableEntry) {      if (!initingUriAsFallbackOnNoMounts) {        throw new IOException(new StringBuilder(            "ViewFs: Cannot initialize: Empty Mount table in config for ")            .append(theUri.getScheme()).append("://").append(mountTableName)            .append("/").toString());      }      FileSystem.LOG          .info("Empty mount table detected for {} and considering itself "              + "as a linkFallback.", theUri);      rootFallbackLink = new INodeLink<T>(mountTableName, ugi,          initAndGetTargetFs(), theUri);      getRootDir().addFallbackLink(rootFallbackLink);    }  }  private void checkMntEntryKeyEqualsTarget(      String mntEntryKey, String targetMntEntryKey) throws IOException {    if (!mntEntryKey.equals(targetMntEntryKey)) {      throw new IOException("ViewFs: Mount points initialization error." +          " Invalid " + targetMntEntryKey +          " entry in config: " + mntEntryKey);    }  }  private void addRegexMountEntry(LinkEntry le) throws IOException {    LOGGER.info("Add regex mount point:" + le.getSrc()        + ", target:" + le.getTarget()        + ", interceptor settings:" + le.getSettings());    RegexMountPoint regexMountPoint =        new RegexMountPoint<T>(            this, le.getSrc(), le.getTarget(), le.getSettings());    regexMountPoint.initialize();    regexMountPointList.add(regexMountPoint);  }  private LinkEntry buildLinkRegexEntry(      Configuration config, UserGroupInformation ugi,      String mntEntryStrippedKey, String mntEntryValue) {    String linkKeyPath = null;    String settings = null;    final String linkRegexPrefix = Constants.CONFIG_VIEWFS_LINK_REGEX + ".";        String settingsAndLinkKeyPath =        mntEntryStrippedKey.substring(linkRegexPrefix.length());    int settingLinkKeySepIndex = settingsAndLinkKeyPath        .indexOf(RegexMountPoint.SETTING_SRCREGEX_SEP);    if (settingLinkKeySepIndex == -1) {            linkKeyPath = settingsAndLinkKeyPath;      settings = null;    } else {                  settings =          settingsAndLinkKeyPath.substring(0, settingLinkKeySepIndex);            linkKeyPath = settingsAndLinkKeyPath.substring(          settings.length() + RegexMountPoint.SETTING_SRCREGEX_SEP              .length());    }    return new LinkEntry(        linkKeyPath, mntEntryValue, LinkType.REGEX, settings, ugi, config);  }    static class ResolveResult<T> {    final ResultKind kind;    final T targetFileSystem;    final String resolvedPath;    final Path remainingPath;       private final boolean isLastInternalDirLink;    ResolveResult(final ResultKind k, final T targetFs, final String resolveP,        final Path remainingP, boolean isLastIntenalDirLink) {      kind = k;      targetFileSystem = targetFs;      resolvedPath = resolveP;      remainingPath = remainingP;      this.isLastInternalDirLink = isLastIntenalDirLink;    }        boolean isInternalDir() {      return (kind == ResultKind.INTERNAL_DIR);    }            boolean isLastInternalDirLink() {      return this.isLastInternalDirLink;    }  }    ResolveResult<T> resolve(final String p, final boolean resolveLastComponent)      throws IOException {    ResolveResult<T> resolveResult = null;    String[] path = breakIntoPathComponents(p);    if (path.length <= 1) {       T targetFs = root.isInternalDir() ?          getRootDir().getInternalDirFs()          : getRootLink().getTargetFileSystem();      resolveResult = new ResolveResult<T>(ResultKind.INTERNAL_DIR,          targetFs, root.fullPath, SlashPath, false);      return resolveResult;    }        if (root.isLink()) {      Path remainingPath;      StringBuilder remainingPathStr = new StringBuilder();            for (int i = 1; i < path.length; i++) {        remainingPathStr.append("/").append(path[i]);      }      remainingPath = new Path(remainingPathStr.toString());      resolveResult = new ResolveResult<T>(ResultKind.EXTERNAL_DIR,          getRootLink().getTargetFileSystem(), root.fullPath, remainingPath,          true);      return resolveResult;    }    Preconditions.checkState(root.isInternalDir());    INodeDir<T> curInode = getRootDir();        resolveResult = tryResolveInRegexMountpoint(p, resolveLastComponent);    if (resolveResult != null) {      return resolveResult;    }    int i;        for (i = 1; i < path.length - (resolveLastComponent ? 0 : 1); i++) {      INode<T> nextInode = curInode.resolveInternal(path[i]);      if (nextInode == null) {        if (hasFallbackLink()) {          resolveResult = new ResolveResult<T>(ResultKind.EXTERNAL_DIR,              getRootFallbackLink().getTargetFileSystem(), root.fullPath,              new Path(p), false);          return resolveResult;        } else {          StringBuilder failedAt = new StringBuilder(path[0]);          for (int j = 1; j <= i; ++j) {            failedAt.append('/').append(path[j]);          }          throw (new FileNotFoundException(              "File/Directory does not exist: " + failedAt.toString()));        }      }      if (nextInode.isLink()) {        final INodeLink<T> link = (INodeLink<T>) nextInode;        final Path remainingPath;        if (i >= path.length - 1) {          remainingPath = SlashPath;        } else {          StringBuilder remainingPathStr =              new StringBuilder("/" + path[i + 1]);          for (int j = i + 2; j < path.length; ++j) {            remainingPathStr.append('/').append(path[j]);          }          remainingPath = new Path(remainingPathStr.toString());        }        resolveResult = new ResolveResult<T>(ResultKind.EXTERNAL_DIR,            link.getTargetFileSystem(), nextInode.fullPath, remainingPath,            true);        return resolveResult;      } else if (nextInode.isInternalDir()) {        curInode = (INodeDir<T>) nextInode;      }    }        Path remainingPath;    if (resolveLastComponent) {      remainingPath = SlashPath;    } else {                              StringBuilder remainingPathStr = new StringBuilder("/" + path[i]);      for (int j = i + 1; j < path.length; ++j) {        remainingPathStr.append('/').append(path[j]);      }      remainingPath = new Path(remainingPathStr.toString());    }    resolveResult = new ResolveResult<T>(ResultKind.INTERNAL_DIR,        curInode.getInternalDirFs(), curInode.fullPath, remainingPath, false);    return resolveResult;  }    protected ResolveResult<T> tryResolveInRegexMountpoint(final String srcPath,      final boolean resolveLastComponent) {    for (RegexMountPoint regexMountPoint : regexMountPointList) {      ResolveResult resolveResult =          regexMountPoint.resolve(srcPath, resolveLastComponent);      if (resolveResult != null) {        return resolveResult;      }    }    return null;  }    protected ResolveResult<T> buildResolveResultForRegexMountPoint(      ResultKind resultKind, String resolvedPathStr,      String targetOfResolvedPathStr, Path remainingPath) {    try {      T targetFs = initAndGetTargetFs()          .apply(new URI(targetOfResolvedPathStr));      if (targetFs == null) {        LOGGER.error(String.format(            "Not able to initialize target file system."                + " ResultKind:%s, resolvedPathStr:%s,"                + " targetOfResolvedPathStr:%s, remainingPath:%s,"                + " will return null.",            resultKind, resolvedPathStr, targetOfResolvedPathStr,            remainingPath));        return null;      }      return new ResolveResult<T>(resultKind, targetFs, resolvedPathStr,          remainingPath, true);    } catch (URISyntaxException uex) {      LOGGER.error(String.format(          "Got Exception while build resolve result."              + " ResultKind:%s, resolvedPathStr:%s,"              + " targetOfResolvedPathStr:%s, remainingPath:%s,"              + " will return null.",          resultKind, resolvedPathStr, targetOfResolvedPathStr, remainingPath),          uex);      return null;    }  }  List<MountPoint<T>> getMountPoints() {    return mountPoints;  }    String getHomeDirPrefixValue() {    return homedirPrefix;  }}
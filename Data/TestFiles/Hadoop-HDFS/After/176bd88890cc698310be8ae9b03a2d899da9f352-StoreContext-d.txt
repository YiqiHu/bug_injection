

package org.apache.hadoop.fs.s3a.impl;

import java.io.File;
import java.io.IOException;
import java.net.URI;
import java.util.concurrent.Callable;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutorService;

import org.apache.hadoop.thirdparty.com.google.common.util.concurrent.ListeningExecutorService;

import org.apache.hadoop.thirdparty.com.google.common.util.concurrent.MoreExecutors;
import org.apache.hadoop.classification.InterfaceAudience;
import org.apache.hadoop.classification.InterfaceStability;
import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.fs.Path;
import org.apache.hadoop.fs.s3a.Invoker;
import org.apache.hadoop.fs.s3a.S3AFileStatus;
import org.apache.hadoop.fs.s3a.S3AInputPolicy;
import org.apache.hadoop.fs.s3a.S3AStorageStatistics;
import org.apache.hadoop.fs.s3a.Statistic;
import org.apache.hadoop.fs.s3a.statistics.S3AStatisticsContext;
import org.apache.hadoop.fs.s3a.s3guard.ITtlTimeProvider;
import org.apache.hadoop.fs.s3a.s3guard.MetadataStore;
import org.apache.hadoop.security.UserGroupInformation;
import org.apache.hadoop.util.LambdaUtils;
import org.apache.hadoop.util.SemaphoredDelegatingExecutor;


@InterfaceAudience.LimitedPrivate("S3A Filesystem and extensions")
@InterfaceStability.Unstable
public class StoreContext {

  
  private final URI fsURI;

  
  private final String bucket;

  
  private final Configuration configuration;

  
  private final String username;

  
  private final UserGroupInformation owner;

  
  private final ListeningExecutorService executor;

  
  private final int executorCapacity;

  
  private final Invoker invoker;

  
  private final S3AStatisticsContext instrumentation;

  private final S3AStorageStatistics storageStatistics;

  
  private final S3AInputPolicy inputPolicy;

  
  private final ChangeDetectionPolicy changeDetectionPolicy;

  
  private final boolean multiObjectDeleteEnabled;

  
  private final boolean useListV1;

  
  private final MetadataStore metadataStore;

  private final ContextAccessors contextAccessors;

  
  private ITtlTimeProvider timeProvider;

  
  public StoreContext(
      final URI fsURI,
      final String bucket,
      final Configuration configuration,
      final String username,
      final UserGroupInformation owner,
      final ExecutorService executor,
      final int executorCapacity,
      final Invoker invoker,
      final S3AStatisticsContext instrumentation,
      final S3AStorageStatistics storageStatistics,
      final S3AInputPolicy inputPolicy,
      final ChangeDetectionPolicy changeDetectionPolicy,
      final boolean multiObjectDeleteEnabled,
      final MetadataStore metadataStore,
      final boolean useListV1,
      final ContextAccessors contextAccessors,
      final ITtlTimeProvider timeProvider) {
    this.fsURI = fsURI;
    this.bucket = bucket;
    this.configuration = configuration;
    this.username = username;
    this.owner = owner;
    this.executor = MoreExecutors.listeningDecorator(executor);
    this.executorCapacity = executorCapacity;
    this.invoker = invoker;
    this.instrumentation = instrumentation;
    this.storageStatistics = storageStatistics;
    this.inputPolicy = inputPolicy;
    this.changeDetectionPolicy = changeDetectionPolicy;
    this.multiObjectDeleteEnabled = multiObjectDeleteEnabled;
    this.metadataStore = metadataStore;
    this.useListV1 = useListV1;
    this.contextAccessors = contextAccessors;
    this.timeProvider = timeProvider;
  }

  @Override
  protected Object clone() throws CloneNotSupportedException {
    return super.clone();
  }

  public URI getFsURI() {
    return fsURI;
  }

  public String getBucket() {
    return bucket;
  }

  public Configuration getConfiguration() {
    return configuration;
  }

  public String getUsername() {
    return username;
  }

  public ExecutorService getExecutor() {
    return executor;
  }

  public Invoker getInvoker() {
    return invoker;
  }

  
  public S3AStatisticsContext getInstrumentation() {
    return instrumentation;
  }

  public S3AInputPolicy getInputPolicy() {
    return inputPolicy;
  }

  public ChangeDetectionPolicy getChangeDetectionPolicy() {
    return changeDetectionPolicy;
  }

  public boolean isMultiObjectDeleteEnabled() {
    return multiObjectDeleteEnabled;
  }

  public MetadataStore getMetadataStore() {
    return metadataStore;
  }

  public boolean isUseListV1() {
    return useListV1;
  }

  public ContextAccessors getContextAccessors() {
    return contextAccessors;
  }

  
  public Path keyToPath(String key) {
    return contextAccessors.keyToPath(key);
  }

  
  public String pathToKey(Path path) {
    return contextAccessors.pathToKey(path);
  }

  
  public Path makeQualified(Path path) {
    return contextAccessors.makeQualified(path);
  }

  
  public S3AStorageStatistics getStorageStatistics() {
    return storageStatistics;
  }

  
  public void incrementStatistic(Statistic statistic) {
    incrementStatistic(statistic, 1);
  }

  
  public void incrementStatistic(Statistic statistic, long count) {
    instrumentation.incrementCounter(statistic, count);
  }

  
  public void decrementGauge(Statistic statistic, long count) {
    instrumentation.decrementGauge(statistic, count);
  }

  
  public void incrementGauge(Statistic statistic, long count) {
    instrumentation.incrementGauge(statistic, count);
  }

  
  public ExecutorService createThrottledExecutor(int capacity) {
    return new SemaphoredDelegatingExecutor(executor,
        capacity, true);
  }

  
  public ExecutorService createThrottledExecutor() {
    return createThrottledExecutor(executorCapacity);
  }

  
  public UserGroupInformation getOwner() {
    return owner;
  }

  
  public File createTempFile(String prefix, long size) throws IOException {
    return contextAccessors.createTempFile(prefix, size);
  }

  
  public String getBucketLocation() throws IOException {
    return contextAccessors.getBucketLocation();
  }

  
  public ITtlTimeProvider getTimeProvider() {
    return timeProvider;
  }

  
  public String fullKey(final S3AFileStatus stat) {
    String k = pathToKey(stat.getPath());
    return (stat.isDirectory() && !k.endsWith("/"))
        ? k + "/"
        : k;
  }

  
  public <T> CompletableFuture<T> submit(
      final CompletableFuture<T> future,
      final Callable<T> call) {
    getExecutor().submit(() ->
        LambdaUtils.eval(future, call));
    return future;
  }
}

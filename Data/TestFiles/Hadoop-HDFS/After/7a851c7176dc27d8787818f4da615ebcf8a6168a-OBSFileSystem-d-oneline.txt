public final class OBSFileSystem extends FileSystem {    public static final Logger LOG = LoggerFactory.getLogger(      OBSFileSystem.class);    private final AtomicBoolean closed = new AtomicBoolean(false);    private URI uri;    private Path workingDir;    private String username;    private ObsClient obs;    private boolean enablePosix = false;    private boolean enableMultiObjectDeleteRecursion = true;    private boolean obsContentSummaryEnable = true;    private boolean obsClientDFSListEnable = true;    private String bucket;    private int maxKeys;    private OBSListing obsListing;    private OBSWriteOperationHelper writeHelper;    private long partSize;    private boolean enableMultiObjectDelete;    private int multiDeleteThreshold;    private int maxEntriesToDelete;    private ExecutorService boundedMultipartUploadThreadPool;    private ThreadPoolExecutor boundedCopyThreadPool;    private ThreadPoolExecutor boundedDeleteThreadPool;    private ThreadPoolExecutor boundedCopyPartThreadPool;    private ThreadPoolExecutor boundedListThreadPool;    private int listParallelFactor;    private long readAheadRange;    private boolean readTransformEnable = true;    private OBSDataBlocks.BlockFactory blockFactory;    private int blockOutputActiveBlocks;    private long copyPartSize;    private boolean enableTrash = false;    private String trashDir;    private AccessControlList cannedACL;    private SseWrapper sse;    private long blockSize;    @Override  public void initialize(final URI name, final Configuration originalConf)      throws IOException {    uri = URI.create(name.getScheme() + "://" + name.getAuthority());    bucket = name.getAuthority();        Configuration conf = OBSCommonUtils.propagateBucketOptions(originalConf,        bucket);    OBSCommonUtils.patchSecurityCredentialProviders(conf);    super.initialize(name, conf);    setConf(conf);    try {            username = UserGroupInformation.getCurrentUser().getShortUserName();      workingDir = new Path("/user", username).makeQualified(this.uri,          this.getWorkingDirectory());      Class<? extends OBSClientFactory> obsClientFactoryClass =          conf.getClass(              OBSConstants.OBS_CLIENT_FACTORY_IMPL,              OBSConstants.DEFAULT_OBS_CLIENT_FACTORY_IMPL,              OBSClientFactory.class);      obs = ReflectionUtils.newInstance(obsClientFactoryClass, conf)          .createObsClient(name);      sse = new SseWrapper(conf);      OBSCommonUtils.verifyBucketExists(this);      enablePosix = OBSCommonUtils.getBucketFsStatus(obs, bucket);      maxKeys = OBSCommonUtils.intOption(conf,          OBSConstants.MAX_PAGING_KEYS,          OBSConstants.DEFAULT_MAX_PAGING_KEYS, 1);      obsListing = new OBSListing(this);      partSize = OBSCommonUtils.getMultipartSizeProperty(conf,          OBSConstants.MULTIPART_SIZE,          OBSConstants.DEFAULT_MULTIPART_SIZE);            blockSize = OBSCommonUtils.longBytesOption(conf,          OBSConstants.FS_OBS_BLOCK_SIZE,          OBSConstants.DEFAULT_FS_OBS_BLOCK_SIZE, 1);      enableMultiObjectDelete = conf.getBoolean(          OBSConstants.ENABLE_MULTI_DELETE, true);      maxEntriesToDelete = conf.getInt(          OBSConstants.MULTI_DELETE_MAX_NUMBER,          OBSConstants.DEFAULT_MULTI_DELETE_MAX_NUMBER);      enableMultiObjectDeleteRecursion = conf.getBoolean(          OBSConstants.MULTI_DELETE_RECURSION, true);      obsContentSummaryEnable = conf.getBoolean(          OBSConstants.OBS_CONTENT_SUMMARY_ENABLE, true);      readAheadRange = OBSCommonUtils.longBytesOption(conf,          OBSConstants.READAHEAD_RANGE,          OBSConstants.DEFAULT_READAHEAD_RANGE, 0);      readTransformEnable = conf.getBoolean(          OBSConstants.READ_TRANSFORM_ENABLE, true);      multiDeleteThreshold = conf.getInt(          OBSConstants.MULTI_DELETE_THRESHOLD,          OBSConstants.MULTI_DELETE_DEFAULT_THRESHOLD);      initThreadPools(conf);      writeHelper = new OBSWriteOperationHelper(this);      initCannedAcls(conf);      OBSCommonUtils.initMultipartUploads(this, conf);      String blockOutputBuffer = conf.getTrimmed(          OBSConstants.FAST_UPLOAD_BUFFER,          OBSConstants.FAST_UPLOAD_BUFFER_DISK);      partSize = OBSCommonUtils.ensureOutputParameterInRange(          OBSConstants.MULTIPART_SIZE, partSize);      blockFactory = OBSDataBlocks.createFactory(this, blockOutputBuffer);      blockOutputActiveBlocks =          OBSCommonUtils.intOption(conf,              OBSConstants.FAST_UPLOAD_ACTIVE_BLOCKS,              OBSConstants.DEFAULT_FAST_UPLOAD_ACTIVE_BLOCKS, 1);      LOG.debug(          "Using OBSBlockOutputStream with buffer = {}; block={};"              + " queue limit={}",          blockOutputBuffer,          partSize,          blockOutputActiveBlocks);      enableTrash = conf.getBoolean(OBSConstants.TRASH_ENABLE,          OBSConstants.DEFAULT_TRASH);      if (enableTrash) {        if (!isFsBucket()) {          String errorMsg = String.format(              "The bucket [%s] is not posix. not supported for "                  + "trash.", bucket);          LOG.warn(errorMsg);          enableTrash = false;          trashDir = null;        } else {          trashDir = conf.get(OBSConstants.TRASH_DIR);          if (StringUtils.isEmpty(trashDir)) {            String errorMsg =                String.format(                    "The trash feature(fs.obs.trash.enable) is "                        + "enabled, but the "                        + "configuration(fs.obs.trash.dir [%s]) "                        + "is empty.",                    trashDir);            LOG.error(errorMsg);            throw new ObsException(errorMsg);          }          trashDir = OBSCommonUtils.maybeAddBeginningSlash(trashDir);          trashDir = OBSCommonUtils.maybeAddTrailingSlash(trashDir);        }      }    } catch (ObsException e) {      throw OBSCommonUtils.translateException("initializing ",          new Path(name), e);    }  }  private void initThreadPools(final Configuration conf) {    long keepAliveTime = OBSCommonUtils.longOption(conf,        OBSConstants.KEEPALIVE_TIME,        OBSConstants.DEFAULT_KEEPALIVE_TIME, 0);    int maxThreads = conf.getInt(OBSConstants.MAX_THREADS,        OBSConstants.DEFAULT_MAX_THREADS);    if (maxThreads < 2) {      LOG.warn(OBSConstants.MAX_THREADS          + " must be at least 2: forcing to 2.");      maxThreads = 2;    }    int totalTasks = OBSCommonUtils.intOption(conf,        OBSConstants.MAX_TOTAL_TASKS,        OBSConstants.DEFAULT_MAX_TOTAL_TASKS, 1);    boundedMultipartUploadThreadPool =            BlockingThreadPoolExecutorService.newInstance(                    maxThreads,                    maxThreads + totalTasks,                    keepAliveTime,                    TimeUnit.SECONDS,                    "obs-transfer-shared");    int maxDeleteThreads = conf.getInt(OBSConstants.MAX_DELETE_THREADS,        OBSConstants.DEFAULT_MAX_DELETE_THREADS);    if (maxDeleteThreads < 2) {      LOG.warn(OBSConstants.MAX_DELETE_THREADS          + " must be at least 2: forcing to 2.");      maxDeleteThreads = 2;    }    int coreDeleteThreads = (int) Math.ceil(maxDeleteThreads / 2.0);    boundedDeleteThreadPool =        new ThreadPoolExecutor(            coreDeleteThreads,            maxDeleteThreads,            keepAliveTime,            TimeUnit.SECONDS,            new LinkedBlockingQueue<>(),            BlockingThreadPoolExecutorService.newDaemonThreadFactory(                "obs-delete-transfer-shared"));    boundedDeleteThreadPool.allowCoreThreadTimeOut(true);    if (enablePosix) {      obsClientDFSListEnable = conf.getBoolean(          OBSConstants.OBS_CLIENT_DFS_LIST_ENABLE, true);      if (obsClientDFSListEnable) {        int coreListThreads = conf.getInt(            OBSConstants.CORE_LIST_THREADS,            OBSConstants.DEFAULT_CORE_LIST_THREADS);        int maxListThreads = conf.getInt(OBSConstants.MAX_LIST_THREADS,            OBSConstants.DEFAULT_MAX_LIST_THREADS);        int listWorkQueueCapacity = conf.getInt(            OBSConstants.LIST_WORK_QUEUE_CAPACITY,            OBSConstants.DEFAULT_LIST_WORK_QUEUE_CAPACITY);        listParallelFactor = conf.getInt(            OBSConstants.LIST_PARALLEL_FACTOR,            OBSConstants.DEFAULT_LIST_PARALLEL_FACTOR);        if (listParallelFactor < 1) {          LOG.warn(OBSConstants.LIST_PARALLEL_FACTOR              + " must be at least 1: forcing to 1.");          listParallelFactor = 1;        }        boundedListThreadPool =            new ThreadPoolExecutor(                coreListThreads,                maxListThreads,                keepAliveTime,                TimeUnit.SECONDS,                new LinkedBlockingQueue<>(listWorkQueueCapacity),                BlockingThreadPoolExecutorService                    .newDaemonThreadFactory(                        "obs-list-transfer-shared"));        boundedListThreadPool.allowCoreThreadTimeOut(true);      }    } else {      int maxCopyThreads = conf.getInt(OBSConstants.MAX_COPY_THREADS,          OBSConstants.DEFAULT_MAX_COPY_THREADS);      if (maxCopyThreads < 2) {        LOG.warn(OBSConstants.MAX_COPY_THREADS            + " must be at least 2: forcing to 2.");        maxCopyThreads = 2;      }      int coreCopyThreads = (int) Math.ceil(maxCopyThreads / 2.0);      boundedCopyThreadPool =          new ThreadPoolExecutor(              coreCopyThreads,              maxCopyThreads,              keepAliveTime,              TimeUnit.SECONDS,              new LinkedBlockingQueue<>(),              BlockingThreadPoolExecutorService.newDaemonThreadFactory(                  "obs-copy-transfer-shared"));      boundedCopyThreadPool.allowCoreThreadTimeOut(true);      copyPartSize = OBSCommonUtils.longOption(conf,          OBSConstants.COPY_PART_SIZE,          OBSConstants.DEFAULT_COPY_PART_SIZE, 0);      if (copyPartSize > OBSConstants.MAX_COPY_PART_SIZE) {        LOG.warn(            "obs: {} capped to ~5GB (maximum allowed part size with "                + "current output mechanism)",            OBSConstants.COPY_PART_SIZE);        copyPartSize = OBSConstants.MAX_COPY_PART_SIZE;      }      int maxCopyPartThreads = conf.getInt(          OBSConstants.MAX_COPY_PART_THREADS,          OBSConstants.DEFAULT_MAX_COPY_PART_THREADS);      if (maxCopyPartThreads < 2) {        LOG.warn(OBSConstants.MAX_COPY_PART_THREADS            + " must be at least 2: forcing to 2.");        maxCopyPartThreads = 2;      }      int coreCopyPartThreads = (int) Math.ceil(maxCopyPartThreads / 2.0);      boundedCopyPartThreadPool =          new ThreadPoolExecutor(              coreCopyPartThreads,              maxCopyPartThreads,              keepAliveTime,              TimeUnit.SECONDS,              new LinkedBlockingQueue<>(),              BlockingThreadPoolExecutorService.newDaemonThreadFactory(                  "obs-copy-part-transfer-shared"));      boundedCopyPartThreadPool.allowCoreThreadTimeOut(true);    }  }    boolean isFsBucket() {    return enablePosix;  }    boolean isReadTransformEnabled() {    return readTransformEnable;  }    private void initCannedAcls(final Configuration conf) {        String cannedACLName = conf.get(OBSConstants.CANNED_ACL,        OBSConstants.DEFAULT_CANNED_ACL);    if (!cannedACLName.isEmpty()) {      switch (cannedACLName) {      case "Private":      case "PublicRead":      case "PublicReadWrite":      case "AuthenticatedRead":      case "LogDeliveryWrite":      case "BucketOwnerRead":      case "BucketOwnerFullControl":        cannedACL = new AccessControlList();        break;      default:        cannedACL = null;      }    } else {      cannedACL = null;    }  }    AccessControlList getCannedACL() {    return cannedACL;  }    @Override  public String getScheme() {    return "obs";  }    @Override  public URI getUri() {    return uri;  }    @Override  public int getDefaultPort() {    return OBSConstants.OBS_DEFAULT_PORT;  }    @VisibleForTesting  ObsClient getObsClient() {    return obs;  }    @VisibleForTesting  long getReadAheadRange() {    return readAheadRange;  }    String getBucket() {    return bucket;  }    @Override  public void checkPath(final Path path) {    OBSLoginHelper.checkPath(getConf(), getUri(), path, getDefaultPort());  }    @Override  protected URI canonicalizeUri(final URI rawUri) {    return OBSLoginHelper.canonicalizeUri(rawUri, getDefaultPort());  }    @Override  public FSDataInputStream open(final Path f, final int bufferSize)      throws IOException {    LOG.debug("Opening '{}' for reading.", f);    final FileStatus fileStatus = getFileStatus(f);    if (fileStatus.isDirectory()) {      throw new FileNotFoundException(          "Can't open " + f + " because it is a directory");    }    return new FSDataInputStream(        new OBSInputStream(bucket, OBSCommonUtils.pathToKey(this, f),            fileStatus.getLen(),            obs, statistics, readAheadRange, this));  }    @Override  public FSDataOutputStream create(      final Path f,      final FsPermission permission,      final boolean overwrite,      final int bufferSize,      final short replication,      final long blkSize,      final Progressable progress)      throws IOException {    String key = OBSCommonUtils.pathToKey(this, f);    FileStatus status;    long objectLen = 0;    try {            status = getFileStatus(f);      objectLen = status.getLen();            if (status.isDirectory()) {                throw new FileAlreadyExistsException(f + " is a directory");      }      if (!overwrite) {                throw new FileAlreadyExistsException(f + " already exists");      }      LOG.debug("create: Overwriting file {}", f);    } catch (FileNotFoundException e) {            LOG.debug("create: Creating new file {}", f);    }    return new FSDataOutputStream(        new OBSBlockOutputStream(            this,            key,            objectLen,            new SemaphoredDelegatingExecutor(                boundedMultipartUploadThreadPool,                blockOutputActiveBlocks, true),            false),        null);  }    long getPartSize() {    return partSize;  }    OBSDataBlocks.BlockFactory getBlockFactory() {    return blockFactory;  }    OBSWriteOperationHelper getWriteHelper() {    return writeHelper;  }    @Override  @SuppressWarnings("checkstyle:parameternumber")  public FSDataOutputStream create(      final Path f,      final FsPermission permission,      final EnumSet<CreateFlag> flags,      final int bufferSize,      final short replication,      final long blkSize,      final Progressable progress,      final ChecksumOpt checksumOpt)      throws IOException {    LOG.debug("create: Creating new file {}, flags:{}, isFsBucket:{}", f,        flags, isFsBucket());    if (null != flags && flags.contains(CreateFlag.APPEND)) {      if (!isFsBucket()) {        throw new UnsupportedOperationException(            "non-posix bucket. Append is not supported by "                + "OBSFileSystem");      }      String key = OBSCommonUtils.pathToKey(this, f);      FileStatus status;      long objectLen = 0;      try {                status = getFileStatus(f);        objectLen = status.getLen();                if (status.isDirectory()) {                    throw new FileAlreadyExistsException(f + " is a directory");        }      } catch (FileNotFoundException e) {        LOG.debug("FileNotFoundException, create: Creating new file {}",            f);      }      return new FSDataOutputStream(          new OBSBlockOutputStream(              this,              key,              objectLen,              new SemaphoredDelegatingExecutor(                  boundedMultipartUploadThreadPool,                  blockOutputActiveBlocks, true),              true),          null);    } else {      return create(          f,          permission,          flags == null || flags.contains(CreateFlag.OVERWRITE),          bufferSize,          replication,          blkSize,          progress);    }  }    @Override  public FSDataOutputStream createNonRecursive(      final Path path,      final FsPermission permission,      final EnumSet<CreateFlag> flags,      final int bufferSize,      final short replication,      final long blkSize,      final Progressable progress)      throws IOException {    Path parent = path.getParent();    if (parent != null && !getFileStatus(parent).isDirectory()) {            throw new FileAlreadyExistsException("Not a directory: " + parent);    }    return create(        path,        permission,        flags.contains(CreateFlag.OVERWRITE),        bufferSize,        replication,        blkSize,        progress);  }    @Override  public FSDataOutputStream append(final Path f, final int bufferSize,      final Progressable progress)      throws IOException {    if (!isFsBucket()) {      throw new UnsupportedOperationException(          "non-posix bucket. Append is not supported "              + "by OBSFileSystem");    }    LOG.debug("append: Append file {}.", f);    String key = OBSCommonUtils.pathToKey(this, f);        FileStatus status = getFileStatus(f);    long objectLen = status.getLen();        if (status.isDirectory()) {            throw new FileAlreadyExistsException(f + " is a directory");    }    return new FSDataOutputStream(        new OBSBlockOutputStream(            this,            key,            objectLen,            new SemaphoredDelegatingExecutor(                boundedMultipartUploadThreadPool,                blockOutputActiveBlocks, true),            true),        null);  }    @Override  public boolean exists(final Path f) throws IOException {    try {      return getFileStatus(f) != null;    } catch (FileNotFoundException | FileConflictException e) {      return false;    }  }    @Override  public boolean rename(final Path src, final Path dst) throws IOException {    long startTime = System.currentTimeMillis();    long threadId = Thread.currentThread().getId();    LOG.debug("Rename path {} to {} start", src, dst);    try {      if (enablePosix) {        return OBSPosixBucketUtils.renameBasedOnPosix(this, src, dst);      } else {        return OBSObjectBucketUtils.renameBasedOnObject(this, src, dst);      }    } catch (ObsException e) {      throw OBSCommonUtils.translateException(          "rename(" + src + ", " + dst + ")", src, e);    } catch (RenameFailedException e) {      LOG.error(e.getMessage());      return e.getExitCode();    } catch (FileNotFoundException e) {      LOG.error(e.toString());      return false;    } finally {      long endTime = System.currentTimeMillis();      LOG.debug(          "Rename path {} to {} finished, thread:{}, "              + "timeUsedInMilliSec:{}.", src, dst, threadId,          endTime - startTime);    }  }    int getMaxEntriesToDelete() {    return maxEntriesToDelete;  }    int getListParallelFactor() {    return listParallelFactor;  }    ThreadPoolExecutor getBoundedListThreadPool() {    return boundedListThreadPool;  }    boolean isObsClientDFSListEnable() {    return obsClientDFSListEnable;  }    Statistics getSchemeStatistics() {    return statistics;  }    int getMultiDeleteThreshold() {    return multiDeleteThreshold;  }    boolean isEnableMultiObjectDelete() {    return enableMultiObjectDelete;  }    @Override  public boolean delete(final Path f, final boolean recursive)      throws IOException {    try {      FileStatus status = getFileStatus(f);      LOG.debug("delete: path {} - recursive {}", status.getPath(),          recursive);      if (enablePosix) {        return OBSPosixBucketUtils.fsDelete(this, status, recursive);      }      return OBSObjectBucketUtils.objectDelete(this, status, recursive);    } catch (FileNotFoundException e) {      LOG.warn("Couldn't delete {} - does not exist", f);      return false;    } catch (ObsException e) {      throw OBSCommonUtils.translateException("delete", f, e);    }  }    boolean isEnableTrash() {    return enableTrash;  }    String getTrashDir() {    return trashDir;  }    boolean isEnableMultiObjectDeleteRecursion() {    return enableMultiObjectDeleteRecursion;  }    @Override  public FileStatus[] listStatus(final Path f)      throws FileNotFoundException, IOException {    long startTime = System.currentTimeMillis();    long threadId = Thread.currentThread().getId();    try {      FileStatus[] statuses = OBSCommonUtils.innerListStatus(this, f,          false);      long endTime = System.currentTimeMillis();      LOG.debug(          "List status for path:{}, thread:{}, timeUsedInMilliSec:{}", f,          threadId, endTime - startTime);      return statuses;    } catch (ObsException e) {      throw OBSCommonUtils.translateException("listStatus", f, e);    }  }    public FileStatus[] listStatus(final Path f, final boolean recursive)      throws FileNotFoundException, IOException {    long startTime = System.currentTimeMillis();    long threadId = Thread.currentThread().getId();    try {      FileStatus[] statuses = OBSCommonUtils.innerListStatus(this, f,          recursive);      long endTime = System.currentTimeMillis();      LOG.debug(          "List status for path:{}, thread:{}, timeUsedInMilliSec:{}", f,          threadId, endTime - startTime);      return statuses;    } catch (ObsException e) {      throw OBSCommonUtils.translateException(          "listStatus with recursive flag["              + (recursive ? "true] " : "false] "), f, e);    }  }    OBSListing getObsListing() {    return obsListing;  }    @Override  public Path getWorkingDirectory() {    return workingDir;  }    @Override  public void setWorkingDirectory(final Path newDir) {    workingDir = newDir;  }    String getUsername() {    return username;  }    @Override  public boolean mkdirs(final Path path, final FsPermission permission)      throws IOException, FileAlreadyExistsException {    try {      return OBSCommonUtils.innerMkdirs(this, path);    } catch (ObsException e) {      throw OBSCommonUtils.translateException("mkdirs", path, e);    }  }    @Override  public FileStatus getFileStatus(final Path f)      throws FileNotFoundException, IOException {    for (int retryTime = 1;        retryTime < OBSCommonUtils.MAX_RETRY_TIME; retryTime++) {      try {        return innerGetFileStatus(f);      } catch (FileNotFoundException | FileConflictException e) {        throw e;      } catch (IOException e) {        LOG.warn("Failed to get file status for [{}], retry time [{}], "            + "exception [{}]", f, retryTime, e);        try {          Thread.sleep(OBSCommonUtils.DELAY_TIME);        } catch (InterruptedException ie) {          throw e;        }      }    }    return innerGetFileStatus(f);  }    @VisibleForTesting  OBSFileStatus innerGetFileStatus(final Path f) throws IOException {    if (enablePosix) {      return OBSPosixBucketUtils.innerFsGetObjectStatus(this, f);    }    return OBSObjectBucketUtils.innerGetObjectStatus(this, f);  }    @Override  public ContentSummary getContentSummary(final Path f)      throws FileNotFoundException, IOException {    if (!obsContentSummaryEnable) {      return super.getContentSummary(f);    }    FileStatus status = getFileStatus(f);    if (status.isFile()) {            long length = status.getLen();      return new ContentSummary.Builder().length(length)          .fileCount(1).directoryCount(0).spaceConsumed(length).build();    }        if (enablePosix) {      return OBSPosixBucketUtils.fsGetDirectoryContentSummary(this,          OBSCommonUtils.pathToKey(this, f));    } else {      return OBSObjectBucketUtils.getDirectoryContentSummary(this,          OBSCommonUtils.pathToKey(this, f));    }  }    @Override  public void copyFromLocalFile(final boolean delSrc, final boolean overwrite,      final Path src, final Path dst) throws FileAlreadyExistsException,      IOException {    try {      super.copyFromLocalFile(delSrc, overwrite, src, dst);    } catch (ObsException e) {      throw OBSCommonUtils.translateException(          "copyFromLocalFile(" + src + ", " + dst + ")", src, e);    }  }    @Override  public void close() throws IOException {    LOG.debug("This Filesystem closed by user, clear resource.");    if (closed.getAndSet(true)) {            return;    }    try {      super.close();    } finally {      OBSCommonUtils.shutdownAll(          boundedMultipartUploadThreadPool,          boundedCopyThreadPool,          boundedDeleteThreadPool,          boundedCopyPartThreadPool,          boundedListThreadPool);    }  }    @Override  public String getCanonicalServiceName() {        return null;  }    long getCopyPartSize() {    return copyPartSize;  }    ThreadPoolExecutor getBoundedCopyPartThreadPool() {    return boundedCopyPartThreadPool;  }    ThreadPoolExecutor getBoundedCopyThreadPool() {    return boundedCopyThreadPool;  }    @Override  public long getDefaultBlockSize() {    return blockSize;  }    @Override  public long getDefaultBlockSize(final Path f) {    return blockSize;  }    @Override  public String toString() {    final StringBuilder sb = new StringBuilder("OBSFileSystem{");    sb.append("uri=").append(uri);    sb.append(", workingDir=").append(workingDir);    sb.append(", partSize=").append(partSize);    sb.append(", enableMultiObjectsDelete=")        .append(enableMultiObjectDelete);    sb.append(", maxKeys=").append(maxKeys);    if (cannedACL != null) {      sb.append(", cannedACL=").append(cannedACL.toString());    }    sb.append(", readAheadRange=").append(readAheadRange);    sb.append(", blockSize=").append(getDefaultBlockSize());    if (blockFactory != null) {      sb.append(", blockFactory=").append(blockFactory);    }    sb.append(", boundedMultipartUploadThreadPool=")        .append(boundedMultipartUploadThreadPool);    sb.append(", statistics {").append(statistics).append("}");    sb.append(", metrics {").append("}");    sb.append('}');    return sb.toString();  }    int getMaxKeys() {    return maxKeys;  }    @Override  public RemoteIterator<LocatedFileStatus> listFiles(final Path f,      final boolean recursive)      throws FileNotFoundException, IOException {    Path path = OBSCommonUtils.qualify(this, f);    LOG.debug("listFiles({}, {})", path, recursive);    try {            final FileStatus fileStatus = getFileStatus(path);      if (fileStatus.isFile()) {                LOG.debug("Path is a file");        return new OBSListing            .SingleStatusRemoteIterator(            OBSCommonUtils.toLocatedFileStatus(this, fileStatus));      } else {        LOG.debug(            "listFiles: doing listFiles of directory {} - recursive {}",            path, recursive);                String key = OBSCommonUtils.maybeAddTrailingSlash(            OBSCommonUtils.pathToKey(this, path));        String delimiter = recursive ? null : "/";        LOG.debug("Requesting all entries under {} with delimiter '{}'",            key, delimiter);        return obsListing.createLocatedFileStatusIterator(            obsListing.createFileStatusListingIterator(                path,                OBSCommonUtils.createListObjectsRequest(this, key,                    delimiter),                OBSListing.ACCEPT_ALL,                new OBSListing.AcceptFilesOnly(path)));      }    } catch (ObsException e) {      throw OBSCommonUtils.translateException("listFiles", path, e);    }  }    @Override  public RemoteIterator<LocatedFileStatus> listLocatedStatus(final Path f)      throws FileNotFoundException, IOException {    return listLocatedStatus(f,        OBSListing.ACCEPT_ALL);  }    @Override  public RemoteIterator<LocatedFileStatus> listLocatedStatus(final Path f,      final PathFilter filter)      throws FileNotFoundException, IOException {    Path path = OBSCommonUtils.qualify(this, f);    LOG.debug("listLocatedStatus({}, {}", path, filter);    try {            final FileStatus fileStatus = getFileStatus(path);      if (fileStatus.isFile()) {                LOG.debug("Path is a file");        return new OBSListing.SingleStatusRemoteIterator(            filter.accept(path) ? OBSCommonUtils.toLocatedFileStatus(                this, fileStatus) : null);      } else {                String key = OBSCommonUtils.maybeAddTrailingSlash(            OBSCommonUtils.pathToKey(this, path));        return obsListing.createLocatedFileStatusIterator(            obsListing.createFileStatusListingIterator(                path,                OBSCommonUtils.createListObjectsRequest(this, key, "/"),                filter,                new OBSListing.AcceptAllButSelfAndS3nDirs(path)));      }    } catch (ObsException e) {      throw OBSCommonUtils.translateException("listLocatedStatus", path,          e);    }  }    SseWrapper getSse() {    return sse;  }}
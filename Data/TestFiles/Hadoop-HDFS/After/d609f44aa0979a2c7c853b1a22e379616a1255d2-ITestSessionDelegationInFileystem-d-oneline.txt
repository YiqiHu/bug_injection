public class ITestSessionDelegationInFileystem extends AbstractDelegationIT {  private static final Logger LOG =      LoggerFactory.getLogger(ITestSessionDelegationInFileystem.class);  private static MiniKerberizedHadoopCluster cluster;  private UserGroupInformation bobUser;  private UserGroupInformation aliceUser;  private S3ADelegationTokens delegationTokens;    @BeforeClass  public static void setupCluster() throws Exception {    cluster = new MiniKerberizedHadoopCluster();    cluster.init(new Configuration());    cluster.start();  }    @SuppressWarnings("ThrowableNotThrown")  @AfterClass  public static void teardownCluster() throws Exception {    ServiceOperations.stopQuietly(LOG, cluster);  }  protected static MiniKerberizedHadoopCluster getCluster() {    return cluster;  }    protected String getDelegationBinding() {    return DELEGATION_TOKEN_SESSION_BINDING;  }    public Text getTokenKind() {    return SESSION_TOKEN_KIND;  }  @SuppressWarnings("deprecation")  @Override  protected Configuration createConfiguration() {    Configuration conf = super.createConfiguration();        assumeSessionTestsEnabled(conf);    disableFilesystemCaching(conf);    String s3EncryptionMethod =        conf.getTrimmed(Constants.S3_ENCRYPTION_ALGORITHM,            S3AEncryptionMethods.SSE_KMS.getMethod());    String s3EncryptionKey = getS3EncryptionKey(getTestBucketName(conf), conf);    removeBaseAndBucketOverrides(conf,        DELEGATION_TOKEN_BINDING,        Constants.S3_ENCRYPTION_ALGORITHM,        Constants.S3_ENCRYPTION_KEY,        SERVER_SIDE_ENCRYPTION_ALGORITHM,        SERVER_SIDE_ENCRYPTION_KEY);    conf.set(HADOOP_SECURITY_AUTHENTICATION,        UserGroupInformation.AuthenticationMethod.KERBEROS.name());    enableDelegationTokens(conf, getDelegationBinding());    conf.set(AWS_CREDENTIALS_PROVIDER, " ");        if (conf.getBoolean(KEY_ENCRYPTION_TESTS, true)) {      conf.set(Constants.S3_ENCRYPTION_ALGORITHM, s3EncryptionMethod);            conf.set(Constants.S3_ENCRYPTION_KEY, s3EncryptionKey);    }        conf.set(YarnConfiguration.RM_PRINCIPAL, YARN_RM);            conf.set(CANNED_ACL, LOG_DELIVERY_WRITE);    return conf;  }  @Override  public void setup() throws Exception {        resetUGI();    UserGroupInformation.setConfiguration(createConfiguration());    aliceUser = cluster.createAliceUser();    bobUser = cluster.createBobUser();    UserGroupInformation.setLoginUser(aliceUser);    assertSecurityEnabled();        super.setup();    S3AFileSystem fs = getFileSystem();        assertNull("Unexpectedly found an S3A token",        lookupS3ADelegationToken(        UserGroupInformation.getCurrentUser().getCredentials(),        fs.getUri()));        delegationTokens = instantiateDTSupport(getConfiguration());  }  @SuppressWarnings("ThrowableNotThrown")  @Override  public void teardown() throws Exception {    super.teardown();    ServiceOperations.stopQuietly(LOG, delegationTokens);    FileSystem.closeAllForUGI(UserGroupInformation.getCurrentUser());    MiniKerberizedHadoopCluster.closeUserFileSystems(aliceUser);    MiniKerberizedHadoopCluster.closeUserFileSystems(bobUser);    cluster.resetUGI();  }    protected boolean encryptionTestEnabled() {    return getConfiguration().getBoolean(KEY_ENCRYPTION_TESTS, true);  }  @Test  public void testGetDTfromFileSystem() throws Throwable {    describe("Enable delegation tokens and request one");    delegationTokens.start();    S3AFileSystem fs = getFileSystem();    assertNotNull("No tokens from " + fs,        fs.getCanonicalServiceName());    S3ATestUtils.MetricDiff invocationDiff = new S3ATestUtils.MetricDiff(fs,        Statistic.INVOCATION_GET_DELEGATION_TOKEN);    S3ATestUtils.MetricDiff issueDiff = new S3ATestUtils.MetricDiff(fs,        Statistic.DELEGATION_TOKENS_ISSUED);    Token<AbstractS3ATokenIdentifier> token =        requireNonNull(fs.getDelegationToken(""),            "no token from filesystem " + fs);    assertEquals("token kind", getTokenKind(), token.getKind());    assertTokenCreationCount(fs, 1);    final String fsInfo = fs.toString();    invocationDiff.assertDiffEquals("getDelegationToken() in " + fsInfo,        1);    issueDiff.assertDiffEquals("DTs issued in " + delegationTokens,        1);    Text service = delegationTokens.getService();    assertEquals("service name", service, token.getService());    Credentials creds = new Credentials();    creds.addToken(service, token);    assertEquals("retrieve token from " + creds,        token, creds.getToken(service));  }  @Test  public void testAddTokensFromFileSystem() throws Throwable {    describe("verify FileSystem.addDelegationTokens() collects tokens");    S3AFileSystem fs = getFileSystem();    Credentials cred = new Credentials();    Token<?>[] tokens = fs.addDelegationTokens(YARN_RM, cred);    assertEquals("Number of tokens", 1, tokens.length);    Token<?> token = requireNonNull(tokens[0], "token");    LOG.info("FS token is {}", token);    Text service = delegationTokens.getService();    Token<? extends TokenIdentifier> retrieved = requireNonNull(        cred.getToken(service),        "retrieved token with key " + service + "; expected " + token);    delegationTokens.start();        delegationTokens.resetTokenBindingToDT(        (Token<AbstractS3ATokenIdentifier>) retrieved);    assertTrue("bind to existing DT failed",        delegationTokens.isBoundToDT());    AWSCredentialProviderList providerList = requireNonNull(        delegationTokens.getCredentialProviders(), "providers");    providerList.getCredentials();  }  @Test  public void testCanRetrieveTokenFromCurrentUserCreds() throws Throwable {    describe("Create a DT, add it to the current UGI credentials,"        + " then retrieve");    delegationTokens.start();    Credentials cred = createDelegationTokens();    UserGroupInformation ugi = UserGroupInformation.getCurrentUser();    ugi.addCredentials(cred);    Token<?>[] tokens = cred.getAllTokens().toArray(new Token<?>[0]);    Token<?> token0 = tokens[0];    Text service = token0.getService();    LOG.info("Token = " + token0);    Token<?> token1 = requireNonNull(        ugi.getCredentials().getToken(service), "Token from " + service);    assertEquals("retrieved token", token0, token1);    assertNotNull("token identifier of "  + token1,        token1.getIdentifier());  }  @Test  public void testDTCredentialProviderFromCurrentUserCreds() throws Throwable {    describe("Add credentials to the current user, "        + "then verify that they can be found when S3ADelegationTokens binds");    Credentials cred = createDelegationTokens();    assertThat("Token size", cred.getAllTokens(), hasSize(1));    UserGroupInformation.getCurrentUser().addCredentials(cred);    delegationTokens.start();    assertTrue("bind to existing DT failed",        delegationTokens.isBoundToDT());  }    protected Credentials createDelegationTokens() throws IOException {    return mkTokens(getFileSystem());  }    @SuppressWarnings("deprecation")  @Test  public void testDelegatedFileSystem() throws Throwable {    describe("Delegation tokens can be passed to a new filesystem;"        + " if role restricted, permissions are tightened.");    S3AFileSystem fs = getFileSystem();            fs.getObjectMetadata(new Path("/"));    readLandsatMetadata(fs);    URI uri = fs.getUri();        Credentials creds = createDelegationTokens();    final Text tokenKind = getTokenKind();    AbstractS3ATokenIdentifier origTokenId = requireNonNull(        lookupToken(            creds,            uri,            tokenKind), "original");            final UserGroupInformation currentUser        = UserGroupInformation.getCurrentUser();    currentUser.addCredentials(creds);        requireNonNull(lookupToken(            currentUser.getCredentials(),            uri,            tokenKind), "user credentials");    Configuration conf = new Configuration(getConfiguration());    String bucket = fs.getBucket();    disableFilesystemCaching(conf);    unsetHadoopCredentialProviders(conf);                removeBaseAndBucketOverrides(bucket, conf,        ACCESS_KEY, SECRET_KEY, SESSION_TOKEN,        Constants.S3_ENCRYPTION_ALGORITHM,        Constants.S3_ENCRYPTION_KEY,        SERVER_SIDE_ENCRYPTION_ALGORITHM,        SERVER_SIDE_ENCRYPTION_KEY,        DELEGATION_TOKEN_ROLE_ARN,        DELEGATION_TOKEN_ENDPOINT);            conf.set(DELEGATION_TOKEN_ENDPOINT, "http://localhost:8080/");    bindProviderList(bucket, conf, CountInvocationsProvider.NAME);    long originalCount = CountInvocationsProvider.getInvocationCount();            Path testPath = path("testDTFileSystemClient");    try (S3AFileSystem delegatedFS = newS3AInstance(uri, conf)) {      LOG.info("Delegated filesystem is: {}", delegatedFS);      assertBoundToDT(delegatedFS, tokenKind);      if (encryptionTestEnabled()) {        assertNotNull("Encryption propagation failed",            delegatedFS.getS3EncryptionAlgorithm());        assertEquals("Encryption propagation failed",            fs.getS3EncryptionAlgorithm(),            delegatedFS.getS3EncryptionAlgorithm());      }      verifyRestrictedPermissions(delegatedFS);      executeDelegatedFSOperations(delegatedFS, testPath);      delegatedFS.mkdirs(testPath);      S3ATestUtils.MetricDiff issueDiff = new S3ATestUtils.MetricDiff(          delegatedFS,          Statistic.DELEGATION_TOKENS_ISSUED);                  AbstractS3ATokenIdentifier tokenFromDelegatedFS          = requireNonNull(delegatedFS.getDelegationToken(""),          "New token").decodeIdentifier();      assertEquals("Newly issued token != old one",          origTokenId,          tokenFromDelegatedFS);      issueDiff.assertDiffEquals("DTs issued in " + delegatedFS,          0);    }        assertEquals("invocation count",        originalCount,        CountInvocationsProvider.getInvocationCount());        try (S3AFileSystem secondDelegate = newS3AInstance(uri, conf)) {      assertBoundToDT(secondDelegate, tokenKind);      if (encryptionTestEnabled()) {        assertNotNull("Encryption propagation failed",            secondDelegate.getS3EncryptionAlgorithm());        assertEquals("Encryption propagation failed",            fs.getS3EncryptionAlgorithm(),            secondDelegate.getS3EncryptionAlgorithm());      }      ContractTestUtils.assertDeleted(secondDelegate, testPath, true);      assertNotNull("unbounded DT",          secondDelegate.getDelegationToken(""));    }  }    protected void executeDelegatedFSOperations(final S3AFileSystem delegatedFS,      final Path testPath) throws Exception {    ContractTestUtils.assertIsDirectory(delegatedFS, new Path("/"));    ContractTestUtils.touch(delegatedFS, testPath);    ContractTestUtils.assertDeleted(delegatedFS, testPath, false);    delegatedFS.mkdirs(testPath);    ContractTestUtils.assertIsDirectory(delegatedFS, testPath);    Path srcFile = new Path(testPath, "src.txt");    Path destFile = new Path(testPath, "dest.txt");    ContractTestUtils.touch(delegatedFS, srcFile);    ContractTestUtils.rename(delegatedFS, srcFile, destFile);        ContractTestUtils.assertIsFile(delegatedFS, destFile);    ContractTestUtils.assertDeleted(delegatedFS, testPath, true);  }    protected void verifyRestrictedPermissions(final S3AFileSystem delegatedFS)      throws Exception {    readLandsatMetadata(delegatedFS);  }  @Test  public void testDelegationBindingMismatch1() throws Throwable {    describe("Verify that when the DT client and remote bindings are different,"        + " the failure is meaningful");    S3AFileSystem fs = getFileSystem();    URI uri = fs.getUri();    UserGroupInformation.getCurrentUser().addCredentials(        createDelegationTokens());        Configuration conf = new Configuration(getConfiguration());    String bucket = fs.getBucket();    removeBaseAndBucketOverrides(bucket, conf,        ACCESS_KEY, SECRET_KEY, SESSION_TOKEN);    conf.set(ACCESS_KEY, "aaaaa");    conf.set(SECRET_KEY, "bbbb");    bindProviderList(bucket, conf, CountInvocationsProvider.NAME);    conf.set(DELEGATION_TOKEN_BINDING,        DELEGATION_TOKEN_FULL_CREDENTIALS_BINDING);    ServiceStateException e = intercept(        ServiceStateException.class,        TOKEN_MISMATCH,        () -> {          S3AFileSystem remote = newS3AInstance(uri, conf);                              String s = remote.toString();          remote.close();          return s;        });    if (!(e.getCause() instanceof DelegationTokenIOException)) {      throw e;    }  }  @Test  public void testDelegationBindingMismatch2() throws Throwable {    describe("assert mismatch reported when client DT is a "        + "subclass of the remote one");    S3AFileSystem fs = getFileSystem();    URI uri = fs.getUri();        Configuration conf = new Configuration(getConfiguration());    String bucket = fs.getBucket();    enableDelegationTokens(conf, DELEGATION_TOKEN_FULL_CREDENTIALS_BINDING);        Credentials fullTokens;    Token<AbstractS3ATokenIdentifier> firstDT;    try (S3AFileSystem fullFS = newS3AInstance(uri, conf)) {            fullTokens = mkTokens(fullFS);      assertTokenCreationCount(fullFS, 1);      firstDT = fullFS.getDelegationToken(          "first");      assertTokenCreationCount(fullFS, 2);      Token<AbstractS3ATokenIdentifier> secondDT = fullFS.getDelegationToken(          "second");      assertTokenCreationCount(fullFS, 3);      assertNotEquals("DT identifiers",          firstDT.getIdentifier(), secondDT.getIdentifier());    }        AbstractS3ATokenIdentifier origTokenId = requireNonNull(        lookupToken(            fullTokens,            uri,            FULL_TOKEN_KIND), "token from credentials");    UserGroupInformation.getCurrentUser().addCredentials(        fullTokens);        try (S3AFileSystem delegatedFS = newS3AInstance(uri, conf)) {      assertBoundToDT(delegatedFS, FULL_TOKEN_KIND);      delegatedFS.getFileStatus(new Path("/"));      SessionTokenIdentifier tokenFromDelegatedFS          = (SessionTokenIdentifier) requireNonNull(              delegatedFS.getDelegationToken(""), "New token")          .decodeIdentifier();      assertTokenCreationCount(delegatedFS, 0);      assertEquals("Newly issued token != old one",          origTokenId,          tokenFromDelegatedFS);    }        Configuration conf2 = new Configuration(getConfiguration());    removeBaseAndBucketOverrides(bucket, conf2,        ACCESS_KEY, SECRET_KEY, SESSION_TOKEN);    conf.set(DELEGATION_TOKEN_BINDING,        getDelegationBinding());    ServiceStateException e = intercept(ServiceStateException.class,        TOKEN_MISMATCH,        () -> {          S3AFileSystem remote = newS3AInstance(uri, conf);                              String s = remote.toString();          remote.close();          return s;        });    if (!(e.getCause() instanceof DelegationTokenIOException)) {      throw e;    }  }    protected ObjectMetadata readLandsatMetadata(final S3AFileSystem delegatedFS)      throws Exception {    AWSCredentialProviderList testingCreds        = delegatedFS.shareCredentials("testing");    URI landsat = new URI(DEFAULT_CSVTEST_FILE);    DefaultS3ClientFactory factory        = new DefaultS3ClientFactory();    factory.setConf(new Configuration(delegatedFS.getConf()));    String host = landsat.getHost();    S3ClientFactory.S3ClientCreationParameters parameters = null;    parameters = new S3ClientFactory.S3ClientCreationParameters()        .withCredentialSet(testingCreds)        .withEndpoint(DEFAULT_ENDPOINT)        .withMetrics(new EmptyS3AStatisticsContext()            .newStatisticsFromAwsSdk())        .withUserAgentSuffix("ITestSessionDelegationInFileystem");    AmazonS3 s3 = factory.createS3Client(landsat, parameters);    return Invoker.once("HEAD", host,        () -> s3.getObjectMetadata(host, landsat.getPath().substring(1)));  }    @Test  public void testYarnCredentialPickup() throws Throwable {    describe("Verify tokens are picked up by the YARN"        + " TokenCache.obtainTokensForNamenodes() API Call");    Credentials cred = new Credentials();    Path yarnPath = path("testYarnCredentialPickup");    Path[] paths = new Path[] {yarnPath};    Configuration conf = getConfiguration();    S3AFileSystem fs = getFileSystem();    TokenCache.obtainTokensForNamenodes(cred, paths, conf);    assertNotNull("No Token in credentials file",        lookupToken(            cred,            fs.getUri(),            getTokenKind()));  }    @Test  public void testHDFSFetchDTCommand() throws Throwable {    describe("Use the HDFS fetchdt CLI to fetch a token");    ExitUtil.disableSystemExit();    S3AFileSystem fs = getFileSystem();    Configuration conf = fs.getConf();    URI fsUri = fs.getUri();    String fsurl = fsUri.toString();    File tokenfile = createTempTokenFile();                String tokenFilePath = tokenfile.getAbsolutePath();        doAs(bobUser,        () -> DelegationTokenFetcher.main(conf,            args("--webservice", fsurl, tokenFilePath)));    assertTrue("token file was not created: " + tokenfile,        tokenfile.exists());        String s = DelegationTokenFetcher.printTokensToString(conf,        new Path(tokenfile.toURI()),        false);    LOG.info("Tokens: {}", s);    DelegationTokenFetcher.main(conf,        args("--print", tokenFilePath));    DelegationTokenFetcher.main(conf,        args("--print", "--verbose", tokenFilePath));        Credentials creds = Credentials.readTokenStorageFile(tokenfile, conf);    AbstractS3ATokenIdentifier identifier = requireNonNull(        lookupToken(            creds,            fsUri,            getTokenKind()), "Token lookup");    assertEquals("encryption secrets",        fs.getEncryptionSecrets(),        identifier.getEncryptionSecrets());    assertEquals("Username of decoded token",        bobUser.getUserName(), identifier.getUser().getUserName());        DelegationTokenFetcher.main(conf, args("--renew", tokenFilePath));        DelegationTokenFetcher.main(conf, args("--cancel", tokenFilePath));  }  protected File createTempTokenFile() throws IOException {    File tokenfile = File.createTempFile("tokens", ".bin",        cluster.getWorkDir());    tokenfile.delete();    return tokenfile;  }    private String[] args(String...args) {    return args;  }    @Test  public void testFileSystemBoundToCreator() throws Throwable {    describe("Run tests to verify the DT Setup is bound to the creator");        assertNotEquals("Alice and Bob logins",        aliceUser.getUserName(), bobUser.getUserName());    final S3AFileSystem fs = getFileSystem();    assertEquals("FS username in doAs()",        ALICE,        doAs(bobUser, () -> fs.getUsername()));    UserGroupInformation fsOwner = doAs(bobUser,        () -> fs.getDelegationTokens().get().getOwner());    assertEquals("username mismatch",        aliceUser.getUserName(), fsOwner.getUserName());    Token<AbstractS3ATokenIdentifier> dt = fs.getDelegationToken(ALICE);    AbstractS3ATokenIdentifier identifier        = dt.decodeIdentifier();    UserGroupInformation user = identifier.getUser();    assertEquals("User in DT",        aliceUser.getUserName(), user.getUserName());  }  protected String dtutil(int expected, String...args) throws Exception {    final ByteArrayOutputStream dtUtilContent = new ByteArrayOutputStream();    DtUtilShell dt = new DtUtilShell();    dt.setOut(new PrintStream(dtUtilContent));    dtUtilContent.reset();    int r =  doAs(aliceUser,        () ->ToolRunner.run(getConfiguration(), dt, args));    String s = dtUtilContent.toString();    LOG.info("\n{}", s);    assertEquals(expected, r);    return s;  }  @Test  public void testDTUtilShell() throws Throwable {    describe("Verify the dtutil shell command can fetch tokens");    File tokenfile = createTempTokenFile();    String tfs = tokenfile.toString();    String fsURI = getFileSystem().getCanonicalUri().toString();    dtutil(0,        "get", fsURI,        "-format", "protobuf",        tfs);    assertTrue("not created: " + tokenfile,        tokenfile.exists());    assertTrue("File is empty" + tokenfile,        tokenfile.length() > 0);    assertTrue("File only contains header" + tokenfile,        tokenfile.length() > 6);    String printed = dtutil(0, "print", tfs);    assertThat(printed, containsString(fsURI));    assertThat(printed, containsString(getTokenKind().toString()));  }}
public class ClientCache {  private Map<SocketFactory, Client> clients =    new HashMap<SocketFactory, Client>();    public synchronized Client getClient(Configuration conf,      SocketFactory factory, Class<? extends Writable> valueClass) {                        Client client = clients.get(factory);    if (client == null) {      client = new Client(valueClass, conf, factory);      clients.put(factory, client);    } else {      client.incCount();    }    if (Client.LOG.isDebugEnabled()) {      Client.LOG.debug("getting client out of cache: " + client);    }    return client;  }    public synchronized Client getClient(Configuration conf) {    return getClient(conf, SocketFactory.getDefault(), ObjectWritable.class);  }      public synchronized Client getClient(Configuration conf, SocketFactory factory) {    return this.getClient(conf, factory, ObjectWritable.class);  }    public void stopClient(Client client) {    if (Client.LOG.isDebugEnabled()) {      Client.LOG.debug("stopping client from cache: " + client);    }    final int count;    synchronized (this) {      count = client.decAndGetCount();      if (count == 0) {        if (Client.LOG.isDebugEnabled()) {          Client.LOG.debug("removing client from cache: " + client);        }        clients.remove(client.getSocketFactory());      }    }    if (count == 0) {      if (Client.LOG.isDebugEnabled()) {        Client.LOG.debug("stopping actual client because no more references remain: "            + client);      }      client.stop();    }  }  @VisibleForTesting  public void clearCache() {    clients.values().forEach(c -> c.stop());    clients.clear();  }}
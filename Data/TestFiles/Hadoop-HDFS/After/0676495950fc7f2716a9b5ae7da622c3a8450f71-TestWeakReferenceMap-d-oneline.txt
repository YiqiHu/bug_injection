public class TestWeakReferenceMap extends AbstractHadoopTestBase {  public static final String FACTORY_STRING = "recreated %d";    private WeakReferenceMap<Integer, String> referenceMap;    private List<Integer> lostReferences;  @Before  public void setup() {    lostReferences = new ArrayList<>();    referenceMap = new WeakReferenceMap<>(        this::factory,        this::referenceLost);  }    private void referenceLost(Integer key) {    lostReferences.add(key);  }    @Test  public void testBasicOperationsWithValidReferences() {    referenceMap.put(1, "1");    referenceMap.put(2, "2");    assertMapSize(2);    assertMapContainsKey(1);    assertMapEntryEquals(1, "1");    assertMapEntryEquals(2, "2");        referenceMap.put(1, "3");    assertMapEntryEquals(1, "3");        referenceMap.remove(1);    assertMapDoesNotContainKey(1);    assertMapSize(1);        referenceMap.clear();    assertMapSize(0);  }    @Test  public void testPruneNullEntries() {    referenceMap.put(1, "1");    assertPruned(0);    referenceMap.put(2, null);    assertMapSize(2);    assertPruned(1);    assertMapSize(1);    assertMapDoesNotContainKey(2);    assertMapEntryEquals(1, "1");    assertLostCount(1);  }    @Test  public void testDemandCreateEntries() {        assertMapEntryEquals(1, factory(1));    assertMapSize(1);    assertMapContainsKey(1);    assertLostCount(0);        referenceMap.put(2, null);    assertMapEntryEquals(2, factory(2));        assertLostCount(1);  }    @Test  public void testFactoryReturningNull() throws Throwable {    referenceMap = new WeakReferenceMap<>(        (k) -> null,            null);    intercept(NullPointerException.class, () ->        referenceMap.get(0));  }    @Test  public void testWeakReferenceThreadMapAssignment()      throws Throwable {        final AtomicLong created = new AtomicLong();    final AtomicLong lost = new AtomicLong();    WeakReferenceThreadMap<String> threadMap = new WeakReferenceThreadMap<>(        id -> "Entry for thread ID " + id + " (" + created.incrementAndGet() + ")",        id -> lost.incrementAndGet());    Assertions.assertThat(threadMap.setForCurrentThread("hello"))        .describedAs("current thread map value on first set")        .isNull();        Assertions.assertThat(threadMap.setForCurrentThread("hello"))        .describedAs("current thread map value on second set")        .isEqualTo("hello");        intercept(NullPointerException.class, () ->        threadMap.setForCurrentThread(null));        Assertions.assertThat(threadMap.getForCurrentThread())        .describedAs("current thread map value")        .isEqualTo("hello");        Assertions.assertThat(threadMap.removeForCurrentThread())        .describedAs("removed thread map value")        .isEqualTo("hello");        Assertions.assertThat(threadMap.removeForCurrentThread())        .describedAs("removed thread map value on second call")        .isNull();        long c1 = created.get();    String dynamicValue = threadMap.getForCurrentThread();    Assertions.assertThat(dynamicValue)        .describedAs("dynamically created thread map value")        .startsWith("Entry for thread ID")        .contains("(" + (c1 + 1) + ")");        Assertions.assertThat(threadMap.setForCurrentThread("hello2"))        .describedAs("value before the thread entry is changed")        .isEqualTo(dynamicValue);        long threadId = threadMap.currentThreadId();    threadMap.put(threadId, null);    String updated = threadMap.getForCurrentThread();    Assertions.assertThat(lost.get())        .describedAs("lost count")        .isEqualTo(1);    Assertions.assertThat(updated)        .describedAs("dynamically created thread map value")        .startsWith("Entry for thread ID")        .contains("(" + (c1 + 2) + ")");  }    private void assertMapEntryEquals(int key, String val) {    Assertions.assertThat(referenceMap.get(key))        .describedAs("map enty of key %d", key)        .isEqualTo(val);  }    private void assertMapContainsKey(int key) {    Assertions.assertThat(referenceMap.containsKey(key))        .describedAs("map entry of key %d should be present", key)        .isTrue();  }    private void assertMapDoesNotContainKey(int key) {    Assertions.assertThat(referenceMap.containsKey(key))        .describedAs("map enty of key %d should be absent", key)        .isFalse();  }    private void assertMapSize(int size) {    Assertions.assertThat(referenceMap.size())        .describedAs("size of map %s", referenceMap)        .isEqualTo(size);  }    private void assertPruned(int count) {    Assertions.assertThat(referenceMap.prune())        .describedAs("number of entries pruned from map %s", referenceMap)        .isEqualTo(count);  }    private void assertLostCount(int count) {    Assertions.assertThat(lostReferences)        .describedAs("number of entries lost from map %s", referenceMap)        .hasSize(count);  }    private String factory(Integer key) {    return String.format(FACTORY_STRING, key);  }}
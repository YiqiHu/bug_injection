public class TestKerberosAuthenticator extends KerberosSecurityTestcase {  public TestKerberosAuthenticator() {  }  @Before  public void setup() throws Exception {        File keytabFile = new File(KerberosTestUtils.getKeytabFile());    String clientPrincipal = KerberosTestUtils.getClientPrincipal();    String serverPrincipal = KerberosTestUtils.getServerPrincipal();    clientPrincipal = clientPrincipal.substring(0, clientPrincipal.lastIndexOf("@"));    serverPrincipal = serverPrincipal.substring(0, serverPrincipal.lastIndexOf("@"));    getKdc().createPrincipal(keytabFile, clientPrincipal, serverPrincipal);  }  private Properties getAuthenticationHandlerConfiguration() {    Properties props = new Properties();    props.setProperty(AuthenticationFilter.AUTH_TYPE, "kerberos");    props.setProperty(KerberosAuthenticationHandler.PRINCIPAL, KerberosTestUtils.getServerPrincipal());    props.setProperty(KerberosAuthenticationHandler.KEYTAB, KerberosTestUtils.getKeytabFile());    props.setProperty(KerberosAuthenticationHandler.NAME_RULES,                      "RULE:[1:$1@$0](.*@" + KerberosTestUtils.getRealm()+")s/@.*//\n");    props.setProperty(KerberosAuthenticationHandler.RULE_MECHANISM, "hadoop");    return props;  }  private Properties getMultiAuthHandlerConfiguration() {    Properties props = new Properties();    props.setProperty(AUTH_TYPE, MultiSchemeAuthenticationHandler.TYPE);    props.setProperty(SCHEMES_PROPERTY, "negotiate");    props.setProperty(String.format(AUTH_HANDLER_PROPERTY, "negotiate"),        "kerberos");    props.setProperty(PRINCIPAL, KerberosTestUtils.getServerPrincipal());    props.setProperty(KEYTAB, KerberosTestUtils.getKeytabFile());    props.setProperty(NAME_RULES,        "RULE:[1:$1@$0](.*@" + KerberosTestUtils.getRealm() + ")s/@.*//\n");    return props;  }  @Test(timeout=60000)  public void testFallbacktoPseudoAuthenticator() throws Exception {    AuthenticatorTestCase auth = new AuthenticatorTestCase();    Properties props = new Properties();    props.setProperty(AuthenticationFilter.AUTH_TYPE, "simple");    props.setProperty(PseudoAuthenticationHandler.ANONYMOUS_ALLOWED, "false");    AuthenticatorTestCase.setAuthenticationHandlerConfig(props);    auth._testAuthentication(new KerberosAuthenticator(), false);  }  @Test(timeout=60000)  public void testFallbacktoPseudoAuthenticatorAnonymous() throws Exception {    AuthenticatorTestCase auth = new AuthenticatorTestCase();    Properties props = new Properties();    props.setProperty(AuthenticationFilter.AUTH_TYPE, "simple");    props.setProperty(PseudoAuthenticationHandler.ANONYMOUS_ALLOWED, "true");    AuthenticatorTestCase.setAuthenticationHandlerConfig(props);    auth._testAuthentication(new KerberosAuthenticator(), false);  }  @Test(timeout=60000)  public void testNotAuthenticated() throws Exception {    AuthenticatorTestCase auth = new AuthenticatorTestCase();    AuthenticatorTestCase.setAuthenticationHandlerConfig(getAuthenticationHandlerConfiguration());    auth.start();    try {      URL url = new URL(auth.getBaseURL());      HttpURLConnection conn = (HttpURLConnection) url.openConnection();      conn.connect();      Assert.assertEquals(HttpURLConnection.HTTP_UNAUTHORIZED, conn.getResponseCode());      Assert.assertTrue(conn.getHeaderField(KerberosAuthenticator.WWW_AUTHENTICATE) != null);    } finally {      auth.stop();    }  }  @Test(timeout=60000)  public void testAuthentication() throws Exception {    final AuthenticatorTestCase auth = new AuthenticatorTestCase();    AuthenticatorTestCase.setAuthenticationHandlerConfig(            getAuthenticationHandlerConfiguration());    KerberosTestUtils.doAsClient(new Callable<Void>() {      @Override      public Void call() throws Exception {        auth._testAuthentication(new KerberosAuthenticator(), false);        return null;      }    });  }  @Test(timeout=60000)  public void testAuthenticationPost() throws Exception {    final AuthenticatorTestCase auth = new AuthenticatorTestCase();    AuthenticatorTestCase.setAuthenticationHandlerConfig(            getAuthenticationHandlerConfiguration());    KerberosTestUtils.doAsClient(new Callable<Void>() {      @Override      public Void call() throws Exception {        auth._testAuthentication(new KerberosAuthenticator(), true);        return null;      }    });  }  @Test(timeout=60000)  public void testAuthenticationHttpClient() throws Exception {    final AuthenticatorTestCase auth = new AuthenticatorTestCase();    AuthenticatorTestCase.setAuthenticationHandlerConfig(            getAuthenticationHandlerConfiguration());    KerberosTestUtils.doAsClient(new Callable<Void>() {      @Override      public Void call() throws Exception {        auth._testAuthenticationHttpClient(new KerberosAuthenticator(), false);        return null;      }    });  }  @Test(timeout=60000)  public void testAuthenticationHttpClientPost() throws Exception {    final AuthenticatorTestCase auth = new AuthenticatorTestCase();    AuthenticatorTestCase.setAuthenticationHandlerConfig(            getAuthenticationHandlerConfiguration());    KerberosTestUtils.doAsClient(new Callable<Void>() {      @Override      public Void call() throws Exception {        auth._testAuthenticationHttpClient(new KerberosAuthenticator(), true);        return null;      }    });  }  @Test(timeout = 60000)  public void testNotAuthenticatedWithMultiAuthHandler() throws Exception {    AuthenticatorTestCase auth = new AuthenticatorTestCase();    AuthenticatorTestCase        .setAuthenticationHandlerConfig(getMultiAuthHandlerConfiguration());    auth.start();    try {      URL url = new URL(auth.getBaseURL());      HttpURLConnection conn = (HttpURLConnection) url.openConnection();      conn.connect();      Assert.assertEquals(HttpURLConnection.HTTP_UNAUTHORIZED,          conn.getResponseCode());      Assert.assertTrue(conn          .getHeaderField(KerberosAuthenticator.WWW_AUTHENTICATE) != null);    } finally {      auth.stop();    }  }  @Test(timeout = 60000)  public void testAuthenticationWithMultiAuthHandler() throws Exception {    final AuthenticatorTestCase auth = new AuthenticatorTestCase();    AuthenticatorTestCase        .setAuthenticationHandlerConfig(getMultiAuthHandlerConfiguration());    KerberosTestUtils.doAsClient(new Callable<Void>() {      @Override      public Void call() throws Exception {        auth._testAuthentication(new KerberosAuthenticator(), false);        return null;      }    });  }  @Test(timeout = 60000)  public void testAuthenticationHttpClientPostWithMultiAuthHandler()      throws Exception {    final AuthenticatorTestCase auth = new AuthenticatorTestCase();    AuthenticatorTestCase        .setAuthenticationHandlerConfig(getMultiAuthHandlerConfiguration());    KerberosTestUtils.doAsClient(new Callable<Void>() {      @Override      public Void call() throws Exception {        auth._testAuthenticationHttpClient(new KerberosAuthenticator(), true);        return null;      }    });  }  @Test(timeout = 60000)  public void testWrapExceptionWithMessage() {    IOException ex;    ex = new IOException("Induced exception");    ex = KerberosAuthenticator.wrapExceptionWithMessage(ex, "Error while "        + "authenticating with endpoint: localhost");    Assert.assertEquals("Induced exception", ex.getCause().getMessage());    Assert.assertEquals("Error while authenticating with endpoint: localhost",        ex.getMessage());    ex = new AuthenticationException("Auth exception");    ex = KerberosAuthenticator.wrapExceptionWithMessage(ex, "Error while "        + "authenticating with endpoint: localhost");    Assert.assertEquals("Auth exception", ex.getCause().getMessage());    Assert.assertEquals("Error while authenticating with endpoint: localhost",        ex.getMessage());            ex = new CharacterCodingException();    Exception ex2 = KerberosAuthenticator.wrapExceptionWithMessage(ex,        "Error while authenticating with endpoint: localhost");    Assert.assertTrue(ex instanceof CharacterCodingException);    Assert.assertTrue(ex.equals(ex2));  }  @Test(timeout = 60000)  public void testNegotiate() throws NoSuchMethodException, InvocationTargetException,          IllegalAccessException, IOException {    KerberosAuthenticator kerberosAuthenticator = new KerberosAuthenticator();    HttpURLConnection conn = Mockito.mock(HttpURLConnection.class);    Mockito.when(conn.getHeaderField(KerberosAuthenticator.WWW_AUTHENTICATE)).            thenReturn(KerberosAuthenticator.NEGOTIATE);    Mockito.when(conn.getResponseCode()).thenReturn(HttpURLConnection.HTTP_UNAUTHORIZED);    Method method = KerberosAuthenticator.class.getDeclaredMethod("isNegotiate",            HttpURLConnection.class);    method.setAccessible(true);    Assert.assertTrue((boolean)method.invoke(kerberosAuthenticator, conn));  }  @Test(timeout = 60000)  public void testNegotiateLowerCase() throws NoSuchMethodException, InvocationTargetException,          IllegalAccessException, IOException {    KerberosAuthenticator kerberosAuthenticator = new KerberosAuthenticator();    HttpURLConnection conn = Mockito.mock(HttpURLConnection.class);    Mockito.when(conn.getHeaderField("www-authenticate"))            .thenReturn(KerberosAuthenticator.NEGOTIATE);    Mockito.when(conn.getResponseCode()).thenReturn(HttpURLConnection.HTTP_UNAUTHORIZED);    Method method = KerberosAuthenticator.class.getDeclaredMethod("isNegotiate",            HttpURLConnection.class);    method.setAccessible(true);    Assert.assertTrue((boolean)method.invoke(kerberosAuthenticator, conn));  }  @Test(timeout = 60000)  public void testReadToken() throws NoSuchMethodException, IOException, IllegalAccessException,          InvocationTargetException {    KerberosAuthenticator kerberosAuthenticator = new KerberosAuthenticator();    FieldUtils.writeField(kerberosAuthenticator, "base64", new Base64(), true);    Base64 base64 = new Base64();    HttpURLConnection conn = Mockito.mock(HttpURLConnection.class);    Mockito.when(conn.getResponseCode()).thenReturn(HttpURLConnection.HTTP_UNAUTHORIZED);    Mockito.when(conn.getHeaderField(KerberosAuthenticator.WWW_AUTHENTICATE))            .thenReturn(KerberosAuthenticator.NEGOTIATE + " " +                    Arrays.toString(base64.encode("foobar".getBytes())));    Method method = KerberosAuthenticator.class.getDeclaredMethod("readToken",            HttpURLConnection.class);    method.setAccessible(true);    method.invoke(kerberosAuthenticator, conn);   }  @Test(timeout = 60000)  public void testReadTokenLowerCase() throws NoSuchMethodException, IOException,          IllegalAccessException, InvocationTargetException {    KerberosAuthenticator kerberosAuthenticator = new KerberosAuthenticator();    FieldUtils.writeField(kerberosAuthenticator, "base64", new Base64(), true);    Base64 base64 = new Base64();    HttpURLConnection conn = Mockito.mock(HttpURLConnection.class);    Mockito.when(conn.getResponseCode()).thenReturn(HttpURLConnection.HTTP_UNAUTHORIZED);    Mockito.when(conn.getHeaderField("www-authenticate"))            .thenReturn(KerberosAuthenticator.NEGOTIATE +                    Arrays.toString(base64.encode("foobar".getBytes())));    Method method = KerberosAuthenticator.class.getDeclaredMethod("readToken",            HttpURLConnection.class);    method.setAccessible(true);    method.invoke(kerberosAuthenticator, conn);   }}
public abstract class FileSystem extends Configured    implements Closeable, DelegationTokenIssuer, PathCapabilities {  public static final String FS_DEFAULT_NAME_KEY =                   CommonConfigurationKeys.FS_DEFAULT_NAME_KEY;  public static final String DEFAULT_FS =                   CommonConfigurationKeys.FS_DEFAULT_NAME_DEFAULT;    @InterfaceAudience.Private  public static final Log LOG = LogFactory.getLog(FileSystem.class);    private static final Logger LOGGER =      LoggerFactory.getLogger(FileSystem.class);    public static final int SHUTDOWN_HOOK_PRIORITY = 10;    public static final String TRASH_PREFIX = ".Trash";  public static final String USER_HOME_PREFIX = "/user";    static final Cache CACHE = new Cache();    private Cache.Key key;    private static final Map<Class<? extends FileSystem>, Statistics>      statisticsTable = new IdentityHashMap<>();    protected Statistics statistics;    private final Set<Path> deleteOnExit = new TreeSet<>();    boolean resolveSymlinks;    @VisibleForTesting  static void addFileSystemForTesting(URI uri, Configuration conf,      FileSystem fs) throws IOException {    CACHE.map.put(new Cache.Key(uri, conf), fs);  }  @VisibleForTesting  static void removeFileSystemForTesting(URI uri, Configuration conf,      FileSystem fs) throws IOException {    CACHE.map.remove(new Cache.Key(uri, conf), fs);  }  @VisibleForTesting  static int cacheSize() {    return CACHE.map.size();  }    public static FileSystem get(final URI uri, final Configuration conf,        final String user) throws IOException, InterruptedException {    String ticketCachePath =      conf.get(CommonConfigurationKeys.KERBEROS_TICKET_CACHE_PATH);    UserGroupInformation ugi =        UserGroupInformation.getBestUGI(ticketCachePath, user);    return ugi.doAs(new PrivilegedExceptionAction<FileSystem>() {      @Override      public FileSystem run() throws IOException {        return get(uri, conf);      }    });  }    public static FileSystem get(Configuration conf) throws IOException {    return get(getDefaultUri(conf), conf);  }    public static URI getDefaultUri(Configuration conf) {    URI uri =        URI.create(fixName(conf.getTrimmed(FS_DEFAULT_NAME_KEY, DEFAULT_FS)));    if (uri.getScheme() == null) {      throw new IllegalArgumentException("No scheme in default FS: " + uri);    }    return uri;  }    public static void setDefaultUri(Configuration conf, URI uri) {    conf.set(FS_DEFAULT_NAME_KEY, uri.toString());  }    public static void setDefaultUri(Configuration conf, String uri) {    setDefaultUri(conf, URI.create(fixName(uri)));  }    public void initialize(URI name, Configuration conf) throws IOException {    final String scheme;    if (name.getScheme() == null || name.getScheme().isEmpty()) {      scheme = getDefaultUri(conf).getScheme();    } else {      scheme = name.getScheme();    }    statistics = getStatistics(scheme, getClass());    resolveSymlinks = conf.getBoolean(        CommonConfigurationKeysPublic.FS_CLIENT_RESOLVE_REMOTE_SYMLINKS_KEY,        CommonConfigurationKeysPublic.FS_CLIENT_RESOLVE_REMOTE_SYMLINKS_DEFAULT);  }    public String getScheme() {    throw new UnsupportedOperationException("Not implemented by the "        + getClass().getSimpleName() + " FileSystem implementation");  }    public abstract URI getUri();    protected URI getCanonicalUri() {    return canonicalizeUri(getUri());  }    protected URI canonicalizeUri(URI uri) {    if (uri.getPort() == -1 && getDefaultPort() > 0) {            try {        uri = new URI(uri.getScheme(), uri.getUserInfo(),            uri.getHost(), getDefaultPort(),            uri.getPath(), uri.getQuery(), uri.getFragment());      } catch (URISyntaxException e) {                throw new AssertionError("Valid URI became unparseable: " +            uri);      }    }    return uri;  }    protected int getDefaultPort() {    return 0;  }  protected static FileSystem getFSofPath(final Path absOrFqPath,      final Configuration conf)      throws UnsupportedFileSystemException, IOException {    absOrFqPath.checkNotSchemeWithRelative();    absOrFqPath.checkNotRelative();        return get(absOrFqPath.toUri(), conf);  }    @InterfaceAudience.Public  @InterfaceStability.Evolving  @Override  public String getCanonicalServiceName() {    return (getChildFileSystems() == null)      ? SecurityUtil.buildDTServiceName(getUri(), getDefaultPort())      : null;  }    @Deprecated  public String getName() { return getUri().toString(); }    @Deprecated  public static FileSystem getNamed(String name, Configuration conf)    throws IOException {    return get(URI.create(fixName(name)), conf);  }    private static String fixName(String name) {        if (name.equals("local")) {               LOGGER.warn("\"local\" is a deprecated filesystem name."               +" Use \"file:///\" instead.");      name = "file:///";    } else if (name.indexOf('/')==-1) {         LOGGER.warn("\""+name+"\" is a deprecated filesystem name."               +" Use \"hdfs://"+name+"/\" instead.");      name = "hdfs://"+name;    }    return name;  }    public static LocalFileSystem getLocal(Configuration conf)    throws IOException {    return (LocalFileSystem)get(LocalFileSystem.NAME, conf);  }    public static FileSystem get(URI uri, Configuration conf) throws IOException {    String scheme = uri.getScheme();    String authority = uri.getAuthority();    if (scheme == null && authority == null) {           return get(conf);    }    if (scheme != null && authority == null) {           URI defaultUri = getDefaultUri(conf);      if (scheme.equals(defaultUri.getScheme())              && defaultUri.getAuthority() != null) {          return get(defaultUri, conf);                    }    }    String disableCacheName = String.format("fs.%s.impl.disable.cache", scheme);    if (conf.getBoolean(disableCacheName, false)) {      LOGGER.debug("Bypassing cache to create filesystem {}", uri);      return createFileSystem(uri, conf);    }    return CACHE.get(uri, conf);  }    public static FileSystem newInstance(final URI uri, final Configuration conf,      final String user) throws IOException, InterruptedException {    String ticketCachePath =      conf.get(CommonConfigurationKeys.KERBEROS_TICKET_CACHE_PATH);    UserGroupInformation ugi =        UserGroupInformation.getBestUGI(ticketCachePath, user);    return ugi.doAs(new PrivilegedExceptionAction<FileSystem>() {      @Override      public FileSystem run() throws IOException {        return newInstance(uri, conf);      }    });  }    public static FileSystem newInstance(URI uri, Configuration config)      throws IOException {    String scheme = uri.getScheme();    String authority = uri.getAuthority();    if (scheme == null) {                             return newInstance(config);    }    if (authority == null) {                             URI defaultUri = getDefaultUri(config);      if (scheme.equals(defaultUri.getScheme())              && defaultUri.getAuthority() != null) {          return newInstance(defaultUri, config);                    }    }    return CACHE.getUnique(uri, config);  }    public static FileSystem newInstance(Configuration conf) throws IOException {    return newInstance(getDefaultUri(conf), conf);  }    public static LocalFileSystem newInstanceLocal(Configuration conf)    throws IOException {    return (LocalFileSystem)newInstance(LocalFileSystem.NAME, conf);  }    public static void closeAll() throws IOException {    CACHE.closeAll();  }    public static void closeAllForUGI(UserGroupInformation ugi)  throws IOException {    CACHE.closeAll(ugi);  }    public Path makeQualified(Path path) {    checkPath(path);    return path.makeQualified(this.getUri(), this.getWorkingDirectory());  }    @InterfaceAudience.Private()  @Override  public Token<?> getDelegationToken(String renewer) throws IOException {    return null;  }    @InterfaceAudience.LimitedPrivate({ "HDFS" })  @VisibleForTesting  public FileSystem[] getChildFileSystems() {    return null;  }  @InterfaceAudience.Private  @Override  public DelegationTokenIssuer[] getAdditionalTokenIssuers()      throws IOException {    return getChildFileSystems();  }    public static FSDataOutputStream create(FileSystem fs,      Path file, FsPermission permission) throws IOException {        FSDataOutputStream out = fs.create(file);        fs.setPermission(file, permission);    return out;  }    public static boolean mkdirs(FileSystem fs, Path dir, FsPermission permission)      throws IOException {        boolean result = fs.mkdirs(dir);        fs.setPermission(dir, permission);    return result;  }        protected FileSystem() {    super(null);  }    protected void checkPath(Path path) {    Preconditions.checkArgument(path != null, "null path");    URI uri = path.toUri();    String thatScheme = uri.getScheme();    if (thatScheme == null)                      return;    URI thisUri = getCanonicalUri();    String thisScheme = thisUri.getScheme();        if (thisScheme.equalsIgnoreCase(thatScheme)) {      String thisAuthority = thisUri.getAuthority();      String thatAuthority = uri.getAuthority();      if (thatAuthority == null &&                          thisAuthority != null) {                        URI defaultUri = getDefaultUri(getConf());        if (thisScheme.equalsIgnoreCase(defaultUri.getScheme())) {          uri = defaultUri;         } else {          uri = null;         }      }      if (uri != null) {                uri = canonicalizeUri(uri);        thatAuthority = uri.getAuthority();        if (thisAuthority == thatAuthority ||                   (thisAuthority != null &&             thisAuthority.equalsIgnoreCase(thatAuthority)))          return;      }    }    throw new IllegalArgumentException("Wrong FS: " + path +                                       ", expected: " + this.getUri());  }    public BlockLocation[] getFileBlockLocations(FileStatus file,      long start, long len) throws IOException {    if (file == null) {      return null;    }    if (start < 0 || len < 0) {      throw new IllegalArgumentException("Invalid start or len parameter");    }    if (file.getLen() <= start) {      return new BlockLocation[0];    }    String[] name = {"localhost:9866"};    String[] host = {"localhost"};    return new BlockLocation[] {      new BlockLocation(name, host, 0, file.getLen()) };  }    public BlockLocation[] getFileBlockLocations(Path p,      long start, long len) throws IOException {    if (p == null) {      throw new NullPointerException();    }    FileStatus file = getFileStatus(p);    return getFileBlockLocations(file, start, len);  }    @Deprecated  public FsServerDefaults getServerDefaults() throws IOException {    Configuration config = getConf();                return new FsServerDefaults(getDefaultBlockSize(),        config.getInt("io.bytes.per.checksum", 512),        64 * 1024,        getDefaultReplication(),        config.getInt(IO_FILE_BUFFER_SIZE_KEY, IO_FILE_BUFFER_SIZE_DEFAULT),        false,        FS_TRASH_INTERVAL_DEFAULT,        DataChecksum.Type.CRC32,        "");  }    public FsServerDefaults getServerDefaults(Path p) throws IOException {    return getServerDefaults();  }     public Path resolvePath(final Path p) throws IOException {     checkPath(p);     return getFileStatus(p).getPath();   }    public abstract FSDataInputStream open(Path f, int bufferSize)    throws IOException;    public FSDataInputStream open(Path f) throws IOException {    return open(f, getConf().getInt(IO_FILE_BUFFER_SIZE_KEY,        IO_FILE_BUFFER_SIZE_DEFAULT));  }    public FSDataInputStream open(PathHandle fd) throws IOException {    return open(fd, getConf().getInt(IO_FILE_BUFFER_SIZE_KEY,        IO_FILE_BUFFER_SIZE_DEFAULT));  }    public FSDataInputStream open(PathHandle fd, int bufferSize)      throws IOException {    throw new UnsupportedOperationException();  }    public final PathHandle getPathHandle(FileStatus stat, HandleOpt... opt) {            if (null == opt || 0 == opt.length) {      return createPathHandle(stat, HandleOpt.path());    }    return createPathHandle(stat, opt);  }    protected PathHandle createPathHandle(FileStatus stat, HandleOpt... opt) {    throw new UnsupportedOperationException();  }    public FSDataOutputStream create(Path f) throws IOException {    return create(f, true);  }    public FSDataOutputStream create(Path f, boolean overwrite)      throws IOException {    return create(f, overwrite,                  getConf().getInt(IO_FILE_BUFFER_SIZE_KEY,                      IO_FILE_BUFFER_SIZE_DEFAULT),                  getDefaultReplication(f),                  getDefaultBlockSize(f));  }    public FSDataOutputStream create(Path f, Progressable progress)      throws IOException {    return create(f, true,                  getConf().getInt(IO_FILE_BUFFER_SIZE_KEY,                      IO_FILE_BUFFER_SIZE_DEFAULT),                  getDefaultReplication(f),                  getDefaultBlockSize(f), progress);  }    public FSDataOutputStream create(Path f, short replication)      throws IOException {    return create(f, true,                  getConf().getInt(IO_FILE_BUFFER_SIZE_KEY,                      IO_FILE_BUFFER_SIZE_DEFAULT),                  replication,                  getDefaultBlockSize(f));  }    public FSDataOutputStream create(Path f, short replication,      Progressable progress) throws IOException {    return create(f, true,                  getConf().getInt(IO_FILE_BUFFER_SIZE_KEY,                      IO_FILE_BUFFER_SIZE_DEFAULT),                  replication, getDefaultBlockSize(f), progress);  }    public FSDataOutputStream create(Path f,                                   boolean overwrite,                                   int bufferSize                                   ) throws IOException {    return create(f, overwrite, bufferSize,                  getDefaultReplication(f),                  getDefaultBlockSize(f));  }    public FSDataOutputStream create(Path f,                                   boolean overwrite,                                   int bufferSize,                                   Progressable progress                                   ) throws IOException {    return create(f, overwrite, bufferSize,                  getDefaultReplication(f),                  getDefaultBlockSize(f), progress);  }    public FSDataOutputStream create(Path f,      boolean overwrite,      int bufferSize,      short replication,      long blockSize) throws IOException {    return create(f, overwrite, bufferSize, replication, blockSize, null);  }    public FSDataOutputStream create(Path f,                                            boolean overwrite,                                            int bufferSize,                                            short replication,                                            long blockSize,                                            Progressable progress                                            ) throws IOException {    return this.create(f, FsCreateModes.applyUMask(        FsPermission.getFileDefault(), FsPermission.getUMask(getConf())),        overwrite, bufferSize, replication, blockSize, progress);  }    public abstract FSDataOutputStream create(Path f,      FsPermission permission,      boolean overwrite,      int bufferSize,      short replication,      long blockSize,      Progressable progress) throws IOException;    public FSDataOutputStream create(Path f,      FsPermission permission,      EnumSet<CreateFlag> flags,      int bufferSize,      short replication,      long blockSize,      Progressable progress) throws IOException {    return create(f, permission, flags, bufferSize, replication,        blockSize, progress, null);  }    public FSDataOutputStream create(Path f,      FsPermission permission,      EnumSet<CreateFlag> flags,      int bufferSize,      short replication,      long blockSize,      Progressable progress,      ChecksumOpt checksumOpt) throws IOException {                return create(f, permission, flags.contains(CreateFlag.OVERWRITE),        bufferSize, replication, blockSize, progress);  }    @Deprecated  protected FSDataOutputStream primitiveCreate(Path f,      FsPermission absolutePermission,      EnumSet<CreateFlag> flag,      int bufferSize,      short replication,      long blockSize,      Progressable progress,      ChecksumOpt checksumOpt) throws IOException {    boolean pathExists = exists(f);    CreateFlag.validate(f, pathExists, flag);                    if (pathExists && flag.contains(CreateFlag.APPEND)) {      return append(f, bufferSize, progress);    }    return this.create(f, absolutePermission,        flag.contains(CreateFlag.OVERWRITE), bufferSize, replication,        blockSize, progress);  }    @Deprecated  protected boolean primitiveMkdir(Path f, FsPermission absolutePermission)    throws IOException {   return this.mkdirs(f, absolutePermission);  }    @Deprecated  protected void primitiveMkdir(Path f, FsPermission absolutePermission,                    boolean createParent)    throws IOException {    if (!createParent) {                   final FileStatus stat = getFileStatus(f.getParent());      if (stat == null) {        throw new FileNotFoundException("Missing parent:" + f);      }      if (!stat.isDirectory()) {        throw new ParentNotDirectoryException("parent is not a dir");      }          }                if (!this.mkdirs(f, absolutePermission)) {      throw new IOException("mkdir of "+ f + " failed");    }  }    public FSDataOutputStream createNonRecursive(Path f,      boolean overwrite,      int bufferSize, short replication, long blockSize,      Progressable progress) throws IOException {    return this.createNonRecursive(f, FsPermission.getFileDefault(),        overwrite, bufferSize, replication, blockSize, progress);  }     public FSDataOutputStream createNonRecursive(Path f, FsPermission permission,       boolean overwrite, int bufferSize, short replication, long blockSize,       Progressable progress) throws IOException {     return createNonRecursive(f, permission,         overwrite ? EnumSet.of(CreateFlag.CREATE, CreateFlag.OVERWRITE)             : EnumSet.of(CreateFlag.CREATE), bufferSize,             replication, blockSize, progress);   }       public FSDataOutputStream createNonRecursive(Path f, FsPermission permission,        EnumSet<CreateFlag> flags, int bufferSize, short replication, long blockSize,        Progressable progress) throws IOException {      throw new IOException("createNonRecursive unsupported for this filesystem "          + this.getClass());    }    public boolean createNewFile(Path f) throws IOException {    if (exists(f)) {      return false;    } else {      create(f, false, getConf().getInt(IO_FILE_BUFFER_SIZE_KEY,          IO_FILE_BUFFER_SIZE_DEFAULT)).close();      return true;    }  }    public FSDataOutputStream append(Path f) throws IOException {    return append(f, getConf().getInt(IO_FILE_BUFFER_SIZE_KEY,        IO_FILE_BUFFER_SIZE_DEFAULT), null);  }    public FSDataOutputStream append(Path f, int bufferSize) throws IOException {    return append(f, bufferSize, null);  }    public abstract FSDataOutputStream append(Path f, int bufferSize,      Progressable progress) throws IOException;    public void concat(final Path trg, final Path [] psrcs) throws IOException {    throw new UnsupportedOperationException("Not implemented by the " +        getClass().getSimpleName() + " FileSystem implementation");  }   @Deprecated  public short getReplication(Path src) throws IOException {    return getFileStatus(src).getReplication();  }    public boolean setReplication(Path src, short replication)    throws IOException {    return true;  }    public abstract boolean rename(Path src, Path dst) throws IOException;    @Deprecated  protected void rename(final Path src, final Path dst,      final Rename... options) throws IOException {        final FileStatus srcStatus = getFileLinkStatus(src);    if (srcStatus == null) {      throw new FileNotFoundException("rename source " + src + " not found.");    }    boolean overwrite = false;    if (null != options) {      for (Rename option : options) {        if (option == Rename.OVERWRITE) {          overwrite = true;        }      }    }    FileStatus dstStatus;    try {      dstStatus = getFileLinkStatus(dst);    } catch (IOException e) {      dstStatus = null;    }    if (dstStatus != null) {      if (srcStatus.isDirectory() != dstStatus.isDirectory()) {        throw new IOException("Source " + src + " Destination " + dst            + " both should be either file or directory");      }      if (!overwrite) {        throw new FileAlreadyExistsException("rename destination " + dst            + " already exists.");      }            if (dstStatus.isDirectory()) {        FileStatus[] list = listStatus(dst);        if (list != null && list.length != 0) {          throw new IOException(              "rename cannot overwrite non empty destination directory " + dst);        }      }      delete(dst, false);    } else {      final Path parent = dst.getParent();      final FileStatus parentStatus = getFileStatus(parent);      if (parentStatus == null) {        throw new FileNotFoundException("rename destination parent " + parent            + " not found.");      }      if (!parentStatus.isDirectory()) {        throw new ParentNotDirectoryException("rename destination parent " + parent            + " is a file.");      }    }    if (!rename(src, dst)) {      throw new IOException("rename from " + src + " to " + dst + " failed.");    }  }    public boolean truncate(Path f, long newLength) throws IOException {    throw new UnsupportedOperationException("Not implemented by the " +        getClass().getSimpleName() + " FileSystem implementation");  }    @Deprecated  public boolean delete(Path f) throws IOException {    return delete(f, true);  }    public abstract boolean delete(Path f, boolean recursive) throws IOException;    public boolean deleteOnExit(Path f) throws IOException {    if (!exists(f)) {      return false;    }    synchronized (deleteOnExit) {      deleteOnExit.add(f);    }    return true;  }    public boolean cancelDeleteOnExit(Path f) {    synchronized (deleteOnExit) {      return deleteOnExit.remove(f);    }  }    protected void processDeleteOnExit() {    synchronized (deleteOnExit) {      for (Iterator<Path> iter = deleteOnExit.iterator(); iter.hasNext();) {        Path path = iter.next();        try {          if (exists(path)) {            delete(path, true);          }        }        catch (IOException e) {          LOGGER.info("Ignoring failure to deleteOnExit for path {}", path);        }        iter.remove();      }    }  }    public boolean exists(Path f) throws IOException {    try {      return getFileStatus(f) != null;    } catch (FileNotFoundException e) {      return false;    }  }    @Deprecated  public boolean isDirectory(Path f) throws IOException {    try {      return getFileStatus(f).isDirectory();    } catch (FileNotFoundException e) {      return false;                   }  }    @Deprecated  public boolean isFile(Path f) throws IOException {    try {      return getFileStatus(f).isFile();    } catch (FileNotFoundException e) {      return false;                   }  }    @Deprecated  public long getLength(Path f) throws IOException {    return getFileStatus(f).getLen();  }    public ContentSummary getContentSummary(Path f) throws IOException {    FileStatus status = getFileStatus(f);    if (status.isFile()) {            long length = status.getLen();      return new ContentSummary.Builder().length(length).          fileCount(1).directoryCount(0).spaceConsumed(length).build();    }        long[] summary = {0, 0, 1};    for(FileStatus s : listStatus(f)) {      long length = s.getLen();      ContentSummary c = s.isDirectory() ? getContentSummary(s.getPath()) :          new ContentSummary.Builder().length(length).          fileCount(1).directoryCount(0).spaceConsumed(length).build();      summary[0] += c.getLength();      summary[1] += c.getFileCount();      summary[2] += c.getDirectoryCount();    }    return new ContentSummary.Builder().length(summary[0]).        fileCount(summary[1]).directoryCount(summary[2]).        spaceConsumed(summary[0]).build();  }    public QuotaUsage getQuotaUsage(Path f) throws IOException {    return getContentSummary(f);  }    public void setQuota(Path src, final long namespaceQuota,      final long storagespaceQuota) throws IOException {    methodNotSupported();  }    public void setQuotaByStorageType(Path src, final StorageType type,      final long quota) throws IOException {    methodNotSupported();  }    private static final PathFilter DEFAULT_FILTER = new PathFilter() {      @Override      public boolean accept(Path file) {        return true;      }    };    public abstract FileStatus[] listStatus(Path f) throws FileNotFoundException,                                                         IOException;    @InterfaceAudience.Private  public static class DirectoryEntries {    private final FileStatus[] entries;    private final byte[] token;    private final boolean hasMore;    public DirectoryEntries(FileStatus[] entries, byte[] token, boolean        hasMore) {      this.entries = entries;      if (token != null) {        this.token = token.clone();      } else {        this.token = null;      }      this.hasMore = hasMore;    }    public FileStatus[] getEntries() {      return entries;    }    public byte[] getToken() {      return token;    }    public boolean hasMore() {      return hasMore;    }  }    @InterfaceAudience.Private  protected DirectoryEntries listStatusBatch(Path f, byte[] token) throws      FileNotFoundException, IOException {                FileStatus[] listing = listStatus(f);    return new DirectoryEntries(listing, null, false);  }    private void listStatus(ArrayList<FileStatus> results, Path f,      PathFilter filter) throws FileNotFoundException, IOException {    FileStatus listing[] = listStatus(f);    Preconditions.checkNotNull(listing, "listStatus should not return NULL");    for (int i = 0; i < listing.length; i++) {      if (filter.accept(listing[i].getPath())) {        results.add(listing[i]);      }    }  }    public RemoteIterator<Path> listCorruptFileBlocks(Path path)    throws IOException {    throw new UnsupportedOperationException(getClass().getCanonicalName() +        " does not support listCorruptFileBlocks");  }    public FileStatus[] listStatus(Path f, PathFilter filter)                                   throws FileNotFoundException, IOException {    ArrayList<FileStatus> results = new ArrayList<>();    listStatus(results, f, filter);    return results.toArray(new FileStatus[results.size()]);  }    public FileStatus[] listStatus(Path[] files)      throws FileNotFoundException, IOException {    return listStatus(files, DEFAULT_FILTER);  }    public FileStatus[] listStatus(Path[] files, PathFilter filter)      throws FileNotFoundException, IOException {    ArrayList<FileStatus> results = new ArrayList<FileStatus>();    for (int i = 0; i < files.length; i++) {      listStatus(results, files[i], filter);    }    return results.toArray(new FileStatus[results.size()]);  }    public FileStatus[] globStatus(Path pathPattern) throws IOException {    return Globber.createGlobber(this)        .withPathPattern(pathPattern)        .withPathFiltern(DEFAULT_FILTER)        .withResolveSymlinks(true)        .build()        .glob();  }    public FileStatus[] globStatus(Path pathPattern, PathFilter filter)      throws IOException {    return new Globber(this, pathPattern, filter).glob();  }    public RemoteIterator<LocatedFileStatus> listLocatedStatus(final Path f)  throws FileNotFoundException, IOException {    return listLocatedStatus(f, DEFAULT_FILTER);  }    protected RemoteIterator<LocatedFileStatus> listLocatedStatus(final Path f,      final PathFilter filter)  throws FileNotFoundException, IOException {    return new RemoteIterator<LocatedFileStatus>() {      private final FileStatus[] stats = listStatus(f, filter);      private int i = 0;      @Override      public boolean hasNext() {        return i<stats.length;      }      @Override      public LocatedFileStatus next() throws IOException {        if (!hasNext()) {          throw new NoSuchElementException("No more entries in " + f);        }        FileStatus result = stats[i++];                        BlockLocation[] locs = result.isFile() ?            getFileBlockLocations(result, 0, result.getLen()) :            null;        return new LocatedFileStatus(result, locs);      }    };  }    protected class DirListingIterator<T extends FileStatus> implements      RemoteIterator<T> {    private final Path path;    private DirectoryEntries entries;    private int i = 0;    DirListingIterator(Path path) throws IOException {      this.path = path;      this.entries = listStatusBatch(path, null);    }    @Override    public boolean hasNext() throws IOException {      return i < entries.getEntries().length ||          entries.hasMore();    }    private void fetchMore() throws IOException {      byte[] token = entries.getToken();      entries = listStatusBatch(path, token);      i = 0;    }    @Override    @SuppressWarnings("unchecked")    public T next() throws IOException {      Preconditions.checkState(hasNext(), "No more items in iterator");      if (i == entries.getEntries().length) {        fetchMore();      }      return (T)entries.getEntries()[i++];    }  }    public RemoteIterator<FileStatus> listStatusIterator(final Path p)  throws FileNotFoundException, IOException {    return new DirListingIterator<>(p);  }    public RemoteIterator<LocatedFileStatus> listFiles(      final Path f, final boolean recursive)  throws FileNotFoundException, IOException {    return new RemoteIterator<LocatedFileStatus>() {      private Stack<RemoteIterator<LocatedFileStatus>> itors = new Stack<>();      private RemoteIterator<LocatedFileStatus> curItor =        listLocatedStatus(f);      private LocatedFileStatus curFile;      @Override      public boolean hasNext() throws IOException {        while (curFile == null) {          if (curItor.hasNext()) {            handleFileStat(curItor.next());          } else if (!itors.empty()) {            curItor = itors.pop();          } else {            return false;          }        }        return true;      }            private void handleFileStat(LocatedFileStatus stat) throws IOException {        if (stat.isFile()) {           curFile = stat;        } else if (recursive) {           itors.push(curItor);          curItor = listLocatedStatus(stat.getPath());        }      }      @Override      public LocatedFileStatus next() throws IOException {        if (hasNext()) {          LocatedFileStatus result = curFile;          curFile = null;          return result;        }        throw new java.util.NoSuchElementException("No more entry in " + f);      }    };  }    public Path getHomeDirectory() {    String username;    try {      username = UserGroupInformation.getCurrentUser().getShortUserName();    } catch(IOException ex) {      LOGGER.warn("Unable to get user name. Fall back to system property " +          "user.name", ex);      username = System.getProperty("user.name");    }    return this.makeQualified(        new Path(USER_HOME_PREFIX + "/" + username));  }    public abstract void setWorkingDirectory(Path new_dir);    public abstract Path getWorkingDirectory();    protected Path getInitialWorkingDirectory() {    return null;  }    public boolean mkdirs(Path f) throws IOException {    return mkdirs(f, FsPermission.getDirDefault());  }    public abstract boolean mkdirs(Path f, FsPermission permission      ) throws IOException;    public void copyFromLocalFile(Path src, Path dst)    throws IOException {    copyFromLocalFile(false, src, dst);  }    public void moveFromLocalFile(Path[] srcs, Path dst)    throws IOException {    copyFromLocalFile(true, true, srcs, dst);  }    public void moveFromLocalFile(Path src, Path dst)    throws IOException {    copyFromLocalFile(true, src, dst);  }    public void copyFromLocalFile(boolean delSrc, Path src, Path dst)    throws IOException {    copyFromLocalFile(delSrc, true, src, dst);  }    public void copyFromLocalFile(boolean delSrc, boolean overwrite,                                Path[] srcs, Path dst)    throws IOException {    Configuration conf = getConf();    FileUtil.copy(getLocal(conf), srcs, this, dst, delSrc, overwrite, conf);  }    public void copyFromLocalFile(boolean delSrc, boolean overwrite,                                Path src, Path dst)    throws IOException {    Configuration conf = getConf();    FileUtil.copy(getLocal(conf), src, this, dst, delSrc, overwrite, conf);  }    public void copyToLocalFile(Path src, Path dst) throws IOException {    copyToLocalFile(false, src, dst);  }    public void moveToLocalFile(Path src, Path dst) throws IOException {    copyToLocalFile(true, src, dst);  }    public void copyToLocalFile(boolean delSrc, Path src, Path dst)    throws IOException {    copyToLocalFile(delSrc, src, dst, false);  }    public void copyToLocalFile(boolean delSrc, Path src, Path dst,      boolean useRawLocalFileSystem) throws IOException {    Configuration conf = getConf();    FileSystem local = null;    if (useRawLocalFileSystem) {      local = getLocal(conf).getRawFileSystem();    } else {      local = getLocal(conf);    }    FileUtil.copy(this, src, local, dst, delSrc, conf);  }    public Path startLocalOutput(Path fsOutputFile, Path tmpLocalFile)    throws IOException {    return tmpLocalFile;  }    public void completeLocalOutput(Path fsOutputFile, Path tmpLocalFile)    throws IOException {    moveFromLocalFile(tmpLocalFile, fsOutputFile);  }    @Override  public void close() throws IOException {        processDeleteOnExit();    CACHE.remove(this.key, this);  }    public long getUsed() throws IOException {    Path path = new Path("/");    return getUsed(path);  }    public long getUsed(Path path) throws IOException {    return getContentSummary(path).getLength();  }    @Deprecated  public long getBlockSize(Path f) throws IOException {    return getFileStatus(f).getBlockSize();  }    @Deprecated  public long getDefaultBlockSize() {        return getConf().getLong("fs.local.block.size", 32 * 1024 * 1024);  }    public long getDefaultBlockSize(Path f) {    return getDefaultBlockSize();  }    @Deprecated  public short getDefaultReplication() { return 1; }    public short getDefaultReplication(Path path) {    return getDefaultReplication();  }    public abstract FileStatus getFileStatus(Path f) throws IOException;    @InterfaceAudience.LimitedPrivate({"HDFS", "Hive"})  public void access(Path path, FsAction mode) throws AccessControlException,      FileNotFoundException, IOException {    checkAccessPermissions(this.getFileStatus(path), mode);  }    @InterfaceAudience.Private  static void checkAccessPermissions(FileStatus stat, FsAction mode)      throws AccessControlException, IOException {    FsPermission perm = stat.getPermission();    UserGroupInformation ugi = UserGroupInformation.getCurrentUser();    String user = ugi.getShortUserName();    if (user.equals(stat.getOwner())) {      if (perm.getUserAction().implies(mode)) {        return;      }    } else if (ugi.getGroups().contains(stat.getGroup())) {      if (perm.getGroupAction().implies(mode)) {        return;      }    } else {      if (perm.getOtherAction().implies(mode)) {        return;      }    }    throw new AccessControlException(String.format(      "Permission denied: user=%s, path=\"%s\":%s:%s:%s%s", user, stat.getPath(),      stat.getOwner(), stat.getGroup(), stat.isDirectory() ? "d" : "-", perm));  }    protected Path fixRelativePart(Path p) {    if (p.isUriPathAbsolute()) {      return p;    } else {      return new Path(getWorkingDirectory(), p);    }  }    public void createSymlink(final Path target, final Path link,      final boolean createParent) throws AccessControlException,      FileAlreadyExistsException, FileNotFoundException,      ParentNotDirectoryException, UnsupportedFileSystemException,      IOException {        throw new UnsupportedOperationException(        "Filesystem does not support symlinks!");  }    public FileStatus getFileLinkStatus(final Path f)      throws AccessControlException, FileNotFoundException,      UnsupportedFileSystemException, IOException {        return getFileStatus(f);  }    public boolean supportsSymlinks() {    return false;  }    public Path getLinkTarget(Path f) throws IOException {        throw new UnsupportedOperationException(        "Filesystem does not support symlinks!");  }    protected Path resolveLink(Path f) throws IOException {        throw new UnsupportedOperationException(        "Filesystem does not support symlinks!");  }    public FileChecksum getFileChecksum(Path f) throws IOException {    return getFileChecksum(f, Long.MAX_VALUE);  }    public FileChecksum getFileChecksum(Path f, final long length)      throws IOException {    return null;  }    public void setVerifyChecksum(boolean verifyChecksum) {      }    public void setWriteChecksum(boolean writeChecksum) {      }    public FsStatus getStatus() throws IOException {    return getStatus(null);  }    public FsStatus getStatus(Path p) throws IOException {    return new FsStatus(Long.MAX_VALUE, 0, Long.MAX_VALUE);  }    public void setPermission(Path p, FsPermission permission      ) throws IOException {  }    public void setOwner(Path p, String username, String groupname      ) throws IOException {  }    public void setTimes(Path p, long mtime, long atime      ) throws IOException {  }    public final Path createSnapshot(Path path) throws IOException {    return createSnapshot(path, null);  }    public Path createSnapshot(Path path, String snapshotName)      throws IOException {    throw new UnsupportedOperationException(getClass().getSimpleName()        + " doesn't support createSnapshot");  }    public void renameSnapshot(Path path, String snapshotOldName,      String snapshotNewName) throws IOException {    throw new UnsupportedOperationException(getClass().getSimpleName()        + " doesn't support renameSnapshot");  }    public void deleteSnapshot(Path path, String snapshotName)      throws IOException {    throw new UnsupportedOperationException(getClass().getSimpleName()        + " doesn't support deleteSnapshot");  }    public void modifyAclEntries(Path path, List<AclEntry> aclSpec)      throws IOException {    throw new UnsupportedOperationException(getClass().getSimpleName()        + " doesn't support modifyAclEntries");  }    public void removeAclEntries(Path path, List<AclEntry> aclSpec)      throws IOException {    throw new UnsupportedOperationException(getClass().getSimpleName()        + " doesn't support removeAclEntries");  }    public void removeDefaultAcl(Path path)      throws IOException {    throw new UnsupportedOperationException(getClass().getSimpleName()        + " doesn't support removeDefaultAcl");  }    public void removeAcl(Path path)      throws IOException {    throw new UnsupportedOperationException(getClass().getSimpleName()        + " doesn't support removeAcl");  }    public void setAcl(Path path, List<AclEntry> aclSpec) throws IOException {    throw new UnsupportedOperationException(getClass().getSimpleName()        + " doesn't support setAcl");  }    public AclStatus getAclStatus(Path path) throws IOException {    throw new UnsupportedOperationException(getClass().getSimpleName()        + " doesn't support getAclStatus");  }    public void setXAttr(Path path, String name, byte[] value)      throws IOException {    setXAttr(path, name, value, EnumSet.of(XAttrSetFlag.CREATE,        XAttrSetFlag.REPLACE));  }    public void setXAttr(Path path, String name, byte[] value,      EnumSet<XAttrSetFlag> flag) throws IOException {    throw new UnsupportedOperationException(getClass().getSimpleName()        + " doesn't support setXAttr");  }    public byte[] getXAttr(Path path, String name) throws IOException {    throw new UnsupportedOperationException(getClass().getSimpleName()        + " doesn't support getXAttr");  }    public Map<String, byte[]> getXAttrs(Path path) throws IOException {    throw new UnsupportedOperationException(getClass().getSimpleName()        + " doesn't support getXAttrs");  }    public Map<String, byte[]> getXAttrs(Path path, List<String> names)      throws IOException {    throw new UnsupportedOperationException(getClass().getSimpleName()        + " doesn't support getXAttrs");  }    public List<String> listXAttrs(Path path) throws IOException {    throw new UnsupportedOperationException(getClass().getSimpleName()            + " doesn't support listXAttrs");  }    public void removeXAttr(Path path, String name) throws IOException {    throw new UnsupportedOperationException(getClass().getSimpleName()        + " doesn't support removeXAttr");  }    public void satisfyStoragePolicy(final Path path) throws IOException {    throw new UnsupportedOperationException(        getClass().getSimpleName() + " doesn't support setStoragePolicy");  }    public void setStoragePolicy(final Path src, final String policyName)      throws IOException {    throw new UnsupportedOperationException(getClass().getSimpleName()        + " doesn't support setStoragePolicy");  }    public void unsetStoragePolicy(final Path src) throws IOException {    throw new UnsupportedOperationException(getClass().getSimpleName()        + " doesn't support unsetStoragePolicy");  }    public BlockStoragePolicySpi getStoragePolicy(final Path src)      throws IOException {    throw new UnsupportedOperationException(getClass().getSimpleName()        + " doesn't support getStoragePolicy");  }    public Collection<? extends BlockStoragePolicySpi> getAllStoragePolicies()      throws IOException {    throw new UnsupportedOperationException(getClass().getSimpleName()        + " doesn't support getAllStoragePolicies");  }    public Path getTrashRoot(Path path) {    return this.makeQualified(new Path(getHomeDirectory().toUri().getPath(),        TRASH_PREFIX));  }    public Collection<FileStatus> getTrashRoots(boolean allUsers) {    Path userHome = new Path(getHomeDirectory().toUri().getPath());    List<FileStatus> ret = new ArrayList<>();    try {      if (!allUsers) {        Path userTrash = new Path(userHome, TRASH_PREFIX);        if (exists(userTrash)) {          ret.add(getFileStatus(userTrash));        }      } else {        Path homeParent = userHome.getParent();        if (exists(homeParent)) {          FileStatus[] candidates = listStatus(homeParent);          for (FileStatus candidate : candidates) {            Path userTrash = new Path(candidate.getPath(), TRASH_PREFIX);            if (exists(userTrash)) {              candidate.setPath(userTrash);              ret.add(candidate);            }          }        }      }    } catch (IOException e) {      LOGGER.warn("Cannot get all trash roots", e);    }    return ret;  }    public boolean hasPathCapability(final Path path, final String capability)      throws IOException {    switch (validatePathCapabilityArgs(makeQualified(path), capability)) {    case CommonPathCapabilities.FS_SYMLINKS:            return supportsSymlinks() && areSymlinksEnabled();    default:            return false;    }  }    private volatile static boolean FILE_SYSTEMS_LOADED = false;    private static final Map<String, Class<? extends FileSystem>>      SERVICE_FILE_SYSTEMS = new HashMap<>();    private static void loadFileSystems() {    LOGGER.debug("Loading filesystems");    synchronized (FileSystem.class) {      if (!FILE_SYSTEMS_LOADED) {        ServiceLoader<FileSystem> serviceLoader = ServiceLoader.load(FileSystem.class);        Iterator<FileSystem> it = serviceLoader.iterator();        while (it.hasNext()) {          FileSystem fs;          try {            fs = it.next();            try {              SERVICE_FILE_SYSTEMS.put(fs.getScheme(), fs.getClass());              if (LOGGER.isDebugEnabled()) {                LOGGER.debug("{}:// = {} from {}",                    fs.getScheme(), fs.getClass(),                    ClassUtil.findContainingJar(fs.getClass()));              }            } catch (Exception e) {              LOGGER.warn("Cannot load: {} from {}", fs,                  ClassUtil.findContainingJar(fs.getClass()));              LOGGER.info("Full exception loading: {}", fs, e);            }          } catch (ServiceConfigurationError ee) {            LOG.warn("Cannot load filesystem: " + ee);            Throwable cause = ee.getCause();                        while (cause != null) {              LOG.warn(cause.toString());              cause = cause.getCause();            }                        LOG.debug("Stack Trace", ee);          }        }        FILE_SYSTEMS_LOADED = true;      }    }  }    public static Class<? extends FileSystem> getFileSystemClass(String scheme,      Configuration conf) throws IOException {    if (!FILE_SYSTEMS_LOADED) {      loadFileSystems();    }    LOGGER.debug("Looking for FS supporting {}", scheme);    Class<? extends FileSystem> clazz = null;    if (conf != null) {      String property = "fs." + scheme + ".impl";      LOGGER.debug("looking for configuration option {}", property);      clazz = (Class<? extends FileSystem>) conf.getClass(          property, null);    } else {      LOGGER.debug("No configuration: skipping check for fs.{}.impl", scheme);    }    if (clazz == null) {      LOGGER.debug("Looking in service filesystems for implementation class");      clazz = SERVICE_FILE_SYSTEMS.get(scheme);    } else {      LOGGER.debug("Filesystem {} defined in configuration option", scheme);    }    if (clazz == null) {      throw new UnsupportedFileSystemException("No FileSystem for scheme "          + "\"" + scheme + "\"");    }    LOGGER.debug("FS for {} is {}", scheme, clazz);    return clazz;  }    private static FileSystem createFileSystem(URI uri, Configuration conf)      throws IOException {    Tracer tracer = FsTracer.get(conf);    try(TraceScope scope = tracer.newScope("FileSystem#createFileSystem")) {      scope.addKVAnnotation("scheme", uri.getScheme());      Class<? extends FileSystem> clazz =          getFileSystemClass(uri.getScheme(), conf);      FileSystem fs = ReflectionUtils.newInstance(clazz, conf);      try {        fs.initialize(uri, conf);      } catch (IOException | RuntimeException e) {                        LOGGER.warn("Failed to initialize fileystem {}: {}",            uri, e.toString());        LOGGER.debug("Failed to initialize fileystem", e);                        IOUtils.cleanupWithLogger(LOGGER, fs);        throw e;      }      return fs;    }  }    static class Cache {    private final ClientFinalizer clientFinalizer = new ClientFinalizer();    private final Map<Key, FileSystem> map = new HashMap<>();    private final Set<Key> toAutoClose = new HashSet<>();        private static AtomicLong unique = new AtomicLong(1);    FileSystem get(URI uri, Configuration conf) throws IOException{      Key key = new Key(uri, conf);      return getInternal(uri, conf, key);    }        FileSystem getUnique(URI uri, Configuration conf) throws IOException{      Key key = new Key(uri, conf, unique.getAndIncrement());      return getInternal(uri, conf, key);    }        private FileSystem getInternal(URI uri, Configuration conf, Key key)        throws IOException{      FileSystem fs;      synchronized (this) {        fs = map.get(key);      }      if (fs != null) {        return fs;      }      fs = createFileSystem(uri, conf);      final long timeout = conf.getTimeDuration(SERVICE_SHUTDOWN_TIMEOUT,          SERVICE_SHUTDOWN_TIMEOUT_DEFAULT,          ShutdownHookManager.TIME_UNIT_DEFAULT);      synchronized (this) {         FileSystem oldfs = map.get(key);        if (oldfs != null) {           fs.close();           return oldfs;          }                if (map.isEmpty()                && !ShutdownHookManager.get().isShutdownInProgress()) {          ShutdownHookManager.get().addShutdownHook(clientFinalizer,              SHUTDOWN_HOOK_PRIORITY, timeout,              ShutdownHookManager.TIME_UNIT_DEFAULT);        }        fs.key = key;        map.put(key, fs);        if (conf.getBoolean(            FS_AUTOMATIC_CLOSE_KEY, FS_AUTOMATIC_CLOSE_DEFAULT)) {          toAutoClose.add(key);        }        return fs;      }    }    synchronized void remove(Key key, FileSystem fs) {      FileSystem cachedFs = map.remove(key);      if (fs == cachedFs) {        toAutoClose.remove(key);      } else if (cachedFs != null) {        map.put(key, cachedFs);      }    }        synchronized void closeAll() throws IOException {      closeAll(false);    }        synchronized void closeAll(boolean onlyAutomatic) throws IOException {      List<IOException> exceptions = new ArrayList<>();                  List<Key> keys = new ArrayList<>();      keys.addAll(map.keySet());      for (Key key : keys) {        final FileSystem fs = map.get(key);        if (onlyAutomatic && !toAutoClose.contains(key)) {          continue;        }                map.remove(key);        toAutoClose.remove(key);        if (fs != null) {          try {            fs.close();          }          catch(IOException ioe) {            exceptions.add(ioe);          }        }      }      if (!exceptions.isEmpty()) {        throw MultipleIOException.createIOException(exceptions);      }    }    private class ClientFinalizer implements Runnable {      @Override      public synchronized void run() {        try {          closeAll(true);        } catch (IOException e) {          LOGGER.info("FileSystem.Cache.closeAll() threw an exception:\n" + e);        }      }    }    synchronized void closeAll(UserGroupInformation ugi) throws IOException {      List<FileSystem> targetFSList = new ArrayList<>(map.entrySet().size());                  for (Map.Entry<Key, FileSystem> entry : map.entrySet()) {        final Key key = entry.getKey();        final FileSystem fs = entry.getValue();        if (ugi.equals(key.ugi) && fs != null) {          targetFSList.add(fs);        }      }      List<IOException> exceptions = new ArrayList<>();            for (FileSystem fs : targetFSList) {        try {          fs.close();        }        catch(IOException ioe) {          exceptions.add(ioe);        }      }      if (!exceptions.isEmpty()) {        throw MultipleIOException.createIOException(exceptions);      }    }        static class Key {      final String scheme;      final String authority;      final UserGroupInformation ugi;      final long unique;         Key(URI uri, Configuration conf) throws IOException {        this(uri, conf, 0);      }      Key(URI uri, Configuration conf, long unique) throws IOException {        scheme = uri.getScheme()==null ?            "" : StringUtils.toLowerCase(uri.getScheme());        authority = uri.getAuthority()==null ?            "" : StringUtils.toLowerCase(uri.getAuthority());        this.unique = unique;        this.ugi = UserGroupInformation.getCurrentUser();      }      @Override      public int hashCode() {        return (scheme + authority).hashCode() + ugi.hashCode() + (int)unique;      }      static boolean isEqual(Object a, Object b) {        return a == b || (a != null && a.equals(b));      }      @Override      public boolean equals(Object obj) {        if (obj == this) {          return true;        }        if (obj instanceof Key) {          Key that = (Key)obj;          return isEqual(this.scheme, that.scheme)                 && isEqual(this.authority, that.authority)                 && isEqual(this.ugi, that.ugi)                 && (this.unique == that.unique);        }        return false;      }      @Override      public String toString() {        return "("+ugi.toString() + ")@" + scheme + "://" + authority;      }    }  }    public static final class Statistics {        public static class StatisticsData {      private volatile long bytesRead;      private volatile long bytesWritten;      private volatile int readOps;      private volatile int largeReadOps;      private volatile int writeOps;      private volatile long bytesReadLocalHost;      private volatile long bytesReadDistanceOfOneOrTwo;      private volatile long bytesReadDistanceOfThreeOrFour;      private volatile long bytesReadDistanceOfFiveOrLarger;      private volatile long bytesReadErasureCoded;            void add(StatisticsData other) {        this.bytesRead += other.bytesRead;        this.bytesWritten += other.bytesWritten;        this.readOps += other.readOps;        this.largeReadOps += other.largeReadOps;        this.writeOps += other.writeOps;        this.bytesReadLocalHost += other.bytesReadLocalHost;        this.bytesReadDistanceOfOneOrTwo += other.bytesReadDistanceOfOneOrTwo;        this.bytesReadDistanceOfThreeOrFour +=            other.bytesReadDistanceOfThreeOrFour;        this.bytesReadDistanceOfFiveOrLarger +=            other.bytesReadDistanceOfFiveOrLarger;        this.bytesReadErasureCoded += other.bytesReadErasureCoded;      }            void negate() {        this.bytesRead = -this.bytesRead;        this.bytesWritten = -this.bytesWritten;        this.readOps = -this.readOps;        this.largeReadOps = -this.largeReadOps;        this.writeOps = -this.writeOps;        this.bytesReadLocalHost = -this.bytesReadLocalHost;        this.bytesReadDistanceOfOneOrTwo = -this.bytesReadDistanceOfOneOrTwo;        this.bytesReadDistanceOfThreeOrFour =            -this.bytesReadDistanceOfThreeOrFour;        this.bytesReadDistanceOfFiveOrLarger =            -this.bytesReadDistanceOfFiveOrLarger;        this.bytesReadErasureCoded = -this.bytesReadErasureCoded;      }      @Override      public String toString() {        return bytesRead + " bytes read, " + bytesWritten + " bytes written, "            + readOps + " read ops, " + largeReadOps + " large read ops, "            + writeOps + " write ops";      }      public long getBytesRead() {        return bytesRead;      }      public long getBytesWritten() {        return bytesWritten;      }      public int getReadOps() {        return readOps;      }      public int getLargeReadOps() {        return largeReadOps;      }      public int getWriteOps() {        return writeOps;      }      public long getBytesReadLocalHost() {        return bytesReadLocalHost;      }      public long getBytesReadDistanceOfOneOrTwo() {        return bytesReadDistanceOfOneOrTwo;      }      public long getBytesReadDistanceOfThreeOrFour() {        return bytesReadDistanceOfThreeOrFour;      }      public long getBytesReadDistanceOfFiveOrLarger() {        return bytesReadDistanceOfFiveOrLarger;      }      public long getBytesReadErasureCoded() {        return bytesReadErasureCoded;      }    }    private interface StatisticsAggregator<T> {      void accept(StatisticsData data);      T aggregate();    }    private final String scheme;        private final StatisticsData rootData;        @SuppressWarnings("ThreadLocalNotStaticFinal")    private final ThreadLocal<StatisticsData> threadData;        private final Set<StatisticsDataReference> allData;        private static final ReferenceQueue<Thread> STATS_DATA_REF_QUEUE;    private static final Thread STATS_DATA_CLEANER;    static {      STATS_DATA_REF_QUEUE = new ReferenceQueue<>();            STATS_DATA_CLEANER = new Thread(new StatisticsDataReferenceCleaner());      STATS_DATA_CLEANER.          setName(StatisticsDataReferenceCleaner.class.getName());      STATS_DATA_CLEANER.setDaemon(true);      STATS_DATA_CLEANER.start();    }    public Statistics(String scheme) {      this.scheme = scheme;      this.rootData = new StatisticsData();      this.threadData = new ThreadLocal<>();      this.allData = new HashSet<>();    }        public Statistics(Statistics other) {      this.scheme = other.scheme;      this.rootData = new StatisticsData();      other.visitAll(new StatisticsAggregator<Void>() {        @Override        public void accept(StatisticsData data) {          rootData.add(data);        }        public Void aggregate() {          return null;        }      });      this.threadData = new ThreadLocal<>();      this.allData = new HashSet<>();    }        private final class StatisticsDataReference extends WeakReference<Thread> {      private final StatisticsData data;      private StatisticsDataReference(StatisticsData data, Thread thread) {        super(thread, STATS_DATA_REF_QUEUE);        this.data = data;      }      public StatisticsData getData() {        return data;      }            public void cleanUp() {                synchronized (Statistics.this) {                    rootData.add(data);          allData.remove(this);        }      }    }        private static class StatisticsDataReferenceCleaner implements Runnable {      @Override      public void run() {        while (!Thread.interrupted()) {          try {            StatisticsDataReference ref =                (StatisticsDataReference)STATS_DATA_REF_QUEUE.remove();            ref.cleanUp();          } catch (InterruptedException ie) {            LOGGER.warn("Cleaner thread interrupted, will stop", ie);            Thread.currentThread().interrupt();          } catch (Throwable th) {            LOGGER.warn("Exception in the cleaner thread but it will" +                " continue to run", th);          }        }      }    }        public StatisticsData getThreadStatistics() {      StatisticsData data = threadData.get();      if (data == null) {        data = new StatisticsData();        threadData.set(data);        StatisticsDataReference ref =            new StatisticsDataReference(data, Thread.currentThread());        synchronized(this) {          allData.add(ref);        }      }      return data;    }        public void incrementBytesRead(long newBytes) {      getThreadStatistics().bytesRead += newBytes;    }        public void incrementBytesWritten(long newBytes) {      getThreadStatistics().bytesWritten += newBytes;    }        public void incrementReadOps(int count) {      getThreadStatistics().readOps += count;    }        public void incrementLargeReadOps(int count) {      getThreadStatistics().largeReadOps += count;    }        public void incrementWriteOps(int count) {      getThreadStatistics().writeOps += count;    }        public void incrementBytesReadErasureCoded(long newBytes) {      getThreadStatistics().bytesReadErasureCoded += newBytes;    }        public void incrementBytesReadByDistance(int distance, long newBytes) {      switch (distance) {      case 0:        getThreadStatistics().bytesReadLocalHost += newBytes;        break;      case 1:      case 2:        getThreadStatistics().bytesReadDistanceOfOneOrTwo += newBytes;        break;      case 3:      case 4:        getThreadStatistics().bytesReadDistanceOfThreeOrFour += newBytes;        break;      default:        getThreadStatistics().bytesReadDistanceOfFiveOrLarger += newBytes;        break;      }    }        private synchronized <T> T visitAll(StatisticsAggregator<T> visitor) {      visitor.accept(rootData);      for (StatisticsDataReference ref: allData) {        StatisticsData data = ref.getData();        visitor.accept(data);      }      return visitor.aggregate();    }        public long getBytesRead() {      return visitAll(new StatisticsAggregator<Long>() {        private long bytesRead = 0;        @Override        public void accept(StatisticsData data) {          bytesRead += data.bytesRead;        }        public Long aggregate() {          return bytesRead;        }      });    }        public long getBytesWritten() {      return visitAll(new StatisticsAggregator<Long>() {        private long bytesWritten = 0;        @Override        public void accept(StatisticsData data) {          bytesWritten += data.bytesWritten;        }        public Long aggregate() {          return bytesWritten;        }      });    }        public int getReadOps() {      return visitAll(new StatisticsAggregator<Integer>() {        private int readOps = 0;        @Override        public void accept(StatisticsData data) {          readOps += data.readOps;          readOps += data.largeReadOps;        }        public Integer aggregate() {          return readOps;        }      });    }        public int getLargeReadOps() {      return visitAll(new StatisticsAggregator<Integer>() {        private int largeReadOps = 0;        @Override        public void accept(StatisticsData data) {          largeReadOps += data.largeReadOps;        }        public Integer aggregate() {          return largeReadOps;        }      });    }        public int getWriteOps() {      return visitAll(new StatisticsAggregator<Integer>() {        private int writeOps = 0;        @Override        public void accept(StatisticsData data) {          writeOps += data.writeOps;        }        public Integer aggregate() {          return writeOps;        }      });    }        public long getBytesReadByDistance(int distance) {      long bytesRead;      switch (distance) {      case 0:        bytesRead = getData().getBytesReadLocalHost();        break;      case 1:      case 2:        bytesRead = getData().getBytesReadDistanceOfOneOrTwo();        break;      case 3:      case 4:        bytesRead = getData().getBytesReadDistanceOfThreeOrFour();        break;      default:        bytesRead = getData().getBytesReadDistanceOfFiveOrLarger();        break;      }      return bytesRead;    }        public StatisticsData getData() {      return visitAll(new StatisticsAggregator<StatisticsData>() {        private StatisticsData all = new StatisticsData();        @Override        public void accept(StatisticsData data) {          all.add(data);        }        public StatisticsData aggregate() {          return all;        }      });    }        public long getBytesReadErasureCoded() {      return visitAll(new StatisticsAggregator<Long>() {        private long bytesReadErasureCoded = 0;        @Override        public void accept(StatisticsData data) {          bytesReadErasureCoded += data.bytesReadErasureCoded;        }        public Long aggregate() {          return bytesReadErasureCoded;        }      });    }    @Override    public String toString() {      return visitAll(new StatisticsAggregator<String>() {        private StatisticsData total = new StatisticsData();        @Override        public void accept(StatisticsData data) {          total.add(data);        }        public String aggregate() {          return total.toString();        }      });    }        public void reset() {      visitAll(new StatisticsAggregator<Void>() {        private StatisticsData total = new StatisticsData();        @Override        public void accept(StatisticsData data) {          total.add(data);        }        public Void aggregate() {          total.negate();          rootData.add(total);          return null;        }      });    }        public String getScheme() {      return scheme;    }    @VisibleForTesting    synchronized int getAllThreadLocalDataSize() {      return allData.size();    }  }    @Deprecated  public static synchronized Map<String, Statistics> getStatistics() {    Map<String, Statistics> result = new HashMap<>();    for(Statistics stat: statisticsTable.values()) {      result.put(stat.getScheme(), stat);    }    return result;  }    @Deprecated  public static synchronized List<Statistics> getAllStatistics() {    return new ArrayList<>(statisticsTable.values());  }    @Deprecated  public static synchronized Statistics getStatistics(final String scheme,      Class<? extends FileSystem> cls) {    checkArgument(scheme != null,        "No statistics is allowed for a file system with null scheme!");    Statistics result = statisticsTable.get(cls);    if (result == null) {      final Statistics newStats = new Statistics(scheme);      statisticsTable.put(cls, newStats);      result = newStats;      GlobalStorageStatistics.INSTANCE.put(scheme,          new StorageStatisticsProvider() {            @Override            public StorageStatistics provide() {              return new FileSystemStorageStatistics(scheme, newStats);            }          });    }    return result;  }    public static synchronized void clearStatistics() {    GlobalStorageStatistics.INSTANCE.reset();  }    public static synchronized  void printStatistics() throws IOException {    for (Map.Entry<Class<? extends FileSystem>, Statistics> pair:            statisticsTable.entrySet()) {      System.out.println("  FileSystem " + pair.getKey().getName() +                         ": " + pair.getValue());    }  }    private static boolean symlinksEnabled = false;  @VisibleForTesting  public static boolean areSymlinksEnabled() {    return symlinksEnabled;  }  @VisibleForTesting  public static void enableSymlinks() {    symlinksEnabled = true;  }    public StorageStatistics getStorageStatistics() {    return new EmptyStorageStatistics(getUri().toString());  }    public static GlobalStorageStatistics getGlobalStorageStatistics() {    return GlobalStorageStatistics.INSTANCE;  }    @InterfaceStability.Unstable  protected static FSDataOutputStreamBuilder createDataOutputStreamBuilder(      @Nonnull final FileSystem fileSystem,      @Nonnull final Path path) {    return new FileSystemDataOutputStreamBuilder(fileSystem, path);  }    private static final class FileSystemDataOutputStreamBuilder extends      FSDataOutputStreamBuilder<FSDataOutputStream,        FileSystemDataOutputStreamBuilder> {        private FileSystemDataOutputStreamBuilder(FileSystem fileSystem, Path p) {      super(fileSystem, p);    }    @Override    public FSDataOutputStream build() throws IOException {      rejectUnknownMandatoryKeys(Collections.emptySet(),          " for " + getPath());      if (getFlags().contains(CreateFlag.CREATE) ||          getFlags().contains(CreateFlag.OVERWRITE)) {        if (isRecursive()) {          return getFS().create(getPath(), getPermission(), getFlags(),              getBufferSize(), getReplication(), getBlockSize(), getProgress(),              getChecksumOpt());        } else {          return getFS().createNonRecursive(getPath(), getPermission(),              getFlags(), getBufferSize(), getReplication(), getBlockSize(),              getProgress());        }      } else if (getFlags().contains(CreateFlag.APPEND)) {        return getFS().append(getPath(), getBufferSize(), getProgress());      }      throw new PathIOException(getPath().toString(),          "Must specify either create, overwrite or append");    }    @Override    public FileSystemDataOutputStreamBuilder getThisBuilder() {      return this;    }  }    public FSDataOutputStreamBuilder createFile(Path path) {    return createDataOutputStreamBuilder(this, path)        .create().overwrite(true);  }    public FSDataOutputStreamBuilder appendFile(Path path) {    return createDataOutputStreamBuilder(this, path).append();  }    @InterfaceStability.Unstable  public FutureDataInputStreamBuilder openFile(Path path)      throws IOException, UnsupportedOperationException {    return createDataInputStreamBuilder(this, path).getThisBuilder();  }    @InterfaceStability.Unstable  public FutureDataInputStreamBuilder openFile(PathHandle pathHandle)      throws IOException, UnsupportedOperationException {    return createDataInputStreamBuilder(this, pathHandle)        .getThisBuilder();  }    protected CompletableFuture<FSDataInputStream> openFileWithOptions(      final Path path,      final OpenFileParameters parameters) throws IOException {    AbstractFSBuilderImpl.rejectUnknownMandatoryKeys(        parameters.getMandatoryKeys(),        Collections.emptySet(),        "for " + path);    return LambdaUtils.eval(        new CompletableFuture<>(), () ->            open(path, parameters.getBufferSize()));  }    protected CompletableFuture<FSDataInputStream> openFileWithOptions(      final PathHandle pathHandle,      final OpenFileParameters parameters) throws IOException {    AbstractFSBuilderImpl.rejectUnknownMandatoryKeys(        parameters.getMandatoryKeys(),        Collections.emptySet(), "");    CompletableFuture<FSDataInputStream> result = new CompletableFuture<>();    try {      result.complete(open(pathHandle, parameters.getBufferSize()));    } catch (UnsupportedOperationException tx) {            throw tx;    } catch (Throwable tx) {                  result.completeExceptionally(tx);    }    return result;  }    private void methodNotSupported() {                            String name = Thread.currentThread().getStackTrace()[2].getMethodName();    throw new UnsupportedOperationException(getClass().getCanonicalName() +        " does not support method " + name);  }    @InterfaceAudience.LimitedPrivate("Filesystems")  @InterfaceStability.Unstable  protected static FSDataInputStreamBuilder createDataInputStreamBuilder(      @Nonnull final FileSystem fileSystem,      @Nonnull final Path path) {    return new FSDataInputStreamBuilder(fileSystem, path);  }    @InterfaceAudience.LimitedPrivate("Filesystems")  @InterfaceStability.Unstable  protected static FSDataInputStreamBuilder createDataInputStreamBuilder(      @Nonnull final FileSystem fileSystem,      @Nonnull final PathHandle pathHandle) {    return new FSDataInputStreamBuilder(fileSystem, pathHandle);  }    private static class FSDataInputStreamBuilder      extends FutureDataInputStreamBuilderImpl      implements FutureDataInputStreamBuilder {        protected FSDataInputStreamBuilder(        @Nonnull final FileSystem fileSystem,        @Nonnull final Path path) {      super(fileSystem, path);    }        protected FSDataInputStreamBuilder(        @Nonnull final FileSystem fileSystem,        @Nonnull final PathHandle pathHandle) {      super(fileSystem, pathHandle);    }        @Override    public CompletableFuture<FSDataInputStream> build() throws IOException {      Optional<Path> optionalPath = getOptionalPath();      OpenFileParameters parameters = new OpenFileParameters()          .withMandatoryKeys(getMandatoryKeys())          .withOptions(getOptions())          .withBufferSize(getBufferSize())          .withStatus(super.getStatus());        if(optionalPath.isPresent()) {        return getFS().openFileWithOptions(optionalPath.get(),            parameters);      } else {        return getFS().openFileWithOptions(getPathHandle(),            parameters);      }    }  }}
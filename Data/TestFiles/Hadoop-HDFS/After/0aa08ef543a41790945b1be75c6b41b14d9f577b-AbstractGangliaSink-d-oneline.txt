public abstract class AbstractGangliaSink implements MetricsSink {  public final Logger LOG = LoggerFactory.getLogger(this.getClass());    public static final String DEFAULT_UNITS = "";  public static final int DEFAULT_TMAX = 60;  public static final int DEFAULT_DMAX = 0;  public static final GangliaSlope DEFAULT_SLOPE = GangliaSlope.both;  public static final int DEFAULT_PORT = 8649;  public static final boolean DEFAULT_MULTICAST_ENABLED = false;  public static final int DEFAULT_MULTICAST_TTL = 1;  public static final String SERVERS_PROPERTY = "servers";  public static final String MULTICAST_ENABLED_PROPERTY = "multicast";  public static final String MULTICAST_TTL_PROPERTY = "multicast.ttl";  public static final int BUFFER_SIZE = 1500;   public static final String SUPPORT_SPARSE_METRICS_PROPERTY = "supportsparse";  public static final boolean SUPPORT_SPARSE_METRICS_DEFAULT = false;  public static final String EQUAL = "=";  private String hostName = "UNKNOWN.example.com";  private DatagramSocket datagramSocket;  private List<? extends SocketAddress> metricsServers;  private boolean multicastEnabled;  private int multicastTtl;  private byte[] buffer = new byte[BUFFER_SIZE];  private int offset;  private boolean supportSparseMetrics = SUPPORT_SPARSE_METRICS_DEFAULT;  public List<? extends SocketAddress> getMetricsServers() {    return metricsServers;  }    protected final GangliaMetricVisitor gangliaMetricVisitor =    new GangliaMetricVisitor();  private SubsetConfiguration conf;  private Map<String, GangliaConf> gangliaConfMap;  private GangliaConf DEFAULT_GANGLIA_CONF = new GangliaConf();    public enum GangliaSlope {    zero,           positive,       negative,       both          };    public enum GangliaConfType {    slope, units, dmax, tmax  };    @Override  public void init(SubsetConfiguration conf) {    LOG.debug("Initializing the GangliaSink for Ganglia metrics.");    this.conf = conf;        if (conf.getString("slave.host.name") != null) {      hostName = conf.getString("slave.host.name");    } else {      try {        hostName = DNS.getDefaultHost(            conf.getString("dfs.datanode.dns.interface", "default"),            conf.getString("dfs.datanode.dns.nameserver", "default"));      } catch (UnknownHostException uhe) {        LOG.error(uhe.toString());        hostName = "UNKNOWN.example.com";      }    }        List<String> serversFromConf =        conf.getList(String.class, SERVERS_PROPERTY, new ArrayList<String>());    metricsServers =        Servers.parse(serversFromConf.size() > 0 ? String.join(",", serversFromConf) : null,            DEFAULT_PORT);    multicastEnabled = conf.getBoolean(MULTICAST_ENABLED_PROPERTY,            DEFAULT_MULTICAST_ENABLED);    multicastTtl = conf.getInt(MULTICAST_TTL_PROPERTY, DEFAULT_MULTICAST_TTL);        gangliaConfMap = new HashMap<String, GangliaConf>();    loadGangliaConf(GangliaConfType.units);    loadGangliaConf(GangliaConfType.tmax);    loadGangliaConf(GangliaConfType.dmax);    loadGangliaConf(GangliaConfType.slope);    try {      if (multicastEnabled) {        LOG.info("Enabling multicast for Ganglia with TTL " + multicastTtl);        datagramSocket = new MulticastSocket();        ((MulticastSocket) datagramSocket).setTimeToLive(multicastTtl);      } else {        datagramSocket = new DatagramSocket();      }    } catch (IOException e) {      LOG.error(e.toString());    }        supportSparseMetrics = conf.getBoolean(SUPPORT_SPARSE_METRICS_PROPERTY,        SUPPORT_SPARSE_METRICS_DEFAULT);  }    @Override  public void flush() {      }    private void loadGangliaConf(GangliaConfType gtype) {    String propertyarr[] = conf.getStringArray(gtype.name());    if (propertyarr != null && propertyarr.length > 0) {      for (String metricNValue : propertyarr) {        String metricNValueArr[] = metricNValue.split(EQUAL);        if (metricNValueArr.length != 2 || metricNValueArr[0].length() == 0) {          LOG.error("Invalid propertylist for " + gtype.name());        }        String metricName = metricNValueArr[0].trim();        String metricValue = metricNValueArr[1].trim();        GangliaConf gconf = gangliaConfMap.get(metricName);        if (gconf == null) {          gconf = new GangliaConf();          gangliaConfMap.put(metricName, gconf);        }        switch (gtype) {        case units:          gconf.setUnits(metricValue);          break;        case dmax:          gconf.setDmax(Integer.parseInt(metricValue));          break;        case tmax:          gconf.setTmax(Integer.parseInt(metricValue));          break;        case slope:          gconf.setSlope(GangliaSlope.valueOf(metricValue));          break;        }      }    }  }    protected GangliaConf getGangliaConfForMetric(String metricName) {    GangliaConf gconf = gangliaConfMap.get(metricName);    return gconf != null ? gconf : DEFAULT_GANGLIA_CONF;  }    protected String getHostName() {    return hostName;  }    protected void xdr_string(String s) {    byte[] bytes = s.getBytes(StandardCharsets.UTF_8);    int len = bytes.length;    xdr_int(len);    System.arraycopy(bytes, 0, buffer, offset, len);    offset += len;    pad();  }    private void pad() {    int newOffset = ((offset + 3) / 4) * 4;    while (offset < newOffset) {      buffer[offset++] = 0;    }  }    protected void xdr_int(int i) {    buffer[offset++] = (byte) ((i >> 24) & 0xff);    buffer[offset++] = (byte) ((i >> 16) & 0xff);    buffer[offset++] = (byte) ((i >> 8) & 0xff);    buffer[offset++] = (byte) (i & 0xff);  }    protected void emitToGangliaHosts() throws IOException {    try {      for (SocketAddress socketAddress : metricsServers) {        if (socketAddress == null || !(socketAddress instanceof InetSocketAddress))          throw new IllegalArgumentException("Unsupported Address type");        InetSocketAddress inetAddress = (InetSocketAddress)socketAddress;        if(inetAddress.isUnresolved()) {          throw new UnknownHostException("Unresolved host: " + inetAddress);        }        DatagramPacket packet =          new DatagramPacket(buffer, offset, socketAddress);        datagramSocket.send(packet);      }    } finally {            offset = 0;    }  }    void resetBuffer() {    offset = 0;  }    protected boolean isSupportSparseMetrics() {    return supportSparseMetrics;  }    void setDatagramSocket(DatagramSocket datagramSocket) {    this.datagramSocket = datagramSocket;  }    DatagramSocket getDatagramSocket() {    return datagramSocket;  }}


package org.apache.hadoop.fs.s3a;

import javax.net.ssl.SSLException;
import java.io.IOException;
import java.net.SocketException;
import java.nio.charset.Charset;

import com.amazonaws.SdkClientException;
import com.amazonaws.services.s3.model.GetObjectRequest;
import com.amazonaws.services.s3.model.ObjectMetadata;
import com.amazonaws.services.s3.model.S3Object;
import com.amazonaws.services.s3.model.S3ObjectInputStream;
import org.junit.Test;

import org.apache.commons.io.IOUtils;
import org.apache.hadoop.fs.Path;
import org.apache.hadoop.fs.s3a.audit.impl.NoopSpan;
import org.apache.hadoop.fs.s3a.auth.delegation.EncryptionSecrets;
import org.apache.hadoop.fs.s3a.impl.ChangeDetectionPolicy;

import static java.lang.Math.min;
import static org.junit.Assert.assertArrayEquals;
import static org.junit.Assert.assertEquals;


public class TestS3AInputStreamRetry extends AbstractS3AMockTest {

  private static final String INPUT = "ab";

  @Test
  public void testInputStreamReadRetryForException() throws IOException {
    S3AInputStream s3AInputStream = getMockedS3AInputStream();

    assertEquals("'a' from the test input stream 'ab' should be the first " +
        "character being read", INPUT.charAt(0), s3AInputStream.read());
    assertEquals("'b' from the test input stream 'ab' should be the second " +
        "character being read", INPUT.charAt(1), s3AInputStream.read());
  }

  @Test
  public void testInputStreamReadLengthRetryForException() throws IOException {
    byte[] result = new byte[INPUT.length()];
    S3AInputStream s3AInputStream = getMockedS3AInputStream();
    s3AInputStream.read(result, 0, INPUT.length());

    assertArrayEquals(
        "The read result should equals to the test input stream content",
        INPUT.getBytes(), result);
  }

  @Test
  public void testInputStreamReadFullyRetryForException() throws IOException {
    byte[] result = new byte[INPUT.length()];
    S3AInputStream s3AInputStream = getMockedS3AInputStream();
    s3AInputStream.readFully(0, result);

    assertArrayEquals(
        "The read result should equals to the test input stream content",
        INPUT.getBytes(), result);
  }

  private S3AInputStream getMockedS3AInputStream() {
    Path path = new Path("test-path");
    String eTag = "test-etag";
    String versionId = "test-version-id";
    String owner = "test-owner";

    S3AFileStatus s3AFileStatus = new S3AFileStatus(
        INPUT.length(), 0, path, INPUT.length(), owner, eTag, versionId);

    S3ObjectAttributes s3ObjectAttributes = new S3ObjectAttributes(
        fs.getBucket(),
        path,
        fs.pathToKey(path),
        fs.getS3EncryptionAlgorithm(),
        new EncryptionSecrets().getEncryptionKey(),
        eTag,
        versionId,
        INPUT.length());

    S3AReadOpContext s3AReadOpContext = fs.createReadContext(
        s3AFileStatus, S3AInputPolicy.Normal,
        ChangeDetectionPolicy.getPolicy(fs.getConf()), 100, NoopSpan.INSTANCE);

    return new S3AInputStream(
        s3AReadOpContext,
        s3ObjectAttributes,
        getMockedInputStreamCallback());
  }

  
  private S3AInputStream.InputStreamCallbacks getMockedInputStreamCallback() {
    return new S3AInputStream.InputStreamCallbacks() {

      private final S3Object mockedS3Object = getMockedS3Object();
      private Integer mockedS3ObjectIndex = 0;

      @Override
      public S3Object getObject(GetObjectRequest request) {
        
        mockedS3ObjectIndex++;
        
        
        
        
        
        
        
        
        
        
        
        
        
        if (mockedS3ObjectIndex == 3) {
          throw new SdkClientException("Failed to get S3Object");
        }
        return mockedS3Object;
      }

      @Override
      public GetObjectRequest newGetRequest(String key) {
        return new GetObjectRequest(fs.getBucket(), key);
      }

      @Override
      public void close() {
      }
    };
  }

  
  private S3Object getMockedS3Object() {
    S3ObjectInputStream objectInputStreamBad1 = getMockedInputStream(true);
    S3ObjectInputStream objectInputStreamBad2 = getMockedInputStream(true);
    S3ObjectInputStream objectInputStreamGood = getMockedInputStream(false);

    return new S3Object() {
      private final S3ObjectInputStream[] inputStreams =
          {objectInputStreamBad1, objectInputStreamBad2, objectInputStreamGood};

      private Integer inputStreamIndex = 0;

      @Override
      public S3ObjectInputStream getObjectContent() {
        
        
        inputStreamIndex++;
        return inputStreams[min(inputStreamIndex, inputStreams.length) - 1];
      }

      @Override
      public ObjectMetadata getObjectMetadata() {
        
        ObjectMetadata metadata = new ObjectMetadata();
        metadata.setHeader("ETag", "test-etag");
        return metadata;
      }
    };
  }

  
  private S3ObjectInputStream getMockedInputStream(boolean triggerFailure) {
    return new S3ObjectInputStream(
        IOUtils.toInputStream(INPUT, Charset.defaultCharset()), null) {

      private final IOException exception =
          new SSLException(new SocketException("Connection reset"));

      @Override
      public int read() throws IOException {
        int result = super.read();
        if (triggerFailure) {
          throw exception;
        }
        return result;
      }

      @Override
      public int read(byte[] b, int off, int len) throws IOException {
        int result = super.read(b, off, len);
        if (triggerFailure) {
          throw exception;
        }
        return result;
      }
    };
  }
}

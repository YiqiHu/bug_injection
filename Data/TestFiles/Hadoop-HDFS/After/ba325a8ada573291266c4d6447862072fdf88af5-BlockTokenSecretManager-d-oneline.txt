public class BlockTokenSecretManager extends    SecretManager<BlockTokenIdentifier> {  public static final Logger LOG =      LoggerFactory.getLogger(BlockTokenSecretManager.class);  public static final Token<BlockTokenIdentifier> DUMMY_TOKEN = new Token<BlockTokenIdentifier>();  private final boolean isMaster;    private long keyUpdateInterval;  private volatile long tokenLifetime;  private int serialNo;  private BlockKey currentKey;  private BlockKey nextKey;  private final Map<Integer, BlockKey> allKeys;  private String blockPoolId;  private final String encryptionAlgorithm;  private final int intRange;  private final int nnRangeStart;  private final boolean useProto;  private final boolean shouldWrapQOP;  private final SecureRandom nonceGenerator = new SecureRandom();    private Timer timer;    public BlockTokenSecretManager(long keyUpdateInterval,      long tokenLifetime, String blockPoolId, String encryptionAlgorithm,      boolean useProto) {    this(false, keyUpdateInterval, tokenLifetime, blockPoolId,        encryptionAlgorithm, 0, 1, useProto, false);  }  public BlockTokenSecretManager(long keyUpdateInterval,      long tokenLifetime, int nnIndex, int numNNs, String blockPoolId,      String encryptionAlgorithm, boolean useProto) {    this(keyUpdateInterval, tokenLifetime, nnIndex, numNNs,        blockPoolId, encryptionAlgorithm, useProto, false);  }  public BlockTokenSecretManager(long keyUpdateInterval,      long tokenLifetime, int nnIndex, int numNNs,  String blockPoolId,      String encryptionAlgorithm, boolean useProto, boolean shouldWrapQOP) {    this(true, keyUpdateInterval, tokenLifetime, blockPoolId,        encryptionAlgorithm, nnIndex, numNNs, useProto, shouldWrapQOP);    Preconditions.checkArgument(nnIndex >= 0);    Preconditions.checkArgument(numNNs > 0);  }    private BlockTokenSecretManager(boolean isMaster, long keyUpdateInterval,      long tokenLifetime, String blockPoolId, String encryptionAlgorithm,      int nnIndex, int numNNs, boolean useProto, boolean shouldWrapQOP) {    this.intRange = Integer.MAX_VALUE / numNNs;    this.nnRangeStart = intRange * nnIndex;    this.isMaster = isMaster;    this.keyUpdateInterval = keyUpdateInterval;    this.tokenLifetime = tokenLifetime;    this.allKeys = new HashMap<Integer, BlockKey>();    this.blockPoolId = blockPoolId;    this.encryptionAlgorithm = encryptionAlgorithm;    this.useProto = useProto;    this.shouldWrapQOP = shouldWrapQOP;    this.timer = new Timer();    setSerialNo(new SecureRandom().nextInt(Integer.MAX_VALUE));    LOG.info("Block token key range: [{}, {})",        nnRangeStart, nnRangeStart + intRange);    generateKeys();  }  @VisibleForTesting  public synchronized void setSerialNo(int nextNo) {        this.serialNo = (nextNo % intRange) + (nnRangeStart);    assert serialNo >= nnRangeStart && serialNo < (nnRangeStart + intRange) :      "serialNo " + serialNo + " is not in the designated range: [" +      nnRangeStart + ", " + (nnRangeStart + intRange) + ")";  }  public void setBlockPoolId(String blockPoolId) {    this.blockPoolId = blockPoolId;  }    private synchronized void generateKeys() {    if (!isMaster) {      return;    }        setSerialNo(serialNo + 1);    currentKey = new BlockKey(serialNo, timer.now() + 2        * keyUpdateInterval + tokenLifetime, generateSecret());    setSerialNo(serialNo + 1);    nextKey = new BlockKey(serialNo, timer.now() + 3        * keyUpdateInterval + tokenLifetime, generateSecret());    allKeys.put(currentKey.getKeyId(), currentKey);    allKeys.put(nextKey.getKeyId(), nextKey);  }    public synchronized ExportedBlockKeys exportKeys() {    if (!isMaster) {      return null;    }    LOG.debug("Exporting access keys");    return new ExportedBlockKeys(true, keyUpdateInterval, tokenLifetime,        currentKey, allKeys.values().toArray(new BlockKey[0]));  }  private synchronized void removeExpiredKeys() {    long now = timer.now();    for (Iterator<Map.Entry<Integer, BlockKey>> it = allKeys.entrySet()        .iterator(); it.hasNext();) {      Map.Entry<Integer, BlockKey> e = it.next();      if (e.getValue().getExpiryDate() < now) {        it.remove();      }    }  }    public synchronized void addKeys(ExportedBlockKeys exportedKeys)      throws IOException {    if (isMaster || exportedKeys == null) {      return;    }    LOG.info("Setting block keys");    removeExpiredKeys();    this.currentKey = exportedKeys.getCurrentKey();    BlockKey[] receivedKeys = exportedKeys.getAllKeys();    for (int i = 0; i < receivedKeys.length; i++) {      if (receivedKeys[i] != null) {        this.allKeys.put(receivedKeys[i].getKeyId(), receivedKeys[i]);      }    }  }    public synchronized boolean updateKeys(final long updateTime) throws IOException {    if (updateTime > keyUpdateInterval) {      return updateKeys();    }    return false;  }    synchronized boolean updateKeys() throws IOException {    if (!isMaster) {      return false;    }    LOG.info("Updating block keys");    removeExpiredKeys();        allKeys.put(currentKey.getKeyId(), new BlockKey(currentKey.getKeyId(),        timer.now() + keyUpdateInterval + tokenLifetime,        currentKey.getKey()));        currentKey = new BlockKey(nextKey.getKeyId(), timer.now()        + 2 * keyUpdateInterval + tokenLifetime, nextKey.getKey());    allKeys.put(currentKey.getKeyId(), currentKey);        setSerialNo(serialNo + 1);    nextKey = new BlockKey(serialNo, timer.now() + 3        * keyUpdateInterval + tokenLifetime, generateSecret());    allKeys.put(nextKey.getKeyId(), nextKey);    return true;  }    public Token<BlockTokenIdentifier> generateToken(ExtendedBlock block,      EnumSet<BlockTokenIdentifier.AccessMode> modes,      StorageType[] storageTypes, String[] storageIds) throws IOException {    UserGroupInformation ugi = UserGroupInformation.getCurrentUser();    String userID = (ugi == null ? null : ugi.getShortUserName());    return generateToken(userID, block, modes, storageTypes, storageIds);  }    public Token<BlockTokenIdentifier> generateToken(String userId,      ExtendedBlock block, EnumSet<BlockTokenIdentifier.AccessMode> modes,      StorageType[] storageTypes, String[] storageIds) {    BlockTokenIdentifier id = new BlockTokenIdentifier(userId, block        .getBlockPoolId(), block.getBlockId(), modes, storageTypes,        storageIds, useProto);    if (shouldWrapQOP) {      String qop = Server.getAuxiliaryPortEstablishedQOP();      if (qop != null) {        id.setHandshakeMsg(qop.getBytes(Charsets.UTF_8));      }    }    return new Token<BlockTokenIdentifier>(id, this);  }    public void checkAccess(BlockTokenIdentifier id, String userId,      ExtendedBlock block, BlockTokenIdentifier.AccessMode mode,      StorageType[] storageTypes, String[] storageIds) throws InvalidToken {    checkAccess(id, userId, block, mode);    if (ArrayUtils.isNotEmpty(storageTypes)) {      checkAccess(id.getStorageTypes(), storageTypes, "StorageTypes");    }    if (ArrayUtils.isNotEmpty(storageIds)) {      checkAccess(id.getStorageIds(), storageIds, "StorageIDs");    }  }    public void checkAccess(BlockTokenIdentifier id, String userId,      ExtendedBlock block, BlockTokenIdentifier.AccessMode mode,      StorageType[] storageTypes) throws InvalidToken {    checkAccess(id, userId, block, mode);    if (ArrayUtils.isNotEmpty(storageTypes)) {      checkAccess(id.getStorageTypes(), storageTypes, "StorageTypes");    }  }  public void checkAccess(BlockTokenIdentifier id, String userId,      ExtendedBlock block, BlockTokenIdentifier.AccessMode mode)      throws InvalidToken {    if (LOG.isDebugEnabled()) {      LOG.debug("Checking access for user=" + userId + ", block=" + block          + ", access mode=" + mode + " using " + id);    }    if (userId != null && !userId.equals(id.getUserId())) {      throw new InvalidToken("Block token with " + id          + " doesn't belong to user " + userId);    }    if (!id.getBlockPoolId().equals(block.getBlockPoolId())) {      throw new InvalidToken("Block token with " + id          + " doesn't apply to block " + block);    }    if (id.getBlockId() != block.getBlockId()) {      throw new InvalidToken("Block token with " + id          + " doesn't apply to block " + block);    }    if (isExpired(id.getExpiryDate())) {      throw new InvalidToken("Block token with " + id          + " is expired.");    }    if (!id.getAccessModes().contains(mode)) {      throw new InvalidToken("Block token with " + id          + " doesn't have " + mode + " permission");    }  }    public static <T> void checkAccess(T[] candidates, T[] requested, String msg)      throws InvalidToken {    if (ArrayUtils.isEmpty(requested)) {      throw new InvalidToken("The request has no " + msg + ". "          + "This is probably a configuration error.");    }    if (ArrayUtils.isEmpty(candidates)) {      return;    }    Multiset<T> c = HashMultiset.create(Arrays.asList(candidates));    for (T req : requested) {      if (!c.remove(req)) {        throw new InvalidToken("Block token with " + msg + " "            + Arrays.toString(candidates)            + " not valid for access with " + msg + " "            + Arrays.toString(requested));      }    }  }    public void checkAccess(Token<BlockTokenIdentifier> token, String userId,      ExtendedBlock block, BlockTokenIdentifier.AccessMode mode,      StorageType[] storageTypes, String[] storageIds) throws InvalidToken {    BlockTokenIdentifier id = new BlockTokenIdentifier();    try {      id.readFields(new DataInputStream(new ByteArrayInputStream(token          .getIdentifier())));    } catch (IOException e) {      throw new InvalidToken(          "Unable to de-serialize block token identifier for user=" + userId              + ", block=" + block + ", access mode=" + mode);    }    checkAccess(id, userId, block, mode, storageTypes, storageIds);    if (!MessageDigest.isEqual(retrievePassword(id), token.getPassword())) {      throw new InvalidToken("Block token with " + id          + " doesn't have the correct token password");    }  }    public void checkAccess(Token<BlockTokenIdentifier> token, String userId,      ExtendedBlock block, BlockTokenIdentifier.AccessMode mode)      throws InvalidToken {    BlockTokenIdentifier id = new BlockTokenIdentifier();    try {      id.readFields(new DataInputStream(new ByteArrayInputStream(token          .getIdentifier())));    } catch (IOException e) {      throw new InvalidToken(          "Unable to de-serialize block token identifier for user=" + userId              + ", block=" + block + ", access mode=" + mode);    }    checkAccess(id, userId, block, mode);    if (!MessageDigest.isEqual(retrievePassword(id), token.getPassword())) {      throw new InvalidToken("Block token with " + id          + " doesn't have the correct token password");    }  }  private static boolean isExpired(long expiryDate) {    return Time.now() > expiryDate;  }    static boolean isTokenExpired(Token<BlockTokenIdentifier> token)      throws IOException {    ByteArrayInputStream buf = new ByteArrayInputStream(token.getIdentifier());    DataInputStream in = new DataInputStream(buf);    long expiryDate = WritableUtils.readVLong(in);    return isExpired(expiryDate);  }    public void setTokenLifetime(long tokenLifetime) {    this.tokenLifetime = tokenLifetime;  }    @Override  public BlockTokenIdentifier createIdentifier() {    return new BlockTokenIdentifier();  }    @Override  protected byte[] createPassword(BlockTokenIdentifier identifier) {    BlockKey key = null;    synchronized (this) {      key = currentKey;    }    if (key == null) {      throw new IllegalStateException("currentKey hasn't been initialized.");    }    identifier.setExpiryDate(timer.now() + tokenLifetime);    identifier.setKeyId(key.getKeyId());    if (LOG.isDebugEnabled()) {      LOG.debug("Generating block token for " + identifier);    }    return createPassword(identifier.getBytes(), key.getKey());  }    @Override  public byte[] retrievePassword(BlockTokenIdentifier identifier)      throws InvalidToken {    if (isExpired(identifier.getExpiryDate())) {      throw new InvalidToken("Block token with " + identifier          + " is expired.");    }    BlockKey key = null;    synchronized (this) {      key = allKeys.get(identifier.getKeyId());    }    if (key == null) {      throw new InvalidToken("Can't re-compute password for "          + identifier + ", since the required block key (keyID="          + identifier.getKeyId() + ") doesn't exist.");    }    return createPassword(identifier.getBytes(), key.getKey());  }    public DataEncryptionKey generateDataEncryptionKey() {    byte[] nonce = new byte[8];    nonceGenerator.nextBytes(nonce);    BlockKey key = null;    synchronized (this) {      key = currentKey;    }    byte[] encryptionKey = createPassword(nonce, key.getKey());    return new DataEncryptionKey(key.getKeyId(), blockPoolId, nonce,        encryptionKey, timer.now() + tokenLifetime,        encryptionAlgorithm);  }    public byte[] retrieveDataEncryptionKey(int keyId, byte[] nonce)      throws InvalidEncryptionKeyException {    BlockKey key = null;    synchronized (this) {      key = allKeys.get(keyId);      if (key == null) {        throw new InvalidEncryptionKeyException("Can't re-compute encryption key"            + " for nonce, since the required block key (keyID=" + keyId            + ") doesn't exist. Current key: " + currentKey.getKeyId());      }    }    return createPassword(nonce, key.getKey());  }  public BlockKey getCurrentKey() {    return currentKey;  }  @VisibleForTesting  public synchronized void setKeyUpdateIntervalForTesting(long millis) {    this.keyUpdateInterval = millis;  }  @VisibleForTesting  public void clearAllKeysForTesting() {    allKeys.clear();  }  @VisibleForTesting  public synchronized boolean hasKey(int keyId) {    BlockKey key = allKeys.get(keyId);    return key != null;  }  @VisibleForTesting  public synchronized int getSerialNoForTesting() {    return serialNo;  }}
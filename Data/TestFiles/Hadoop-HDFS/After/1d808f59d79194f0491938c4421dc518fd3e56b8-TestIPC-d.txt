

package org.apache.hadoop.ipc;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.doAnswer;
import static org.mockito.Mockito.doThrow;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.spy;
import static org.mockito.Mockito.timeout;
import static org.mockito.Mockito.verify;

import java.io.ByteArrayOutputStream;
import java.io.DataInput;
import java.io.DataOutput;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import java.net.InetAddress;
import java.net.InetSocketAddress;
import java.net.ServerSocket;
import java.net.Socket;
import java.net.SocketAddress;
import java.net.SocketException;
import java.net.SocketTimeoutException;
import java.net.UnknownHostException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Random;
import java.util.Set;
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.Callable;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.CyclicBarrier;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;

import javax.net.SocketFactory;

import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.fs.CommonConfigurationKeys;
import org.apache.hadoop.fs.CommonConfigurationKeysPublic;
import org.apache.hadoop.io.IOUtils;
import org.apache.hadoop.io.LongWritable;
import org.apache.hadoop.io.Writable;
import org.apache.hadoop.io.retry.DefaultFailoverProxyProvider;
import org.apache.hadoop.io.retry.FailoverProxyProvider;
import org.apache.hadoop.io.retry.Idempotent;
import org.apache.hadoop.io.retry.RetryPolicies;
import org.apache.hadoop.io.retry.RetryProxy;
import org.apache.hadoop.ipc.Client.ConnectionId;
import org.apache.hadoop.ipc.RPC.RpcKind;
import org.apache.hadoop.ipc.Server.Call;
import org.apache.hadoop.ipc.Server.Connection;
import org.apache.hadoop.ipc.protobuf.RpcHeaderProtos.RpcResponseHeaderProto;
import org.apache.hadoop.net.ConnectTimeoutException;
import org.apache.hadoop.net.NetUtils;
import org.apache.hadoop.security.KerberosInfo;
import org.apache.hadoop.security.SecurityUtil;
import org.apache.hadoop.security.UserGroupInformation;
import org.apache.hadoop.security.UserGroupInformation.AuthenticationMethod;
import org.apache.hadoop.security.token.SecretManager.InvalidToken;
import org.apache.hadoop.test.GenericTestUtils;
import org.apache.hadoop.test.LambdaTestUtils;
import org.apache.hadoop.test.Whitebox;
import org.apache.hadoop.util.StringUtils;
import org.junit.Assert;
import org.junit.Assume;
import org.junit.Before;
import org.junit.Test;
import org.mockito.Mockito;
import org.mockito.invocation.InvocationOnMock;
import org.mockito.stubbing.Answer;

import java.util.function.Supplier;
import org.apache.hadoop.thirdparty.com.google.common.primitives.Bytes;
import org.apache.hadoop.thirdparty.com.google.common.primitives.Ints;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.slf4j.event.Level;

import static org.assertj.core.api.Assertions.assertThat;


public class TestIPC {
  public static final Logger LOG = LoggerFactory.getLogger(TestIPC.class);
  
  private static Configuration conf;
  final static int PING_INTERVAL = 1000;
  final static private int MIN_SLEEP_TIME = 1000;
  
  static boolean WRITABLE_FAULTS_ENABLED = true;
  static int WRITABLE_FAULTS_SLEEP = 0;
  
  @Before
  public void setupConf() {
    conf = new Configuration();
    Client.setPingInterval(conf, PING_INTERVAL);
    
    UserGroupInformation.setConfiguration(conf);
  }

  static final Random RANDOM = new Random();

  private static final String ADDRESS = "0.0.0.0";

  
  private static final File FD_DIR = new File("/proc/self/fd");

  static ConnectionId getConnectionId(InetSocketAddress addr, int rpcTimeout,
      Configuration conf) throws IOException {
    return ConnectionId.getConnectionId(addr, null,
        UserGroupInformation.getCurrentUser(), rpcTimeout, null, conf);
  }

  static Writable call(Client client, InetSocketAddress addr,
      int serviceClass, Configuration conf) throws IOException {
    final LongWritable param = new LongWritable(RANDOM.nextLong());
    final ConnectionId remoteId = getConnectionId(addr, MIN_SLEEP_TIME, conf);
    return client.call(RPC.RpcKind.RPC_BUILTIN, param, remoteId, serviceClass,
        null);
  }

  static LongWritable call(Client client, long param, InetSocketAddress addr,
      Configuration conf) throws IOException {
    return call(client, new LongWritable(param), addr, 0, conf);
  }

  static LongWritable call(Client client, LongWritable param,
      InetSocketAddress addr, int rpcTimeout, Configuration conf)
          throws IOException {
    final ConnectionId remoteId = getConnectionId(addr, rpcTimeout, conf);
    return (LongWritable)client.call(RPC.RpcKind.RPC_BUILTIN, param, remoteId,
        RPC.RPC_SERVICE_CLASS_DEFAULT, null);
  }

  static class TestServer extends Server {
    
    
    
    Runnable callListener;
    private boolean sleep;
    private Class<? extends Writable> responseClass;

    public TestServer(int handlerCount, boolean sleep) throws IOException {
      this(handlerCount, sleep, LongWritable.class, null);
    }

    public TestServer(int port, int handlerCount, boolean sleep)
        throws IOException {
      this(port, handlerCount, sleep, LongWritable.class, null);
    }

    public TestServer(int handlerCount, boolean sleep, Configuration conf)
        throws IOException {
      this(handlerCount, sleep, LongWritable.class, null, conf);
    }

    public TestServer(int handlerCount, boolean sleep,
        Class<? extends Writable> paramClass,
        Class<? extends Writable> responseClass) throws IOException {
      this(handlerCount, sleep, paramClass, responseClass, conf);
    }

    public TestServer(int port, int handlerCount, boolean sleep,
        Class<? extends Writable> paramClass,
        Class<? extends Writable> responseClass) throws IOException {
      this(port, handlerCount, sleep, paramClass, responseClass, conf);
    }

    public TestServer(int handlerCount, boolean sleep,
        Class<? extends Writable> paramClass,
        Class<? extends Writable> responseClass, Configuration conf)
        throws IOException {
      this(0, handlerCount, sleep, paramClass, responseClass, conf);
    }

    public TestServer(int port, int handlerCount, boolean sleep,
        Class<? extends Writable> paramClass,
        Class<? extends Writable> responseClass, Configuration conf)
        throws IOException {
      super(ADDRESS, port, paramClass, handlerCount, conf);
      this.sleep = sleep;
      this.responseClass = responseClass;
    }

    @Override
    public Writable call(RPC.RpcKind rpcKind, String protocol, Writable param,
        long receiveTime) throws IOException {
      if (sleep) {
        
        try {
          Thread.sleep(RANDOM.nextInt(PING_INTERVAL) + MIN_SLEEP_TIME);
        } catch (InterruptedException e) {}
      }
      if (callListener != null) {
        callListener.run();
      }
      if (responseClass != null) {
        try {
          return responseClass.newInstance();
        } catch (Exception e) {
          throw new RuntimeException(e);
        }  
      } else {
        return param;                               
      }
    }
  }

  private static class SerialCaller extends Thread {
    private Client client;
    private InetSocketAddress server;
    private int count;
    private boolean failed;

    public SerialCaller(Client client, InetSocketAddress server, int count) {
      this.client = client;
      this.server = server;
      this.count = count;
    }

    @Override
    public void run() {
      for (int i = 0; i < count; i++) {
        try {
          final long param = RANDOM.nextLong();
          LongWritable value = call(client, param, server, conf);
          if (value.get() != param) {
            LOG.error("Call failed!");
            failed = true;
            break;
          }
        } catch (Exception e) {
          LOG.error("Caught: " + StringUtils.stringifyException(e));
          failed = true;
        }
      }
    }
  }

  
  private static class TestInvocationHandler implements RpcInvocationHandler {
    private static int retry = 0;
    private final Client client;
    private final Server server;
    private final int total;
    
    TestInvocationHandler(Client client, Server server, int total) {
      this.client = client;
      this.server = server;
      this.total = total;
    }

    protected Object returnValue(Object value) throws Exception {
      if (retry++ < total) {
        throw new IOException("Fake IOException");
      }
      return value;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args)
        throws Throwable {
      LongWritable value = call(client, RANDOM.nextLong(),
          NetUtils.getConnectAddress(server), conf);
      return returnValue(value);
    }

    @Override
    public void close() throws IOException {}
    
    @Override
    public ConnectionId getConnectionId() {
      return null;
    }
  }

  private static class TestInvalidTokenHandler extends TestInvocationHandler {
    private int invocations = 0;
    TestInvalidTokenHandler(Client client, Server server) {
      super(client, server, 1);
    }

    @Override
    protected Object returnValue(Object value) throws Exception {
      throw new InvalidToken("Invalid Token");
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args)
        throws Throwable {
      invocations++;
      return super.invoke(proxy, method, args);
    }
  }

  @Test(timeout=60000)
  public void testSerial() throws IOException, InterruptedException {
    internalTestSerial(3, false, 2, 5, 100);
    internalTestSerial(3, true, 2, 5, 10);
  }

  public void internalTestSerial(int handlerCount, boolean handlerSleep,
                         int clientCount, int callerCount, int callCount)
    throws IOException, InterruptedException {
    Server server = new TestServer(handlerCount, handlerSleep);
    InetSocketAddress addr = NetUtils.getConnectAddress(server);
    server.start();

    Client[] clients = new Client[clientCount];
    for (int i = 0; i < clientCount; i++) {
      clients[i] = new Client(LongWritable.class, conf);
    }
    
    SerialCaller[] callers = new SerialCaller[callerCount];
    for (int i = 0; i < callerCount; i++) {
      callers[i] = new SerialCaller(clients[i%clientCount], addr, callCount);
      callers[i].start();
    }
    for (int i = 0; i < callerCount; i++) {
      callers[i].join();
      assertFalse(callers[i].failed);
    }
    for (int i = 0; i < clientCount; i++) {
      clients[i].stop();
    }
    server.stop();
  }

  @Test
  public void testAuxiliaryPorts() throws IOException, InterruptedException {
    int defaultPort = 9000;
    int[] auxiliaryPorts = {9001, 9002, 9003};
    final int handlerCount = 5;
    final boolean handlerSleep = false;
    Server server = new TestServer(defaultPort, handlerCount, handlerSleep);
    for (int port : auxiliaryPorts) {
      server.addAuxiliaryListener(port);
    }
    Set<InetSocketAddress> listenerAddrs =
        server.getAuxiliaryListenerAddresses();
    Set<InetSocketAddress> addrs = new HashSet<>();
    for (InetSocketAddress addr : listenerAddrs) {
      addrs.add(NetUtils.getConnectAddress(addr));
    }
    server.start();

    Client client = new Client(LongWritable.class, conf);
    Set<SerialCaller> calls = new HashSet<>();
    for (InetSocketAddress addr : addrs) {
      calls.add(new SerialCaller(client, addr, 100));
    }
    for (SerialCaller caller : calls) {
      caller.join();
      assertFalse(caller.failed);
    }
    client.stop();
    server.stop();
  }
	
  @Test(timeout=60000)
  public void testStandAloneClient() throws IOException {
    Client client = new Client(LongWritable.class, conf);
    InetSocketAddress address = new InetSocketAddress("127.0.0.1", 10);
    try {
      call(client, RANDOM.nextLong(), address, conf);
      fail("Expected an exception to have been thrown");
    } catch (IOException e) {
      String message = e.getMessage();
      String addressText = address.getHostName() + ":" + address.getPort();
      assertTrue("Did not find "+addressText+" in "+message,
              message.contains(addressText));
      Throwable cause=e.getCause();
      assertNotNull("No nested exception in "+e,cause);
      String causeText=cause.getMessage();
      assertTrue("Did not find " + causeText + " in " + message,
              message.contains(causeText));
    } finally {
      client.stop();
    }
  }
  
  static void maybeThrowIOE() throws IOException {
    if (WRITABLE_FAULTS_ENABLED) {
      maybeSleep();
      throw new IOException("Injected fault");
    }
  }

  static void maybeThrowRTE() {
    if (WRITABLE_FAULTS_ENABLED) {
      maybeSleep();
      throw new RuntimeException("Injected fault");
    }
  }

  private static void maybeSleep() {
    if (WRITABLE_FAULTS_SLEEP > 0) {
      try {
        Thread.sleep(WRITABLE_FAULTS_SLEEP);
      } catch (InterruptedException ie) {
      }
    }
  }

  @SuppressWarnings("unused")
  private static class IOEOnReadWritable extends LongWritable {
    public IOEOnReadWritable() {}

    @Override
    public void readFields(DataInput in) throws IOException {
      super.readFields(in);
      maybeThrowIOE();
    }
  }
  
  @SuppressWarnings("unused")
  private static class RTEOnReadWritable extends LongWritable {
    public RTEOnReadWritable() {}
    
    @Override
    public void readFields(DataInput in) throws IOException {
      super.readFields(in);
      maybeThrowRTE();
    }
  }
  
  @SuppressWarnings("unused")
  private static class IOEOnWriteWritable extends LongWritable {
    public IOEOnWriteWritable() {}

    @Override
    public void write(DataOutput out) throws IOException {
      super.write(out);
      maybeThrowIOE();
    }
  }

  @SuppressWarnings("unused")
  private static class RTEOnWriteWritable extends LongWritable {
    public RTEOnWriteWritable() {}

    @Override
    public void write(DataOutput out) throws IOException {
      super.write(out);
      maybeThrowRTE();
    }
  }
  
  
  private void doErrorTest(
      Class<? extends LongWritable> clientParamClass,
      Class<? extends LongWritable> serverParamClass,
      Class<? extends LongWritable> serverResponseClass,
      Class<? extends LongWritable> clientResponseClass) 
      throws IOException, InstantiationException, IllegalAccessException {
    
    
    Server server = new TestServer(1, false,
        serverParamClass, serverResponseClass);
    InetSocketAddress addr = NetUtils.getConnectAddress(server);
    server.start();

    
    WRITABLE_FAULTS_ENABLED = true;
    Client client = new Client(clientResponseClass, conf);
    try {
      LongWritable param = clientParamClass.newInstance();

      try {
        call(client, param, addr, 0, conf);
        fail("Expected an exception to have been thrown");
      } catch (Throwable t) {
        assertExceptionContains(t, "Injected fault");
      }
      
      
      
      
      WRITABLE_FAULTS_ENABLED = false;
      call(client, param, addr, 0, conf);
      
    } finally {
      client.stop();
      server.stop();
    }
  }

  @Test(timeout=60000)
  public void testIOEOnClientWriteParam() throws Exception {
    doErrorTest(IOEOnWriteWritable.class,
        LongWritable.class,
        LongWritable.class,
        LongWritable.class);
  }
  
  @Test(timeout=60000)
  public void testRTEOnClientWriteParam() throws Exception {
    doErrorTest(RTEOnWriteWritable.class,
        LongWritable.class,
        LongWritable.class,
        LongWritable.class);
  }

  @Test(timeout=60000)
  public void testIOEOnServerReadParam() throws Exception {
    doErrorTest(LongWritable.class,
        IOEOnReadWritable.class,
        LongWritable.class,
        LongWritable.class);
  }
  
  @Test(timeout=60000)
  public void testRTEOnServerReadParam() throws Exception {
    doErrorTest(LongWritable.class,
        RTEOnReadWritable.class,
        LongWritable.class,
        LongWritable.class);
  }

  
  @Test(timeout=60000)
  public void testIOEOnServerWriteResponse() throws Exception {
    doErrorTest(LongWritable.class,
        LongWritable.class,
        IOEOnWriteWritable.class,
        LongWritable.class);
  }
  
  @Test(timeout=60000)
  public void testRTEOnServerWriteResponse() throws Exception {
    doErrorTest(LongWritable.class,
        LongWritable.class,
        RTEOnWriteWritable.class,
        LongWritable.class);
  }
  
  @Test(timeout=60000)
  public void testIOEOnClientReadResponse() throws Exception {
    doErrorTest(LongWritable.class,
        LongWritable.class,
        LongWritable.class,
        IOEOnReadWritable.class);
  }
  
  @Test(timeout=60000)
  public void testRTEOnClientReadResponse() throws Exception {
    doErrorTest(LongWritable.class,
        LongWritable.class,
        LongWritable.class,
        RTEOnReadWritable.class);
  }
  
  
  @Test(timeout=60000)
  public void testIOEOnWriteAfterPingClient() throws Exception {
    
    Client.setPingInterval(conf, 100);

    try {
      WRITABLE_FAULTS_SLEEP = 1000;
      doErrorTest(IOEOnWriteWritable.class,
          LongWritable.class,
          LongWritable.class,
          LongWritable.class);
    } finally {
      WRITABLE_FAULTS_SLEEP = 0;
    }
  }
  
  private static void assertExceptionContains(
      Throwable t, String substring) {
    String msg = StringUtils.stringifyException(t);
    assertTrue("Exception should contain substring '" + substring + "':\n" +
        msg, msg.contains(substring));
    LOG.info("Got expected exception", t);
  }
  
  
  @Test(timeout=60000)
  public void testSocketFactoryException() throws IOException {
    SocketFactory mockFactory = mock(SocketFactory.class);
    doThrow(new IOException("Injected fault")).when(mockFactory).createSocket();
    Client client = new Client(LongWritable.class, conf, mockFactory);
    
    InetSocketAddress address = new InetSocketAddress("127.0.0.1", 10);
    try {
      call(client, RANDOM.nextLong(), address, conf);
      fail("Expected an exception to have been thrown");
    } catch (IOException e) {
      assertTrue(e.getMessage().contains("Injected fault"));
    } finally {
      client.stop();
    }
  }

  
  static class MockSocket extends Socket {
    @Override
    public synchronized void setSoTimeout(int timeout) {
      throw new RuntimeException("Injected fault");
    }
  }

  
  @Test(timeout=60000)
  public void testRTEDuringConnectionSetup() throws IOException {
    
    
    SocketFactory spyFactory = spy(NetUtils.getDefaultSocketFactory(conf));
    Mockito.doAnswer(new Answer<Socket>() {
      @Override
      public Socket answer(InvocationOnMock invocation) {
        return new MockSocket();
      }
    }).when(spyFactory).createSocket();
      
    Server server = new TestServer(1, true);
    Client client = new Client(LongWritable.class, conf, spyFactory);
    server.start();
    try {
      
      InetSocketAddress address = NetUtils.getConnectAddress(server);
      try {
        call(client, RANDOM.nextLong(), address, conf);
        fail("Expected an exception to have been thrown");
      } catch (Exception e) {
        LOG.info("caught expected exception", e);
        assertTrue(StringUtils.stringifyException(e).contains(
            "Injected fault"));
      }
      
      
  
      Mockito.reset(spyFactory);
      call(client, RANDOM.nextLong(), address, conf);
    } finally {
      client.stop();
      server.stop();
    }
  }
  
  @Test(timeout=60000)
  public void testIpcTimeout() throws IOException {
    
    Server server = new TestServer(1, true);
    InetSocketAddress addr = NetUtils.getConnectAddress(server);
    server.start();

    
    Client client = new Client(LongWritable.class, conf);
    
    try {
      call(client, new LongWritable(RANDOM.nextLong()), addr,
          MIN_SLEEP_TIME / 2, conf);
      fail("Expected an exception to have been thrown");
    } catch (SocketTimeoutException e) {
      LOG.info("Get a SocketTimeoutException ", e);
    }
    
    call(client, new LongWritable(RANDOM.nextLong()), addr,
        3 * PING_INTERVAL + MIN_SLEEP_TIME, conf);
    client.stop();
  }

  @Test(timeout=60000)
  public void testIpcConnectTimeout() throws IOException {
    
    Server server = new TestServer(1, true);
    InetSocketAddress addr = NetUtils.getConnectAddress(server);
    

    
    Client.setConnectTimeout(conf, 100);
    Client client = new Client(LongWritable.class, conf);
    
    try {
      call(client, new LongWritable(RANDOM.nextLong()), addr,
          MIN_SLEEP_TIME * 2, conf);
      fail("Expected an exception to have been thrown");
    } catch (SocketTimeoutException e) {
      LOG.info("Get a SocketTimeoutException ", e);
    }
    client.stop();
  }
  
  
  @Test(timeout=60000)
  public void testIpcWithServiceClass() throws IOException {
    
    Server server = new TestServer(5, false);
    InetSocketAddress addr = NetUtils.getConnectAddress(server);
    server.start();

    
    Client.setConnectTimeout(conf, 10000);

    callAndVerify(server, addr, 0, true);
    
    
    callAndVerify(server, addr, -128, true);
    callAndVerify(server, addr, -129, false);

    
    
    callAndVerify(server, addr, 127, true);
    callAndVerify(server, addr, 128, false);

    server.stop();
  }

  private static class TestServerQueue extends Server {
    final CountDownLatch firstCallLatch = new CountDownLatch(1);
    final CountDownLatch callBlockLatch = new CountDownLatch(1);
    
    TestServerQueue(int expectedCalls, int readers, int callQ, int handlers,
        Configuration conf) throws IOException {
      super(ADDRESS, 0, LongWritable.class, handlers, readers, callQ, conf, null, null); 
    }

    @Override
    public Writable call(RPC.RpcKind rpcKind, String protocol, Writable param,
        long receiveTime) throws IOException {
      firstCallLatch.countDown();
      try {
        callBlockLatch.await();
      } catch (InterruptedException e) {
        throw new IOException(e);
      }
      return param;
    }
  }

  @Test(timeout=60000)
  public void testIpcHostResolutionTimeout() throws Exception {
    final InetSocketAddress addr = new InetSocketAddress("host.invalid", 80);

    
    Client.setConnectTimeout(conf, 100);
    final Client client = new Client(LongWritable.class, conf);
    
    try {
      LambdaTestUtils.intercept(UnknownHostException.class,
          new Callable<Void>() {
            @Override
            public Void call() throws IOException {
              TestIPC.this.call(client, new LongWritable(RANDOM.nextLong()),
                  addr, MIN_SLEEP_TIME * 2, conf);
              return null;
            }
          });
    } finally {
      client.stop();
    }
  }

  @Test(timeout=60000)
  public void testIpcFlakyHostResolution() throws IOException {
    
    Server server = new TestServer(5, false);
    server.start();

    
    
    
    InetSocketAddress unresolvedAddr = InetSocketAddress.createUnresolved(
        "localhost", NetUtils.getConnectAddress(server).getPort());

    
    Client.setConnectTimeout(conf, 100);
    Client client = new Client(LongWritable.class, conf);

    try {
      
      call(client, new LongWritable(RANDOM.nextLong()), unresolvedAddr,
          MIN_SLEEP_TIME * 2, conf);
    } finally {
      client.stop();
      server.stop();
    }
  }

  
  @Test(timeout=60000)
  public void testIpcWithReaderQueuing() throws Exception {
    
    for (int i=0; i < 10; i++) {
      checkBlocking(1, 1, 1);
    }
    
    for (int i=0; i < 10; i++) {
      checkBlocking(4, 5, 2);
    }
  }
  
  
  
  
  @SuppressWarnings("unchecked")
  private void checkBlocking(int readers, int readerQ, int callQ) throws Exception {
    int handlers = 1; 
    
    final Configuration conf = new Configuration();
    conf.setInt(CommonConfigurationKeys.IPC_SERVER_RPC_READ_CONNECTION_QUEUE_SIZE_KEY, readerQ);

    
    final int initialClients = readers + callQ + handlers;
    
    final int maxAccept = initialClients + readers*readerQ + 1; 
    
    int clients = maxAccept*2;
    
    final AtomicInteger failures = new AtomicInteger(0);
    final CountDownLatch callFinishedLatch = new CountDownLatch(clients);

    
    final TestServerQueue server =
        new TestServerQueue(clients, readers, callQ, handlers, conf);
    CallQueueManager<Call> spy = spy(
        (CallQueueManager<Call>)Whitebox.getInternalState(server, "callQueue"));
    Whitebox.setInternalState(server, "callQueue", spy);
    final InetSocketAddress addr = NetUtils.getConnectAddress(server);
    server.start();

    Client.setConnectTimeout(conf, 10000);
    
    
    Thread[] threads = new Thread[clients];
    for (int i=0; i<clients; i++) {
      threads[i] = new Thread(new Runnable() {
        @Override
        public void run() {
          Client client = new Client(LongWritable.class, conf);
          try {
            call(client, new LongWritable(Thread.currentThread().getId()),
                addr, 60000, conf);
          } catch (Throwable e) {
            LOG.error(e.toString());
            failures.incrementAndGet();
            return;
          } finally {
            callFinishedLatch.countDown();            
            client.stop();
          }
        }
      });
    }
    
    
    
    
    for (int i=0; i < initialClients; i++) {
      threads[i].start();
      if (i==0) {
        
        server.firstCallLatch.await();
      }
      
      
      verify(spy, timeout(5000).times(i + 1)).put(any());
    }

    try {
      
      GenericTestUtils.waitFor(new Supplier<Boolean>() {
        @Override public Boolean get() {
          return server.getNumOpenConnections() >= initialClients;
        }
      }, 100, 3000);
    } catch (TimeoutException e) {
      fail("timed out while waiting for connections to open.");
    }
    LOG.info("(initial clients) need:"+initialClients
        +" connections have:"+server.getNumOpenConnections());
    LOG.info("ipc layer should be blocked");
    assertEquals(callQ, server.getCallQueueLen());
    assertEquals(initialClients, server.getNumOpenConnections());
    
    
    
    for (int i=initialClients; i<clients; i++) {
      threads[i].start();
    }
    Thread.sleep(10);

    try {
      GenericTestUtils.waitFor(new Supplier<Boolean>() {
        @Override public Boolean get() {
          return server.getNumOpenConnections() >= maxAccept;
        }
      }, 100, 3000);
    } catch (TimeoutException e) {
      fail("timed out while waiting for connections to open until maxAccept.");
    }
    LOG.info("(max clients) need:"+maxAccept
        +" connections have:"+server.getNumOpenConnections());
    
    for (int i=0; i<4; i++) {
      assertEquals(maxAccept, server.getNumOpenConnections());
      Thread.sleep(100);
    }
    
    
    assertEquals(clients, callFinishedLatch.getCount());
    LOG.info("releasing the calls");
    server.callBlockLatch.countDown();
    callFinishedLatch.await();
    for (Thread t : threads) {
      t.join();
    }
    assertEquals(0, failures.get());
    server.stop();
  }

  @Test(timeout=30000)
  public void testConnectionIdleTimeouts() throws Exception {
    GenericTestUtils.setLogLevel(Server.LOG, Level.DEBUG);
    final int maxIdle = 1000;
    final int cleanupInterval = maxIdle*3/4; 
    final int killMax = 3;
    final int clients = 1 + killMax*2; 
    
    conf.setInt(CommonConfigurationKeysPublic.IPC_CLIENT_CONNECTION_MAXIDLETIME_KEY, maxIdle);
    conf.setInt(CommonConfigurationKeysPublic.IPC_CLIENT_IDLETHRESHOLD_KEY, 0);
    conf.setInt(CommonConfigurationKeysPublic.IPC_CLIENT_KILL_MAX_KEY, killMax);
    conf.setInt(CommonConfigurationKeys.IPC_CLIENT_CONNECTION_IDLESCANINTERVAL_KEY, cleanupInterval);
    
    final CyclicBarrier firstCallBarrier = new CyclicBarrier(2);
    final CyclicBarrier callBarrier = new CyclicBarrier(clients);
    final CountDownLatch allCallLatch = new CountDownLatch(clients);
    final AtomicBoolean error = new AtomicBoolean();
    
    final TestServer server = new TestServer(clients, false);
    Thread[] threads = new Thread[clients];
    try {
      server.callListener = new Runnable(){
        AtomicBoolean first = new AtomicBoolean(true);
        @Override
        public void run() {
          try {
            allCallLatch.countDown();
            
            if (first.compareAndSet(true, false)) {
              firstCallBarrier.await();
            } else {
              callBarrier.await();
            }
          } catch (Throwable t) {
            LOG.error(t.toString());
            error.set(true); 
          } 
        }
      };
      server.start();

      
      final CountDownLatch callReturned = new CountDownLatch(clients-1);
      final InetSocketAddress addr = NetUtils.getConnectAddress(server);
      final Configuration clientConf = new Configuration();
      clientConf.setInt(CommonConfigurationKeysPublic.IPC_CLIENT_CONNECTION_MAXIDLETIME_KEY, 10000);
      for (int i=0; i < clients; i++) {
        threads[i] = new Thread(new Runnable(){
          @Override
          public void run() {
            Client client = new Client(LongWritable.class, clientConf);
            try {
              call(client, Thread.currentThread().getId(), addr, clientConf);
              callReturned.countDown();
              Thread.sleep(10000);
            } catch (IOException e) {
              LOG.error(e.toString());
            } catch (InterruptedException e) {
            } finally {
              client.stop();
            }
          }
        });
        threads[i].start();
      }
      
      
      allCallLatch.await();
      assertFalse(error.get());
      assertEquals(clients, server.getNumOpenConnections());
      
      
      
      callBarrier.await();
      callReturned.await();
      assertEquals(clients, server.getNumOpenConnections());
      
      
      
      
      Thread.sleep(maxIdle*2-cleanupInterval);
      for (int i=clients; i > 1; i -= killMax) {
        Thread.sleep(cleanupInterval);
        assertFalse(error.get());
        assertEquals(i, server.getNumOpenConnections());
      }

      
      Thread.sleep(cleanupInterval);
      assertFalse(error.get());
      assertEquals(1, server.getNumOpenConnections());
     
      
      firstCallBarrier.await();
      Thread.sleep(maxIdle*2);
      assertFalse(error.get());
      assertEquals(0, server.getNumOpenConnections());
    } finally {
      for (Thread t : threads) {
        if (t != null) {
          t.interrupt();
          t.join();
        }
        server.stop();
      }
    }
  }

  
  private static void callAndVerify(Server server, InetSocketAddress addr,
      int serviceClass, boolean noChanged) throws IOException{
    Client client = new Client(LongWritable.class, conf);

    call(client, addr, serviceClass, conf);
    Connection connection = server.getConnections()[0];
    int serviceClass2 = connection.getServiceClass();
    assertFalse(noChanged ^ serviceClass == serviceClass2);
    client.stop();
  }
  
  @Test(timeout=30000, expected=IOException.class)
  public void testIpcAfterStopping() throws IOException {
    
    Server server = new TestServer(5, false);
    InetSocketAddress addr = NetUtils.getConnectAddress(server);
    server.start();

    
    Client client = new Client(LongWritable.class, conf);
    call(client, addr, 0, conf);
    client.stop();
 
    
    call(client, addr, 0, conf);
  }

  
  @Test(timeout=60000)
  public void testSocketLeak() throws IOException {
    Assume.assumeTrue(FD_DIR.exists()); 

    long startFds = countOpenFileDescriptors();
    for (int i = 0; i < 50; i++) {
      Server server = new TestServer(1, true);
      server.start();
      server.stop();
    }
    long endFds = countOpenFileDescriptors();
    
    assertTrue("Leaked " + (endFds - startFds) + " file descriptors",
        endFds - startFds < 20);
  }
  
  
  @Test(timeout=30000)
  public void testInterrupted() {
    Client client = new Client(LongWritable.class, conf);
    Client.getClientExecutor().submit(new Runnable() {
      public void run() {
        while(true);
      }
    });
    Thread.currentThread().interrupt();
    client.stop();
    try {
      assertTrue(Thread.currentThread().isInterrupted());
      LOG.info("Expected thread interrupt during client cleanup");
    } catch (AssertionError e) {
      LOG.error("The Client did not interrupt after handling an Interrupted Exception");
      Assert.fail("The Client did not interrupt after handling an Interrupted Exception");
    }
    
    Thread.interrupted();
  }

  private long countOpenFileDescriptors() {
    return FD_DIR.list().length;
  }

  @Test(timeout=60000)
  public void testIpcFromHadoop_0_18_13() throws IOException {
    doIpcVersionTest(NetworkTraces.HADOOP_0_18_3_RPC_DUMP,
        NetworkTraces.RESPONSE_TO_HADOOP_0_18_3_RPC);
  }
  
  @Test(timeout=60000)
  public void testIpcFromHadoop0_20_3() throws IOException {
    doIpcVersionTest(NetworkTraces.HADOOP_0_20_3_RPC_DUMP,
        NetworkTraces.RESPONSE_TO_HADOOP_0_20_3_RPC);
  }
  
  @Test(timeout=60000)
  public void testIpcFromHadoop0_21_0() throws IOException {
    doIpcVersionTest(NetworkTraces.HADOOP_0_21_0_RPC_DUMP,
        NetworkTraces.RESPONSE_TO_HADOOP_0_21_0_RPC);
  }
  
  @Test(timeout=60000)
  public void testHttpGetResponse() throws IOException {
    doIpcVersionTest("GET / HTTP/1.0\r\n\r\n".getBytes(),
        Server.RECEIVED_HTTP_REQ_RESPONSE.getBytes());
  }
  
  @Test(timeout=60000)
  public void testConnectionRetriesOnSocketTimeoutExceptions() throws IOException {
    Configuration conf = new Configuration();
    
    conf.setInt(
      CommonConfigurationKeysPublic.IPC_CLIENT_CONNECT_MAX_RETRIES_ON_SOCKET_TIMEOUTS_KEY,
      0);
    assertRetriesOnSocketTimeouts(conf, 1);

    
    conf.setInt(
      CommonConfigurationKeysPublic.IPC_CLIENT_CONNECT_MAX_RETRIES_ON_SOCKET_TIMEOUTS_KEY,
      3);
    assertRetriesOnSocketTimeouts(conf, 4);
  }

  static class CallInfo {
    int id = RpcConstants.INVALID_CALL_ID;
    int retry = RpcConstants.INVALID_RETRY_COUNT;
  }

  
  @Test(timeout=60000)
  public void testCallIdAndRetry() throws IOException {
    final CallInfo info = new CallInfo();

    
    final Client client = new Client(LongWritable.class, conf) {
      @Override
      Call createCall(RpcKind rpcKind, Writable rpcRequest) {
        final Call call = super.createCall(rpcKind, rpcRequest);
        info.id = call.id;
        info.retry = call.retry;
        return call;
      }
      
      @Override
      void checkResponse(RpcResponseHeaderProto header) throws IOException {
        super.checkResponse(header);
        Assert.assertEquals(info.id, header.getCallId());
        Assert.assertEquals(info.retry, header.getRetryCount());
      }
    };

    
    final TestServer server = new TestServer(1, false);
    server.callListener = new Runnable() {
      @Override
      public void run() {
        Assert.assertEquals(info.id, Server.getCallId());
        Assert.assertEquals(info.retry, Server.getCallRetryCount());
      }
    };

    try {
      InetSocketAddress addr = NetUtils.getConnectAddress(server);
      server.start();
      final SerialCaller caller = new SerialCaller(client, addr, 10);
      caller.run();
      assertFalse(caller.failed);
    } finally {
      client.stop();
      server.stop();
    }
  }
  
  
  interface DummyProtocol {
    @Idempotent
    public void dummyRun() throws IOException;
  }
  
  
  @Test(timeout=60000)
  public void testRetryProxy() throws IOException {
    final Client client = new Client(LongWritable.class, conf);
    
    final TestServer server = new TestServer(1, false);
    server.callListener = new Runnable() {
      private int retryCount = 0;
      @Override
      public void run() {
        Assert.assertEquals(retryCount++, Server.getCallRetryCount());
      }
    };

    
    
    final int totalRetry = 10000;
    DummyProtocol proxy = (DummyProtocol) Proxy.newProxyInstance(
        DummyProtocol.class.getClassLoader(),
        new Class[] { DummyProtocol.class }, new TestInvocationHandler(client,
            server, totalRetry));
    DummyProtocol retryProxy = (DummyProtocol) RetryProxy.create(
        DummyProtocol.class, proxy, RetryPolicies.RETRY_FOREVER);
    
    try {
      server.start();
      retryProxy.dummyRun();
      Assert.assertEquals(TestInvocationHandler.retry, totalRetry + 1);
    } finally {
      Client.setCallIdAndRetryCount(0, 0, null);
      client.stop();
      server.stop();
    }
  }

  
  @Test(expected = InvalidToken.class)
  public void testNoRetryOnInvalidToken() throws IOException {
    final Client client = new Client(LongWritable.class, conf);
    final TestServer server = new TestServer(1, false);
    TestInvalidTokenHandler handler =
        new TestInvalidTokenHandler(client, server);
    DummyProtocol proxy = (DummyProtocol) Proxy.newProxyInstance(
        DummyProtocol.class.getClassLoader(),
        new Class[] { DummyProtocol.class }, handler);
    FailoverProxyProvider<DummyProtocol> provider =
        new DefaultFailoverProxyProvider<DummyProtocol>(
            DummyProtocol.class, proxy);
    DummyProtocol retryProxy =
        (DummyProtocol) RetryProxy.create(DummyProtocol.class, provider,
        RetryPolicies.failoverOnNetworkException(
            RetryPolicies.TRY_ONCE_THEN_FAIL, 100, 100, 10000, 0));

    try {
      server.start();
      retryProxy.dummyRun();
    } finally {
      
      assertThat(handler.invocations).isOne();
      Client.setCallIdAndRetryCount(0, 0, null);
      client.stop();
      server.stop();
    }
  }

  
  @Test(timeout=60000)
  public void testInitialCallRetryCount() throws IOException {
    
    final Client client = new Client(LongWritable.class, conf);

    
    final TestServer server = new TestServer(1, false);
    server.callListener = new Runnable() {
      @Override
      public void run() {
        
        
        Assert.assertEquals(0, Server.getCallRetryCount());
      }
    };

    try {
      InetSocketAddress addr = NetUtils.getConnectAddress(server);
      server.start();
      final SerialCaller caller = new SerialCaller(client, addr, 10);
      caller.run();
      assertFalse(caller.failed);
    } finally {
      client.stop();
      server.stop();
    }
  }
  
  
  @Test(timeout=60000)
  public void testCallRetryCount() throws IOException {
    final int retryCount = 255;
    
    final Client client = new Client(LongWritable.class, conf);
    Client.setCallIdAndRetryCount(Client.nextCallId(), 255, null);

    
    final TestServer server = new TestServer(1, false);
    server.callListener = new Runnable() {
      @Override
      public void run() {
        
        
        Assert.assertEquals(retryCount, Server.getCallRetryCount());
      }
    };

    try {
      InetSocketAddress addr = NetUtils.getConnectAddress(server);
      server.start();
      final SerialCaller caller = new SerialCaller(client, addr, 10);
      caller.run();
      assertFalse(caller.failed);
    } finally {
      client.stop();
      server.stop();
    }
  }

  
  @Test(timeout=60000)
  public void testUniqueSequentialCallIds() 
      throws IOException, InterruptedException {
    int serverThreads = 10, callerCount = 100, perCallerCallCount = 100;
    TestServer server = new TestServer(serverThreads, false);

    
    
    final List<Integer> callIds = Collections.synchronizedList(
      new ArrayList<Integer>());
    server.callListener = new Runnable() {
      @Override
      public void run() {
        callIds.add(Server.getCallId());
      }
    };

    Client client = new Client(LongWritable.class, conf);

    try {
      InetSocketAddress addr = NetUtils.getConnectAddress(server);
      server.start();
      SerialCaller[] callers = new SerialCaller[callerCount];
      for (int i = 0; i < callerCount; ++i) {
        callers[i] = new SerialCaller(client, addr, perCallerCallCount);
        callers[i].start();
      }
      for (int i = 0; i < callerCount; ++i) {
        callers[i].join();
        assertFalse(callers[i].failed);
      }
    } finally {
      client.stop();
      server.stop();
    }

    int expectedCallCount = callerCount * perCallerCallCount;
    assertEquals(expectedCallCount, callIds.size());

    
    
    
    Collections.sort(callIds);
    final int startID = callIds.get(0).intValue();
    for (int i = 0; i < expectedCallCount; ++i) {
      assertEquals(startID + i, callIds.get(i).intValue());
    }
  }

  @Test
  public void testMaxConnections() throws Exception {
    conf.setInt("ipc.server.max.connections", 6);
    Server server = null;
    Thread connectors[] = new Thread[10];

    try {
      server = new TestServer(3, false);
      final InetSocketAddress addr = NetUtils.getConnectAddress(server);
      server.start();
      assertEquals(0, server.getNumOpenConnections());

      for (int i = 0; i < 10; i++) {
        connectors[i] = new Thread() {
          @Override
          public void run() {
            Socket sock = null;
            try {
              sock = NetUtils.getDefaultSocketFactory(conf).createSocket();
              NetUtils.connect(sock, addr, 3000);
              try {
                Thread.sleep(4000);
              } catch (InterruptedException ie) { }
            } catch (IOException ioe) {
            } finally {
              if (sock != null) {
                try {
                  sock.close();
                } catch (IOException ioe) { }
              }
            }
          }
        };
        connectors[i].start();
      }

      Thread.sleep(1000);
      
      assertEquals(6, server.getNumOpenConnections());
      
      assertEquals(4, server.getNumDroppedConnections());

      for (int i = 0; i < 10; i++) {
        connectors[i].join();
      }
    } finally {
      if (server != null) {
        server.stop();
      }
      conf.setInt("ipc.server.max.connections", 0);
    }
  }

  @Test
  public void testClientGetTimeout() throws IOException {
    Configuration config = new Configuration();
    config.setInt(CommonConfigurationKeys.IPC_CLIENT_RPC_TIMEOUT_KEY, 0);
    assertThat(Client.getTimeout(config)).isEqualTo(-1);
  }

  @Test(timeout=60000)
  public void testSetupConnectionShouldNotBlockShutdown() throws Exception {
    
    SocketFactory mockFactory = Mockito.mock(SocketFactory.class);
    Server server = new TestServer(1, true);
    final InetSocketAddress addr = NetUtils.getConnectAddress(server);

    
    final AtomicInteger createSocketCalled = new AtomicInteger();

    doAnswer(new Answer() {
      @Override
      public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
        createSocketCalled.addAndGet(1);
        Thread.sleep(MIN_SLEEP_TIME * 5);
        throw new ConnectTimeoutException("fake");
      }
    }).when(mockFactory).createSocket();
    final Client client = new Client(LongWritable.class, conf, mockFactory);

    final AtomicBoolean callStarted = new AtomicBoolean(false);

    
    new Thread(new Runnable() {
      public void run() {
        try {
          callStarted.set(true);
          call(client, RANDOM.nextLong(), addr, conf);
        } catch (IOException ignored) {}
      }
    }).start();

    GenericTestUtils.waitFor(new Supplier<Boolean>() {
      @Override
      public Boolean get() {
        return callStarted.get() && createSocketCalled.get() == 1;
      }
    }, 50, 60000);

    
    client.stop();
    assertEquals(1, createSocketCalled.get());
  }

  private void assertRetriesOnSocketTimeouts(Configuration conf,
      int maxTimeoutRetries) throws IOException {
    SocketFactory mockFactory = Mockito.mock(SocketFactory.class);
    doThrow(new ConnectTimeoutException("fake")).when(mockFactory).createSocket();
    Client client = new Client(LongWritable.class, conf, mockFactory);
    InetSocketAddress address = new InetSocketAddress("127.0.0.1", 9090);
    try {
      call(client, RANDOM.nextLong(), address, conf);
      fail("Not throwing the SocketTimeoutException");
    } catch (SocketTimeoutException e) {
      Mockito.verify(mockFactory, Mockito.times(maxTimeoutRetries))
          .createSocket();
    }
    client.stop();
  }
  
  @Test(timeout=4000)
  public void testInsecureVersionMismatch() throws IOException {
    checkVersionMismatch();
  }

  @Test(timeout=4000)
  public void testSecureVersionMismatch() throws IOException {
    SecurityUtil.setAuthenticationMethod(AuthenticationMethod.KERBEROS, conf);
    UserGroupInformation.setConfiguration(conf);
    checkVersionMismatch();
  }

  private void checkVersionMismatch() throws IOException {
    try (ServerSocket listenSocket = new ServerSocket()) {
      listenSocket.bind(null);
      InetSocketAddress addr =
          (InetSocketAddress) listenSocket.getLocalSocketAddress();

      
      
      ExecutorService executor = Executors.newSingleThreadExecutor();
      executor.submit(new Runnable(){
        @Override
        public void run() {
          try {
            Socket socket = listenSocket.accept();
            socket.getOutputStream().write(
                NetworkTraces.RESPONSE_TO_HADOOP_0_20_3_RPC);
            socket.close();
          } catch (Throwable t) {
            
          }
        }
      });

      try {
        Client client = new Client(LongWritable.class, conf);
        call(client, 0, addr, conf);
      } catch (RemoteException re) {
        Assert.assertEquals(RPC.VersionMismatch.class.getName(),
            re.getClassName());
        Assert.assertEquals(NetworkTraces.HADOOP0_20_ERROR_MSG,
            re.getMessage());
        return;
      }
      Assert.fail("didn't get version mismatch");
    }
  }

  @Test
  public void testRpcResponseLimit() throws Throwable {
    Server server = new TestServer(1, false);
    InetSocketAddress addr = NetUtils.getConnectAddress(server);
    server.start();

    conf.setInt(CommonConfigurationKeys.IPC_MAXIMUM_RESPONSE_LENGTH, 0);
    Client client = new Client(LongWritable.class, conf);
    call(client, 0, addr, conf);

    conf.setInt(CommonConfigurationKeys.IPC_MAXIMUM_RESPONSE_LENGTH, 4);
    client = new Client(LongWritable.class, conf);
    try {
      call(client, 0, addr, conf);
    } catch (IOException ioe) {
      Assert.assertNotNull(ioe);
      Assert.assertEquals(RpcException.class, ioe.getClass());
      Assert.assertEquals("RPC response exceeds maximum data length",
          ioe.getMessage());
      return;
    }
    Assert.fail("didn't get limit exceeded");
  }

  @Test
  public void testUserBinding() throws Exception {
    checkUserBinding(false);
  }

  @Test
  public void testProxyUserBinding() throws Exception {
    checkUserBinding(true);
  }

  private void checkUserBinding(boolean asProxy) throws Exception {
    Socket s;
    
    s = checkConnect(null, asProxy);
    Mockito.verify(s, Mockito.never()).bind(any(SocketAddress.class));

    
    s = checkConnect("1.2.3.4", asProxy);
    Mockito.verify(s, Mockito.never()).bind(any(SocketAddress.class));

    
    InetAddress addr = InetAddress.getLocalHost();
    s = checkConnect(addr.getHostAddress(), asProxy);
    Mockito.verify(s).bind(new InetSocketAddress(addr, 0));
  }

  
  @KerberosInfo(serverPrincipal = "server@REALM")
  private static class TestBindingProtocol {
  }

  private Socket checkConnect(String addr, boolean asProxy) throws Exception {
    
    StringBuilder principal = new StringBuilder();
    principal.append("client");
    if (addr != null) {
      principal.append("/").append(addr);
    }
    principal.append("@REALM");
    UserGroupInformation ugi =
        spy(UserGroupInformation.createRemoteUser(principal.toString()));
    Mockito.doReturn(true).when(ugi).hasKerberosCredentials();
    if (asProxy) {
      ugi = UserGroupInformation.createProxyUser("proxy", ugi);
    }

    
    SocketException expectedConnectEx =
        new SocketException("Expected connect failure");
    Socket s = Mockito.mock(Socket.class);
    SocketFactory mockFactory = Mockito.mock(SocketFactory.class);
    Mockito.doReturn(s).when(mockFactory).createSocket();
    doThrow(expectedConnectEx).when(s).connect(
        any(SocketAddress.class), Mockito.anyInt());

    
    
    try (Client client = new Client(LongWritable.class, conf, mockFactory)) {
      final InetSocketAddress sockAddr = new InetSocketAddress(0);
      final LongWritable param = new LongWritable(RANDOM.nextLong());
      final ConnectionId remoteId = new ConnectionId(
          sockAddr, TestBindingProtocol.class, ugi, 0,
          RetryPolicies.TRY_ONCE_THEN_FAIL, conf);
      client.call(RPC.RpcKind.RPC_BUILTIN, param, remoteId, null);
      fail("call didn't throw connect exception");
    } catch (SocketException se) {
      
      Assert.assertSame(expectedConnectEx, se.getCause());
    }
    return s;
  }

  private void doIpcVersionTest(
      byte[] requestData,
      byte[] expectedResponse) throws IOException {
    Server server = new TestServer(1, true);
    InetSocketAddress addr = NetUtils.getConnectAddress(server);
    server.start();
    Socket socket = new Socket();

    try {
      NetUtils.connect(socket, addr, 5000);
      
      OutputStream out = socket.getOutputStream();
      InputStream in = socket.getInputStream();
      out.write(requestData, 0, requestData.length);
      out.flush();
      ByteArrayOutputStream baos = new ByteArrayOutputStream();
      IOUtils.copyBytes(in, baos, 256);
      
      byte[] responseData = baos.toByteArray();
      
      assertEquals(
          StringUtils.byteToHexString(expectedResponse),
          StringUtils.byteToHexString(responseData));
    } finally {
      IOUtils.closeSocket(socket);
      server.stop();
    }
  }
  
  
  private static byte[] hexDumpToBytes(String hexdump) {
    final int LAST_HEX_COL = 3 * 16;
    
    StringBuilder hexString = new StringBuilder();
    
    for (String line : StringUtils.toUpperCase(hexdump).split("\n")) {
      hexString.append(line.substring(0, LAST_HEX_COL).replace(" ", ""));
    }
    return StringUtils.hexStringToByte(hexString.toString());
  }
  
  
  private static abstract class NetworkTraces {
    
    final static byte[] HADOOP_0_18_3_RPC_DUMP =
      hexDumpToBytes(
      "68 72 70 63 02 00 00 00  82 00 1d 6f 72 67 2e 61 hrpc.... ...org.a\n" +
      "70 61 63 68 65 2e 68 61  64 6f 6f 70 2e 69 6f 2e pache.ha doop.io.\n" +
      "57 72 69 74 61 62 6c 65  00 30 6f 72 67 2e 61 70 Writable .0org.ap\n" +
      "61 63 68 65 2e 68 61 64  6f 6f 70 2e 69 6f 2e 4f ache.had oop.io.O\n" +
      "62 6a 65 63 74 57 72 69  74 61 62 6c 65 24 4e 75 bjectWri table$Nu\n" +
      "6c 6c 49 6e 73 74 61 6e  63 65 00 2f 6f 72 67 2e llInstan ce./org.\n" +
      "61 70 61 63 68 65 2e 68  61 64 6f 6f 70 2e 73 65 apache.h adoop.se\n" +
      "63 75 72 69 74 79 2e 55  73 65 72 47 72 6f 75 70 curity.U serGroup\n" +
      "49 6e 66 6f 72 6d 61 74  69 6f 6e 00 00 00 6c 00 Informat ion...l.\n" +
      "00 00 00 00 12 67 65 74  50 72 6f 74 6f 63 6f 6c .....get Protocol\n" +
      "56 65 72 73 69 6f 6e 00  00 00 02 00 10 6a 61 76 Version. .....jav\n" +
      "61 2e 6c 61 6e 67 2e 53  74 72 69 6e 67 00 2e 6f a.lang.S tring..o\n" +
      "72 67 2e 61 70 61 63 68  65 2e 68 61 64 6f 6f 70 rg.apach e.hadoop\n" +
      "2e 6d 61 70 72 65 64 2e  4a 6f 62 53 75 62 6d 69 .mapred. JobSubmi\n" +
      "73 73 69 6f 6e 50 72 6f  74 6f 63 6f 6c 00 04 6c ssionPro tocol..l\n" +
      "6f 6e 67 00 00 00 00 00  00 00 0a                ong..... ...     \n");

    final static String HADOOP0_18_ERROR_MSG =
      "Server IPC version " + RpcConstants.CURRENT_VERSION +
      " cannot communicate with client version 2";
    
    
    final static byte[] RESPONSE_TO_HADOOP_0_18_3_RPC =
      Bytes.concat(hexDumpToBytes(
      "00 00 00 00 01 00 00 00  29 6f 72 67 2e 61 70 61 ........ )org.apa\n" +
      "63 68 65 2e 68 61 64 6f  6f 70 2e 69 70 63 2e 52 che.hado op.ipc.R\n" +
      "50 43 24 56 65 72 73 69  6f 6e 4d 69 73 6d 61 74 PC$Versi onMismat\n" +
      "63 68                                            ch               \n"),
       Ints.toByteArray(HADOOP0_18_ERROR_MSG.length()),
       HADOOP0_18_ERROR_MSG.getBytes());
    
    
    final static byte[] HADOOP_0_20_3_RPC_DUMP =
      hexDumpToBytes(
      "68 72 70 63 03 00 00 00  79 27 6f 72 67 2e 61 70 hrpc.... y'org.ap\n" +
      "61 63 68 65 2e 68 61 64  6f 6f 70 2e 69 70 63 2e ache.had oop.ipc.\n" +
      "56 65 72 73 69 6f 6e 65  64 50 72 6f 74 6f 63 6f Versione dProtoco\n" +
      "6c 01 0a 53 54 52 49 4e  47 5f 55 47 49 04 74 6f l..STRIN G_UGI.to\n" +
      "64 64 09 04 74 6f 64 64  03 61 64 6d 07 64 69 61 dd..todd .adm.dia\n" +
      "6c 6f 75 74 05 63 64 72  6f 6d 07 70 6c 75 67 64 lout.cdr om.plugd\n" +
      "65 76 07 6c 70 61 64 6d  69 6e 05 61 64 6d 69 6e ev.lpadm in.admin\n" +
      "0a 73 61 6d 62 61 73 68  61 72 65 06 6d 72 74 65 .sambash are.mrte\n" +
      "73 74 00 00 00 6c 00 00  00 00 00 12 67 65 74 50 st...l.. ....getP\n" +
      "72 6f 74 6f 63 6f 6c 56  65 72 73 69 6f 6e 00 00 rotocolV ersion..\n" +
      "00 02 00 10 6a 61 76 61  2e 6c 61 6e 67 2e 53 74 ....java .lang.St\n" +
      "72 69 6e 67 00 2e 6f 72  67 2e 61 70 61 63 68 65 ring..or g.apache\n" +
      "2e 68 61 64 6f 6f 70 2e  6d 61 70 72 65 64 2e 4a .hadoop. mapred.J\n" +
      "6f 62 53 75 62 6d 69 73  73 69 6f 6e 50 72 6f 74 obSubmis sionProt\n" +
      "6f 63 6f 6c 00 04 6c 6f  6e 67 00 00 00 00 00 00 ocol..lo ng......\n" +
      "00 14                                            ..               \n");

    final static String HADOOP0_20_ERROR_MSG =
      "Server IPC version " + RpcConstants.CURRENT_VERSION +
      " cannot communicate with client version 3";
    

    final static byte[] RESPONSE_TO_HADOOP_0_20_3_RPC =
      Bytes.concat(hexDumpToBytes(
      "ff ff ff ff ff ff ff ff  00 00 00 29 6f 72 67 2e ........ ...)org.\n" +
      "61 70 61 63 68 65 2e 68  61 64 6f 6f 70 2e 69 70 apache.h adoop.ip\n" +
      "63 2e 52 50 43 24 56 65  72 73 69 6f 6e 4d 69 73 c.RPC$Ve rsionMis\n" +
      "6d 61 74 63 68                                   match            \n"),
      Ints.toByteArray(HADOOP0_20_ERROR_MSG.length()),
      HADOOP0_20_ERROR_MSG.getBytes());
    
    
    final static String HADOOP0_21_ERROR_MSG =
      "Server IPC version " + RpcConstants.CURRENT_VERSION +
      " cannot communicate with client version 4";

    final static byte[] HADOOP_0_21_0_RPC_DUMP =
      hexDumpToBytes(
      "68 72 70 63 04 50                                hrpc.P" +
      
      "00 00 00 3c 33 6f 72 67  2e 61 70 61 63 68 65 2e ...<3org .apache.\n" +
      "68 61 64 6f 6f 70 2e 6d  61 70 72 65 64 75 63 65 hadoop.m apreduce\n" +
      "2e 70 72 6f 74 6f 63 6f  6c 2e 43 6c 69 65 6e 74 .protoco l.Client\n" +
      "50 72 6f 74 6f 63 6f 6c  01 00 04 74 6f 64 64 00 Protocol ...todd.\n" +
      "00 00 00 71 00 00 00 00  00 12 67 65 74 50 72 6f ...q.... ..getPro\n" +
      "74 6f 63 6f 6c 56 65 72  73 69 6f 6e 00 00 00 02 tocolVer sion....\n" +
      "00 10 6a 61 76 61 2e 6c  61 6e 67 2e 53 74 72 69 ..java.l ang.Stri\n" +
      "6e 67 00 33 6f 72 67 2e  61 70 61 63 68 65 2e 68 ng.3org. apache.h\n" +
      "61 64 6f 6f 70 2e 6d 61  70 72 65 64 75 63 65 2e adoop.ma preduce.\n" +
      "70 72 6f 74 6f 63 6f 6c  2e 43 6c 69 65 6e 74 50 protocol .ClientP\n" +
      "72 6f 74 6f 63 6f 6c 00  04 6c 6f 6e 67 00 00 00 rotocol. .long...\n" +
      "00 00 00 00 21                                   ....!            \n");
    
    final static byte[] RESPONSE_TO_HADOOP_0_21_0_RPC =
      Bytes.concat(hexDumpToBytes(
      "ff ff ff ff ff ff ff ff  00 00 00 29 6f 72 67 2e ........ ...)org.\n" +
      "61 70 61 63 68 65 2e 68  61 64 6f 6f 70 2e 69 70 apache.h adoop.ip\n" +
      "63 2e 52 50 43 24 56 65  72 73 69 6f 6e 4d 69 73 c.RPC$Ve rsionMis\n" +
      "6d 61 74 63 68                                   match            \n"),
      Ints.toByteArray(HADOOP0_21_ERROR_MSG.length()),
      HADOOP0_21_ERROR_MSG.getBytes());
  }
}

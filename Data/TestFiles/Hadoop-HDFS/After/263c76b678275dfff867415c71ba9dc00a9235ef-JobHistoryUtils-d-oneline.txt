public class JobHistoryUtils {      public static final FsPermission HISTORY_STAGING_DIR_PERMISSIONS =        FsPermission.createImmutable( (short) 0700);      public static final FsPermission HISTORY_STAGING_USER_DIR_PERMISSIONS =     FsPermission.createImmutable((short) 0700);          public static final FsPermission HISTORY_DONE_DIR_PERMISSION =    FsPermission.createImmutable((short) 0770);   public static final FsPermission HISTORY_DONE_FILE_PERMISSION =    FsPermission.createImmutable((short) 0770);    public static final FsPermission HISTORY_DONE_DIR_UMASK = FsPermission      .createImmutable((short) (0770 ^ 0777));      public static final FsPermission HISTORY_INTERMEDIATE_DONE_DIR_PERMISSIONS =     FsPermission.createImmutable((short) 01777);  public static final FsPermission HISTORY_INTERMEDIATE_FILE_PERMISSIONS =     FsPermission.createImmutable((short) 0770);       public static final String CONF_FILE_NAME_SUFFIX = "_conf.xml";      public static final String SUMMARY_FILE_NAME_SUFFIX = ".summary";      public static final String JOB_HISTORY_FILE_EXTENSION = ".jhist";    public static final int VERSION = 4;  public static final int SERIAL_NUMBER_DIRECTORY_DIGITS = 6;    public static final String TIMESTAMP_DIR_REGEX = "\\d{4}" + "\\" + Path.SEPARATOR +  "\\d{2}" + "\\" + Path.SEPARATOR + "\\d{2}";  public static final Pattern TIMESTAMP_DIR_PATTERN = Pattern.compile(TIMESTAMP_DIR_REGEX);  private static final String TIMESTAMP_DIR_FORMAT = "%04d" + File.separator + "%02d" + File.separator + "%02d";  private static final Logger LOG =      LoggerFactory.getLogger(JobHistoryUtils.class);  private static final PathFilter CONF_FILTER = new PathFilter() {    @Override    public boolean accept(Path path) {      return path.getName().endsWith(CONF_FILE_NAME_SUFFIX);    }  };    private static final PathFilter JOB_HISTORY_FILE_FILTER = new PathFilter() {    @Override    public boolean accept(Path path) {      return path.getName().endsWith(JOB_HISTORY_FILE_EXTENSION);    }  };    public static boolean isValidJobHistoryFileName(String pathString) {    return pathString.endsWith(JOB_HISTORY_FILE_EXTENSION);  }    public static JobID getJobIDFromHistoryFilePath(String pathString) throws IOException {    String [] parts = pathString.split(Path.SEPARATOR);    String fileNamePart = parts[parts.length -1];    JobIndexInfo jobIndexInfo =  FileNameIndexUtils.getIndexInfo(fileNamePart);    return TypeConverter.fromYarn(jobIndexInfo.getJobId());  }    public static PathFilter getConfFileFilter() {    return CONF_FILTER;  }      public static PathFilter getHistoryFileFilter() {    return JOB_HISTORY_FILE_FILTER;  }    public static String      getConfiguredHistoryStagingDirPrefix(Configuration conf, String jobId)          throws IOException {    String user = UserGroupInformation.getCurrentUser().getShortUserName();    Path stagingPath = MRApps.getStagingAreaDir(conf, user);    Path path = new Path(stagingPath, jobId);    String logDir = path.toString();    return ensurePathInDefaultFileSystem(logDir, conf);  }      public static String getConfiguredHistoryIntermediateDoneDirPrefix(      Configuration conf) {    String doneDirPrefix = conf        .get(JHAdminConfig.MR_HISTORY_INTERMEDIATE_DONE_DIR);    if (doneDirPrefix == null) {      doneDirPrefix = conf.get(MRJobConfig.MR_AM_STAGING_DIR,          MRJobConfig.DEFAULT_MR_AM_STAGING_DIR)          + "/history/done_intermediate";    }    return ensurePathInDefaultFileSystem(doneDirPrefix, conf);  }    public static FsPermission        getConfiguredHistoryIntermediateUserDoneDirPermissions(            Configuration conf) {    String userDoneDirPermissions = conf.get(        JHAdminConfig.MR_HISTORY_INTERMEDIATE_USER_DONE_DIR_PERMISSIONS);    if (userDoneDirPermissions == null) {      return new FsPermission(          JHAdminConfig.DEFAULT_MR_HISTORY_INTERMEDIATE_USER_DONE_DIR_PERMISSIONS);    }    FsPermission permission = new FsPermission(userDoneDirPermissions);    if (permission.getUserAction() != FsAction.ALL ||        permission.getGroupAction() != FsAction.ALL) {      permission = new FsPermission(FsAction.ALL, FsAction.ALL,          permission.getOtherAction(), permission.getStickyBit());      LOG.warn("Unsupported permission configured in " +          JHAdminConfig.MR_HISTORY_INTERMEDIATE_USER_DONE_DIR_PERMISSIONS +          ", the user and the group permission must be 7 (rwx). " +          "The permission was set to " + permission.toString());    }    return permission;  }      public static String getConfiguredHistoryServerDoneDirPrefix(      Configuration conf) {    String doneDirPrefix = conf.get(JHAdminConfig.MR_HISTORY_DONE_DIR);    if (doneDirPrefix == null) {      doneDirPrefix = conf.get(MRJobConfig.MR_AM_STAGING_DIR,          MRJobConfig.DEFAULT_MR_AM_STAGING_DIR)          + "/history/done";    }    return ensurePathInDefaultFileSystem(doneDirPrefix, conf);  }    private static FileContext getDefaultFileContext() {                    FileContext fc = null;    Configuration defaultConf = new Configuration();    String[] sources;    sources = defaultConf.getPropertySources(        CommonConfigurationKeysPublic.FS_DEFAULT_NAME_KEY);    if (sources != null &&        (!Arrays.asList(sources).contains("core-default.xml") ||        sources.length > 1)) {      try {        fc = FileContext.getFileContext(defaultConf);        LOG.info("Default file system [" +                  fc.getDefaultFileSystem().getUri() + "]");      } catch (UnsupportedFileSystemException e) {        LOG.error("Unable to create default file context [" +            defaultConf.get(CommonConfigurationKeysPublic.FS_DEFAULT_NAME_KEY) +            "]",            e);      }    }    else {      LOG.info("Default file system is set solely " +          "by core-default.xml therefore -  ignoring");    }    return fc;  }    private static String ensurePathInDefaultFileSystem(String sourcePath, Configuration conf) {    Path path = new Path(sourcePath);    FileContext fc = getDefaultFileContext();    if (fc == null ||        fc.getDefaultFileSystem().getUri().toString().equals(            conf.getTrimmed(                CommonConfigurationKeysPublic.FS_DEFAULT_NAME_KEY, "")) ||        path.toUri().getAuthority() != null ||        path.toUri().getScheme()!= null) {      return sourcePath;    }    return fc.makeQualified(path).toString();  }    public static String getHistoryIntermediateDoneDirForUser(Configuration conf) throws IOException {    return new Path(getConfiguredHistoryIntermediateDoneDirPrefix(conf),        UserGroupInformation.getCurrentUser().getShortUserName()).toString();  }  public static boolean shouldCreateNonUserDirectory(Configuration conf) {            return conf.getBoolean(MRJobConfig.MR_AM_CREATE_JH_INTERMEDIATE_BASE_DIR, true);   }    public static Path getStagingJobHistoryFile(Path dir, JobId jobId, int attempt) {    return getStagingJobHistoryFile(dir, TypeConverter.fromYarn(jobId).toString(), attempt);  }      public static Path getStagingJobHistoryFile(Path dir, String jobId, int attempt) {    return new Path(dir, jobId + "_" +         attempt + JOB_HISTORY_FILE_EXTENSION);  }      public static String getIntermediateConfFileName(JobId jobId) {    return TypeConverter.fromYarn(jobId).toString() + CONF_FILE_NAME_SUFFIX;  }      public static String getIntermediateSummaryFileName(JobId jobId) {    return TypeConverter.fromYarn(jobId).toString() + SUMMARY_FILE_NAME_SUFFIX;  }      public static Path getStagingConfFile(Path logDir, JobId jobId, int attempt) {    Path jobFilePath = null;    if (logDir != null) {      jobFilePath = new Path(logDir, TypeConverter.fromYarn(jobId).toString()          + "_" + attempt + CONF_FILE_NAME_SUFFIX);    }    return jobFilePath;  }      public static String serialNumberDirectoryComponent(JobId id, String serialNumberFormat) {    return String.format(serialNumberFormat,        Integer.valueOf(jobSerialNumber(id))).substring(0,        SERIAL_NUMBER_DIRECTORY_DIGITS);  }      public static String getTimestampPartFromPath(String path) {    Matcher matcher = TIMESTAMP_DIR_PATTERN.matcher(path);    if (matcher.find()) {      String matched = matcher.group();      String ret = matched.intern();      return ret;    } else {      return null;    }  }      public static String historyLogSubdirectory(JobId id, String timestampComponent, String serialNumberFormat) {    String result = "";    String serialNumberDirectory = serialNumberDirectoryComponent(id, serialNumberFormat);        result = result       + timestampComponent      + File.separator + serialNumberDirectory      + File.separator;        return result;  }      public static String timestampDirectoryComponent(long millisecondTime) {    Calendar timestamp = Calendar.getInstance();    timestamp.setTimeInMillis(millisecondTime);    String dateString = null;    dateString = String        .format(TIMESTAMP_DIR_FORMAT,            timestamp.get(Calendar.YEAR),                                    timestamp.get(Calendar.MONTH) + 1,            timestamp.get(Calendar.DAY_OF_MONTH));    dateString = dateString.intern();    return dateString;  }    public static String doneSubdirsBeforeSerialTail() {        String result = "/*/*/*";     return result;  }      public static int jobSerialNumber(JobId id) {    return id.getId();  }    public static List<FileStatus> localGlobber(FileContext fc, Path root, String tail)      throws IOException {    return localGlobber(fc, root, tail, null);  }  public static List<FileStatus> localGlobber(FileContext fc, Path root, String tail,      PathFilter filter) throws IOException {    return localGlobber(fc, root, tail, filter, null);  }      public static List<FileStatus> localGlobber(FileContext fc, Path root, String tail,      PathFilter filter, AtomicBoolean hasFlatFiles) throws IOException {    if (tail.equals("")) {      return (listFilteredStatus(fc, root, filter));    }    if (tail.startsWith("/*")) {      Path[] subdirs = filteredStat2Paths(          remoteIterToList(fc.listStatus(root)), true, hasFlatFiles);      List<List<FileStatus>> subsubdirs = new LinkedList<List<FileStatus>>();      int subsubdirCount = 0;      if (subdirs.length == 0) {        return new LinkedList<FileStatus>();      }      String newTail = tail.substring(2);      for (int i = 0; i < subdirs.length; ++i) {        subsubdirs.add(localGlobber(fc, subdirs[i], newTail, filter, null));                        subsubdirCount += subsubdirs.get(i).size();      }      List<FileStatus> result = new LinkedList<FileStatus>();      for (int i = 0; i < subsubdirs.size(); ++i) {        result.addAll(subsubdirs.get(i));      }      return result;    }    if (tail.startsWith("/")) {      int split = tail.indexOf('/', 1);      if (split < 0) {        return listFilteredStatus(fc, new Path(root, tail.substring(1)), filter);      } else {        String thisSegment = tail.substring(1, split);        String newTail = tail.substring(split);        return localGlobber(fc, new Path(root, thisSegment), newTail, filter,            hasFlatFiles);      }    }    IOException e = new IOException("localGlobber: bad tail");    throw e;  }  private static List<FileStatus> listFilteredStatus(FileContext fc, Path root,      PathFilter filter) throws IOException {    List<FileStatus> fsList = remoteIterToList(fc.listStatus(root));    if (filter == null) {      return fsList;    } else {      List<FileStatus> filteredList = new LinkedList<FileStatus>();      for (FileStatus fs : fsList) {        if (filter.accept(fs.getPath())) {          filteredList.add(fs);        }      }      return filteredList;    }  }  private static List<FileStatus> remoteIterToList(      RemoteIterator<FileStatus> rIter) throws IOException {    List<FileStatus> fsList = new LinkedList<FileStatus>();    if (rIter == null)      return fsList;    while (rIter.hasNext()) {      fsList.add(rIter.next());    }    return fsList;  }        private static Path[] filteredStat2Paths(List<FileStatus> stats, boolean dirs,      AtomicBoolean hasMismatches) {    int resultCount = 0;    if (hasMismatches == null) {      hasMismatches = new AtomicBoolean(false);    }    for (int i = 0; i < stats.size(); ++i) {      if (stats.get(i).isDirectory() == dirs) {        stats.set(resultCount++, stats.get(i));      } else {        hasMismatches.set(true);      }    }    Path[] result = new Path[resultCount];    for (int i = 0; i < resultCount; i++) {      result[i] = stats.get(i).getPath();    }    return result;  }  public static Path getPreviousJobHistoryPath(      Configuration conf, ApplicationAttemptId applicationAttemptId)      throws IOException {    String jobId =        TypeConverter.fromYarn(applicationAttemptId.getApplicationId())          .toString();    String jobhistoryDir =        JobHistoryUtils.getConfiguredHistoryStagingDirPrefix(conf, jobId);    Path histDirPath = FileContext.getFileContext(conf).makeQualified(            new Path(jobhistoryDir));    FileContext fc = FileContext.getFileContext(histDirPath.toUri(), conf);    return fc.makeQualified(JobHistoryUtils.getStagingJobHistoryFile(        histDirPath,jobId, (applicationAttemptId.getAttemptId() - 1)));  }    public static List<FileStatus> getHistoryDirsForCleaning(FileContext fc,      Path root, long cutoff) throws IOException {    List<FileStatus> fsList = new ArrayList<FileStatus>();    Calendar cCal = Calendar.getInstance();    cCal.setTimeInMillis(cutoff);    int cYear = cCal.get(Calendar.YEAR);    int cMonth = cCal.get(Calendar.MONTH) + 1;    int cDate = cCal.get(Calendar.DATE);    RemoteIterator<FileStatus> yearDirIt = fc.listStatus(root);    while (yearDirIt.hasNext()) {      FileStatus yearDir = yearDirIt.next();      try {        int year = Integer.parseInt(yearDir.getPath().getName());        if (year <= cYear) {          RemoteIterator<FileStatus> monthDirIt =              fc.listStatus(yearDir.getPath());          while (monthDirIt.hasNext()) {            FileStatus monthDir = monthDirIt.next();            try {              int month = Integer.parseInt(monthDir.getPath().getName());                                          if (year < cYear || month <= cMonth) {                RemoteIterator<FileStatus> dateDirIt =                    fc.listStatus(monthDir.getPath());                while (dateDirIt.hasNext()) {                  FileStatus dateDir = dateDirIt.next();                  try {                    int date = Integer.parseInt(dateDir.getPath().getName());                                                                                if (year < cYear || month < cMonth || date <= cDate) {                      fsList.addAll(remoteIterToList(                          fc.listStatus(dateDir.getPath())));                    }                  } catch (NumberFormatException nfe) {                                                          }                }              }            } catch (NumberFormatException nfe) {                                        }          }        }      } catch (NumberFormatException nfe) {              }    }    return fsList;  }}
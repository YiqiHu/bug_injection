public class Token<T extends TokenIdentifier> implements Writable {  public static final Logger LOG = LoggerFactory.getLogger(Token.class);  private static Map<Text, Class<? extends TokenIdentifier>> tokenKindMap;  private byte[] identifier;  private byte[] password;  private Text kind;  private Text service;  private TokenRenewer renewer;    public Token(T id, SecretManager<T> mgr) {    password = mgr.createPassword(id);    identifier = id.getBytes();    kind = id.getKind();    service = new Text();  }  public void setID(byte[] bytes) {    identifier = bytes;  }  public void setPassword(byte[] newPassword) {    password = newPassword;  }    public Token(byte[] identifier, byte[] password, Text kind, Text service) {    this.identifier = (identifier == null)? new byte[0] : identifier;    this.password = (password == null)? new byte[0] : password;    this.kind = (kind == null)? new Text() : kind;    this.service = (service == null)? new Text() : service;  }    public Token() {    identifier = new byte[0];    password = new byte[0];    kind = new Text();    service = new Text();  }    public Token(Token<T> other) {    this.identifier = other.identifier.clone();    this.password = other.password.clone();    this.kind = new Text(other.kind);    this.service = new Text(other.service);  }  public Token<T> copyToken() {    return new Token<T>(this);  }    public byte[] getIdentifier() {    return identifier;  }  private static Class<? extends TokenIdentifier>      getClassForIdentifier(Text kind) {    Class<? extends TokenIdentifier> cls = null;    synchronized (Token.class) {      if (tokenKindMap == null) {        tokenKindMap = Maps.newHashMap();                        final Iterator<TokenIdentifier> tokenIdentifiers =            ServiceLoader.load(TokenIdentifier.class).iterator();        while (tokenIdentifiers.hasNext()) {          try {            TokenIdentifier id = tokenIdentifiers.next();            tokenKindMap.put(id.getKind(), id.getClass());          } catch (ServiceConfigurationError | LinkageError e) {                                    LOG.debug("Failed to load token identifier implementation", e);          }        }      }      cls = tokenKindMap.get(kind);    }    if (cls == null) {      LOG.debug("Cannot find class for token kind {}", kind);      return null;    }    return cls;  }    @SuppressWarnings("unchecked")  public T decodeIdentifier() throws IOException {    Class<? extends TokenIdentifier> cls = getClassForIdentifier(getKind());    if (cls == null) {      return null;    }    TokenIdentifier tokenIdentifier = ReflectionUtils.newInstance(cls, null);    ByteArrayInputStream buf = new ByteArrayInputStream(identifier);    DataInputStream in = new DataInputStream(buf);    tokenIdentifier.readFields(in);    in.close();    return (T) tokenIdentifier;  }    public byte[] getPassword() {    return password;  }    public synchronized Text getKind() {    return kind;  }    @InterfaceAudience.Private  public synchronized void setKind(Text newKind) {    kind = newKind;    renewer = null;  }    public Text getService() {    return service;  }    public void setService(Text newService) {    service = newService;  }    public boolean isPrivate() {    return false;  }    public boolean isPrivateCloneOf(Text thePublicService) {    return false;  }    public Token<T> privateClone(Text newService) {    return new PrivateToken<>(this, newService);  }    static class PrivateToken<T extends TokenIdentifier> extends Token<T> {    final private Text publicService;    PrivateToken(Token<T> publicToken, Text newService) {      super(publicToken.identifier, publicToken.password, publicToken.kind,          newService);      assert !publicToken.isPrivate();      publicService = publicToken.service;      if (LOG.isDebugEnabled()) {        LOG.debug("Cloned private token {} from {}", this, publicToken);      }    }        @Override    public boolean isPrivate() {      return true;    }        @Override    public boolean isPrivateCloneOf(Text thePublicService) {      return publicService.equals(thePublicService);    }    @Override    public boolean equals(Object o) {      if (this == o) {        return true;      }      if (o == null || getClass() != o.getClass()) {        return false;      }      if (!super.equals(o)) {        return false;      }      PrivateToken<?> that = (PrivateToken<?>) o;      return publicService.equals(that.publicService);    }    @Override    public int hashCode() {      int result = super.hashCode();      result = 31 * result + publicService.hashCode();      return result;    }  }  @Override  public void readFields(DataInput in) throws IOException {    int len = WritableUtils.readVInt(in);    if (identifier == null || identifier.length != len) {      identifier = new byte[len];    }    in.readFully(identifier);    len = WritableUtils.readVInt(in);    if (password == null || password.length != len) {      password = new byte[len];    }    in.readFully(password);    kind.readFields(in);    service.readFields(in);  }  @Override  public void write(DataOutput out) throws IOException {    WritableUtils.writeVInt(out, identifier.length);    out.write(identifier);    WritableUtils.writeVInt(out, password.length);    out.write(password);    kind.write(out);    service.write(out);  }    private static String encodeWritable(Writable obj) throws IOException {    DataOutputBuffer buf = new DataOutputBuffer();    obj.write(buf);    Base64 encoder = new Base64(0, null, true);    byte[] raw = new byte[buf.getLength()];    System.arraycopy(buf.getData(), 0, raw, 0, buf.getLength());    return encoder.encodeToString(raw);  }    private static void decodeWritable(Writable obj,                                     String newValue) throws IOException {    if (newValue == null) {      throw new HadoopIllegalArgumentException(              "Invalid argument, newValue is null");    }    Base64 decoder = new Base64(0, null, true);    DataInputBuffer buf = new DataInputBuffer();    byte[] decoded = decoder.decode(newValue);    buf.reset(decoded, decoded.length);    obj.readFields(buf);  }    public String encodeToUrlString() throws IOException {    return encodeWritable(this);  }    public void decodeFromUrlString(String newValue) throws IOException {    decodeWritable(this, newValue);  }  @SuppressWarnings("unchecked")  @Override  public boolean equals(Object right) {    if (this == right) {      return true;    } else if (right == null || getClass() != right.getClass()) {      return false;    } else {      Token<T> r = (Token<T>) right;      return MessageDigest.isEqual(identifier, r.identifier) &&             MessageDigest.isEqual(password, r.password) &&             kind.equals(r.kind) &&             service.equals(r.service);    }  }  @Override  public int hashCode() {    return WritableComparator.hashBytes(identifier, identifier.length);  }  private static void addBinaryBuffer(StringBuilder buffer, byte[] bytes) {    for (int idx = 0; idx < bytes.length; idx++) {            if (idx != 0) {        buffer.append(' ');      }      String num = Integer.toHexString(0xff & bytes[idx]);            if (num.length() < 2) {        buffer.append('0');      }      buffer.append(num);    }  }  private void identifierToString(StringBuilder buffer) {    T id = null;    try {      id = decodeIdentifier();    } catch (IOException e) {          } finally {      if (id != null) {        buffer.append("(").append(id).append(")");      } else {        addBinaryBuffer(buffer, identifier);      }    }  }  @Override  public String toString() {    StringBuilder buffer = new StringBuilder();    buffer.append("Kind: ")        .append(kind.toString())        .append(", Service: ")        .append(service.toString())        .append(", Ident: ");    identifierToString(buffer);    return buffer.toString();  }  public String buildCacheKey() {    return UUID.nameUUIDFromBytes(        Bytes.concat(kind.getBytes(), identifier, password)).toString();  }  private static ServiceLoader<TokenRenewer> renewers =      ServiceLoader.load(TokenRenewer.class);  private synchronized TokenRenewer getRenewer() throws IOException {    if (renewer != null) {      return renewer;    }    renewer = TRIVIAL_RENEWER;    synchronized (renewers) {      Iterator<TokenRenewer> it = renewers.iterator();      while (it.hasNext()) {        try {          TokenRenewer candidate = it.next();          if (candidate.handleKind(this.kind)) {            renewer = candidate;            return renewer;          }        } catch (ServiceConfigurationError e) {                              LOG.debug("Failed to load token renewer implementation", e);        }      }    }    LOG.warn("No TokenRenewer defined for token kind {}", kind);    return renewer;  }    public boolean isManaged() throws IOException {    return getRenewer().isManaged(this);  }    public long renew(Configuration conf                    ) throws IOException, InterruptedException {    return getRenewer().renew(this, conf);  }    public void cancel(Configuration conf                     ) throws IOException, InterruptedException {    getRenewer().cancel(this, conf);  }    @InterfaceAudience.Public  @InterfaceStability.Evolving  public static class TrivialRenewer extends TokenRenewer {        protected Text getKind() {      return null;    }    @Override    public boolean handleKind(Text kind) {      return kind.equals(getKind());    }    @Override    public boolean isManaged(Token<?> token) {      return false;    }    @Override    public long renew(Token<?> token, Configuration conf) {      throw new UnsupportedOperationException("Token renewal is not supported "+                                              " for " + token.kind + " tokens");    }    @Override    public void cancel(Token<?> token, Configuration conf) throws IOException,        InterruptedException {      throw new UnsupportedOperationException("Token cancel is not supported " +          " for " + token.kind + " tokens");    }  }  private static final TokenRenewer TRIVIAL_RENEWER = new TrivialRenewer();}
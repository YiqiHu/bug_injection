public class Configuration implements Iterable<Map.Entry<String,String>>,                                      Writable {  private static final Logger LOG =      LoggerFactory.getLogger(Configuration.class);  private static final Logger LOG_DEPRECATION =      LoggerFactory.getLogger(          "org.apache.hadoop.conf.Configuration.deprecation");  private static final Set<String> TAGS = ConcurrentHashMap.newKeySet();  private boolean quietmode = true;  private static final String DEFAULT_STRING_CHECK =    "testingforemptydefaultvalue";  private static boolean restrictSystemPropsDefault = false;  private boolean restrictSystemProps = restrictSystemPropsDefault;  private boolean allowNullValueProperties = false;  private static class Resource {    private final Object resource;    private final String name;    private final boolean restrictParser;        public Resource(Object resource) {      this(resource, resource.toString());    }    public Resource(Object resource, boolean useRestrictedParser) {      this(resource, resource.toString(), useRestrictedParser);    }    public Resource(Object resource, String name) {      this(resource, name, getRestrictParserDefault(resource));    }    public Resource(Object resource, String name, boolean restrictParser) {      this.resource = resource;      this.name = name;      this.restrictParser = restrictParser;    }        public String getName(){      return name;    }        public Object getResource() {      return resource;    }    public boolean isParserRestricted() {      return restrictParser;    }    @Override    public String toString() {      return name;    }    private static boolean getRestrictParserDefault(Object resource) {      if (resource instanceof String || !UserGroupInformation.isInitialized()) {        return false;      }      UserGroupInformation user;      try {        user = UserGroupInformation.getCurrentUser();      } catch (IOException e) {        throw new RuntimeException("Unable to determine current user", e);      }      return user.getRealUser() != null;    }  }      private ArrayList<Resource> resources = new ArrayList<Resource>();      static final String UNKNOWN_RESOURCE = "Unknown";    private Set<String> finalParameters = Collections.newSetFromMap(      new ConcurrentHashMap<String, Boolean>());    private boolean loadDefaults = true;    private static final WeakHashMap<Configuration,Object> REGISTRY =     new WeakHashMap<Configuration,Object>();    private final Map<String, Properties> propertyTagsMap =      new ConcurrentHashMap<>();    private static final CopyOnWriteArrayList<String> defaultResources =    new CopyOnWriteArrayList<String>();  private static final Map<ClassLoader, Map<String, WeakReference<Class<?>>>>    CACHE_CLASSES = new WeakHashMap<ClassLoader, Map<String, WeakReference<Class<?>>>>();    private static final Class<?> NEGATIVE_CACHE_SENTINEL =    NegativeCacheSentinel.class;    private volatile Map<String, String[]> updatingResource;    private static final WstxInputFactory XML_INPUT_FACTORY =      new WstxInputFactory();    private static class DeprecatedKeyInfo {    private final String[] newKeys;    private final String customMessage;    private final AtomicBoolean accessed = new AtomicBoolean(false);    DeprecatedKeyInfo(String[] newKeys, String customMessage) {      this.newKeys = newKeys;      this.customMessage = customMessage;    }    private final String getWarningMessage(String key) {      return getWarningMessage(key, null);    }        private String getWarningMessage(String key, String source) {      String warningMessage;      if(customMessage == null) {        StringBuilder message = new StringBuilder(key);        if (source != null) {          message.append(" in " + source);        }        message.append(" is deprecated. Instead, use ");        for (int i = 0; i < newKeys.length; i++) {          message.append(newKeys[i]);          if(i != newKeys.length-1) {            message.append(", ");          }        }        warningMessage = message.toString();      }      else {        warningMessage = customMessage;      }      return warningMessage;    }    boolean getAndSetAccessed() {      return accessed.getAndSet(true);    }    public void clearAccessed() {      accessed.set(false);    }  }      public static class DeprecationDelta {    private final String key;    private final String[] newKeys;    private final String customMessage;    DeprecationDelta(String key, String[] newKeys, String customMessage) {      Preconditions.checkNotNull(key);      Preconditions.checkNotNull(newKeys);      Preconditions.checkArgument(newKeys.length > 0);      this.key = key;      this.newKeys = newKeys;      this.customMessage = customMessage;    }    public DeprecationDelta(String key, String newKey, String customMessage) {      this(key, new String[] { newKey }, customMessage);    }    public DeprecationDelta(String key, String newKey) {      this(key, new String[] { newKey }, null);    }    public String getKey() {      return key;    }    public String[] getNewKeys() {      return newKeys;    }    public String getCustomMessage() {      return customMessage;    }  }    private static class DeprecationContext {        private final Map<String, DeprecatedKeyInfo> deprecatedKeyMap;        private final Map<String, String> reverseDeprecatedKeyMap;        @SuppressWarnings("unchecked")    DeprecationContext(DeprecationContext other, DeprecationDelta[] deltas) {      HashMap<String, DeprecatedKeyInfo> newDeprecatedKeyMap =         new HashMap<String, DeprecatedKeyInfo>();      HashMap<String, String> newReverseDeprecatedKeyMap =        new HashMap<String, String>();      if (other != null) {        for (Entry<String, DeprecatedKeyInfo> entry :            other.deprecatedKeyMap.entrySet()) {          newDeprecatedKeyMap.put(entry.getKey(), entry.getValue());        }        for (Entry<String, String> entry :            other.reverseDeprecatedKeyMap.entrySet()) {          newReverseDeprecatedKeyMap.put(entry.getKey(), entry.getValue());        }      }      for (DeprecationDelta delta : deltas) {        if (!newDeprecatedKeyMap.containsKey(delta.getKey())) {          DeprecatedKeyInfo newKeyInfo =            new DeprecatedKeyInfo(delta.getNewKeys(), delta.getCustomMessage());          newDeprecatedKeyMap.put(delta.key, newKeyInfo);          for (String newKey : delta.getNewKeys()) {            newReverseDeprecatedKeyMap.put(newKey, delta.key);          }        }      }      this.deprecatedKeyMap =        UnmodifiableMap.decorate(newDeprecatedKeyMap);      this.reverseDeprecatedKeyMap =        UnmodifiableMap.decorate(newReverseDeprecatedKeyMap);    }    Map<String, DeprecatedKeyInfo> getDeprecatedKeyMap() {      return deprecatedKeyMap;    }    Map<String, String> getReverseDeprecatedKeyMap() {      return reverseDeprecatedKeyMap;    }  }    private static DeprecationDelta[] defaultDeprecations =     new DeprecationDelta[] {      new DeprecationDelta("topology.script.file.name",         CommonConfigurationKeys.NET_TOPOLOGY_SCRIPT_FILE_NAME_KEY),      new DeprecationDelta("topology.script.number.args",         CommonConfigurationKeys.NET_TOPOLOGY_SCRIPT_NUMBER_ARGS_KEY),      new DeprecationDelta("hadoop.configured.node.mapping",         CommonConfigurationKeys.NET_TOPOLOGY_CONFIGURED_NODE_MAPPING_KEY),      new DeprecationDelta("topology.node.switch.mapping.impl",         CommonConfigurationKeys.NET_TOPOLOGY_NODE_SWITCH_MAPPING_IMPL_KEY),      new DeprecationDelta("dfs.df.interval",         CommonConfigurationKeys.FS_DF_INTERVAL_KEY),      new DeprecationDelta("fs.default.name",         CommonConfigurationKeys.FS_DEFAULT_NAME_KEY),      new DeprecationDelta("dfs.umaskmode",        CommonConfigurationKeys.FS_PERMISSIONS_UMASK_KEY),      new DeprecationDelta("dfs.nfs.exports.allowed.hosts",          CommonConfigurationKeys.NFS_EXPORTS_ALLOWED_HOSTS_KEY)    };    private static AtomicReference<DeprecationContext> deprecationContext =      new AtomicReference<DeprecationContext>(          new DeprecationContext(null, defaultDeprecations));    public static void addDeprecations(DeprecationDelta[] deltas) {    DeprecationContext prev, next;    do {      prev = deprecationContext.get();      next = new DeprecationContext(prev, deltas);    } while (!deprecationContext.compareAndSet(prev, next));  }    @Deprecated  public static void addDeprecation(String key, String[] newKeys,      String customMessage) {    addDeprecations(new DeprecationDelta[] {      new DeprecationDelta(key, newKeys, customMessage)    });  }    public static void addDeprecation(String key, String newKey,	      String customMessage) {	  addDeprecation(key, new String[] {newKey}, customMessage);  }    @Deprecated  public static void addDeprecation(String key, String[] newKeys) {    addDeprecation(key, newKeys, null);  }      public static void addDeprecation(String key, String newKey) {    addDeprecation(key, new String[] {newKey}, null);  }      public static boolean isDeprecated(String key) {    return deprecationContext.get().getDeprecatedKeyMap().containsKey(key);  }  private static String getDeprecatedKey(String key) {    return deprecationContext.get().getReverseDeprecatedKeyMap().get(key);  }  private static DeprecatedKeyInfo getDeprecatedKeyInfo(String key) {    return deprecationContext.get().getDeprecatedKeyMap().get(key);  }    public void setDeprecatedProperties() {    DeprecationContext deprecations = deprecationContext.get();    Properties props = getProps();    Properties overlay = getOverlay();    for (Map.Entry<String, DeprecatedKeyInfo> entry :        deprecations.getDeprecatedKeyMap().entrySet()) {      String depKey = entry.getKey();      if (!overlay.contains(depKey)) {        for (String newKey : entry.getValue().newKeys) {          String val = overlay.getProperty(newKey);          if (val != null) {            props.setProperty(depKey, val);            overlay.setProperty(depKey, val);            break;          }        }      }    }  }    private String[] handleDeprecation(DeprecationContext deprecations,                                     String name) {    if (null != name) {      name = name.trim();    }        String[] names = new String[]{name};        DeprecatedKeyInfo keyInfo = deprecations.getDeprecatedKeyMap().get(name);    if (keyInfo != null) {      if (!keyInfo.getAndSetAccessed()) {        logDeprecation(keyInfo.getWarningMessage(name));      }            names = keyInfo.newKeys;    }            updatePropertiesWithDeprecatedKeys(deprecations, names);        Properties overlayProperties = getOverlay();    if (overlayProperties.isEmpty()) {      return names;    }        for (String n : names) {      String deprecatedKey = deprecations.getReverseDeprecatedKeyMap().get(n);      if (deprecatedKey != null && !overlayProperties.containsKey(n)) {        String deprecatedValue = overlayProperties.getProperty(deprecatedKey);        if (deprecatedValue != null) {          getProps().setProperty(n, deprecatedValue);          overlayProperties.setProperty(n, deprecatedValue);        }      }    }    return names;  }  private void updatePropertiesWithDeprecatedKeys(      DeprecationContext deprecations, String[] newNames) {    for (String newName : newNames) {      String deprecatedKey = deprecations.getReverseDeprecatedKeyMap().get(newName);      if (deprecatedKey != null && !getProps().containsKey(newName)) {        String deprecatedValue = getProps().getProperty(deprecatedKey);        if (deprecatedValue != null) {          getProps().setProperty(newName, deprecatedValue);        }      }    }  }   private void handleDeprecation() {    LOG.debug("Handling deprecation for all properties in config...");    DeprecationContext deprecations = deprecationContext.get();    Set<Object> keys = new HashSet<Object>();    keys.addAll(getProps().keySet());    for (Object item: keys) {      LOG.debug("Handling deprecation for " + (String)item);      handleDeprecation(deprecations, (String)item);    }  }   static {        addDefaultResource("core-default.xml");    addDefaultResource("core-site.xml");        ClassLoader cL = Thread.currentThread().getContextClassLoader();    if (cL == null) {      cL = Configuration.class.getClassLoader();    }    if (cL.getResource("hadoop-site.xml") != null) {      LOG.warn("DEPRECATED: hadoop-site.xml found in the classpath. " +          "Usage of hadoop-site.xml is deprecated. Instead use core-site.xml, "          + "mapred-site.xml and hdfs-site.xml to override properties of " +          "core-default.xml, mapred-default.xml and hdfs-default.xml " +          "respectively");      addDefaultResource("hadoop-site.xml");    }  }  private Properties properties;  private Properties overlay;  private ClassLoader classLoader;  {    classLoader = Thread.currentThread().getContextClassLoader();    if (classLoader == null) {      classLoader = Configuration.class.getClassLoader();    }  }      public Configuration() {    this(true);  }    public Configuration(boolean loadDefaults) {    this.loadDefaults = loadDefaults;    synchronized(Configuration.class) {      REGISTRY.put(this, null);    }  }      @SuppressWarnings("unchecked")  public Configuration(Configuration other) {    synchronized(other) {                  other.getProps();      this.resources = (ArrayList<Resource>) other.resources.clone();      if (other.properties != null) {        this.properties = (Properties)other.properties.clone();      }      if (other.overlay!=null) {        this.overlay = (Properties)other.overlay.clone();      }      this.restrictSystemProps = other.restrictSystemProps;      if (other.updatingResource != null) {        this.updatingResource = new ConcurrentHashMap<String, String[]>(           other.updatingResource);      }      this.finalParameters = Collections.newSetFromMap(          new ConcurrentHashMap<String, Boolean>());      this.finalParameters.addAll(other.finalParameters);      this.propertyTagsMap.putAll(other.propertyTagsMap);    }    synchronized(Configuration.class) {      REGISTRY.put(this, null);    }    this.classLoader = other.classLoader;    this.loadDefaults = other.loadDefaults;    setQuietMode(other.getQuietMode());  }    public static synchronized void reloadExistingConfigurations() {    if (LOG.isDebugEnabled()) {      LOG.debug("Reloading " + REGISTRY.keySet().size()          + " existing configurations");    }    for (Configuration conf : REGISTRY.keySet()) {      conf.reloadConfiguration();    }  }    public static synchronized void addDefaultResource(String name) {    if(!defaultResources.contains(name)) {      defaultResources.add(name);      for(Configuration conf : REGISTRY.keySet()) {        if(conf.loadDefaults) {          conf.reloadConfiguration();        }      }    }  }  public static void setRestrictSystemPropertiesDefault(boolean val) {    restrictSystemPropsDefault = val;  }  public void setRestrictSystemProperties(boolean val) {    this.restrictSystemProps = val;  }    public void addResource(String name) {    addResourceObject(new Resource(name));  }  public void addResource(String name, boolean restrictedParser) {    addResourceObject(new Resource(name, restrictedParser));  }    public void addResource(URL url) {    addResourceObject(new Resource(url));  }  public void addResource(URL url, boolean restrictedParser) {    addResourceObject(new Resource(url, restrictedParser));  }    public void addResource(Path file) {    addResourceObject(new Resource(file));  }  public void addResource(Path file, boolean restrictedParser) {    addResourceObject(new Resource(file, restrictedParser));  }    public void addResource(InputStream in) {    addResourceObject(new Resource(in));  }  public void addResource(InputStream in, boolean restrictedParser) {    addResourceObject(new Resource(in, restrictedParser));  }    public void addResource(InputStream in, String name) {    addResourceObject(new Resource(in, name));  }  public void addResource(InputStream in, String name,      boolean restrictedParser) {    addResourceObject(new Resource(in, name, restrictedParser));  }    public void addResource(Configuration conf) {    addResourceObject(new Resource(conf.getProps(), conf.restrictSystemProps));  }        public synchronized void reloadConfiguration() {    properties = null;                                finalParameters.clear();                        }  private synchronized void addResourceObject(Resource resource) {    resources.add(resource);                          restrictSystemProps |= resource.isParserRestricted();    loadProps(properties, resources.size() - 1, false);  }  private static final int MAX_SUBST = 20;  private static final int SUB_START_IDX = 0;  private static final int SUB_END_IDX = SUB_START_IDX + 1;    private static int[] findSubVariable(String eval) {    int[] result = {-1, -1};    int matchStart;    int leftBrace;                match_loop:    for (matchStart = 1, leftBrace = eval.indexOf('{', matchStart);                  leftBrace > 0                  && leftBrace + "{c".length() < eval.length();         leftBrace = eval.indexOf('{', matchStart)) {      int matchedLen = 0;      if (eval.charAt(leftBrace - 1) == '$') {        int subStart = leftBrace + 1;         for (int i = subStart; i < eval.length(); i++) {          switch (eval.charAt(i)) {            case '}':              if (matchedLen > 0) {                 result[SUB_START_IDX] = subStart;                result[SUB_END_IDX] = subStart + matchedLen;                break match_loop;              }                          case ' ':            case '$':              matchStart = i + 1;              continue match_loop;            default:              matchedLen++;          }        }                        break match_loop;      } else {                        matchStart = leftBrace + 1;      }    }    return result;  }    public String substituteCommonVariables(String expr) {    return substituteVars(expr);  }    private String substituteVars(String expr) {    if (expr == null) {      return null;    }    String eval = expr;    for(int s = 0; s < MAX_SUBST; s++) {      final int[] varBounds = findSubVariable(eval);      if (varBounds[SUB_START_IDX] == -1) {        return eval;      }      final String var = eval.substring(varBounds[SUB_START_IDX],          varBounds[SUB_END_IDX]);      String val = null;      try {                                if (var.startsWith("env.") && 4 < var.length()) {          String v = var.substring(4);          int i = 0;          for (; i < v.length(); i++) {            char c = v.charAt(i);            if (c == ':' && i < v.length() - 1 && v.charAt(i + 1) == '-') {              val = getenv(v.substring(0, i));              if (val == null || val.length() == 0) {                val = v.substring(i + 2);              }              break;            } else if (c == '-') {              val = getenv(v.substring(0, i));              if (val == null) {                val = v.substring(i + 1);              }              break;            }          }          if (i == v.length()) {            val = getenv(v);          }        } else {          val = getProperty(var);        }      } catch (SecurityException se) {        LOG.warn("Unexpected SecurityException in Configuration", se);      }      if (val == null) {        val = getRaw(var);      }      if (val == null) {        return eval;       }      final int dollar = varBounds[SUB_START_IDX] - "${".length();      final int afterRightBrace = varBounds[SUB_END_IDX] + "}".length();      final String refVar = eval.substring(dollar, afterRightBrace);            if (val.contains(refVar)) {        return expr;       }            eval = eval.substring(0, dollar)             + val             + eval.substring(afterRightBrace);    }    throw new IllegalStateException("Variable substitution depth too large: "                                     + MAX_SUBST + " " + expr);  }    String getenv(String name) {    if (!restrictSystemProps) {      return System.getenv(name);    } else {      return null;    }  }    String getProperty(String key) {    if (!restrictSystemProps) {      return System.getProperty(key);    } else {      return null;    }  }    public String get(String name) {    String[] names = handleDeprecation(deprecationContext.get(), name);    String result = null;    for(String n : names) {      result = substituteVars(getProps().getProperty(n));    }    return result;  }    @VisibleForTesting  public void setAllowNullValueProperties( boolean val ) {    this.allowNullValueProperties = val;  }  public void setRestrictSystemProps(boolean val) {    this.restrictSystemProps = val;  }    @VisibleForTesting  public boolean onlyKeyExists(String name) {    String[] names = handleDeprecation(deprecationContext.get(), name);    for(String n : names) {      if ( getProps().getProperty(n,DEFAULT_STRING_CHECK)               .equals(DEFAULT_STRING_CHECK) ) {        return true;      }    }    return false;  }    public String getTrimmed(String name) {    String value = get(name);        if (null == value) {      return null;    } else {      return value.trim();    }  }      public String getTrimmed(String name, String defaultValue) {    String ret = getTrimmed(name);    return ret == null ? defaultValue : ret;  }    public String getRaw(String name) {    String[] names = handleDeprecation(deprecationContext.get(), name);    String result = null;    for(String n : names) {      result = getProps().getProperty(n);    }    return result;  }    private String[] getAlternativeNames(String name) {    String altNames[] = null;    DeprecatedKeyInfo keyInfo = null;    DeprecationContext cur = deprecationContext.get();    String depKey = cur.getReverseDeprecatedKeyMap().get(name);    if(depKey != null) {      keyInfo = cur.getDeprecatedKeyMap().get(depKey);      if(keyInfo.newKeys.length > 0) {        if(getProps().containsKey(depKey)) {                    List<String> list = new ArrayList<String>();          list.addAll(Arrays.asList(keyInfo.newKeys));          list.add(depKey);          altNames = list.toArray(new String[list.size()]);        }        else {          altNames = keyInfo.newKeys;        }      }    }    return altNames;  }    public void set(String name, String value) {    set(name, value, null);  }      public void set(String name, String value, String source) {    Preconditions.checkArgument(        name != null,        "Property name must not be null");    Preconditions.checkArgument(        value != null,        "The value of property %s must not be null", name);    name = name.trim();    DeprecationContext deprecations = deprecationContext.get();    if (deprecations.getDeprecatedKeyMap().isEmpty()) {      getProps();    }    getOverlay().setProperty(name, value);    getProps().setProperty(name, value);    String newSource = (source == null ? "programmatically" : source);    if (!isDeprecated(name)) {      putIntoUpdatingResource(name, new String[] {newSource});      String[] altNames = getAlternativeNames(name);      if(altNames != null) {        for(String n: altNames) {          if(!n.equals(name)) {            getOverlay().setProperty(n, value);            getProps().setProperty(n, value);            putIntoUpdatingResource(n, new String[] {newSource});          }        }      }    }    else {      String[] names = handleDeprecation(deprecationContext.get(), name);      String altSource = "because " + name + " is deprecated";      for(String n : names) {        getOverlay().setProperty(n, value);        getProps().setProperty(n, value);        putIntoUpdatingResource(n, new String[] {altSource});      }    }  }  @VisibleForTesting  void logDeprecation(String message) {    LOG_DEPRECATION.info(message);  }  void logDeprecationOnce(String name, String source) {    DeprecatedKeyInfo keyInfo = getDeprecatedKeyInfo(name);    if (keyInfo != null && !keyInfo.getAndSetAccessed()) {      LOG_DEPRECATION.info(keyInfo.getWarningMessage(name, source));    }  }    public synchronized void unset(String name) {    String[] names = null;    if (!isDeprecated(name)) {      names = getAlternativeNames(name);      if(names == null) {    	  names = new String[]{name};      }    }    else {      names = handleDeprecation(deprecationContext.get(), name);    }    for(String n: names) {      getOverlay().remove(n);      getProps().remove(n);    }  }    public synchronized void setIfUnset(String name, String value) {    if (get(name) == null) {      set(name, value);    }  }    private synchronized Properties getOverlay() {    if (overlay==null){      overlay=new Properties();    }    return overlay;  }    public String get(String name, String defaultValue) {    String[] names = handleDeprecation(deprecationContext.get(), name);    String result = null;    for(String n : names) {      result = substituteVars(getProps().getProperty(n, defaultValue));    }    return result;  }    public int getInt(String name, int defaultValue) {    String valueString = getTrimmed(name);    if (valueString == null)      return defaultValue;    String hexString = getHexDigits(valueString);    if (hexString != null) {      return Integer.parseInt(hexString, 16);    }    return Integer.parseInt(valueString);  }      public int[] getInts(String name) {    String[] strings = getTrimmedStrings(name);    int[] ints = new int[strings.length];    for (int i = 0; i < strings.length; i++) {      ints[i] = Integer.parseInt(strings[i]);    }    return ints;  }    public void setInt(String name, int value) {    set(name, Integer.toString(value));  }    public long getLong(String name, long defaultValue) {    String valueString = getTrimmed(name);    if (valueString == null)      return defaultValue;    String hexString = getHexDigits(valueString);    if (hexString != null) {      return Long.parseLong(hexString, 16);    }    return Long.parseLong(valueString);  }    public long getLongBytes(String name, long defaultValue) {    String valueString = getTrimmed(name);    if (valueString == null)      return defaultValue;    return StringUtils.TraditionalBinaryPrefix.string2long(valueString);  }  private String getHexDigits(String value) {    boolean negative = false;    String str = value;    String hexString = null;    if (value.startsWith("-")) {      negative = true;      str = value.substring(1);    }    if (str.startsWith("0x") || str.startsWith("0X")) {      hexString = str.substring(2);      if (negative) {        hexString = "-" + hexString;      }      return hexString;    }    return null;  }      public void setLong(String name, long value) {    set(name, Long.toString(value));  }    public float getFloat(String name, float defaultValue) {    String valueString = getTrimmed(name);    if (valueString == null)      return defaultValue;    return Float.parseFloat(valueString);  }    public void setFloat(String name, float value) {    set(name,Float.toString(value));  }    public double getDouble(String name, double defaultValue) {    String valueString = getTrimmed(name);    if (valueString == null)      return defaultValue;    return Double.parseDouble(valueString);  }    public void setDouble(String name, double value) {    set(name,Double.toString(value));  }     public boolean getBoolean(String name, boolean defaultValue) {    String valueString = getTrimmed(name);    if (null == valueString || valueString.isEmpty()) {      return defaultValue;    }    if (StringUtils.equalsIgnoreCase("true", valueString))      return true;    else if (StringUtils.equalsIgnoreCase("false", valueString))      return false;    else {      LOG.warn("Invalid value for boolean: " + valueString +               ", choose default value: " + defaultValue + " for " + name);      return defaultValue;    }  }    public void setBoolean(String name, boolean value) {    set(name, Boolean.toString(value));  }    public void setBooleanIfUnset(String name, boolean value) {    setIfUnset(name, Boolean.toString(value));  }    public <T extends Enum<T>> void setEnum(String name, T value) {    set(name, value.toString());  }    public <T extends Enum<T>> T getEnum(String name, T defaultValue) {    final String val = getTrimmed(name);    return null == val      ? defaultValue      : Enum.valueOf(defaultValue.getDeclaringClass(), val);  }  enum ParsedTimeDuration {    NS {      TimeUnit unit() { return TimeUnit.NANOSECONDS; }      String suffix() { return "ns"; }    },    US {      TimeUnit unit() { return TimeUnit.MICROSECONDS; }      String suffix() { return "us"; }    },    MS {      TimeUnit unit() { return TimeUnit.MILLISECONDS; }      String suffix() { return "ms"; }    },    S {      TimeUnit unit() { return TimeUnit.SECONDS; }      String suffix() { return "s"; }    },    M {      TimeUnit unit() { return TimeUnit.MINUTES; }      String suffix() { return "m"; }    },    H {      TimeUnit unit() { return TimeUnit.HOURS; }      String suffix() { return "h"; }    },    D {      TimeUnit unit() { return TimeUnit.DAYS; }      String suffix() { return "d"; }    };    abstract TimeUnit unit();    abstract String suffix();    static ParsedTimeDuration unitFor(String s) {      for (ParsedTimeDuration ptd : values()) {                if (s.endsWith(ptd.suffix())) {          return ptd;        }      }      return null;    }    static ParsedTimeDuration unitFor(TimeUnit unit) {      for (ParsedTimeDuration ptd : values()) {        if (ptd.unit() == unit) {          return ptd;        }      }      return null;    }  }    public void setTimeDuration(String name, long value, TimeUnit unit) {    set(name, value + ParsedTimeDuration.unitFor(unit).suffix());  }    public long getTimeDuration(String name, long defaultValue, TimeUnit unit) {    return getTimeDuration(name, defaultValue, unit, unit);  }  public long getTimeDuration(String name, String defaultValue, TimeUnit unit) {    return getTimeDuration(name, defaultValue, unit, unit);  }    public long getTimeDuration(String name, long defaultValue,      TimeUnit defaultUnit, TimeUnit returnUnit) {    String vStr = get(name);    if (null == vStr) {      return returnUnit.convert(defaultValue, defaultUnit);    } else {      return getTimeDurationHelper(name, vStr, defaultUnit, returnUnit);    }  }  public long getTimeDuration(String name, String defaultValue,      TimeUnit defaultUnit, TimeUnit returnUnit) {    String vStr = get(name);    if (null == vStr) {      return getTimeDurationHelper(name, defaultValue, defaultUnit, returnUnit);    } else {      return getTimeDurationHelper(name, vStr, defaultUnit, returnUnit);    }  }    public long getTimeDurationHelper(String name, String vStr, TimeUnit unit) {    return getTimeDurationHelper(name, vStr, unit, unit);  }    private long getTimeDurationHelper(String name, String vStr,      TimeUnit defaultUnit, TimeUnit returnUnit) {    vStr = vStr.trim();    vStr = StringUtils.toLowerCase(vStr);    ParsedTimeDuration vUnit = ParsedTimeDuration.unitFor(vStr);    if (null == vUnit) {      vUnit = ParsedTimeDuration.unitFor(defaultUnit);    } else {      vStr = vStr.substring(0, vStr.lastIndexOf(vUnit.suffix()));    }    long raw = Long.parseLong(vStr);    long converted = returnUnit.convert(raw, vUnit.unit());    if (vUnit.unit().convert(converted, returnUnit) < raw) {      logDeprecation("Possible loss of precision converting " + vStr          + vUnit.suffix() + " to " + returnUnit + " for " + name);    }    return converted;  }  public long[] getTimeDurations(String name, TimeUnit unit) {    String[] strings = getTrimmedStrings(name);    long[] durations = new long[strings.length];    for (int i = 0; i < strings.length; i++) {      durations[i] = getTimeDurationHelper(name, strings[i], unit);    }    return durations;  }    public double getStorageSize(String name, String defaultValue,      StorageUnit targetUnit) {    Preconditions.checkState(isNotBlank(name), "Key cannot be blank.");    String vString = get(name);    if (isBlank(vString)) {      vString = defaultValue;    }                    StorageSize measure = StorageSize.parse(vString);    return convertStorageUnit(measure.getValue(), measure.getUnit(),        targetUnit);  }    public double getStorageSize(String name, double defaultValue,      StorageUnit targetUnit) {    Preconditions.checkNotNull(targetUnit, "Conversion unit cannot be null.");    Preconditions.checkState(isNotBlank(name), "Name cannot be blank.");    String vString = get(name);    if (isBlank(vString)) {      return targetUnit.getDefault(defaultValue);    }    StorageSize measure = StorageSize.parse(vString);    return convertStorageUnit(measure.getValue(), measure.getUnit(),        targetUnit);  }    public void setStorageSize(String name, double value, StorageUnit unit) {    set(name, value + unit.getShortName());  }    private double convertStorageUnit(double value, StorageUnit sourceUnit,      StorageUnit targetUnit) {    double byteValue = sourceUnit.toBytes(value);    return targetUnit.fromBytes(byteValue);  }    public Pattern getPattern(String name, Pattern defaultValue) {    String valString = get(name);    if (null == valString || valString.isEmpty()) {      return defaultValue;    }    try {      return Pattern.compile(valString);    } catch (PatternSyntaxException pse) {      LOG.warn("Regular expression '" + valString + "' for property '" +               name + "' not valid. Using default", pse);      return defaultValue;    }  }    public void setPattern(String name, Pattern pattern) {    assert pattern != null : "Pattern cannot be null";    set(name, pattern.pattern());  }    @InterfaceStability.Unstable  public synchronized String[] getPropertySources(String name) {    if (properties == null) {                        getProps();    }            if (properties == null || updatingResource == null) {      return null;    } else {      String[] source = updatingResource.get(name);      if(source == null) {        return null;      } else {        return Arrays.copyOf(source, source.length);      }    }  }    public static class IntegerRanges implements Iterable<Integer>{    private static class Range {      int start;      int end;    }        private static class RangeNumberIterator implements Iterator<Integer> {      Iterator<Range> internal;      int at;      int end;      public RangeNumberIterator(List<Range> ranges) {        if (ranges != null) {          internal = ranges.iterator();        }        at = -1;        end = -2;      }            @Override      public boolean hasNext() {        if (at <= end) {          return true;        } else if (internal != null){          return internal.hasNext();        }        return false;      }      @Override      public Integer next() {        if (at <= end) {          at++;          return at - 1;        } else if (internal != null){          Range found = internal.next();          if (found != null) {            at = found.start;            end = found.end;            at++;            return at - 1;          }        }        return null;      }      @Override      public void remove() {        throw new UnsupportedOperationException();      }    };    List<Range> ranges = new ArrayList<Range>();        public IntegerRanges() {    }        public IntegerRanges(String newValue) {      StringTokenizer itr = new StringTokenizer(newValue, ",");      while (itr.hasMoreTokens()) {        String rng = itr.nextToken().trim();        String[] parts = rng.split("-", 3);        if (parts.length < 1 || parts.length > 2) {          throw new IllegalArgumentException("integer range badly formed: " +                                              rng);        }        Range r = new Range();        r.start = convertToInt(parts[0], 0);        if (parts.length == 2) {          r.end = convertToInt(parts[1], Integer.MAX_VALUE);        } else {          r.end = r.start;        }        if (r.start > r.end) {          throw new IllegalArgumentException("IntegerRange from " + r.start +                                              " to " + r.end + " is invalid");        }        ranges.add(r);      }    }        private static int convertToInt(String value, int defaultValue) {      String trim = value.trim();      if (trim.length() == 0) {        return defaultValue;      }      return Integer.parseInt(trim);    }        public boolean isIncluded(int value) {      for(Range r: ranges) {        if (r.start <= value && value <= r.end) {          return true;        }      }      return false;    }            public boolean isEmpty() {      return ranges == null || ranges.isEmpty();    }        @Override    public String toString() {      StringBuilder result = new StringBuilder();      boolean first = true;      for(Range r: ranges) {        if (first) {          first = false;        } else {          result.append(',');        }        result.append(r.start);        result.append('-');        result.append(r.end);      }      return result.toString();    }        public int getRangeStart() {      if (ranges == null || ranges.isEmpty()) {        return -1;      }      Range r = ranges.get(0);      return r.start;    }    @Override    public Iterator<Integer> iterator() {      return new RangeNumberIterator(ranges);    }      }    public IntegerRanges getRange(String name, String defaultValue) {    return new IntegerRanges(get(name, defaultValue));  }    public Collection<String> getStringCollection(String name) {    String valueString = get(name);    return StringUtils.getStringCollection(valueString);  }    public String[] getStrings(String name) {    String valueString = get(name);    return StringUtils.getStrings(valueString);  }    public String[] getStrings(String name, String... defaultValue) {    String valueString = get(name);    if (valueString == null) {      return defaultValue;    } else {      return StringUtils.getStrings(valueString);    }  }      public Collection<String> getTrimmedStringCollection(String name) {    String valueString = get(name);    if (null == valueString) {      Collection<String> empty = new ArrayList<String>();      return empty;    }    return StringUtils.getTrimmedStringCollection(valueString);  }      public String[] getTrimmedStrings(String name) {    String valueString = get(name);    return StringUtils.getTrimmedStrings(valueString);  }    public String[] getTrimmedStrings(String name, String... defaultValue) {    String valueString = get(name);    if (null == valueString) {      return defaultValue;    } else {      return StringUtils.getTrimmedStrings(valueString);    }  }    public void setStrings(String name, String... values) {    set(name, StringUtils.arrayToString(values));  }    public char[] getPassword(String name) throws IOException {    char[] pass = null;    pass = getPasswordFromCredentialProviders(name);    if (pass == null) {      pass = getPasswordFromConfig(name);    }    return pass;  }    private CredentialEntry getCredentialEntry(CredentialProvider provider,                                             String name) throws IOException {    CredentialEntry entry = provider.getCredentialEntry(name);    if (entry != null) {      return entry;    }        String oldName = getDeprecatedKey(name);    if (oldName != null) {      entry = provider.getCredentialEntry(oldName);      if (entry != null) {        logDeprecationOnce(oldName, provider.toString());        return entry;      }    }        DeprecatedKeyInfo keyInfo = getDeprecatedKeyInfo(name);    if (keyInfo != null && keyInfo.newKeys != null) {      for (String newName : keyInfo.newKeys) {        entry = provider.getCredentialEntry(newName);        if (entry != null) {          logDeprecationOnce(name, null);          return entry;        }      }    }    return null;  }    public char[] getPasswordFromCredentialProviders(String name)      throws IOException {    char[] pass = null;    try {      List<CredentialProvider> providers =          CredentialProviderFactory.getProviders(this);      if (providers != null) {        for (CredentialProvider provider : providers) {          try {            CredentialEntry entry = getCredentialEntry(provider, name);            if (entry != null) {              pass = entry.getCredential();              break;            }          }          catch (IOException ioe) {            throw new IOException("Can't get key " + name + " from key provider" +            		"of type: " + provider.getClass().getName() + ".", ioe);          }        }      }    }    catch (IOException ioe) {      throw new IOException("Configuration problem with provider path.", ioe);    }    return pass;  }    protected char[] getPasswordFromConfig(String name) {    char[] pass = null;    if (getBoolean(CredentialProvider.CLEAR_TEXT_FALLBACK,        CommonConfigurationKeysPublic.            HADOOP_SECURITY_CREDENTIAL_CLEAR_TEXT_FALLBACK_DEFAULT)) {      String passStr = get(name);      if (passStr != null) {        pass = passStr.toCharArray();      }    }    return pass;  }    public InetSocketAddress getSocketAddr(      String hostProperty,      String addressProperty,      String defaultAddressValue,      int defaultPort) {    InetSocketAddress bindAddr = getSocketAddr(      addressProperty, defaultAddressValue, defaultPort);    final String host = get(hostProperty);    if (host == null || host.isEmpty()) {      return bindAddr;    }    return NetUtils.createSocketAddr(        host, bindAddr.getPort(), hostProperty);  }    public InetSocketAddress getSocketAddr(      String name, String defaultAddress, int defaultPort) {    final String address = getTrimmed(name, defaultAddress);    return NetUtils.createSocketAddr(address, defaultPort, name);  }    public void setSocketAddr(String name, InetSocketAddress addr) {    set(name, NetUtils.getHostPortString(addr));  }    public InetSocketAddress updateConnectAddr(      String hostProperty,      String addressProperty,      String defaultAddressValue,      InetSocketAddress addr) {    final String host = get(hostProperty);    final String connectHostPort = getTrimmed(addressProperty, defaultAddressValue);    if (host == null || host.isEmpty() || connectHostPort == null || connectHostPort.isEmpty()) {            return updateConnectAddr(addressProperty, addr);    }    final String connectHost = connectHostPort.split(":")[0];        return updateConnectAddr(addressProperty, NetUtils.createSocketAddrForHost(        connectHost, addr.getPort()));  }      public InetSocketAddress updateConnectAddr(String name,                                             InetSocketAddress addr) {    final InetSocketAddress connectAddr = NetUtils.getConnectAddress(addr);    setSocketAddr(name, connectAddr);    return connectAddr;  }      public Class<?> getClassByName(String name) throws ClassNotFoundException {    Class<?> ret = getClassByNameOrNull(name);    if (ret == null) {      throw new ClassNotFoundException("Class " + name + " not found");    }    return ret;  }      public Class<?> getClassByNameOrNull(String name) {    Map<String, WeakReference<Class<?>>> map;        synchronized (CACHE_CLASSES) {      map = CACHE_CLASSES.get(classLoader);      if (map == null) {        map = Collections.synchronizedMap(          new WeakHashMap<String, WeakReference<Class<?>>>());        CACHE_CLASSES.put(classLoader, map);      }    }    Class<?> clazz = null;    WeakReference<Class<?>> ref = map.get(name);     if (ref != null) {       clazz = ref.get();    }         if (clazz == null) {      try {        clazz = Class.forName(name, true, classLoader);      } catch (ClassNotFoundException e) {                map.put(name, new WeakReference<Class<?>>(NEGATIVE_CACHE_SENTINEL));        return null;      }            map.put(name, new WeakReference<Class<?>>(clazz));      return clazz;    } else if (clazz == NEGATIVE_CACHE_SENTINEL) {      return null;     } else {            return clazz;    }  }    public Class<?>[] getClasses(String name, Class<?> ... defaultValue) {    String valueString = getRaw(name);    if (null == valueString) {      return defaultValue;    }    String[] classnames = getTrimmedStrings(name);    try {      Class<?>[] classes = new Class<?>[classnames.length];      for(int i = 0; i < classnames.length; i++) {        classes[i] = getClassByName(classnames[i]);      }      return classes;    } catch (ClassNotFoundException e) {      throw new RuntimeException(e);    }  }    public Class<?> getClass(String name, Class<?> defaultValue) {    String valueString = getTrimmed(name);    if (valueString == null)      return defaultValue;    try {      return getClassByName(valueString);    } catch (ClassNotFoundException e) {      throw new RuntimeException(e);    }  }    public <U> Class<? extends U> getClass(String name,                                          Class<? extends U> defaultValue,                                          Class<U> xface) {    try {      Class<?> theClass = getClass(name, defaultValue);      if (theClass != null && !xface.isAssignableFrom(theClass))        throw new RuntimeException(theClass+" not "+xface.getName());      else if (theClass != null)        return theClass.asSubclass(xface);      else        return null;    } catch (Exception e) {      throw new RuntimeException(e);    }  }    @SuppressWarnings("unchecked")  public <U> List<U> getInstances(String name, Class<U> xface) {    List<U> ret = new ArrayList<U>();    Class<?>[] classes = getClasses(name);    for (Class<?> cl: classes) {      if (!xface.isAssignableFrom(cl)) {        throw new RuntimeException(cl + " does not implement " + xface);      }      ret.add((U)ReflectionUtils.newInstance(cl, this));    }    return ret;  }    public void setClass(String name, Class<?> theClass, Class<?> xface) {    if (!xface.isAssignableFrom(theClass))      throw new RuntimeException(theClass+" not "+xface.getName());    set(name, theClass.getName());  }    public Path getLocalPath(String dirsProp, String path)    throws IOException {    String[] dirs = getTrimmedStrings(dirsProp);    int hashCode = path.hashCode();    FileSystem fs = FileSystem.getLocal(this);    for (int i = 0; i < dirs.length; i++) {        int index = (hashCode+i & Integer.MAX_VALUE) % dirs.length;      Path file = new Path(dirs[index], path);      Path dir = file.getParent();      if (fs.mkdirs(dir) || fs.exists(dir)) {        return file;      }    }    LOG.warn("Could not make " + path +              " in local directories from " + dirsProp);    for(int i=0; i < dirs.length; i++) {      int index = (hashCode+i & Integer.MAX_VALUE) % dirs.length;      LOG.warn(dirsProp + "[" + index + "]=" + dirs[index]);    }    throw new IOException("No valid local directories in property: "+dirsProp);  }    public File getFile(String dirsProp, String path)    throws IOException {    String[] dirs = getTrimmedStrings(dirsProp);    int hashCode = path.hashCode();    for (int i = 0; i < dirs.length; i++) {        int index = (hashCode+i & Integer.MAX_VALUE) % dirs.length;      File file = new File(dirs[index], path);      File dir = file.getParentFile();      if (dir.exists() || dir.mkdirs()) {        return file;      }    }    throw new IOException("No valid local directories in property: "+dirsProp);  }    public URL getResource(String name) {    return classLoader.getResource(name);  }      public InputStream getConfResourceAsInputStream(String name) {    try {      URL url= getResource(name);      if (url == null) {        LOG.info(name + " not found");        return null;      } else {        LOG.info("found resource " + name + " at " + url);      }      return url.openStream();    } catch (Exception e) {      return null;    }  }    public Reader getConfResourceAsReader(String name) {    try {      URL url= getResource(name);      if (url == null) {        LOG.info(name + " not found");        return null;      } else {        LOG.info("found resource " + name + " at " + url);      }      return new InputStreamReader(url.openStream(), Charsets.UTF_8);    } catch (Exception e) {      return null;    }  }    public Set<String> getFinalParameters() {    Set<String> setFinalParams = Collections.newSetFromMap(        new ConcurrentHashMap<String, Boolean>());    setFinalParams.addAll(finalParameters);    return setFinalParams;  }  protected synchronized Properties getProps() {    if (properties == null) {      properties = new Properties();      loadProps(properties, 0, true);    }    return properties;  }    private synchronized void loadProps(final Properties props,      final int startIdx, final boolean fullReload) {    if (props != null) {      Map<String, String[]> backup =          updatingResource != null              ? new ConcurrentHashMap<>(updatingResource) : null;      loadResources(props, resources, startIdx, fullReload, quietmode);      if (overlay != null) {        props.putAll(overlay);        if (backup != null) {          for (Map.Entry<Object, Object> item : overlay.entrySet()) {            String key = (String) item.getKey();            String[] source = backup.get(key);            if (source != null) {              updatingResource.put(key, source);            }          }        }      }    }  }    public int size() {    return getProps().size();  }    public void clear() {    getProps().clear();    getOverlay().clear();  }    @Override  public Iterator<Map.Entry<String, String>> iterator() {                    Map<String,String> result = new HashMap<String,String>();    for(Map.Entry<Object,Object> item: getProps().entrySet()) {      if (item.getKey() instanceof String &&          item.getValue() instanceof String) {          result.put((String) item.getKey(), (String) item.getValue());      }    }    return result.entrySet().iterator();  }    public Map<String, String> getPropsWithPrefix(String confPrefix) {    Properties props = getProps();    Map<String, String> configMap = new HashMap<>();    for (String name : props.stringPropertyNames()) {      if (name.startsWith(confPrefix)) {        String value = get(name);        String keyName = name.substring(confPrefix.length());        configMap.put(keyName, value);      }    }    return configMap;  }  private XMLStreamReader parse(URL url, boolean restricted)      throws IOException, XMLStreamException {    if (!quietmode) {      if (LOG.isDebugEnabled()) {        LOG.debug("parsing URL " + url);      }    }    if (url == null) {      return null;    }    URLConnection connection = url.openConnection();    if (connection instanceof JarURLConnection) {                  connection.setUseCaches(false);    }    return parse(connection.getInputStream(), url.toString(), restricted);  }  private XMLStreamReader parse(InputStream is, String systemIdStr,      boolean restricted) throws IOException, XMLStreamException {    if (!quietmode) {      LOG.debug("parsing input stream " + is);    }    if (is == null) {      return null;    }    SystemId systemId = SystemId.construct(systemIdStr);    ReaderConfig readerConfig = XML_INPUT_FACTORY.createPrivateConfig();    if (restricted) {      readerConfig.setProperty(XMLInputFactory.SUPPORT_DTD, false);    }    return XML_INPUT_FACTORY.createSR(readerConfig, systemId,        StreamBootstrapper.getInstance(null, systemId, is), false, true);  }  private void loadResources(Properties properties,                             ArrayList<Resource> resources,                             int startIdx,                             boolean fullReload,                             boolean quiet) {    if(loadDefaults && fullReload) {      for (String resource : defaultResources) {        loadResource(properties, new Resource(resource, false), quiet);      }    }        for (int i = startIdx; i < resources.size(); i++) {      Resource ret = loadResource(properties, resources.get(i), quiet);      if (ret != null) {        resources.set(i, ret);      }    }    this.addTags(properties);  }    private Resource loadResource(Properties properties,                                Resource wrapper, boolean quiet) {    String name = UNKNOWN_RESOURCE;    try {      Object resource = wrapper.getResource();      name = wrapper.getName();      boolean returnCachedProperties = false;      if (resource instanceof InputStream) {        returnCachedProperties = true;      } else if (resource instanceof Properties) {        overlay(properties, (Properties)resource);      }      XMLStreamReader2 reader = getStreamReader(wrapper, quiet);      if (reader == null) {        if (quiet) {          return null;        }        throw new RuntimeException(resource + " not found");      }      Properties toAddTo = properties;      if(returnCachedProperties) {        toAddTo = new Properties();      }      List<ParsedItem> items = new Parser(reader, wrapper, quiet).parse();      for (ParsedItem item : items) {        loadProperty(toAddTo, item.name, item.key, item.value,            item.isFinal, item.sources);      }      reader.close();      if (returnCachedProperties) {        overlay(properties, toAddTo);        return new Resource(toAddTo, name, wrapper.isParserRestricted());      }      return null;    } catch (IOException e) {      LOG.error("error parsing conf " + name, e);      throw new RuntimeException(e);    } catch (XMLStreamException e) {      LOG.error("error parsing conf " + name, e);      throw new RuntimeException(e);    }  }  private XMLStreamReader2 getStreamReader(Resource wrapper, boolean quiet)      throws XMLStreamException, IOException {    Object resource = wrapper.getResource();    boolean isRestricted = wrapper.isParserRestricted();    XMLStreamReader2 reader = null;    if (resource instanceof URL) {                        reader  = (XMLStreamReader2)parse((URL)resource, isRestricted);    } else if (resource instanceof String) {              URL url = getResource((String)resource);      reader = (XMLStreamReader2)parse(url, isRestricted);    } else if (resource instanceof Path) {                            File file = new File(((Path)resource).toUri().getPath())        .getAbsoluteFile();      if (file.exists()) {        if (!quiet) {          LOG.debug("parsing File " + file);        }        reader = (XMLStreamReader2)parse(new BufferedInputStream(            Files.newInputStream(file.toPath())), ((Path) resource).toString(),            isRestricted);      }    } else if (resource instanceof InputStream) {      reader = (XMLStreamReader2)parse((InputStream)resource, null,          isRestricted);    }    return reader;  }  private static class ParsedItem {    String name;    String key;    String value;    boolean isFinal;    String[] sources;    ParsedItem(String name, String key, String value,        boolean isFinal, String[] sources) {      this.name = name;      this.key = key;      this.value = value;      this.isFinal = isFinal;      this.sources = sources;    }  }    private class Parser {    private final XMLStreamReader2 reader;    private final Resource wrapper;    private final String name;    private final String[] nameSingletonArray;    private final boolean isRestricted;    private final boolean quiet;    DeprecationContext deprecations = deprecationContext.get();    private StringBuilder token = new StringBuilder();    private String confName = null;    private String confValue = null;    private String confInclude = null;    private String confTag = null;    private boolean confFinal = false;    private boolean fallbackAllowed = false;    private boolean fallbackEntered = false;    private boolean parseToken = false;    private List<String> confSource = new ArrayList<>();    private List<ParsedItem> results = new ArrayList<>();    Parser(XMLStreamReader2 reader,           Resource wrapper,           boolean quiet) {      this.reader = reader;      this.wrapper = wrapper;      this.name = wrapper.getName();      this.nameSingletonArray = new String[]{ name };      this.isRestricted = wrapper.isParserRestricted();      this.quiet = quiet;    }    List<ParsedItem> parse() throws IOException, XMLStreamException {      while (reader.hasNext()) {        parseNext();      }      return results;    }    private void handleStartElement() throws XMLStreamException, IOException {      switch (reader.getLocalName()) {      case "property":        handleStartProperty();        break;      case "name":      case "value":      case "final":      case "source":      case "tag":        parseToken = true;        token.setLength(0);        break;      case "include":        handleInclude();        break;      case "fallback":        fallbackEntered = true;        break;      case "configuration":        break;      default:        break;      }    }    private void handleStartProperty() {      confName = null;      confValue = null;      confFinal = false;      confTag = null;      confSource.clear();            int attrCount = reader.getAttributeCount();      for (int i = 0; i < attrCount; i++) {        String propertyAttr = reader.getAttributeLocalName(i);        if ("name".equals(propertyAttr)) {          confName = StringInterner.weakIntern(              reader.getAttributeValue(i));        } else if ("value".equals(propertyAttr)) {          confValue = StringInterner.weakIntern(              reader.getAttributeValue(i));        } else if ("final".equals(propertyAttr)) {          confFinal = "true".equals(reader.getAttributeValue(i));        } else if ("source".equals(propertyAttr)) {          confSource.add(StringInterner.weakIntern(              reader.getAttributeValue(i)));        } else if ("tag".equals(propertyAttr)) {          confTag = StringInterner              .weakIntern(reader.getAttributeValue(i));        }      }    }    private void handleInclude() throws XMLStreamException, IOException {            confInclude = null;      int attrCount = reader.getAttributeCount();      List<ParsedItem> items;      for (int i = 0; i < attrCount; i++) {        String attrName = reader.getAttributeLocalName(i);        if ("href".equals(attrName)) {          confInclude = reader.getAttributeValue(i);        }      }      if (confInclude == null) {        return;      }      if (isRestricted) {        throw new RuntimeException("Error parsing resource " + wrapper            + ": XInclude is not supported for restricted resources");      }                        URL include = getResource(confInclude);      if (include != null) {        Resource classpathResource = new Resource(include, name,            wrapper.isParserRestricted());                        synchronized (Configuration.this) {          XMLStreamReader2 includeReader =              getStreamReader(classpathResource, quiet);          if (includeReader == null) {            throw new RuntimeException(classpathResource + " not found");          }          items = new Parser(includeReader, classpathResource, quiet).parse();        }      } else {        URL url;        try {          url = new URL(confInclude);          url.openConnection().connect();        } catch (IOException ioe) {          File href = new File(confInclude);          if (!href.isAbsolute()) {                        File baseFile;            try {              baseFile = new File(new URI(name));            } catch (IllegalArgumentException | URISyntaxException e) {              baseFile = new File(name);            }            baseFile = baseFile.getParentFile();            href = new File(baseFile, href.getPath());          }          if (!href.exists()) {                        fallbackAllowed = true;            return;          }          url = href.toURI().toURL();        }        Resource uriResource = new Resource(url, name,            wrapper.isParserRestricted());                        synchronized (Configuration.this) {          XMLStreamReader2 includeReader =              getStreamReader(uriResource, quiet);          if (includeReader == null) {            throw new RuntimeException(uriResource + " not found");          }          items = new Parser(includeReader, uriResource, quiet).parse();        }      }      results.addAll(items);    }    void handleEndElement() throws IOException {      String tokenStr = token.toString();      switch (reader.getLocalName()) {      case "name":        if (token.length() > 0) {          confName = StringInterner.weakIntern(tokenStr.trim());        }        break;      case "value":        if (token.length() > 0) {          confValue = StringInterner.weakIntern(tokenStr);        }        break;      case "final":        confFinal = "true".equals(tokenStr);        break;      case "source":        confSource.add(StringInterner.weakIntern(tokenStr));        break;      case "tag":        if (token.length() > 0) {          confTag = StringInterner.weakIntern(tokenStr);        }        break;      case "include":        if (fallbackAllowed && !fallbackEntered) {          throw new IOException("Fetch fail on include for '"              + confInclude + "' with no fallback while loading '"              + name + "'");        }        fallbackAllowed = false;        fallbackEntered = false;        break;      case "property":        handleEndProperty();        break;      default:        break;      }    }    void handleEndProperty() {      if (confName == null || (!fallbackAllowed && fallbackEntered)) {        return;      }      String[] confSourceArray;      if (confSource.isEmpty()) {        confSourceArray = nameSingletonArray;      } else {        confSource.add(name);        confSourceArray = confSource.toArray(new String[confSource.size()]);      }            if (confTag != null) {        readTagFromConfig(confTag, confName, confValue, confSourceArray);      }      DeprecatedKeyInfo keyInfo =          deprecations.getDeprecatedKeyMap().get(confName);      if (keyInfo != null) {        keyInfo.clearAccessed();        for (String key : keyInfo.newKeys) {                    results.add(new ParsedItem(              name, key, confValue, confFinal, confSourceArray));        }      } else {        results.add(new ParsedItem(name, confName, confValue, confFinal,            confSourceArray));      }    }    void parseNext() throws IOException, XMLStreamException {      switch (reader.next()) {      case XMLStreamConstants.START_ELEMENT:        handleStartElement();        break;      case XMLStreamConstants.CHARACTERS:      case XMLStreamConstants.CDATA:        if (parseToken) {          char[] text = reader.getTextCharacters();          token.append(text, reader.getTextStart(), reader.getTextLength());        }        break;      case XMLStreamConstants.END_ELEMENT:        handleEndElement();        break;      default:        break;      }    }  }    public void addTags(Properties prop) {        try {      if (prop.containsKey(CommonConfigurationKeys.HADOOP_TAGS_SYSTEM)) {        String systemTags = prop.getProperty(CommonConfigurationKeys            .HADOOP_TAGS_SYSTEM);        TAGS.addAll(Arrays.asList(systemTags.split(",")));      }            if (prop.containsKey(CommonConfigurationKeys.HADOOP_TAGS_CUSTOM)) {        String customTags = prop.getProperty(CommonConfigurationKeys            .HADOOP_TAGS_CUSTOM);        TAGS.addAll(Arrays.asList(customTags.split(",")));      }      if (prop.containsKey(CommonConfigurationKeys.HADOOP_SYSTEM_TAGS)) {        String systemTags = prop.getProperty(CommonConfigurationKeys            .HADOOP_SYSTEM_TAGS);        TAGS.addAll(Arrays.asList(systemTags.split(",")));      }            if (prop.containsKey(CommonConfigurationKeys.HADOOP_CUSTOM_TAGS)) {        String customTags = prop.getProperty(CommonConfigurationKeys            .HADOOP_CUSTOM_TAGS);        TAGS.addAll(Arrays.asList(customTags.split(",")));      }    } catch (Exception ex) {      LOG.trace("Error adding tags in configuration", ex);    }  }    private void readTagFromConfig(String attributeValue, String confName, String      confValue, String[] confSource) {    for (String tagStr : attributeValue.split(",")) {      try {        tagStr = tagStr.trim();                if (confValue == null) {          confValue = "";        }        if (propertyTagsMap.containsKey(tagStr)) {          propertyTagsMap.get(tagStr).setProperty(confName, confValue);        } else {          Properties props = new Properties();          props.setProperty(confName, confValue);          propertyTagsMap.put(tagStr, props);        }      } catch (Exception ex) {                LOG.trace("Tag '{}' for property:{} Source:{}", tagStr, confName,            confSource, ex);      }    }  }  private void overlay(Properties to, Properties from) {    synchronized (from) {      for (Entry<Object, Object> entry : from.entrySet()) {        to.put(entry.getKey(), entry.getValue());      }    }  }  private void loadProperty(Properties properties, String name, String attr,      String value, boolean finalParameter, String[] source) {    if (value != null || allowNullValueProperties) {      if (value == null) {        value = DEFAULT_STRING_CHECK;      }      if (!finalParameters.contains(attr)) {        properties.setProperty(attr, value);        if (source != null) {          putIntoUpdatingResource(attr, source);        }      } else {                checkForOverride(this.properties, name, attr, value);        if (this.properties != properties) {          checkForOverride(properties, name, attr, value);        }      }    }    if (finalParameter && attr != null) {      finalParameters.add(attr);    }  }    private void checkForOverride(Properties properties, String name, String attr, String value) {    String propertyValue = properties.getProperty(attr);    if (propertyValue != null && !propertyValue.equals(value)) {      LOG.warn(name + ":an attempt to override final parameter: " + attr          + ";  Ignoring.");    }  }    public void writeXml(OutputStream out) throws IOException {    writeXml(new OutputStreamWriter(out, "UTF-8"));  }  public void writeXml(Writer out) throws IOException {    writeXml(null, out);  }    public void writeXml(@Nullable String propertyName, Writer out)      throws IOException, IllegalArgumentException {    Document doc = asXmlDocument(propertyName);    try {      DOMSource source = new DOMSource(doc);      StreamResult result = new StreamResult(out);      TransformerFactory transFactory = TransformerFactory.newInstance();      Transformer transformer = transFactory.newTransformer();                        transformer.transform(source, result);    } catch (TransformerException te) {      throw new IOException(te);    }  }    private synchronized Document asXmlDocument(@Nullable String propertyName)      throws IOException, IllegalArgumentException {    Document doc;    try {      doc = DocumentBuilderFactory          .newInstance()          .newDocumentBuilder()          .newDocument();    } catch (ParserConfigurationException pe) {      throw new IOException(pe);    }    Element conf = doc.createElement("configuration");    doc.appendChild(conf);    conf.appendChild(doc.createTextNode("\n"));    handleDeprecation();     if(!Strings.isNullOrEmpty(propertyName)) {      if (!properties.containsKey(propertyName)) {                throw new IllegalArgumentException("Property " +            propertyName + " not found");      } else {                appendXMLProperty(doc, conf, propertyName);        conf.appendChild(doc.createTextNode("\n"));      }    } else {            for (Enumeration<Object> e = properties.keys(); e.hasMoreElements();) {        appendXMLProperty(doc, conf, (String)e.nextElement());        conf.appendChild(doc.createTextNode("\n"));      }    }    return doc;  }    private synchronized void appendXMLProperty(Document doc, Element conf,      String propertyName) {        if (!Strings.isNullOrEmpty(propertyName)) {      String value = properties.getProperty(propertyName);      if (value != null) {        Element propNode = doc.createElement("property");        conf.appendChild(propNode);        Element nameNode = doc.createElement("name");        nameNode.appendChild(doc.createTextNode(propertyName));        propNode.appendChild(nameNode);        Element valueNode = doc.createElement("value");        valueNode.appendChild(doc.createTextNode(            properties.getProperty(propertyName)));        propNode.appendChild(valueNode);        Element finalNode = doc.createElement("final");        finalNode.appendChild(doc.createTextNode(            String.valueOf(finalParameters.contains(propertyName))));        propNode.appendChild(finalNode);        if (updatingResource != null) {          String[] sources = updatingResource.get(propertyName);          if(sources != null) {            for(String s : sources) {              Element sourceNode = doc.createElement("source");              sourceNode.appendChild(doc.createTextNode(s));              propNode.appendChild(sourceNode);            }          }        }      }    }  }    public static void dumpConfiguration(Configuration config,      String propertyName, Writer out) throws IOException {    if(Strings.isNullOrEmpty(propertyName)) {      dumpConfiguration(config, out);    } else if (Strings.isNullOrEmpty(config.get(propertyName))) {      throw new IllegalArgumentException("Property " +          propertyName + " not found");    } else {      JsonFactory dumpFactory = new JsonFactory();      JsonGenerator dumpGenerator = dumpFactory.createGenerator(out);      dumpGenerator.writeStartObject();      dumpGenerator.writeFieldName("property");      appendJSONProperty(dumpGenerator, config, propertyName,          new ConfigRedactor(config));      dumpGenerator.writeEndObject();      dumpGenerator.flush();    }  }    public static void dumpConfiguration(Configuration config,      Writer out) throws IOException {    JsonFactory dumpFactory = new JsonFactory();    JsonGenerator dumpGenerator = dumpFactory.createGenerator(out);    dumpGenerator.writeStartObject();    dumpGenerator.writeFieldName("properties");    dumpGenerator.writeStartArray();    dumpGenerator.flush();    ConfigRedactor redactor = new ConfigRedactor(config);    synchronized (config) {      for (Map.Entry<Object,Object> item: config.getProps().entrySet()) {        appendJSONProperty(dumpGenerator, config, item.getKey().toString(),            redactor);      }    }    dumpGenerator.writeEndArray();    dumpGenerator.writeEndObject();    dumpGenerator.flush();  }    private static void appendJSONProperty(JsonGenerator jsonGen,      Configuration config, String name, ConfigRedactor redactor)      throws IOException {        if(!Strings.isNullOrEmpty(name) && jsonGen != null) {      jsonGen.writeStartObject();      jsonGen.writeStringField("key", name);      jsonGen.writeStringField("value",          redactor.redact(name, config.get(name)));      jsonGen.writeBooleanField("isFinal",          config.finalParameters.contains(name));      String[] resources = config.updatingResource != null ?          config.updatingResource.get(name) : null;      String resource = UNKNOWN_RESOURCE;      if (resources != null && resources.length > 0) {        resource = resources[0];      }      jsonGen.writeStringField("resource", resource);      jsonGen.writeEndObject();    }  }    public ClassLoader getClassLoader() {    return classLoader;  }      public void setClassLoader(ClassLoader classLoader) {    this.classLoader = classLoader;  }    @Override  public String toString() {    StringBuilder sb = new StringBuilder();    sb.append("Configuration: ");    if(loadDefaults) {      toString(defaultResources, sb);      if(resources.size()>0) {        sb.append(", ");      }    }    toString(resources, sb);    return sb.toString();  }    private <T> void toString(List<T> resources, StringBuilder sb) {    ListIterator<T> i = resources.listIterator();    while (i.hasNext()) {      if (i.nextIndex() != 0) {        sb.append(", ");      }      sb.append(i.next());    }  }    public synchronized void setQuietMode(boolean quietmode) {    this.quietmode = quietmode;  }  synchronized boolean getQuietMode() {    return this.quietmode;  }      public static void main(String[] args) throws Exception {    new Configuration().writeXml(System.out);  }  @Override  public void readFields(DataInput in) throws IOException {    clear();    int size = WritableUtils.readVInt(in);    for(int i=0; i < size; ++i) {      String key = org.apache.hadoop.io.Text.readString(in);      String value = org.apache.hadoop.io.Text.readString(in);      set(key, value);       String sources[] = WritableUtils.readCompressedStringArray(in);      if (sources != null) {        putIntoUpdatingResource(key, sources);      }    }  }    @Override  public void write(DataOutput out) throws IOException {    Properties props = getProps();    WritableUtils.writeVInt(out, props.size());    for(Map.Entry<Object, Object> item: props.entrySet()) {      org.apache.hadoop.io.Text.writeString(out, (String) item.getKey());      org.apache.hadoop.io.Text.writeString(out, (String) item.getValue());      WritableUtils.writeCompressedStringArray(out, updatingResource != null ?          updatingResource.get(item.getKey()) : null);    }  }      public Map<String,String> getValByRegex(String regex) {    Pattern p = Pattern.compile(regex);    Map<String,String> result = new HashMap<String,String>();    List<String> resultKeys = new ArrayList<>();    Matcher m;    for(Map.Entry<Object,Object> item: getProps().entrySet()) {      if (item.getKey() instanceof String &&           item.getValue() instanceof String) {        m = p.matcher((String)item.getKey());        if(m.find()) {           resultKeys.add((String) item.getKey());        }      }    }    resultKeys.forEach(item ->            result.put(item, substituteVars(getProps().getProperty(item))));    return result;  }    private static abstract class NegativeCacheSentinel {}  public static void dumpDeprecatedKeys() {    DeprecationContext deprecations = deprecationContext.get();    for (Map.Entry<String, DeprecatedKeyInfo> entry :        deprecations.getDeprecatedKeyMap().entrySet()) {      StringBuilder newKeys = new StringBuilder();      for (String newKey : entry.getValue().newKeys) {        newKeys.append(newKey).append("\t");      }      System.out.println(entry.getKey() + "\t" + newKeys.toString());    }  }    public static boolean hasWarnedDeprecation(String name) {    DeprecationContext deprecations = deprecationContext.get();    if(deprecations.getDeprecatedKeyMap().containsKey(name)) {      if(deprecations.getDeprecatedKeyMap().get(name).accessed.get()) {        return true;      }    }    return false;  }    public Properties getAllPropertiesByTag(final String tag) {    Properties props = new Properties();    if (propertyTagsMap.containsKey(tag)) {      props.putAll(propertyTagsMap.get(tag));    }    return props;  }    public Properties getAllPropertiesByTags(final List<String> tagList) {    Properties prop = new Properties();    for (String tag : tagList) {      prop.putAll(this.getAllPropertiesByTag(tag));    }    return prop;  }    public boolean isPropertyTag(String tagStr) {    return this.TAGS.contains(tagStr);  }  private void putIntoUpdatingResource(String key, String[] value) {    Map<String, String[]> localUR = updatingResource;    if (localUR == null) {      synchronized (this) {        localUR = updatingResource;        if (localUR == null) {          updatingResource = localUR = new ConcurrentHashMap<>(8);        }      }    }    localUR.put(key, value);  }}
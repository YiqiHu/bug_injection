diff --git a/BUILDING.txt b/BUILDING.txt
index d54ce8318384..c96c851204e7 100644
--- a/BUILDING.txt
+++ b/BUILDING.txt
@@ -6,6 +6,7 @@ Requirements:
 * Unix System
 * JDK 1.8
 * Maven 3.3 or later
+* Boost 1.72 (if compiling native code)
 * Protocol Buffers 3.7.1 (if compiling native code)
 * CMake 3.1 or newer (if compiling native code)
 * Zlib devel (if compiling native code)
@@ -72,6 +73,12 @@ Installing required packages for clean install of Ubuntu 14.04 LTS Desktop:
         && ./configure\
         && make install \
         && rm -rf /opt/protobuf-3.7-src
+* Boost
+  $ curl -L https://sourceforge.net/projects/boost/files/boost/1.72.0/boost_1_72_0.tar.bz2/download > boost_1_72_0.tar.bz2 \
+    && tar --bzip2 -xf boost_1_72_0.tar.bz2 \
+    && cd boost_1_72_0 \
+    && ./bootstrap.sh --prefix=/usr/ \
+    && ./b2 --without-python install
 
 Optional packages:
 
@@ -468,6 +475,7 @@ Requirements:
 * Windows System
 * JDK 1.8
 * Maven 3.0 or later
+* Boost 1.72
 * Protocol Buffers 3.7.1
 * CMake 3.1 or newer
 * Visual Studio 2010 Professional or Higher
diff --git a/dev-support/docker/Dockerfile b/dev-support/docker/Dockerfile
index fd2d2938419c..f72fa4659009 100644
--- a/dev-support/docker/Dockerfile
+++ b/dev-support/docker/Dockerfile
@@ -92,6 +92,21 @@ ENV MAVEN_HOME /usr
 ENV JAVA_HOME /usr/lib/jvm/java-8-openjdk-amd64
 ENV FINDBUGS_HOME /usr
 
+#######
+# Install Boost 1.72 (1.65 ships with Bionic)
+#######
+# hadolint ignore=DL3003
+RUN mkdir -p /opt/boost-library \
+    && curl -L https://sourceforge.net/projects/boost/files/boost/1.72.0/boost_1_72_0.tar.bz2/download > boost_1_72_0.tar.bz2 \
+    && mv boost_1_72_0.tar.bz2 /opt/boost-library \
+    && cd /opt/boost-library \
+    && tar --bzip2 -xf boost_1_72_0.tar.bz2 \
+    && cd /opt/boost-library/boost_1_72_0 \
+    && ./bootstrap.sh --prefix=/usr/ \
+    && ./b2 --without-python install \
+    && cd /root \
+    && rm -rf /opt/boost-library
+
 ######
 # Install Google Protobuf 3.7.1 (3.0.0 ships with Bionic)
 ######
diff --git a/dev-support/docker/Dockerfile_aarch64 b/dev-support/docker/Dockerfile_aarch64
index ccc517dbf9fd..5fd646fb9c08 100644
--- a/dev-support/docker/Dockerfile_aarch64
+++ b/dev-support/docker/Dockerfile_aarch64
@@ -95,6 +95,21 @@ ENV MAVEN_HOME /usr
 ENV JAVA_HOME /usr/lib/jvm/java-8-openjdk-arm64
 ENV FINDBUGS_HOME /usr
 
+#######
+# Install Boost 1.72 (1.65 ships with Bionic)
+#######
+# hadolint ignore=DL3003
+RUN mkdir -p /opt/boost-library \
+    && curl -L https://sourceforge.net/projects/boost/files/boost/1.72.0/boost_1_72_0.tar.bz2/download > boost_1_72_0.tar.bz2 \
+    && mv boost_1_72_0.tar.bz2 /opt/boost-library \
+    && cd /opt/boost-library \
+    && tar --bzip2 -xf boost_1_72_0.tar.bz2 \
+    && cd /opt/boost-library/boost_1_72_0 \
+    && ./bootstrap.sh --prefix=/usr/ \
+    && ./b2 --without-python install \
+    && cd /root \
+    && rm -rf /opt/boost-library
+
 ######
 # Install Google Protobuf 3.7.1 (3.0.0 ships with Bionic)
 ######
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/CMakeLists.txt b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/CMakeLists.txt
index 626c49bf192c..6e233fd3991d 100644
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/CMakeLists.txt
+++ b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/CMakeLists.txt
@@ -18,6 +18,8 @@
 
 cmake_minimum_required(VERSION 3.1 FATAL_ERROR)
 
+project(hadoop_hdfs_native_client)
+
 enable_testing()
 
 list(APPEND CMAKE_MODULE_PATH ${CMAKE_SOURCE_DIR}/../../../hadoop-common-project/hadoop-common)
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/CMakeLists.txt b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/CMakeLists.txt
index 411320ad771e..6a2f378d0a4b 100644
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/CMakeLists.txt
+++ b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/CMakeLists.txt
@@ -28,6 +28,8 @@ project (libhdfspp)
 
 cmake_minimum_required(VERSION 2.8)
 
+find_package (Boost 1.72.0 REQUIRED)
+
 enable_testing()
 include (CTest)
 
@@ -220,7 +222,7 @@ include_directories(
 
 include_directories( SYSTEM
   ${PROJECT_BINARY_DIR}/lib/proto
-  third_party/asio-1.10.2/include
+  ${Boost_INCLUDE_DIRS}
   third_party/rapidxml-1.13
   third_party/gmock-1.7.0
   third_party/tr2
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/include/hdfspp/ioservice.h b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/include/hdfspp/ioservice.h
index a6ec97ad4913..b0bac5dd7ece 100644
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/include/hdfspp/ioservice.h
+++ b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/include/hdfspp/ioservice.h
@@ -61,10 +61,7 @@
 #include <functional>
 #include <memory>
 
-// forward decl
-namespace asio {
-  class io_service;
-}
+#include <boost/asio/io_service.hpp>
 
 namespace hdfs {
 
@@ -133,7 +130,7 @@ class IoService : public std::enable_shared_from_this<IoService>
    * Access underlying io_service object.  Only to be used in asio library calls.
    * After HDFS-11884 is complete only tests should need direct access to the asio::io_service.
    **/
-  virtual asio::io_service& GetRaw() = 0;
+  virtual boost::asio::io_service& GetRaw() = 0;
 };
 
 
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/common/CMakeLists.txt b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/common/CMakeLists.txt
index 1ab04d36689c..87779e7f8ae8 100644
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/common/CMakeLists.txt
+++ b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/common/CMakeLists.txt
@@ -19,6 +19,7 @@ if(NEED_LINK_DL)
    set(LIB_DL dl)
 endif()
 
+include_directories(${Boost_INCLUDE_DIRS} ../../include)
 add_library(common_obj OBJECT status.cc sasl_digest_md5.cc ioservice_impl.cc options.cc configuration.cc configuration_loader.cc hdfs_configuration.cc uri.cc util.cc retry_policy.cc cancel_tracker.cc logging.cc libhdfs_events_impl.cc auth_info.cc namenode_info.cc statinfo.cc fsinfo.cc content_summary.cc locks.cc config_parser.cc)
 add_library(common $<TARGET_OBJECTS:common_obj> $<TARGET_OBJECTS:uriparser2_obj>)
 target_link_libraries(common ${LIB_DL})
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/common/async_stream.h b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/common/async_stream.h
index efe2e1c5db37..e9779e7558be 100644
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/common/async_stream.h
+++ b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/common/async_stream.h
@@ -19,15 +19,17 @@
 #ifndef LIB_COMMON_ASYNC_STREAM_H_
 #define LIB_COMMON_ASYNC_STREAM_H_
 
-#include <asio/buffer.hpp>
-#include <asio/error_code.hpp>
+#include <boost/asio/buffer.hpp>
+#include <boost/system/error_code.hpp>
+#include <boost/asio/system_executor.hpp>
+
 #include <functional>
 
 namespace hdfs {
 
 // Contiguous buffer types
-typedef asio::mutable_buffers_1 MutableBuffer;
-typedef asio::const_buffers_1   ConstBuffer;
+typedef boost::asio::mutable_buffers_1 MutableBuffer;
+typedef boost::asio::const_buffers_1   ConstBuffer;
 
 /*
  * asio-compatible stream implementation.
@@ -38,13 +40,20 @@ typedef asio::const_buffers_1   ConstBuffer;
  */
 class AsyncStream  {
 public:
+  using executor_type = boost::asio::system_executor;
+  executor_type executor_;
+
   virtual void async_read_some(const MutableBuffer &buf,
-          std::function<void (const asio::error_code & error,
+          std::function<void (const boost::system::error_code & error,
                                  std::size_t bytes_transferred) > handler) = 0;
 
   virtual void async_write_some(const ConstBuffer &buf,
-            std::function<void (const asio::error_code & error,
+            std::function<void (const boost::system::error_code & error,
                                  std::size_t bytes_transferred) > handler) = 0;
+
+  executor_type get_executor() {
+      return executor_;
+  }
 };
 
 }
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/common/continuation/asio.h b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/common/continuation/asio.h
index 0215176e6d46..f2a3722ec182 100644
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/common/continuation/asio.h
+++ b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/common/continuation/asio.h
@@ -21,7 +21,10 @@
 #include "continuation.h"
 #include "common/util.h"
 #include "hdfspp/status.h"
-#include <asio/write.hpp>
+
+#include <boost/asio/write.hpp>
+#include <boost/system/error_code.hpp>
+
 #include <memory>
 
 namespace hdfs {
@@ -37,8 +40,8 @@ class WriteContinuation : public Continuation {
 
   virtual void Run(const Next &next) override {
     auto handler =
-        [next](const asio::error_code &ec, size_t) { next(ToStatus(ec)); };
-    asio::async_write(*stream_, buffer_, handler);
+        [next](const boost::system::error_code &ec, size_t) { next(ToStatus(ec)); };
+    boost::asio::async_write(*stream_, buffer_, handler);
   }
 
 private:
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/common/continuation/protobuf.h b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/common/continuation/protobuf.h
index 21e063ed0e08..e5be85a5005b 100644
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/common/continuation/protobuf.h
+++ b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/common/continuation/protobuf.h
@@ -20,8 +20,10 @@
 
 #include "common/util.h"
 
-#include <asio/read.hpp>
-
+#include <boost/asio/read.hpp>
+#include <boost/asio/write.hpp>
+#include <boost/asio/buffer.hpp>
+#include <boost/system/error_code.hpp>
 #include <google/protobuf/message_lite.h>
 #include <google/protobuf/io/coded_stream.h>
 #include <google/protobuf/io/zero_copy_stream_impl_lite.h>
@@ -39,7 +41,7 @@ struct ReadDelimitedPBMessageContinuation : public Continuation {
 
   virtual void Run(const Next &next) override {
     namespace pbio = google::protobuf::io;
-    auto handler = [this, next](const asio::error_code &ec, size_t) {
+    auto handler = [this, next](const boost::system::error_code &ec, size_t) {
       Status status;
       if (ec) {
         status = ToStatus(ec);
@@ -57,15 +59,15 @@ struct ReadDelimitedPBMessageContinuation : public Continuation {
       }
       next(status);
     };
-    asio::async_read(*stream_,
-        asio::buffer(buf_),
+    boost::asio::async_read(*stream_,
+        boost::asio::buffer(buf_),
         std::bind(&ReadDelimitedPBMessageContinuation::CompletionHandler, this,
                   std::placeholders::_1, std::placeholders::_2),
         handler);
   }
 
 private:
-  size_t CompletionHandler(const asio::error_code &ec, size_t transferred) {
+  size_t CompletionHandler(const boost::system::error_code &ec, size_t transferred) {
     if (ec) {
       return 0;
     }
@@ -103,7 +105,7 @@ struct WriteDelimitedPBMessageContinuation : Continuation {
       return;
     }
 
-    asio::async_write(*stream_, asio::buffer(buf_), [next](const asio::error_code &ec, size_t) { next(ToStatus(ec)); } );
+    boost::asio::async_write(*stream_, boost::asio::buffer(buf_), [next](const boost::system::error_code &ec, size_t) { next(ToStatus(ec)); } );
   }
 
 private:
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/common/fsinfo.cc b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/common/fsinfo.cc
index 9f350a8f2cc7..f8f592383271 100644
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/common/fsinfo.cc
+++ b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/common/fsinfo.cc
@@ -17,6 +17,8 @@
  */
 
 #include <hdfspp/fsinfo.h>
+
+#include <algorithm>
 #include <sstream>
 #include <iomanip>
 
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/common/ioservice_impl.cc b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/common/ioservice_impl.cc
index de081ed148f5..17a4474a4331 100644
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/common/ioservice_impl.cc
+++ b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/common/ioservice_impl.cc
@@ -125,7 +125,7 @@ void IoServiceImpl::Run() {
   // from escaping this library and crashing the process.
 
   // As recommended in http://www.boost.org/doc/libs/1_39_0/doc/html/boost_asio/reference/io_service.html#boost_asio.reference.io_service.effect_of_exceptions_thrown_from_handlers
-  asio::io_service::work work(io_service_);
+  boost::asio::io_service::work work(io_service_);
   while(true)
   {
     try
@@ -145,7 +145,7 @@ void IoServiceImpl::Stop() {
   io_service_.stop();
 }
 
-asio::io_service& IoServiceImpl::GetRaw() {
+boost::asio::io_service& IoServiceImpl::GetRaw() {
   return io_service_;
 }
 
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/common/ioservice_impl.h b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/common/ioservice_impl.h
index a29985cf88a8..2d627aabf23f 100644
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/common/ioservice_impl.h
+++ b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/common/ioservice_impl.h
@@ -21,7 +21,7 @@
 
 #include "hdfspp/ioservice.h"
 
-#include <asio/io_service.hpp>
+#include <boost/asio/io_service.hpp>
 #include "common/new_delete.h"
 
 #include <mutex>
@@ -45,7 +45,7 @@ class IoServiceImpl : public IoService {
   void PostTask(std::function<void(void)> asyncTask) override;
   void Run() override;
   void Stop() override;
-  asio::io_service& GetRaw() override;
+  boost::asio::io_service& GetRaw() override;
 
   // Add a single worker thread, in the common case try to avoid this in favor
   // of Init[Default]Workers. Public for use by tests and rare cases where a
@@ -57,7 +57,7 @@ class IoServiceImpl : public IoService {
 
  private:
   std::mutex state_lock_;
-  ::asio::io_service io_service_;
+  boost::asio::io_service io_service_;
 
   // For doing logging + resource manager updates on thread start/exit
   void ThreadStartHook();
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/common/logging.cc b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/common/logging.cc
index 94bce83fd1e9..54048fb1201b 100644
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/common/logging.cc
+++ b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/common/logging.cc
@@ -136,7 +136,7 @@ LogMessage& LogMessage::operator<<(const std::string& str) {
   return *this;
 }
 
-LogMessage& LogMessage::operator<<(const ::asio::ip::tcp::endpoint& endpoint) {
+LogMessage& LogMessage::operator<<(const boost::asio::ip::tcp::endpoint& endpoint) {
   msg_buffer_ << endpoint;
   return *this;
 }
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/common/logging.h b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/common/logging.h
index 4e66a9306177..8935287fe010 100644
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/common/logging.h
+++ b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/common/logging.h
@@ -19,7 +19,7 @@
 #ifndef LIB_COMMON_LOGGING_H_
 #define LIB_COMMON_LOGGING_H_
 
-#include <asio/ip/tcp.hpp>
+#include <boost/asio/ip/tcp.hpp>
 
 #include "hdfspp/log.h"
 
@@ -193,7 +193,7 @@ class LogMessage {
   LogMessage& operator<<(void *);
 
   //asio types
-  LogMessage& operator<<(const ::asio::ip::tcp::endpoint& endpoint);
+  LogMessage& operator<<(const boost::asio::ip::tcp::endpoint& endpoint);
 
   //thread and mutex types
   LogMessage& operator<<(const std::thread::id& tid);
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/common/namenode_info.cc b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/common/namenode_info.cc
index a04daf1a8b7f..92054fce07e3 100644
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/common/namenode_info.cc
+++ b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/common/namenode_info.cc
@@ -70,7 +70,7 @@ bool ResolveInPlace(std::shared_ptr<IoService> ioservice, ResolvedNamenodeInfo &
   return true;
 }
 
-typedef std::vector<asio::ip::tcp::endpoint> endpoint_vector;
+typedef std::vector<boost::asio::ip::tcp::endpoint> endpoint_vector;
 
 // RAII wrapper
 class ScopedResolver {
@@ -78,8 +78,8 @@ class ScopedResolver {
   std::shared_ptr<IoService> io_service_;
   std::string host_;
   std::string port_;
-  ::asio::ip::tcp::resolver::query query_;
-  ::asio::ip::tcp::resolver resolver_;
+  boost::asio::ip::tcp::resolver::query query_;
+  boost::asio::ip::tcp::resolver resolver_;
   endpoint_vector endpoints_;
 
   // Caller blocks on access if resolution isn't finished
@@ -111,9 +111,9 @@ class ScopedResolver {
     std::shared_ptr<std::promise<Status>> shared_result = result_status_;
 
     // Callback to pull a copy of endpoints out of resolver and set promise
-    auto callback = [this, shared_result](const asio::error_code &ec, ::asio::ip::tcp::resolver::iterator out) {
+    auto callback = [this, shared_result](const boost::system::error_code &ec, boost::asio::ip::tcp::resolver::iterator out) {
       if(!ec) {
-        std::copy(out, ::asio::ip::tcp::resolver::iterator(), std::back_inserter(endpoints_));
+        std::copy(out, boost::asio::ip::tcp::resolver::iterator(), std::back_inserter(endpoints_));
       }
       shared_result->set_value( ToStatus(ec) );
     };
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/common/namenode_info.h b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/common/namenode_info.h
index f43690dcf63b..0532376e8c75 100644
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/common/namenode_info.h
+++ b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/common/namenode_info.h
@@ -19,7 +19,7 @@
 #ifndef COMMON_HDFS_NAMENODE_INFO_H_
 #define COMMON_HDFS_NAMENODE_INFO_H_
 
-#include <asio.hpp>
+#include <boost/asio/ip/tcp.hpp>
 
 #include <hdfspp/options.h>
 
@@ -37,7 +37,7 @@ struct ResolvedNamenodeInfo : public NamenodeInfo {
   ResolvedNamenodeInfo& operator=(const NamenodeInfo &info);
   std::string str() const;
 
-  std::vector<::asio::ip::tcp::endpoint> endpoints;
+  std::vector<boost::asio::ip::tcp::endpoint> endpoints;
 };
 
 // Clear endpoints if set and resolve all of them in parallel.
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/common/retry_policy.cc b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/common/retry_policy.cc
index dca49fb66212..eb64829601b5 100644
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/common/retry_policy.cc
+++ b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/common/retry_policy.cc
@@ -19,6 +19,8 @@
 #include "common/retry_policy.h"
 #include "common/logging.h"
 
+#include <boost/asio/error.hpp>
+
 #include <sstream>
 
 namespace hdfs {
@@ -57,7 +59,7 @@ RetryAction FixedDelayWithFailover::ShouldRetry(const Status &s, uint64_t retrie
   (void)max_failover_conn_retries_;
   LOG_TRACE(kRPC, << "FixedDelayWithFailover::ShouldRetry(retries=" << retries << ", failovers=" << failovers << ")");
 
-  if(failovers < max_failover_retries_ && (s.code() == ::asio::error::timed_out || s.get_server_exception_type() == Status::kStandbyException) )
+  if(failovers < max_failover_retries_ && (s.code() == boost::asio::error::timed_out || s.get_server_exception_type() == Status::kStandbyException) )
   {
     // Try connecting to another NN in case this one keeps timing out
     // Can add the backoff wait specified by dfs.client.failover.sleep.base.millis here
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/common/util.cc b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/common/util.cc
index 6a0798737b7d..7a4b4cf33efe 100644
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/common/util.cc
+++ b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/common/util.cc
@@ -30,7 +30,7 @@
 
 namespace hdfs {
 
-Status ToStatus(const ::asio::error_code &ec) {
+Status ToStatus(const boost::system::error_code &ec) {
   if (ec) {
     return Status(ec.value(), ec.message().c_str());
   } else {
@@ -134,7 +134,7 @@ std::string Base64Encode(const std::string &src) {
 }
 
 
-std::string SafeDisconnect(asio::ip::tcp::socket *sock) {
+std::string SafeDisconnect(boost::asio::ip::tcp::socket *sock) {
   std::string err;
   if(sock && sock->is_open()) {
     /**
@@ -147,7 +147,7 @@ std::string SafeDisconnect(asio::ip::tcp::socket *sock) {
      **/
 
     try {
-      sock->shutdown(asio::ip::tcp::socket::shutdown_both);
+      sock->shutdown(boost::asio::ip::tcp::socket::shutdown_both);
     } catch (const std::exception &e) {
       err = std::string("shutdown() threw") + e.what();
     }
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/common/util.h b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/common/util.h
index 590ba5453b6e..a7f4f958e79d 100644
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/common/util.h
+++ b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/common/util.h
@@ -24,7 +24,8 @@
 #include <mutex>
 #include <string>
 
-#include <asio/error_code.hpp>
+#include <boost/asio/ip/tcp.hpp>
+#include <boost/system/error_code.hpp>
 #include <openssl/rand.h>
 #include <google/protobuf/io/coded_stream.h>
 
@@ -41,7 +42,7 @@ namespace hdfs {
 typedef std::lock_guard<std::mutex> mutex_guard;
 
 
-Status ToStatus(const ::asio::error_code &ec);
+Status ToStatus(const boost::system::error_code &ec);
 
 // Determine size of buffer that needs to be allocated in order to serialize msg
 // in delimited format
@@ -75,7 +76,7 @@ bool lock_held(T & mutex) {
 // Shutdown and close a socket safely; will check if the socket is open and
 // catch anything thrown by asio.
 // Returns a string containing error message on failure, otherwise an empty string.
-std::string SafeDisconnect(asio::ip::tcp::socket *sock);
+std::string SafeDisconnect(boost::asio::ip::tcp::socket *sock);
 
 
 // The following helper function is used for classes that look like the following:
@@ -94,13 +95,13 @@ std::string SafeDisconnect(asio::ip::tcp::socket *sock);
 // it's a asio socket, and nullptr if it's anything else.
 
 template <typename sock_t>
-inline asio::ip::tcp::socket *get_asio_socket_ptr(sock_t *s) {
+inline boost::asio::ip::tcp::socket *get_asio_socket_ptr(sock_t *s) {
   (void)s;
   return nullptr;
 }
 template<>
-inline asio::ip::tcp::socket *get_asio_socket_ptr<asio::ip::tcp::socket>
-                                            (asio::ip::tcp::socket *s) {
+inline boost::asio::ip::tcp::socket *get_asio_socket_ptr<boost::asio::ip::tcp::socket>
+                                            (boost::asio::ip::tcp::socket *s) {
   return s;
 }
 
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/connection/datanodeconnection.cc b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/connection/datanodeconnection.cc
index 41424827821e..61df6d76d99d 100644
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/connection/datanodeconnection.cc
+++ b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/connection/datanodeconnection.cc
@@ -19,6 +19,8 @@
 #include "datanodeconnection.h"
 #include "common/util.h"
 
+#include <boost/asio/connect.hpp>
+
 namespace hdfs {
 
 DataNodeConnection::~DataNodeConnection(){}
@@ -29,7 +31,7 @@ DataNodeConnectionImpl::DataNodeConnectionImpl(std::shared_ptr<IoService> io_ser
                                                const hadoop::common::TokenProto *token,
                                                LibhdfsEvents *event_handlers) : event_handlers_(event_handlers)
 {
-  using namespace ::asio::ip;
+  using namespace boost::asio::ip;
 
   conn_.reset(new tcp::socket(io_service->GetRaw()));
   auto datanode_addr = dn_proto.id();
@@ -49,8 +51,8 @@ void DataNodeConnectionImpl::Connect(
   // Keep the DN from being freed until we're done
   mutex_guard state_lock(state_lock_);
   auto shared_this = shared_from_this();
-  asio::async_connect(*conn_, endpoints_.begin(), endpoints_.end(),
-          [shared_this, handler](const asio::error_code &ec, std::array<asio::ip::tcp::endpoint, 1>::iterator it) {
+  boost::asio::async_connect(*conn_, endpoints_.begin(), endpoints_.end(),
+          [shared_this, handler](const boost::system::error_code &ec, std::array<boost::asio::ip::tcp::endpoint, 1>::iterator it) {
             (void)it;
             handler(ToStatus(ec), shared_this); });
 }
@@ -69,7 +71,7 @@ void DataNodeConnectionImpl::Cancel() {
 }
 
 void DataNodeConnectionImpl::async_read_some(const MutableBuffer &buf,
-             std::function<void (const asio::error_code & error, std::size_t bytes_transferred) > handler)
+             std::function<void (const boost::system::error_code & error, std::size_t bytes_transferred) > handler)
 {
   event_handlers_->call("DN_read_req", "", "", buf.end() - buf.begin());
 
@@ -78,7 +80,7 @@ void DataNodeConnectionImpl::async_read_some(const MutableBuffer &buf,
 }
 
 void DataNodeConnectionImpl::async_write_some(const ConstBuffer &buf,
-             std::function<void (const asio::error_code & error, std::size_t bytes_transferred) > handler)
+             std::function<void (const boost::system::error_code & error, std::size_t bytes_transferred) > handler)
 {
   event_handlers_->call("DN_write_req", "", "", buf.end() - buf.begin());
 
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/connection/datanodeconnection.h b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/connection/datanodeconnection.h
index a54338f17b6b..a0cb8375a868 100644
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/connection/datanodeconnection.h
+++ b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/connection/datanodeconnection.h
@@ -26,7 +26,8 @@
 #include "common/util.h"
 #include "common/new_delete.h"
 
-#include "asio.hpp"
+#include <boost/asio/ip/tcp.hpp>
+#include <boost/system/error_code.hpp>
 
 namespace hdfs {
 
@@ -43,7 +44,7 @@ class DataNodeConnection : public AsyncStream {
 
 
 struct SocketDeleter {
-  inline void operator()(asio::ip::tcp::socket *sock) {
+inline void operator()(boost::asio::ip::tcp::socket* sock) {
     // Cancel may have already closed the socket.
     std::string err = SafeDisconnect(sock);
     if(!err.empty()) {
@@ -59,8 +60,8 @@ class DataNodeConnectionImpl : public DataNodeConnection, public std::enable_sha
   std::mutex state_lock_;
 public:
   MEMCHECKED_CLASS(DataNodeConnectionImpl)
-  std::unique_ptr<asio::ip::tcp::socket, SocketDeleter> conn_;
-  std::array<asio::ip::tcp::endpoint, 1> endpoints_;
+  std::unique_ptr<boost::asio::ip::tcp::socket, SocketDeleter> conn_;
+  std::array<boost::asio::ip::tcp::endpoint, 1> endpoints_;
   std::string uuid_;
   LibhdfsEvents *event_handlers_;
 
@@ -74,10 +75,10 @@ class DataNodeConnectionImpl : public DataNodeConnection, public std::enable_sha
   void Cancel() override;
 
   void async_read_some(const MutableBuffer &buf,
-                       std::function<void (const asio::error_code & error, std::size_t bytes_transferred) > handler) override;
+                       std::function<void (const boost::system::error_code & error, std::size_t bytes_transferred) > handler) override;
 
   void async_write_some(const ConstBuffer &buf,
-                        std::function<void (const asio::error_code & error, std::size_t bytes_transferred) > handler) override;
+                        std::function<void (const boost::system::error_code & error, std::size_t bytes_transferred) > handler) override;
 };
 
 }
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/fs/filehandle.cc b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/fs/filehandle.cc
index 02630fb247a6..169def364b73 100644
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/fs/filehandle.cc
+++ b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/fs/filehandle.cc
@@ -26,6 +26,8 @@
 #include <future>
 #include <tuple>
 
+#include <boost/asio/buffer.hpp>
+
 #define FMT_THIS_ADDR "this=" << (void*)this
 
 namespace hdfs {
@@ -72,7 +74,7 @@ void FileHandleImpl::PositionRead(
     handler(status, bytes_read);
   };
 
-  AsyncPreadSome(offset, asio::buffer(buf, buf_size), bad_node_tracker_, callback);
+  AsyncPreadSome(offset, boost::asio::buffer(buf, buf_size), bad_node_tracker_, callback);
 }
 
 Status FileHandleImpl::PositionRead(void *buf, size_t buf_size, off_t offset, size_t *bytes_read) {
@@ -233,7 +235,7 @@ void FileHandleImpl::AsyncPreadSome(
 
   uint64_t offset_within_block = offset - block->offset();
   uint64_t size_within_block = std::min<uint64_t>(
-      block->b().numbytes() - offset_within_block, asio::buffer_size(buffer));
+      block->b().numbytes() - offset_within_block, boost::asio::buffer_size(buffer));
 
   LOG_DEBUG(kFileHandle, << "FileHandleImpl::AsyncPreadSome("
             << FMT_THIS_ADDR << "), ...) Datanode hostname=" << dnHostName << ", IP Address=" << dnIpAddr
@@ -281,7 +283,7 @@ void FileHandleImpl::AsyncPreadSome(
     if (status.ok()) {
       reader->AsyncReadBlock(
           client_name, *block, offset_within_block,
-          asio::buffer(buffer, size_within_block), read_handler);
+          boost::asio::buffer(buffer, size_within_block), read_handler);
     } else {
       handler(status, dn_id, 0);
     }
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/fs/filesystem.cc b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/fs/filesystem.cc
index 41cc645be5a2..ba75e86eec78 100644
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/fs/filesystem.cc
+++ b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/fs/filesystem.cc
@@ -29,6 +29,8 @@
 #include <pwd.h>
 #include <fnmatch.h>
 
+#include <boost/asio/ip/tcp.hpp>
+
 #define FMT_THIS_ADDR "this=" << (void*)this
 
 namespace hdfs {
@@ -36,7 +38,7 @@ namespace hdfs {
 static const char kNamenodeProtocol[] = "org.apache.hadoop.hdfs.protocol.ClientProtocol";
 static const int kNamenodeProtocolVersion = 1;
 
-using ::asio::ip::tcp;
+using boost::asio::ip::tcp;
 
 static constexpr uint16_t kDefaultPort = 8020;
 
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/fs/namenode_operations.cc b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/fs/namenode_operations.cc
index e46faad12743..96744e5d03d2 100644
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/fs/namenode_operations.cc
+++ b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/fs/namenode_operations.cc
@@ -19,7 +19,7 @@
 #include "filesystem.h"
 #include "common/continuation/asio.h"
 
-#include <asio/ip/tcp.hpp>
+#include <boost/asio/ip/tcp.hpp>
 
 #include <functional>
 #include <limits>
@@ -31,7 +31,7 @@
 
 #define FMT_THIS_ADDR "this=" << (void*)this
 
-using ::asio::ip::tcp;
+using boost::asio::ip::tcp;
 
 namespace hdfs {
 
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/reader/block_reader.cc b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/reader/block_reader.cc
index 90c02f71c1d5..acecfce52374 100644
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/reader/block_reader.cc
+++ b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/reader/block_reader.cc
@@ -24,6 +24,10 @@
 
 #include <future>
 
+#include <boost/asio/buffer.hpp>
+#include <boost/asio/read.hpp>
+#include <boost/asio/completion_condition.hpp>
+
 namespace hdfs {
 
 #define FMT_CONT_AND_PARENT_ADDR "this=" << (void*)this << ", parent=" << (void*)parent_
@@ -113,7 +117,7 @@ void BlockReaderImpl::AsyncRequestBlock(const std::string &client_name,
   auto read_pb_message =
       new continuation::ReadDelimitedPBMessageContinuation<AsyncStream, 16384>(dn_, &s->response);
 
-  m->Push(asio_continuation::Write(dn_, asio::buffer(s->header))).Push(read_pb_message);
+  m->Push(asio_continuation::Write(dn_, boost::asio::buffer(s->header))).Push(read_pb_message);
 
   m->Run([this, handler, offset](const Status &status, const State &s) {    Status stat = status;
     if (stat.ok()) {
@@ -167,7 +171,7 @@ struct BlockReaderImpl::ReadPacketHeader : continuation::Continuation
 
     parent_->packet_data_read_bytes_ = 0;
     parent_->packet_len_ = 0;
-    auto handler = [next, this](const asio::error_code &ec, size_t) {
+    auto handler = [next, this](const boost::system::error_code &ec, size_t) {
       Status status;
       if (ec) {
         status = Status(ec.value(), ec.message().c_str());
@@ -191,7 +195,7 @@ struct BlockReaderImpl::ReadPacketHeader : continuation::Continuation
       next(status);
     };
 
-    asio::async_read(*parent_->dn_, asio::buffer(buf_),
+    boost::asio::async_read(*parent_->dn_, boost::asio::buffer(buf_),
                      std::bind(&ReadPacketHeader::CompletionHandler, this,
                                std::placeholders::_1, std::placeholders::_2), handler);
   }
@@ -215,7 +219,7 @@ struct BlockReaderImpl::ReadPacketHeader : continuation::Continuation
     return ntohs(*reinterpret_cast<const short *>(&buf_[kHeaderLenOffset]));
   }
 
-  size_t CompletionHandler(const asio::error_code &ec, size_t transferred) {
+  size_t CompletionHandler(const boost::system::error_code &ec, size_t transferred) {
     if (ec) {
       return 0;
     } else if (transferred < kHeaderStart) {
@@ -245,7 +249,7 @@ struct BlockReaderImpl::ReadChecksum : continuation::Continuation
 
     std::shared_ptr<DataNodeConnection> keep_conn_alive_ = shared_conn_;
 
-    auto handler = [parent, next, this, keep_conn_alive_](const asio::error_code &ec, size_t)
+    auto handler = [parent, next, this, keep_conn_alive_](const boost::system::error_code &ec, size_t)
     {
       Status status;
       if (ec) {
@@ -266,7 +270,7 @@ struct BlockReaderImpl::ReadChecksum : continuation::Continuation
 
     parent->checksum_.resize(parent->packet_len_ - sizeof(int) - parent->header_.datalen());
 
-    asio::async_read(*parent->dn_, asio::buffer(parent->checksum_), handler);
+    boost::asio::async_read(*parent->dn_, boost::asio::buffer(parent->checksum_), handler);
   }
 
 private:
@@ -279,8 +283,8 @@ struct BlockReaderImpl::ReadChecksum : continuation::Continuation
 struct BlockReaderImpl::ReadData : continuation::Continuation
 {
   ReadData(BlockReaderImpl *parent, std::shared_ptr<size_t> bytes_transferred,
-        const asio::mutable_buffers_1 &buf) : parent_(parent),
-        bytes_transferred_(bytes_transferred), buf_(buf), shared_conn_(parent->dn_)
+        const boost::asio::mutable_buffers_1 &buf) : parent_(parent),
+                                                     bytes_transferred_(bytes_transferred), buf_(buf), shared_conn_(parent->dn_)
   {
     buf_.begin();
   }
@@ -293,7 +297,7 @@ struct BlockReaderImpl::ReadData : continuation::Continuation
     LOG_TRACE(kBlockReader, << "BlockReaderImpl::ReadData::Run("
                             << FMT_CONT_AND_PARENT_ADDR << ") called");
     auto handler =
-        [next, this](const asio::error_code &ec, size_t transferred) {
+        [next, this](const boost::system::error_code &ec, size_t transferred) {
           Status status;
           if (ec) {
             status = Status(ec.value(), ec.message().c_str());
@@ -320,13 +324,13 @@ struct BlockReaderImpl::ReadData : continuation::Continuation
 
     auto data_len = parent_->header_.datalen() - parent_->packet_data_read_bytes_;
 
-    asio::async_read(*parent_->dn_, buf_, asio::transfer_exactly(data_len), handler);
+    boost::asio::async_read(*parent_->dn_, buf_, boost::asio::transfer_exactly(data_len), handler);
   }
 
 private:
   BlockReaderImpl *parent_;
   std::shared_ptr<size_t> bytes_transferred_;
-  const asio::mutable_buffers_1 buf_;
+  const boost::asio::mutable_buffers_1 buf_;
 
   // Keep DNConnection alive.
   std::shared_ptr<DataNodeConnection> shared_conn_;
@@ -337,7 +341,7 @@ struct BlockReaderImpl::ReadPadding : continuation::Continuation
   ReadPadding(BlockReaderImpl *parent) : parent_(parent),
         padding_(parent->chunk_padding_bytes_),
         bytes_transferred_(std::make_shared<size_t>(0)),
-        read_data_(new ReadData(parent, bytes_transferred_, asio::buffer(padding_))),
+        read_data_(new ReadData(parent, bytes_transferred_, boost::asio::buffer(padding_))),
         shared_conn_(parent->dn_) {}
 
   virtual void Run(const Next &next) override {
@@ -505,7 +509,7 @@ struct BlockReaderImpl::RequestBlockContinuation : continuation::Continuation
 struct BlockReaderImpl::ReadBlockContinuation : continuation::Continuation
 {
   ReadBlockContinuation(BlockReader *reader, MutableBuffer buffer, size_t *transferred)
-      : reader_(reader), buffer_(buffer), buffer_size_(asio::buffer_size(buffer)), transferred_(transferred) {}
+      : reader_(reader), buffer_(buffer), buffer_size_(boost::asio::buffer_size(buffer)), transferred_(transferred) {}
 
   virtual void Run(const Next &next) override {
     LOG_TRACE(kBlockReader, << "BlockReaderImpl::ReadBlockContinuation::Run("
@@ -532,7 +536,7 @@ struct BlockReaderImpl::ReadBlockContinuation : continuation::Continuation
       next_(status);
     } else {
       reader_->AsyncReadPacket(
-          asio::buffer(buffer_ + *transferred_, buffer_size_ - *transferred_),
+          boost::asio::buffer(buffer_ + *transferred_, buffer_size_ - *transferred_),
           std::bind(&ReadBlockContinuation::OnReadData, this, _1, _2));
     }
   }
@@ -551,7 +555,7 @@ void BlockReaderImpl::AsyncReadBlock(
   auto m = continuation::Pipeline<size_t>::Create(cancel_state_);
   size_t * bytesTransferred = &m->state();
 
-  size_t size = asio::buffer_size(buffer);
+  size_t size = boost::asio::buffer_size(buffer);
 
   m->Push(new RequestBlockContinuation(this, client_name, &block.b(), size, offset))
     .Push(new ReadBlockContinuation(this, buffer, bytesTransferred));
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/reader/datatransfer.h b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/reader/datatransfer.h
index ea176532f236..cfa94bea2baf 100644
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/reader/datatransfer.h
+++ b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/reader/datatransfer.h
@@ -21,8 +21,10 @@
 #include "common/sasl_authenticator.h"
 #include "common/async_stream.h"
 #include "connection/datanodeconnection.h"
+
 #include <memory>
 
+#include <boost/system/error_code.hpp>
 
 namespace hdfs {
 
@@ -45,13 +47,13 @@ template <class Stream> class DataTransferSaslStream : public DataNodeConnection
   template <class Handler> void Handshake(const Handler &next);
 
   void async_read_some(const MutableBuffer &buf,
-          std::function<void (const asio::error_code & error,
+          std::function<void (const boost::system::error_code & error,
                                  std::size_t bytes_transferred) > handler) override {
     stream_->async_read_some(buf, handler);
   }
 
   void async_write_some(const ConstBuffer &buf,
-            std::function<void (const asio::error_code & error,
+            std::function<void (const boost::system::error_code & error,
                                  std::size_t bytes_transferred) > handler) override {
     stream_->async_write_some(buf, handler);
   }
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/reader/datatransfer_impl.h b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/reader/datatransfer_impl.h
index 77e618dd7a21..d77685dd45a7 100644
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/reader/datatransfer_impl.h
+++ b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/reader/datatransfer_impl.h
@@ -23,8 +23,8 @@
 #include "common/continuation/asio.h"
 #include "common/continuation/protobuf.h"
 
-#include <asio/read.hpp>
-#include <asio/buffer.hpp>
+#include <boost/asio/read.hpp>
+#include <boost/asio/buffer.hpp>
 
 namespace hdfs {
 
@@ -101,7 +101,7 @@ void DataTransferSaslStream<Stream>::Handshake(const Handler &next) {
   using ::hdfs::continuation::WriteDelimitedPBMessage;
 
   static const int kMagicNumber = htonl(kDataTransferSasl);
-  static const asio::const_buffers_1 kMagicNumberBuffer = asio::buffer(
+  static const boost::asio::const_buffers_1 kMagicNumberBuffer = boost::asio::buffer(
       reinterpret_cast<const char *>(kMagicNumber), sizeof(kMagicNumber));
 
   struct State {
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/rpc/namenode_tracker.cc b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/rpc/namenode_tracker.cc
index 242c6eadcbb3..acb754e738ab 100644
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/rpc/namenode_tracker.cc
+++ b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/rpc/namenode_tracker.cc
@@ -24,7 +24,7 @@
 
 namespace hdfs {
 
-static std::string format_endpoints(const std::vector<::asio::ip::tcp::endpoint> &pts) {
+static std::string format_endpoints(const std::vector<boost::asio::ip::tcp::endpoint> &pts) {
   std::stringstream ss;
   for(unsigned int i=0; i<pts.size(); i++)
     if(i == pts.size() - 1)
@@ -66,7 +66,7 @@ HANamenodeTracker::HANamenodeTracker(const std::vector<ResolvedNamenodeInfo> &se
 
 HANamenodeTracker::~HANamenodeTracker() {}
 
-bool HANamenodeTracker::GetFailoverAndUpdate(const std::vector<::asio::ip::tcp::endpoint>& current_endpoints,
+bool HANamenodeTracker::GetFailoverAndUpdate(const std::vector<boost::asio::ip::tcp::endpoint>& current_endpoints,
                                              ResolvedNamenodeInfo& out)
 {
   mutex_guard swap_lock(swap_lock_);
@@ -117,7 +117,7 @@ bool HANamenodeTracker::GetFailoverAndUpdate(const std::vector<::asio::ip::tcp::
 }
 
 
-bool HANamenodeTracker::IsCurrentActive_locked(const ::asio::ip::tcp::endpoint &ep) const {
+bool HANamenodeTracker::IsCurrentActive_locked(const boost::asio::ip::tcp::endpoint &ep) const {
   for(unsigned int i=0;i<active_info_.endpoints.size();i++) {
     if(ep.address() == active_info_.endpoints[i].address()) {
       if(ep.port() != active_info_.endpoints[i].port())
@@ -128,7 +128,7 @@ bool HANamenodeTracker::IsCurrentActive_locked(const ::asio::ip::tcp::endpoint &
   return false;
 }
 
-bool HANamenodeTracker::IsCurrentStandby_locked(const ::asio::ip::tcp::endpoint &ep) const {
+bool HANamenodeTracker::IsCurrentStandby_locked(const boost::asio::ip::tcp::endpoint &ep) const {
   for(unsigned int i=0;i<standby_info_.endpoints.size();i++) {
     if(ep.address() == standby_info_.endpoints[i].address()) {
       if(ep.port() != standby_info_.endpoints[i].port())
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/rpc/namenode_tracker.h b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/rpc/namenode_tracker.h
index 032b1d98126a..dedfe54c7dd1 100644
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/rpc/namenode_tracker.h
+++ b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/rpc/namenode_tracker.h
@@ -22,7 +22,7 @@
 #include "common/libhdfs_events_impl.h"
 #include "common/namenode_info.h"
 
-#include <asio/ip/tcp.hpp>
+#include <boost/asio/ip/tcp.hpp>
 
 #include <memory>
 #include <mutex>
@@ -52,13 +52,13 @@ class HANamenodeTracker {
   // currently being used.  Swap internal state and set out to other node.
   // Note: This will always mutate internal state.  Use IsCurrentActive/Standby to
   // get info without changing state
-  bool GetFailoverAndUpdate(const std::vector<::asio::ip::tcp::endpoint>& current_endpoints,
+  bool GetFailoverAndUpdate(const std::vector<boost::asio::ip::tcp::endpoint>& current_endpoints,
                             ResolvedNamenodeInfo& out);
 
  private:
   // See if endpoint ep is part of the list of endpoints for the active or standby NN
-  bool IsCurrentActive_locked(const ::asio::ip::tcp::endpoint &ep) const;
-  bool IsCurrentStandby_locked(const ::asio::ip::tcp::endpoint &ep) const;
+  bool IsCurrentActive_locked(const boost::asio::ip::tcp::endpoint &ep) const;
+  bool IsCurrentStandby_locked(const boost::asio::ip::tcp::endpoint &ep) const;
 
   // If HA should be enabled, according to our options and runtime info like # nodes provided
   bool enabled_;
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/rpc/request.h b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/rpc/request.h
index f19554046dcf..0e19fff87b4d 100644
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/rpc/request.h
+++ b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/rpc/request.h
@@ -29,7 +29,7 @@
 #include <google/protobuf/io/coded_stream.h>
 #include <google/protobuf/io/zero_copy_stream_impl_lite.h>
 
-#include <asio/deadline_timer.hpp>
+#include <boost/asio/deadline_timer.hpp>
 
 
 namespace hdfs {
@@ -59,7 +59,7 @@ class Request {
 
   int call_id() const { return call_id_; }
   std::string  method_name() const { return method_name_; }
-  ::asio::deadline_timer &timer() { return timer_; }
+  boost::asio::deadline_timer &timer() { return timer_; }
   int IncrementRetryCount() { return retry_count_++; }
   int IncrementFailoverCount();
   void GetPacket(std::string *res) const;
@@ -75,7 +75,7 @@ class Request {
   const std::string method_name_;
   const int call_id_;
 
-  ::asio::deadline_timer timer_;
+  boost::asio::deadline_timer timer_;
   std::string payload_;
   const Handler handler_;
 
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/rpc/rpc_connection.h b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/rpc/rpc_connection.h
index 9f7b3bbd2424..f599d36ee5c4 100644
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/rpc/rpc_connection.h
+++ b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/rpc/rpc_connection.h
@@ -42,6 +42,8 @@
 #include <deque>
 #include <unordered_map>
 
+#include <boost/asio/ip/tcp.hpp>
+
 namespace hdfs {
 
 typedef const std::function<void(const Status &)> RpcCallback;
@@ -57,10 +59,10 @@ class RpcConnection : public std::enable_shared_from_this<RpcConnection> {
 
   // Note that a single server can have multiple endpoints - especially both
   //   an ipv4 and ipv6 endpoint
-  virtual void Connect(const std::vector<::asio::ip::tcp::endpoint> &server,
+  virtual void Connect(const std::vector<boost::asio::ip::tcp::endpoint> &server,
                        const AuthInfo & auth_info,
                        RpcCallback &handler) = 0;
-  virtual void ConnectAndFlush(const std::vector<::asio::ip::tcp::endpoint> &server) = 0;
+  virtual void ConnectAndFlush(const std::vector<boost::asio::ip::tcp::endpoint> &server) = 0;
   virtual void Disconnect() = 0;
 
   void StartReading();
@@ -110,9 +112,9 @@ class RpcConnection : public std::enable_shared_from_this<RpcConnection> {
   virtual void SendContext(RpcCallback &handler) = 0;
   void ContextComplete(const Status &s);
 
-  virtual void OnSendCompleted(const ::asio::error_code &ec,
+  virtual void OnSendCompleted(const boost::system::error_code &ec,
                                size_t transferred) = 0;
-  virtual void OnRecvCompleted(const ::asio::error_code &ec,
+  virtual void OnRecvCompleted(const boost::system::error_code &ec,
                                size_t transferred) = 0;
   virtual void FlushPendingRequests()=0;      // Synchronously write the next request
 
@@ -133,10 +135,10 @@ class RpcConnection : public std::enable_shared_from_this<RpcConnection> {
 
   Status HandleRpcResponse(std::shared_ptr<Response> response);
   void HandleRpcTimeout(std::shared_ptr<Request> req,
-                        const ::asio::error_code &ec);
+                        const boost::system::error_code &ec);
   void CommsError(const Status &status);
 
-  void ClearAndDisconnect(const ::asio::error_code &ec);
+  void ClearAndDisconnect(const boost::system::error_code &ec);
   std::shared_ptr<Request> RemoveFromRunningQueue(int call_id);
 
   std::weak_ptr<LockFreeRpcEngine> engine_;
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/rpc/rpc_connection_impl.cc b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/rpc/rpc_connection_impl.cc
index 43111eff9499..82fdfeb033d3 100644
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/rpc/rpc_connection_impl.cc
+++ b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/rpc/rpc_connection_impl.cc
@@ -23,6 +23,8 @@
 #include "ProtobufRpcEngine.pb.h"
 #include "IpcConnectionContext.pb.h"
 
+#include <boost/asio/error.hpp>
+
 namespace hdfs {
 
 namespace pb = ::google::protobuf;
@@ -89,7 +91,7 @@ void RpcConnection::StartReading() {
   }
 
   service->PostLambda(
-    [shared_this, this] () { OnRecvCompleted(::asio::error_code(), 0); }
+    [shared_this, this] () { OnRecvCompleted(boost::system::error_code(), 0); }
   );
 }
 
@@ -248,8 +250,8 @@ Status RpcConnection::HandleRpcResponse(std::shared_ptr<Response> response) {
 }
 
 void RpcConnection::HandleRpcTimeout(std::shared_ptr<Request> req,
-                                     const ::asio::error_code &ec) {
-  if (ec.value() == asio::error::operation_aborted) {
+                                     const boost::system::error_code &ec) {
+  if (ec.value() == boost::asio::error::operation_aborted) {
     return;
   }
 
@@ -260,7 +262,7 @@ void RpcConnection::HandleRpcTimeout(std::shared_ptr<Request> req,
     return;
   }
 
-  Status stat = ToStatus(ec ? ec : make_error_code(::asio::error::timed_out));
+  Status stat = ToStatus(ec ? ec : make_error_code(boost::asio::error::timed_out));
 
   r->OnResponseArrived(nullptr, stat);
 }
@@ -469,7 +471,7 @@ void RpcConnection::CommsError(const Status &status) {
   pinnedEngine->AsyncRpcCommsError(status, shared_from_this(), requestsToReturn);
 }
 
-void RpcConnection::ClearAndDisconnect(const ::asio::error_code &ec) {
+void RpcConnection::ClearAndDisconnect(const boost::system::error_code &ec) {
   Disconnect();
   std::vector<std::shared_ptr<Request>> requests;
   std::transform(sent_requests_.begin(), sent_requests_.end(),
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/rpc/rpc_connection_impl.h b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/rpc/rpc_connection_impl.h
index 1dd43af36b0e..884bd64ac642 100644
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/rpc/rpc_connection_impl.h
+++ b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/rpc/rpc_connection_impl.h
@@ -28,9 +28,11 @@
 #include "common/libhdfs_events_impl.h"
 #include "hdfspp/ioservice.h"
 
-#include <asio/connect.hpp>
-#include <asio/read.hpp>
-#include <asio/write.hpp>
+#include <boost/asio/connect.hpp>
+#include <boost/asio/read.hpp>
+#include <boost/asio/write.hpp>
+#include <boost/asio/ip/tcp.hpp>
+#include <boost/date_time/posix_time/posix_time_duration.hpp>
 
 #include <system_error>
 
@@ -44,17 +46,17 @@ class RpcConnectionImpl : public RpcConnection {
   RpcConnectionImpl(std::shared_ptr<RpcEngine> engine);
   virtual ~RpcConnectionImpl() override;
 
-  virtual void Connect(const std::vector<::asio::ip::tcp::endpoint> &server,
+  virtual void Connect(const std::vector<boost::asio::ip::tcp::endpoint> &server,
                        const AuthInfo & auth_info,
                        RpcCallback &handler) override;
   virtual void ConnectAndFlush(
-      const std::vector<::asio::ip::tcp::endpoint> &server) override;
+      const std::vector<boost::asio::ip::tcp::endpoint> &server) override;
   virtual void SendHandshake(RpcCallback &handler) override;
   virtual void SendContext(RpcCallback &handler) override;
   virtual void Disconnect() override;
-  virtual void OnSendCompleted(const ::asio::error_code &ec,
+  virtual void OnSendCompleted(const boost::system::error_code &ec,
                                size_t transferred) override;
-  virtual void OnRecvCompleted(const ::asio::error_code &ec,
+  virtual void OnRecvCompleted(const boost::system::error_code &ec,
                                size_t transferred) override;
   virtual void FlushPendingRequests() override;
 
@@ -65,12 +67,12 @@ class RpcConnectionImpl : public RpcConnection {
 
  private:
   const Options options_;
-  ::asio::ip::tcp::endpoint current_endpoint_;
-  std::vector<::asio::ip::tcp::endpoint> additional_endpoints_;
+  boost::asio::ip::tcp::endpoint current_endpoint_;
+  std::vector<boost::asio::ip::tcp::endpoint> additional_endpoints_;
   Socket socket_;
-  ::asio::deadline_timer connect_timer_;
+  boost::asio::deadline_timer connect_timer_;
 
-  void ConnectComplete(const ::asio::error_code &ec, const ::asio::ip::tcp::endpoint &remote);
+  void ConnectComplete(const boost::system::error_code &ec, const boost::asio::ip::tcp::endpoint &remote);
 };
 
 template <class Socket>
@@ -95,7 +97,7 @@ RpcConnectionImpl<Socket>::~RpcConnectionImpl() {
 
 template <class Socket>
 void RpcConnectionImpl<Socket>::Connect(
-    const std::vector<::asio::ip::tcp::endpoint> &server,
+    const std::vector<boost::asio::ip::tcp::endpoint> &server,
     const AuthInfo & auth_info,
     RpcCallback &handler) {
   LOG_TRACE(kRPC, << "RpcConnectionImpl::Connect called");
@@ -124,7 +126,7 @@ void RpcConnectionImpl<Socket>::Connect(
 
 template <class Socket>
 void RpcConnectionImpl<Socket>::ConnectAndFlush(
-    const std::vector<::asio::ip::tcp::endpoint> &server) {
+    const std::vector<boost::asio::ip::tcp::endpoint> &server) {
 
   LOG_INFO(kRPC, << "ConnectAndFlush called");
   std::lock_guard<std::mutex> state_lock(connection_state_lock_);
@@ -147,29 +149,29 @@ void RpcConnectionImpl<Socket>::ConnectAndFlush(
 
   // Take the first endpoint, but remember the alternatives for later
   additional_endpoints_ = server;
-  ::asio::ip::tcp::endpoint first_endpoint = additional_endpoints_.front();
+  boost::asio::ip::tcp::endpoint first_endpoint = additional_endpoints_.front();
   additional_endpoints_.erase(additional_endpoints_.begin());
   current_endpoint_ = first_endpoint;
 
   auto shared_this = shared_from_this();
-  socket_.async_connect(first_endpoint, [shared_this, this, first_endpoint](const ::asio::error_code &ec) {
+  socket_.async_connect(first_endpoint, [shared_this, this, first_endpoint](const boost::system::error_code &ec) {
     ConnectComplete(ec, first_endpoint);
   });
 
   // Prompt the timer to timeout
   auto weak_this = std::weak_ptr<RpcConnection>(shared_this);
   connect_timer_.expires_from_now(
-        std::chrono::milliseconds(options_.rpc_connect_timeout));
-  connect_timer_.async_wait([shared_this, this, first_endpoint](const ::asio::error_code &ec) {
+        boost::posix_time::milliseconds(options_.rpc_connect_timeout));
+  connect_timer_.async_wait([shared_this, this, first_endpoint](const boost::system::error_code &ec) {
       if (ec)
         ConnectComplete(ec, first_endpoint);
       else
-        ConnectComplete(make_error_code(asio::error::host_unreachable), first_endpoint);
+        ConnectComplete(make_error_code(boost::asio::error::host_unreachable), first_endpoint);
   });
 }
 
 template <class Socket>
-void RpcConnectionImpl<Socket>::ConnectComplete(const ::asio::error_code &ec, const ::asio::ip::tcp::endpoint & remote) {
+void RpcConnectionImpl<Socket>::ConnectComplete(const boost::system::error_code &ec, const boost::asio::ip::tcp::endpoint & remote) {
   auto shared_this = RpcConnectionImpl<Socket>::shared_from_this();
   std::lock_guard<std::mutex> state_lock(connection_state_lock_);
   connect_timer_.cancel();
@@ -211,20 +213,20 @@ void RpcConnectionImpl<Socket>::ConnectComplete(const ::asio::error_code &ec, co
     if (!additional_endpoints_.empty()) {
       // If we have additional endpoints, keep trying until we either run out or
       //    hit one
-      ::asio::ip::tcp::endpoint next_endpoint = additional_endpoints_.front();
+        boost::asio::ip::tcp::endpoint next_endpoint = additional_endpoints_.front();
       additional_endpoints_.erase(additional_endpoints_.begin());
       current_endpoint_ = next_endpoint;
 
-      socket_.async_connect(next_endpoint, [shared_this, this, next_endpoint](const ::asio::error_code &ec) {
+      socket_.async_connect(next_endpoint, [shared_this, this, next_endpoint](const boost::system::error_code &ec) {
         ConnectComplete(ec, next_endpoint);
       });
       connect_timer_.expires_from_now(
-            std::chrono::milliseconds(options_.rpc_connect_timeout));
-      connect_timer_.async_wait([shared_this, this, next_endpoint](const ::asio::error_code &ec) {
+            boost::posix_time::milliseconds(options_.rpc_connect_timeout));
+      connect_timer_.async_wait([shared_this, this, next_endpoint](const boost::system::error_code &ec) {
           if (ec)
             ConnectComplete(ec, next_endpoint);
           else
-            ConnectComplete(make_error_code(asio::error::host_unreachable), next_endpoint);
+            ConnectComplete(make_error_code(boost::asio::error::host_unreachable), next_endpoint);
         });
     } else {
       CommsError(status);
@@ -241,9 +243,9 @@ void RpcConnectionImpl<Socket>::SendHandshake(RpcCallback &handler) {
 
   auto shared_this = shared_from_this();
   auto handshake_packet = PrepareHandshakePacket();
-  ::asio::async_write(socket_, asio::buffer(*handshake_packet),
+  boost::asio::async_write(socket_, boost::asio::buffer(*handshake_packet),
                       [handshake_packet, handler, shared_this, this](
-                          const ::asio::error_code &ec, size_t) {
+                          const boost::system::error_code &ec, size_t) {
                         Status status = ToStatus(ec);
                         handler(status);
                       });
@@ -257,16 +259,16 @@ void RpcConnectionImpl<Socket>::SendContext(RpcCallback &handler) {
 
   auto shared_this = shared_from_this();
   auto context_packet = PrepareContextPacket();
-  ::asio::async_write(socket_, asio::buffer(*context_packet),
+  boost::asio::async_write(socket_, boost::asio::buffer(*context_packet),
                       [context_packet, handler, shared_this, this](
-                          const ::asio::error_code &ec, size_t) {
+                          const boost::system::error_code &ec, size_t) {
                         Status status = ToStatus(ec);
                         handler(status);
                       });
 }
 
 template <class Socket>
-void RpcConnectionImpl<Socket>::OnSendCompleted(const ::asio::error_code &ec,
+void RpcConnectionImpl<Socket>::OnSendCompleted(const boost::system::error_code &ec,
                                                    size_t) {
   using std::placeholders::_1;
   using std::placeholders::_2;
@@ -340,16 +342,16 @@ void RpcConnectionImpl<Socket>::FlushPendingRequests() {
     outgoing_request_ = req;
 
     req->timer().expires_from_now(
-        std::chrono::milliseconds(options_.rpc_timeout));
-    req->timer().async_wait([weak_this, weak_req, this](const ::asio::error_code &ec) {
+        boost::posix_time::milliseconds(options_.rpc_timeout));
+    req->timer().async_wait([weak_this, weak_req, this](const boost::system::error_code &ec) {
         auto timeout_this = weak_this.lock();
         auto timeout_req = weak_req.lock();
         if (timeout_this && timeout_req)
           this->HandleRpcTimeout(timeout_req, ec);
     });
 
-    asio::async_write(socket_, asio::buffer(*payload),
-                      [shared_this, this, payload](const ::asio::error_code &ec,
+    boost::asio::async_write(socket_, boost::asio::buffer(*payload),
+                      [shared_this, this, payload](const boost::system::error_code &ec,
                                                    size_t size) {
                         OnSendCompleted(ec, size);
                       });
@@ -374,13 +376,13 @@ void RpcConnectionImpl<Socket>::FlushPendingRequests() {
 
 
 template <class Socket>
-void RpcConnectionImpl<Socket>::OnRecvCompleted(const ::asio::error_code &original_ec,
+void RpcConnectionImpl<Socket>::OnRecvCompleted(const boost::system::error_code &original_ec,
                                                    size_t) {
   using std::placeholders::_1;
   using std::placeholders::_2;
   std::lock_guard<std::mutex> state_lock(connection_state_lock_);
 
-  ::asio::error_code my_ec(original_ec);
+  boost::system::error_code my_ec(original_ec);
 
   LOG_TRACE(kRPC, << "RpcConnectionImpl::OnRecvCompleted called");
 
@@ -390,7 +392,7 @@ void RpcConnectionImpl<Socket>::OnRecvCompleted(const ::asio::error_code &origin
     event_response event_resp = event_handlers_->call(FS_NN_READ_EVENT, cluster_name_.c_str(), 0);
 #ifndef LIBHDFSPP_SIMULATE_ERROR_DISABLED
     if (event_resp.response_type() == event_response::kTest_Error) {
-      my_ec = std::make_error_code(std::errc::network_down);
+      my_ec = boost::system::error_code(boost::system::errc::errc_t::network_down, boost::system::system_category());
     }
 #endif
   }
@@ -399,7 +401,7 @@ void RpcConnectionImpl<Socket>::OnRecvCompleted(const ::asio::error_code &origin
     case 0:
       // No errors
       break;
-    case asio::error::operation_aborted:
+    case boost::asio::error::operation_aborted:
       // The event loop has been shut down. Ignore the error.
       return;
     default:
@@ -414,20 +416,20 @@ void RpcConnectionImpl<Socket>::OnRecvCompleted(const ::asio::error_code &origin
 
   if (current_response_state_->state_ == Response::kReadLength) {
     current_response_state_->state_ = Response::kReadContent;
-    auto buf = ::asio::buffer(reinterpret_cast<char *>(&current_response_state_->length_),
+    auto buf = boost::asio::buffer(reinterpret_cast<char *>(&current_response_state_->length_),
                               sizeof(current_response_state_->length_));
-    asio::async_read(
+    boost::asio::async_read(
         socket_, buf,
-        [shared_this, this](const ::asio::error_code &ec, size_t size) {
+        [shared_this, this](const boost::system::error_code &ec, size_t size) {
           OnRecvCompleted(ec, size);
         });
   } else if (current_response_state_->state_ == Response::kReadContent) {
     current_response_state_->state_ = Response::kParseResponse;
     current_response_state_->length_ = ntohl(current_response_state_->length_);
     current_response_state_->data_.resize(current_response_state_->length_);
-    asio::async_read(
-        socket_, ::asio::buffer(current_response_state_->data_),
-        [shared_this, this](const ::asio::error_code &ec, size_t size) {
+    boost::asio::async_read(
+        socket_, boost::asio::buffer(current_response_state_->data_),
+        [shared_this, this](const boost::system::error_code &ec, size_t size) {
           OnRecvCompleted(ec, size);
         });
   } else if (current_response_state_->state_ == Response::kParseResponse) {
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/rpc/rpc_engine.cc b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/rpc/rpc_engine.cc
index ad6c9b91364f..06cda962cf9b 100644
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/rpc/rpc_engine.cc
+++ b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/rpc/rpc_engine.cc
@@ -24,6 +24,8 @@
 
 #include <algorithm>
 
+#include <boost/date_time/posix_time/posix_time_duration.hpp>
+
 namespace hdfs {
 
 template <class T>
@@ -171,7 +173,7 @@ std::shared_ptr<RpcConnection> RpcEngine::NewConnection()
 {
   LOG_DEBUG(kRPC, << "RpcEngine::NewConnection called");
 
-  return std::make_shared<RpcConnectionImpl<::asio::ip::tcp::socket>>(shared_from_this());
+  return std::make_shared<RpcConnectionImpl<boost::asio::ip::tcp::socket>>(shared_from_this());
 }
 
 std::shared_ptr<RpcConnection> RpcEngine::InitializeConnection()
@@ -307,8 +309,8 @@ void RpcEngine::RpcCommsError(
       if (head_action->delayMillis > 0) {
         auto weak_conn = std::weak_ptr<RpcConnection>(conn_);
         retry_timer.expires_from_now(
-            std::chrono::milliseconds(head_action->delayMillis));
-        retry_timer.async_wait([this, weak_conn](asio::error_code ec) {
+            boost::posix_time::milliseconds(head_action->delayMillis));
+        retry_timer.async_wait([this, weak_conn](boost::system::error_code ec) {
           auto strong_conn = weak_conn.lock();
           if ( (!ec) && (strong_conn) ) {
             strong_conn->ConnectAndFlush(last_endpoints_);
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/rpc/rpc_engine.h b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/rpc/rpc_engine.h
index 845eaf586878..13e56c5b92fb 100644
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/rpc/rpc_engine.h
+++ b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/lib/rpc/rpc_engine.h
@@ -31,8 +31,8 @@
 
 #include <google/protobuf/message_lite.h>
 
-#include <asio/ip/tcp.hpp>
-#include <asio/deadline_timer.hpp>
+#include <boost/asio/ip/tcp.hpp>
+#include <boost/asio/deadline_timer.hpp>
 
 #include <atomic>
 #include <memory>
@@ -160,7 +160,7 @@ class RpcEngine : public LockFreeRpcEngine, public std::enable_shared_from_this<
   static std::string getRandomClientId();
 
   // Remember all of the last endpoints in case we need to reconnect and retry
-  std::vector<::asio::ip::tcp::endpoint> last_endpoints_;
+  std::vector<boost::asio::ip::tcp::endpoint> last_endpoints_;
 
 private:
   mutable std::shared_ptr<IoService> io_service_;
@@ -173,7 +173,7 @@ class RpcEngine : public LockFreeRpcEngine, public std::enable_shared_from_this<
   AuthInfo auth_info_;
   std::string cluster_name_;
   std::atomic_int call_id_;
-  ::asio::deadline_timer retry_timer;
+  boost::asio::deadline_timer retry_timer;
 
   std::shared_ptr<LibhdfsEvents> event_handlers_;
 
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/tests/CMakeLists.txt b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/tests/CMakeLists.txt
index 59fdbf20a27d..2b2f4f16f167 100644
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/tests/CMakeLists.txt
+++ b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/tests/CMakeLists.txt
@@ -16,6 +16,8 @@
 # limitations under the License.
 #
 
+find_package(Boost REQUIRED COMPONENTS date_time)
+
 # Delegate some functionality to libhdfs, until libhdfspp is complete.
 set (LIBHDFS_SRC_DIR ../../libhdfs)
 set (LIBHDFS_TESTS_DIR ../../libhdfs-tests)
@@ -81,7 +83,7 @@ add_memcheck_test(retry_policy retry_policy_test)
 
 include_directories(${CMAKE_CURRENT_BINARY_DIR})
 add_executable(rpc_engine_test rpc_engine_test.cc ${PROTO_TEST_SRCS} ${PROTO_TEST_HDRS})
-target_link_libraries(rpc_engine_test test_common rpc proto common ${PROTOBUF_LIBRARIES} ${OPENSSL_LIBRARIES} ${SASL_LIBRARIES} gmock_main ${CMAKE_THREAD_LIBS_INIT})
+target_link_libraries(rpc_engine_test test_common rpc proto common ${PROTOBUF_LIBRARIES} ${OPENSSL_LIBRARIES} ${SASL_LIBRARIES} gmock_main ${CMAKE_THREAD_LIBS_INIT} ${Boost_LIBRARIES})
 add_memcheck_test(rpc_engine rpc_engine_test)
 
 add_executable(bad_datanode_test bad_datanode_test.cc)
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/tests/bad_datanode_test.cc b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/tests/bad_datanode_test.cc
index 23de0154f8ab..5417af8f4cf1 100644
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/tests/bad_datanode_test.cc
+++ b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/tests/bad_datanode_test.cc
@@ -25,6 +25,9 @@
 
 #include <gmock/gmock.h>
 
+#include <boost/asio/buffer.hpp>
+#include <boost/asio/error.hpp>
+
 using hadoop::common::TokenProto;
 using hadoop::hdfs::DatanodeInfoProto;
 using hadoop::hdfs::DatanodeIDProto;
@@ -42,7 +45,7 @@ class MockReader : public BlockReader {
 public:
   MOCK_METHOD2(
       AsyncReadPacket,
-      void(const asio::mutable_buffers_1 &,
+      void(const boost::asio::mutable_buffers_1 &,
            const std::function<void(const Status &, size_t transferred)> &));
 
   MOCK_METHOD5(AsyncRequestBlock,
@@ -69,17 +72,17 @@ class MockDNConnection : public DataNodeConnection, public std::enable_shared_fr
     }
 
   void async_read_some(const MutableBuffer &buf,
-        std::function<void (const asio::error_code & error,
+        std::function<void (const boost::system::error_code & error,
                                std::size_t bytes_transferred) > handler) override {
       (void)buf;
-      handler(asio::error::fault, 0);
+      handler(boost::asio::error::fault, 0);
   }
 
   void async_write_some(const ConstBuffer &buf,
-            std::function<void (const asio::error_code & error,
+            std::function<void (const boost::system::error_code & error,
                                  std::size_t bytes_transferred) > handler) override {
       (void)buf;
-      handler(asio::error::fault, 0);
+      handler(boost::asio::error::fault, 0);
   }
 
   virtual void Cancel() override {
@@ -141,7 +144,7 @@ TEST(BadDataNodeTest, TestNoNodes) {
   size_t read = 0;
 
   // Exclude the one datanode with the data
-  is.AsyncPreadSome(0, asio::buffer(buf, sizeof(buf)), nullptr,
+  is.AsyncPreadSome(0, boost::asio::buffer(buf, sizeof(buf)), nullptr,
       [&stat, &read](const Status &status, const std::string &, size_t transferred) {
         stat = status;
         read = transferred;
@@ -202,7 +205,7 @@ TEST(BadDataNodeTest, NNEventCallback) {
           Status::OK(), 0));
 
   is.AsyncPreadSome(
-      0, asio::buffer(buf, sizeof(buf)), nullptr,
+      0, boost::asio::buffer(buf, sizeof(buf)), nullptr,
       [&stat, &read](const Status &status, const std::string &,
                      size_t transferred) {
         stat = status;
@@ -248,7 +251,7 @@ TEST(BadDataNodeTest, RecoverableError) {
 
 
   is.AsyncPreadSome(
-      0, asio::buffer(buf, sizeof(buf)), nullptr,
+      0, boost::asio::buffer(buf, sizeof(buf)), nullptr,
       [&stat, &read](const Status &status, const std::string &,
                      size_t transferred) {
         stat = status;
@@ -300,7 +303,7 @@ TEST(BadDataNodeTest, InternalError) {
                                 sizeof(buf)));
 
   is.AsyncPreadSome(
-      0, asio::buffer(buf, sizeof(buf)), nullptr,
+      0, boost::asio::buffer(buf, sizeof(buf)), nullptr,
       [&stat, &read](const Status &status, const std::string &,
                      size_t transferred) {
         stat = status;
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/tests/mock_connection.cc b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/tests/mock_connection.cc
index 1885eea8da18..37fabf568d27 100644
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/tests/mock_connection.cc
+++ b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/tests/mock_connection.cc
@@ -20,7 +20,7 @@
 
 namespace hdfs {
 
-MockConnectionBase::MockConnectionBase(::asio::io_service *io_service)
+MockConnectionBase::MockConnectionBase(boost::asio::io_service *io_service)
     : io_service_(io_service)
 {}
 
@@ -31,7 +31,7 @@ ProducerResult SharedMockConnection::Produce() {
     return shared_prducer->Produce();
   } else {
     assert(false && "No producer registered");
-    return std::make_pair(asio::error_code(), "");
+    return std::make_pair(boost::system::error_code(), "");
   }
 }
 
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/tests/mock_connection.h b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/tests/mock_connection.h
index 82db76042131..7a7b5f076ed3 100644
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/tests/mock_connection.h
+++ b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/tests/mock_connection.h
@@ -20,21 +20,21 @@
 
 #include "common/async_stream.h"
 
-#include <asio/error_code.hpp>
-#include <asio/buffer.hpp>
-#include <asio/streambuf.hpp>
-#include <asio/io_service.hpp>
+#include <boost/system/error_code.hpp>
+#include <boost/asio/buffer.hpp>
+#include <boost/asio/streambuf.hpp>
+#include <boost/asio/io_service.hpp>
 
 #include <gmock/gmock.h>
 
 namespace hdfs {
 
-typedef std::pair<asio::error_code, std::string> ProducerResult;
+typedef std::pair<boost::system::error_code, std::string> ProducerResult;
 class AsioProducer {
 public:
   /*
    *  Return either:
-   *     (::asio::error_code(), <some data>) for a good result
+   *     (::boost::system::error_code(), <some data>) for a good result
    *     (<an ::asio::error instance>, <anything>) to pass an error to the caller
    *     (::asio::error::would_block, <anything>) to block the next call forever
    */
@@ -45,53 +45,53 @@ class AsioProducer {
 
 class MockConnectionBase : public AsioProducer, public AsyncStream {
 public:
-  MockConnectionBase(::asio::io_service *io_service);
+  MockConnectionBase(boost::asio::io_service *io_service);
   virtual ~MockConnectionBase();
-  typedef std::pair<asio::error_code, std::string> ProducerResult;
+  typedef std::pair<boost::system::error_code, std::string> ProducerResult;
 
   void async_read_some(const MutableBuffer &buf,
-          std::function<void (const asio::error_code & error,
+          std::function<void (const boost::system::error_code & error,
                                  std::size_t bytes_transferred) > handler) override {
     if (produced_.size() == 0) {
       ProducerResult r = Produce();
-      if (r.first == asio::error::would_block) {
+      if (r.first == boost::asio::error::would_block) {
         return; // No more reads to do
       }
       if (r.first) {
         io_service_->post(std::bind(handler, r.first, 0));
         return;
       }
-      asio::mutable_buffers_1 data = produced_.prepare(r.second.size());
-      asio::buffer_copy(data, asio::buffer(r.second));
+      boost::asio::mutable_buffers_1 data = produced_.prepare(r.second.size());
+      boost::asio::buffer_copy(data, boost::asio::buffer(r.second));
       produced_.commit(r.second.size());
     }
 
-    size_t len = std::min(asio::buffer_size(buf), produced_.size());
-    asio::buffer_copy(buf, produced_.data());
+    size_t len = std::min(boost::asio::buffer_size(buf), produced_.size());
+    boost::asio::buffer_copy(buf, produced_.data());
     produced_.consume(len);
-    io_service_->post(std::bind(handler, asio::error_code(), len));
+    io_service_->post(std::bind(handler, boost::system::error_code(), len));
   }
 
   void async_write_some(const ConstBuffer &buf,
-            std::function<void (const asio::error_code & error,
+            std::function<void (const boost::system::error_code & error,
                                  std::size_t bytes_transferred) > handler) override {
     // CompletionResult res = OnWrite(buf);
-    io_service_->post(std::bind(handler, asio::error_code(), asio::buffer_size(buf)));
+    io_service_->post(std::bind(handler, boost::system::error_code(), boost::asio::buffer_size(buf)));
   }
 
   template <class Endpoint, class Callback>
   void async_connect(const Endpoint &, Callback &&handler) {
-    io_service_->post([handler]() { handler(::asio::error_code()); });
+    io_service_->post([handler]() { handler(::boost::system::error_code()); });
   }
 
   virtual void cancel() {}
   virtual void close() {}
 protected:
   ProducerResult Produce() override = 0;
-  ::asio::io_service *io_service_;
+  boost::asio::io_service *io_service_;
 
 private:
-  asio::streambuf produced_;
+  boost::asio::streambuf produced_;
 };
 
 
@@ -114,10 +114,10 @@ class SharedMockConnection : public MockConnectionBase {
     assert(data);
 
     if (!data->checkProducerForConnect) {
-      io_service_->post([handler]() { handler(::asio::error_code()); });
+      io_service_->post([handler]() { handler(::boost::system::error_code()); });
     } else {
       ProducerResult result = Produce();
-      if (result.first == asio::error::would_block) {
+      if (result.first == boost::asio::error::would_block) {
         return; // Connect will hang
       } else {
         io_service_->post([handler, result]() { handler( result.first); });
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/tests/remote_block_reader_test.cc b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/tests/remote_block_reader_test.cc
index 3997e64be5ce..dfee686b6024 100644
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/tests/remote_block_reader_test.cc
+++ b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/tests/remote_block_reader_test.cc
@@ -29,6 +29,9 @@
 #include <google/protobuf/io/zero_copy_stream_impl.h>
 #include <gmock/gmock.h>
 #include <gtest/gtest.h>
+#include <boost/system/error_code.hpp>
+#include <boost/asio/buffer.hpp>
+#include <boost/asio/io_service.hpp>
 
 #include <iostream>
 
@@ -44,9 +47,9 @@ using ::hadoop::hdfs::ReadOpChecksumInfoProto;
 using ::hadoop::hdfs::LocatedBlockProto;
 using ::hadoop::hdfs::LocatedBlocksProto;
 
-using ::asio::buffer;
-using ::asio::error_code;
-using ::asio::mutable_buffers_1;
+using boost::asio::buffer;
+using boost::system::error_code;
+using boost::asio::mutable_buffers_1;
 using ::testing::_;
 using ::testing::InvokeArgument;
 using ::testing::Return;
@@ -60,7 +63,7 @@ namespace hdfs {
 
 class MockDNConnection : public MockConnectionBase, public DataNodeConnection{
 public:
-  MockDNConnection(::asio::io_service &io_service)
+  MockDNConnection(boost::asio::io_service &io_service)
       : MockConnectionBase(&io_service), OnRead([](){}) {}
   MOCK_METHOD0(Produce, ProducerResult());
 
@@ -70,14 +73,14 @@ class MockDNConnection : public MockConnectionBase, public DataNodeConnection{
   std::function<void(void)> OnRead;
 
   void async_read_some(const MutableBuffer &buf,
-        std::function<void (const asio::error_code & error,
+        std::function<void (const boost::system::error_code & error,
                                std::size_t bytes_transferred) > handler) override {
       this->OnRead();
       this->MockConnectionBase::async_read_some(buf, handler);
   }
 
   void async_write_some(const ConstBuffer &buf,
-            std::function<void (const asio::error_code & error,
+            std::function<void (const boost::system::error_code & error,
                                  std::size_t bytes_transferred) > handler) override {
     this->MockConnectionBase::async_write_some(buf, handler);
   }
@@ -96,7 +99,7 @@ class PartialMockReader : public BlockReaderImpl {
 
   MOCK_METHOD2(
       AsyncReadPacket,
-      void(const asio::mutable_buffers_1 &,
+      void(const boost::asio::mutable_buffers_1 &,
            const std::function<void(const Status &, size_t transferred)> &));
 
   MOCK_METHOD5(AsyncRequestBlock,
@@ -163,7 +166,7 @@ TEST(RemoteBlockReaderTest, TestReadSingleTrunk) {
       .WillOnce(InvokeArgument<1>(Status::OK(), sizeof(buf)));
 
   reader.AsyncReadBlock(
-       GetRandomClientName(), block, 0, asio::buffer(buf, sizeof(buf)),
+       GetRandomClientName(), block, 0, boost::asio::buffer(buf, sizeof(buf)),
       [&stat, &read](const Status &status, size_t transferred) {
         stat = status;
         read = transferred;
@@ -190,7 +193,7 @@ TEST(RemoteBlockReaderTest, TestReadMultipleTrunk) {
       .WillRepeatedly(InvokeArgument<1>(Status::OK(), sizeof(buf) / 4));
 
   reader.AsyncReadBlock(
-       GetRandomClientName(), block, 0, asio::buffer(buf, sizeof(buf)),
+       GetRandomClientName(), block, 0, boost::asio::buffer(buf, sizeof(buf)),
       [&stat, &read](const Status &status, size_t transferred) {
         stat = status;
         read = transferred;
@@ -218,7 +221,7 @@ TEST(RemoteBlockReaderTest, TestReadError) {
       .WillOnce(InvokeArgument<1>(Status::Error("error"), 0));
 
   reader.AsyncReadBlock(
-       GetRandomClientName(), block, 0, asio::buffer(buf, sizeof(buf)),
+       GetRandomClientName(), block, 0, boost::asio::buffer(buf, sizeof(buf)),
       [&stat, &read](const Status &status, size_t transferred) {
         stat = status;
         read = transferred;
@@ -250,7 +253,7 @@ ReadContent(std::shared_ptr<Stream> conn, const ExtendedBlockProto &block,
 TEST(RemoteBlockReaderTest, TestReadWholeBlock) {
   static const size_t kChunkSize = 512;
   static const string kChunkData(kChunkSize, 'a');
-  ::asio::io_service io_service;
+  boost::asio::io_service io_service;
   auto conn = std::make_shared<MockDNConnection>(io_service);
   BlockOpResponseProto block_op_resp;
 
@@ -287,7 +290,7 @@ TEST(RemoteBlockReaderTest, TestCancelWhileReceiving) {
 
   static const size_t kChunkSize = 512;
   static const string kChunkData(kChunkSize, 'a');
-  ::asio::io_service io_service;
+  boost::asio::io_service io_service;
   auto conn = std::make_shared<MockDNConnection>(io_service);
   BlockOpResponseProto block_op_resp;
 
@@ -338,7 +341,7 @@ TEST(RemoteBlockReaderTest, TestReadWithinChunk) {
   static const size_t kOffset = kChunkSize / 4;
   static const string kChunkData = string(kOffset, 'a') + string(kLength, 'b');
 
-  ::asio::io_service io_service;
+  boost::asio::io_service io_service;
   auto conn = std::make_shared<MockDNConnection>(io_service);
   BlockOpResponseProto block_op_resp;
   ReadOpChecksumInfoProto *checksum_info =
@@ -378,7 +381,7 @@ TEST(RemoteBlockReaderTest, TestReadMultiplePacket) {
   static const size_t kChunkSize = 1024;
   static const string kChunkData(kChunkSize, 'a');
 
-  ::asio::io_service io_service;
+  boost::asio::io_service io_service;
   auto conn = std::make_shared<MockDNConnection>(io_service);
   BlockOpResponseProto block_op_resp;
   block_op_resp.set_status(::hadoop::hdfs::Status::SUCCESS);
@@ -428,7 +431,7 @@ TEST(RemoteBlockReaderTest, TestReadCancelBetweenPackets) {
   static const size_t kChunkSize = 1024;
   static const string kChunkData(kChunkSize, 'a');
 
-  ::asio::io_service io_service;
+  boost::asio::io_service io_service;
   auto conn = std::make_shared<MockDNConnection>(io_service);
   BlockOpResponseProto block_op_resp;
   block_op_resp.set_status(::hadoop::hdfs::Status::SUCCESS);
@@ -482,7 +485,7 @@ TEST(RemoteBlockReaderTest, TestSaslConnection) {
   static const string kAuthPayload = "realm=\"0\",nonce=\"+GAWc+O6yEAWpew/"
                                      "qKah8qh4QZLoOLCDcTtEKhlS\",qop=\"auth\","
                                      "charset=utf-8,algorithm=md5-sess";
-  ::asio::io_service io_service;
+  boost::asio::io_service io_service;
   auto conn = std::make_shared<MockDNConnection>(io_service);
   BlockOpResponseProto block_op_resp;
   block_op_resp.set_status(::hadoop::hdfs::Status::SUCCESS);
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/tests/rpc_engine_test.cc b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/tests/rpc_engine_test.cc
index 6bbe7259ad85..744e7eba16d8 100644
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/tests/rpc_engine_test.cc
+++ b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/tests/rpc_engine_test.cc
@@ -26,6 +26,8 @@
 
 #include <google/protobuf/io/coded_stream.h>
 #include <gmock/gmock.h>
+#include <boost/system/error_code.hpp>
+#include <boost/date_time/posix_time/posix_time_duration.hpp>
 
 using ::hadoop::common::RpcResponseHeaderProto;
 using ::hadoop::common::EmptyRequestProto;
@@ -33,8 +35,6 @@ using ::hadoop::common::EmptyResponseProto;
 using ::hadoop::common::EchoRequestProto;
 using ::hadoop::common::EchoResponseProto;
 
-using ::asio::error_code;
-
 using ::testing::Return;
 
 using ::std::make_pair;
@@ -47,20 +47,20 @@ namespace hdfs {
 
 std::vector<ResolvedNamenodeInfo> make_endpoint() {
   ResolvedNamenodeInfo result;
-  result.endpoints.push_back(asio::ip::basic_endpoint<asio::ip::tcp>());
+  result.endpoints.push_back(boost::asio::ip::basic_endpoint<boost::asio::ip::tcp>());
   return std::vector<ResolvedNamenodeInfo>({result});
 }
 
 class MockRPCConnection : public MockConnectionBase {
  public:
-  MockRPCConnection(::asio::io_service &io_service)
+  MockRPCConnection(boost::asio::io_service &io_service)
       : MockConnectionBase(&io_service) {}
   MOCK_METHOD0(Produce, ProducerResult());
 };
 
 class SharedMockRPCConnection : public SharedMockConnection {
  public:
-  SharedMockRPCConnection(::asio::io_service &io_service)
+  SharedMockRPCConnection(boost::asio::io_service &io_service)
       : SharedMockConnection(&io_service) {}
 };
 
@@ -79,9 +79,9 @@ class SharedConnectionEngine : public RpcEngine {
 
 }
 
-static inline std::pair<error_code, string> RpcResponse(
+static inline std::pair<boost::system::error_code, string> RpcResponse(
     const RpcResponseHeaderProto &h, const std::string &data,
-    const ::asio::error_code &ec = error_code()) {
+    const boost::system::error_code &ec = boost::system::error_code()) {
   uint32_t payload_length =
       pbio::CodedOutputStream::VarintSize32(h.ByteSize()) +
       pbio::CodedOutputStream::VarintSize32(data.size()) + h.ByteSize() +
@@ -157,7 +157,7 @@ TEST(RpcEngineTest, TestConnectionResetAndFail) {
   h.set_status(RpcResponseHeaderProto::SUCCESS);
   EXPECT_CALL(conn->TEST_get_mutable_socket(), Produce())
       .WillOnce(Return(RpcResponse(
-          h, "", make_error_code(::asio::error::connection_reset))));
+          h, "", make_error_code(boost::asio::error::connection_reset))));
 
   std::shared_ptr<RpcConnection> conn_ptr(conn);
   engine->TEST_SetRpcConnection(conn_ptr);
@@ -200,7 +200,7 @@ TEST(RpcEngineTest, TestConnectionResetAndRecover) {
   h.set_status(RpcResponseHeaderProto::SUCCESS);
   EXPECT_CALL(*producer, Produce())
       .WillOnce(Return(RpcResponse(
-          h, "", make_error_code(::asio::error::connection_reset))))
+          h, "", make_error_code(boost::asio::error::connection_reset))))
       .WillOnce(Return(RpcResponse(h, server_resp.SerializeAsString())));
   SharedMockConnection::SetSharedConnectionData(producer);
 
@@ -240,7 +240,7 @@ TEST(RpcEngineTest, TestConnectionResetAndRecoverWithDelay) {
   h.set_status(RpcResponseHeaderProto::SUCCESS);
   EXPECT_CALL(*producer, Produce())
       .WillOnce(Return(RpcResponse(
-          h, "", make_error_code(::asio::error::connection_reset))))
+          h, "", make_error_code(boost::asio::error::connection_reset))))
       .WillOnce(Return(RpcResponse(h, server_resp.SerializeAsString())));
   SharedMockConnection::SetSharedConnectionData(producer);
 
@@ -254,9 +254,9 @@ TEST(RpcEngineTest, TestConnectionResetAndRecoverWithDelay) {
     ASSERT_TRUE(stat.ok());
   });
 
-  ::asio::deadline_timer timer(io_service->GetRaw());
-  timer.expires_from_now(std::chrono::hours(100));
-  timer.async_wait([](const asio::error_code & err){(void)err; ASSERT_FALSE("Timed out"); });
+  boost::asio::deadline_timer timer(io_service->GetRaw());
+  timer.expires_from_now(boost::posix_time::hours(100));
+  timer.async_wait([](const boost::system::error_code & err){(void)err; ASSERT_FALSE("Timed out"); });
 
   io_service->Run();
   ASSERT_TRUE(complete);
@@ -279,7 +279,7 @@ TEST(RpcEngineTest, TestConnectionFailure)
   std::shared_ptr<SharedConnectionEngine> engine
       = std::make_shared<SharedConnectionEngine>(io_service, options, "foo", "", "protocol", 1);
   EXPECT_CALL(*producer, Produce())
-      .WillOnce(Return(std::make_pair(make_error_code(::asio::error::connection_reset), "")));
+      .WillOnce(Return(std::make_pair(make_error_code(boost::asio::error::connection_reset), "")));
 
   engine->Connect("", make_endpoint(), [&complete, io_service](const Status &stat) {
     complete = true;
@@ -306,9 +306,9 @@ TEST(RpcEngineTest, TestConnectionFailureRetryAndFailure)
   std::shared_ptr<SharedConnectionEngine> engine =
       std::make_shared<SharedConnectionEngine>(io_service, options, "foo", "", "protocol", 1);
   EXPECT_CALL(*producer, Produce())
-      .WillOnce(Return(std::make_pair(make_error_code(::asio::error::connection_reset), "")))
-      .WillOnce(Return(std::make_pair(make_error_code(::asio::error::connection_reset), "")))
-      .WillOnce(Return(std::make_pair(make_error_code(::asio::error::connection_reset), "")));
+      .WillOnce(Return(std::make_pair(make_error_code(boost::asio::error::connection_reset), "")))
+      .WillOnce(Return(std::make_pair(make_error_code(boost::asio::error::connection_reset), "")))
+      .WillOnce(Return(std::make_pair(make_error_code(boost::asio::error::connection_reset), "")));
 
   engine->Connect("", make_endpoint(), [&complete, io_service](const Status &stat) {
     complete = true;
@@ -335,9 +335,9 @@ TEST(RpcEngineTest, TestConnectionFailureAndRecover)
   std::shared_ptr<SharedConnectionEngine> engine =
       std::make_shared<SharedConnectionEngine>(io_service, options, "foo", "", "protocol", 1);
   EXPECT_CALL(*producer, Produce())
-      .WillOnce(Return(std::make_pair(make_error_code(::asio::error::connection_reset), "")))
-      .WillOnce(Return(std::make_pair(::asio::error_code(), "")))
-      .WillOnce(Return(std::make_pair(::asio::error::would_block, "")));
+      .WillOnce(Return(std::make_pair(make_error_code(boost::asio::error::connection_reset), "")))
+      .WillOnce(Return(std::make_pair(boost::system::error_code(), "")))
+      .WillOnce(Return(std::make_pair(boost::asio::error::would_block, "")));
 
   engine->Connect("", make_endpoint(), [&complete, io_service](const Status &stat) {
     complete = true;
@@ -390,8 +390,8 @@ TEST(RpcEngineTest, TestEventCallbacks)
   h.set_callid(1);
   h.set_status(RpcResponseHeaderProto::SUCCESS);
   EXPECT_CALL(*producer, Produce())
-      .WillOnce(Return(std::make_pair(::asio::error_code(), ""))) // subverted by callback
-      .WillOnce(Return(std::make_pair(::asio::error_code(), "")))
+      .WillOnce(Return(std::make_pair(boost::system::error_code(), ""))) // subverted by callback
+      .WillOnce(Return(std::make_pair(boost::system::error_code(), "")))
       .WillOnce(Return(RpcResponse(h, "b"))) // subverted by callback
       .WillOnce(Return(RpcResponse(h, server_resp.SerializeAsString())));
   SharedMockConnection::SetSharedConnectionData(producer);
@@ -444,9 +444,9 @@ TEST(RpcEngineTest, TestConnectionFailureAndAsyncRecover)
   std::shared_ptr<SharedConnectionEngine> engine =
       std::make_shared<SharedConnectionEngine>(io_service, options, "foo", "", "protocol", 1);
   EXPECT_CALL(*producer, Produce())
-      .WillOnce(Return(std::make_pair(make_error_code(::asio::error::connection_reset), "")))
-      .WillOnce(Return(std::make_pair(::asio::error_code(), "")))
-      .WillOnce(Return(std::make_pair(::asio::error::would_block, "")));
+      .WillOnce(Return(std::make_pair(make_error_code(boost::asio::error::connection_reset), "")))
+      .WillOnce(Return(std::make_pair(boost::system::error_code(), "")))
+      .WillOnce(Return(std::make_pair(boost::asio::error::would_block, "")));
 
   engine->Connect("", make_endpoint(), [&complete, io_service](const Status &stat) {
     complete = true;
@@ -454,9 +454,9 @@ TEST(RpcEngineTest, TestConnectionFailureAndAsyncRecover)
     ASSERT_TRUE(stat.ok());
   });
 
-  ::asio::deadline_timer timer(io_service->GetRaw());
-  timer.expires_from_now(std::chrono::hours(100));
-  timer.async_wait([](const asio::error_code & err){(void)err; ASSERT_FALSE("Timed out"); });
+  boost::asio::deadline_timer timer(io_service->GetRaw());
+  timer.expires_from_now(boost::posix_time::hours(100));
+  timer.async_wait([](const boost::system::error_code & err){(void)err; ASSERT_FALSE("Timed out"); });
 
   io_service->Run();
   ASSERT_TRUE(complete);
@@ -473,7 +473,7 @@ TEST(RpcEngineTest, TestTimeout) {
   conn->StartReading();
 
     EXPECT_CALL(conn->TEST_get_mutable_socket(), Produce())
-        .WillOnce(Return(std::make_pair(::asio::error::would_block, "")));
+        .WillOnce(Return(std::make_pair(boost::asio::error::would_block, "")));
 
   std::shared_ptr<RpcConnection> conn_ptr(conn);
   engine->TEST_SetRpcConnection(conn_ptr);
@@ -489,9 +489,9 @@ TEST(RpcEngineTest, TestTimeout) {
     ASSERT_FALSE(stat.ok());
   });
 
-  ::asio::deadline_timer timer(io_service->GetRaw());
-  timer.expires_from_now(std::chrono::hours(100));
-  timer.async_wait([](const asio::error_code & err){(void)err; ASSERT_FALSE("Timed out"); });
+  boost::asio::deadline_timer timer(io_service->GetRaw());
+  timer.expires_from_now(boost::posix_time::hours(100));
+  timer.async_wait([](const boost::system::error_code & err){(void)err; ASSERT_FALSE("Timed out"); });
 
   io_service->Run();
   ASSERT_TRUE(complete);
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/COPYING b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/COPYING
deleted file mode 100644
index e86a3819fc51..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/COPYING
+++ /dev/null
@@ -1,4 +0,0 @@
-Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-
-Distributed under the Boost Software License, Version 1.0. (See accompanying
-file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio.hpp
deleted file mode 100644
index 1f478409c2aa..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio.hpp
+++ /dev/null
@@ -1,122 +0,0 @@
-//
-// asio.hpp
-// ~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_HPP
-#define ASIO_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/async_result.hpp"
-#include "asio/basic_datagram_socket.hpp"
-#include "asio/basic_deadline_timer.hpp"
-#include "asio/basic_io_object.hpp"
-#include "asio/basic_raw_socket.hpp"
-#include "asio/basic_seq_packet_socket.hpp"
-#include "asio/basic_serial_port.hpp"
-#include "asio/basic_signal_set.hpp"
-#include "asio/basic_socket_acceptor.hpp"
-#include "asio/basic_socket_iostream.hpp"
-#include "asio/basic_socket_streambuf.hpp"
-#include "asio/basic_stream_socket.hpp"
-#include "asio/basic_streambuf.hpp"
-#include "asio/basic_waitable_timer.hpp"
-#include "asio/buffer.hpp"
-#include "asio/buffered_read_stream_fwd.hpp"
-#include "asio/buffered_read_stream.hpp"
-#include "asio/buffered_stream_fwd.hpp"
-#include "asio/buffered_stream.hpp"
-#include "asio/buffered_write_stream_fwd.hpp"
-#include "asio/buffered_write_stream.hpp"
-#include "asio/buffers_iterator.hpp"
-#include "asio/completion_condition.hpp"
-#include "asio/connect.hpp"
-#include "asio/coroutine.hpp"
-#include "asio/datagram_socket_service.hpp"
-#include "asio/deadline_timer_service.hpp"
-#include "asio/deadline_timer.hpp"
-#include "asio/error.hpp"
-#include "asio/error_code.hpp"
-#include "asio/generic/basic_endpoint.hpp"
-#include "asio/generic/datagram_protocol.hpp"
-#include "asio/generic/raw_protocol.hpp"
-#include "asio/generic/seq_packet_protocol.hpp"
-#include "asio/generic/stream_protocol.hpp"
-#include "asio/handler_alloc_hook.hpp"
-#include "asio/handler_continuation_hook.hpp"
-#include "asio/handler_invoke_hook.hpp"
-#include "asio/handler_type.hpp"
-#include "asio/io_service.hpp"
-#include "asio/ip/address.hpp"
-#include "asio/ip/address_v4.hpp"
-#include "asio/ip/address_v6.hpp"
-#include "asio/ip/basic_endpoint.hpp"
-#include "asio/ip/basic_resolver.hpp"
-#include "asio/ip/basic_resolver_entry.hpp"
-#include "asio/ip/basic_resolver_iterator.hpp"
-#include "asio/ip/basic_resolver_query.hpp"
-#include "asio/ip/host_name.hpp"
-#include "asio/ip/icmp.hpp"
-#include "asio/ip/multicast.hpp"
-#include "asio/ip/resolver_query_base.hpp"
-#include "asio/ip/resolver_service.hpp"
-#include "asio/ip/tcp.hpp"
-#include "asio/ip/udp.hpp"
-#include "asio/ip/unicast.hpp"
-#include "asio/ip/v6_only.hpp"
-#include "asio/is_read_buffered.hpp"
-#include "asio/is_write_buffered.hpp"
-#include "asio/local/basic_endpoint.hpp"
-#include "asio/local/connect_pair.hpp"
-#include "asio/local/datagram_protocol.hpp"
-#include "asio/local/stream_protocol.hpp"
-#include "asio/placeholders.hpp"
-#include "asio/posix/basic_descriptor.hpp"
-#include "asio/posix/basic_stream_descriptor.hpp"
-#include "asio/posix/descriptor_base.hpp"
-#include "asio/posix/stream_descriptor.hpp"
-#include "asio/posix/stream_descriptor_service.hpp"
-#include "asio/raw_socket_service.hpp"
-#include "asio/read.hpp"
-#include "asio/read_at.hpp"
-#include "asio/read_until.hpp"
-#include "asio/seq_packet_socket_service.hpp"
-#include "asio/serial_port.hpp"
-#include "asio/serial_port_base.hpp"
-#include "asio/serial_port_service.hpp"
-#include "asio/signal_set.hpp"
-#include "asio/signal_set_service.hpp"
-#include "asio/socket_acceptor_service.hpp"
-#include "asio/socket_base.hpp"
-#include "asio/strand.hpp"
-#include "asio/stream_socket_service.hpp"
-#include "asio/streambuf.hpp"
-#include "asio/system_error.hpp"
-#include "asio/thread.hpp"
-#include "asio/time_traits.hpp"
-#include "asio/version.hpp"
-#include "asio/wait_traits.hpp"
-#include "asio/waitable_timer_service.hpp"
-#include "asio/windows/basic_handle.hpp"
-#include "asio/windows/basic_object_handle.hpp"
-#include "asio/windows/basic_random_access_handle.hpp"
-#include "asio/windows/basic_stream_handle.hpp"
-#include "asio/windows/object_handle.hpp"
-#include "asio/windows/object_handle_service.hpp"
-#include "asio/windows/overlapped_ptr.hpp"
-#include "asio/windows/random_access_handle.hpp"
-#include "asio/windows/random_access_handle_service.hpp"
-#include "asio/windows/stream_handle.hpp"
-#include "asio/windows/stream_handle_service.hpp"
-#include "asio/write.hpp"
-#include "asio/write_at.hpp"
-
-#endif // ASIO_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/async_result.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/async_result.hpp
deleted file mode 100644
index b98d7703385f..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/async_result.hpp
+++ /dev/null
@@ -1,94 +0,0 @@
-//
-// async_result.hpp
-// ~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_ASYNC_RESULT_HPP
-#define ASIO_ASYNC_RESULT_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include "asio/handler_type.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-
-/// An interface for customising the behaviour of an initiating function.
-/**
- * This template may be specialised for user-defined handler types.
- */
-template <typename Handler>
-class async_result
-{
-public:
-  /// The return type of the initiating function.
-  typedef void type;
-
-  /// Construct an async result from a given handler.
-  /**
-   * When using a specalised async_result, the constructor has an opportunity
-   * to initialise some state associated with the handler, which is then
-   * returned from the initiating function.
-   */
-  explicit async_result(Handler&)
-  {
-  }
-
-  /// Obtain the value to be returned from the initiating function.
-  type get()
-  {
-  }
-};
-
-namespace detail {
-
-// Helper template to deduce the true type of a handler, capture a local copy
-// of the handler, and then create an async_result for the handler.
-template <typename Handler, typename Signature>
-struct async_result_init
-{
-  explicit async_result_init(ASIO_MOVE_ARG(Handler) orig_handler)
-    : handler(ASIO_MOVE_CAST(Handler)(orig_handler)),
-      result(handler)
-  {
-  }
-
-  typename handler_type<Handler, Signature>::type handler;
-  async_result<typename handler_type<Handler, Signature>::type> result;
-};
-
-template <typename Handler, typename Signature>
-struct async_result_type_helper
-{
-  typedef typename async_result<
-      typename handler_type<Handler, Signature>::type
-    >::type type;
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#if defined(GENERATING_DOCUMENTATION)
-# define ASIO_INITFN_RESULT_TYPE(h, sig) \
-  void_or_deduced
-#elif defined(_MSC_VER) && (_MSC_VER < 1500)
-# define ASIO_INITFN_RESULT_TYPE(h, sig) \
-  typename ::asio::detail::async_result_type_helper<h, sig>::type
-#else
-# define ASIO_INITFN_RESULT_TYPE(h, sig) \
-  typename ::asio::async_result< \
-    typename ::asio::handler_type<h, sig>::type>::type
-#endif
-
-#endif // ASIO_ASYNC_RESULT_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/basic_datagram_socket.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/basic_datagram_socket.hpp
deleted file mode 100644
index a1356b90fba5..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/basic_datagram_socket.hpp
+++ /dev/null
@@ -1,949 +0,0 @@
-//
-// basic_datagram_socket.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_BASIC_DATAGRAM_SOCKET_HPP
-#define ASIO_BASIC_DATAGRAM_SOCKET_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include <cstddef>
-#include "asio/basic_socket.hpp"
-#include "asio/datagram_socket_service.hpp"
-#include "asio/detail/handler_type_requirements.hpp"
-#include "asio/detail/throw_error.hpp"
-#include "asio/detail/type_traits.hpp"
-#include "asio/error.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-
-/// Provides datagram-oriented socket functionality.
-/**
- * The basic_datagram_socket class template provides asynchronous and blocking
- * datagram-oriented socket functionality.
- *
- * @par Thread Safety
- * @e Distinct @e objects: Safe.@n
- * @e Shared @e objects: Unsafe.
- */
-template <typename Protocol,
-    typename DatagramSocketService = datagram_socket_service<Protocol> >
-class basic_datagram_socket
-  : public basic_socket<Protocol, DatagramSocketService>
-{
-public:
-  /// (Deprecated: Use native_handle_type.) The native representation of a
-  /// socket.
-  typedef typename DatagramSocketService::native_handle_type native_type;
-
-  /// The native representation of a socket.
-  typedef typename DatagramSocketService::native_handle_type native_handle_type;
-
-  /// The protocol type.
-  typedef Protocol protocol_type;
-
-  /// The endpoint type.
-  typedef typename Protocol::endpoint endpoint_type;
-
-  /// Construct a basic_datagram_socket without opening it.
-  /**
-   * This constructor creates a datagram socket without opening it. The open()
-   * function must be called before data can be sent or received on the socket.
-   *
-   * @param io_service The io_service object that the datagram socket will use
-   * to dispatch handlers for any asynchronous operations performed on the
-   * socket.
-   */
-  explicit basic_datagram_socket(asio::io_service& io_service)
-    : basic_socket<Protocol, DatagramSocketService>(io_service)
-  {
-  }
-
-  /// Construct and open a basic_datagram_socket.
-  /**
-   * This constructor creates and opens a datagram socket.
-   *
-   * @param io_service The io_service object that the datagram socket will use
-   * to dispatch handlers for any asynchronous operations performed on the
-   * socket.
-   *
-   * @param protocol An object specifying protocol parameters to be used.
-   *
-   * @throws asio::system_error Thrown on failure.
-   */
-  basic_datagram_socket(asio::io_service& io_service,
-      const protocol_type& protocol)
-    : basic_socket<Protocol, DatagramSocketService>(io_service, protocol)
-  {
-  }
-
-  /// Construct a basic_datagram_socket, opening it and binding it to the given
-  /// local endpoint.
-  /**
-   * This constructor creates a datagram socket and automatically opens it bound
-   * to the specified endpoint on the local machine. The protocol used is the
-   * protocol associated with the given endpoint.
-   *
-   * @param io_service The io_service object that the datagram socket will use
-   * to dispatch handlers for any asynchronous operations performed on the
-   * socket.
-   *
-   * @param endpoint An endpoint on the local machine to which the datagram
-   * socket will be bound.
-   *
-   * @throws asio::system_error Thrown on failure.
-   */
-  basic_datagram_socket(asio::io_service& io_service,
-      const endpoint_type& endpoint)
-    : basic_socket<Protocol, DatagramSocketService>(io_service, endpoint)
-  {
-  }
-
-  /// Construct a basic_datagram_socket on an existing native socket.
-  /**
-   * This constructor creates a datagram socket object to hold an existing
-   * native socket.
-   *
-   * @param io_service The io_service object that the datagram socket will use
-   * to dispatch handlers for any asynchronous operations performed on the
-   * socket.
-   *
-   * @param protocol An object specifying protocol parameters to be used.
-   *
-   * @param native_socket The new underlying socket implementation.
-   *
-   * @throws asio::system_error Thrown on failure.
-   */
-  basic_datagram_socket(asio::io_service& io_service,
-      const protocol_type& protocol, const native_handle_type& native_socket)
-    : basic_socket<Protocol, DatagramSocketService>(
-        io_service, protocol, native_socket)
-  {
-  }
-
-#if defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
-  /// Move-construct a basic_datagram_socket from another.
-  /**
-   * This constructor moves a datagram socket from one object to another.
-   *
-   * @param other The other basic_datagram_socket object from which the move
-   * will occur.
-   *
-   * @note Following the move, the moved-from object is in the same state as if
-   * constructed using the @c basic_datagram_socket(io_service&) constructor.
-   */
-  basic_datagram_socket(basic_datagram_socket&& other)
-    : basic_socket<Protocol, DatagramSocketService>(
-        ASIO_MOVE_CAST(basic_datagram_socket)(other))
-  {
-  }
-
-  /// Move-assign a basic_datagram_socket from another.
-  /**
-   * This assignment operator moves a datagram socket from one object to
-   * another.
-   *
-   * @param other The other basic_datagram_socket object from which the move
-   * will occur.
-   *
-   * @note Following the move, the moved-from object is in the same state as if
-   * constructed using the @c basic_datagram_socket(io_service&) constructor.
-   */
-  basic_datagram_socket& operator=(basic_datagram_socket&& other)
-  {
-    basic_socket<Protocol, DatagramSocketService>::operator=(
-        ASIO_MOVE_CAST(basic_datagram_socket)(other));
-    return *this;
-  }
-
-  /// Move-construct a basic_datagram_socket from a socket of another protocol
-  /// type.
-  /**
-   * This constructor moves a datagram socket from one object to another.
-   *
-   * @param other The other basic_datagram_socket object from which the move
-   * will occur.
-   *
-   * @note Following the move, the moved-from object is in the same state as if
-   * constructed using the @c basic_datagram_socket(io_service&) constructor.
-   */
-  template <typename Protocol1, typename DatagramSocketService1>
-  basic_datagram_socket(
-      basic_datagram_socket<Protocol1, DatagramSocketService1>&& other,
-      typename enable_if<is_convertible<Protocol1, Protocol>::value>::type* = 0)
-    : basic_socket<Protocol, DatagramSocketService>(
-        ASIO_MOVE_CAST2(basic_datagram_socket<
-          Protocol1, DatagramSocketService1>)(other))
-  {
-  }
-
-  /// Move-assign a basic_datagram_socket from a socket of another protocol
-  /// type.
-  /**
-   * This assignment operator moves a datagram socket from one object to
-   * another.
-   *
-   * @param other The other basic_datagram_socket object from which the move
-   * will occur.
-   *
-   * @note Following the move, the moved-from object is in the same state as if
-   * constructed using the @c basic_datagram_socket(io_service&) constructor.
-   */
-  template <typename Protocol1, typename DatagramSocketService1>
-  typename enable_if<is_convertible<Protocol1, Protocol>::value,
-      basic_datagram_socket>::type& operator=(
-        basic_datagram_socket<Protocol1, DatagramSocketService1>&& other)
-  {
-    basic_socket<Protocol, DatagramSocketService>::operator=(
-        ASIO_MOVE_CAST2(basic_datagram_socket<
-          Protocol1, DatagramSocketService1>)(other));
-    return *this;
-  }
-#endif // defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
-
-  /// Send some data on a connected socket.
-  /**
-   * This function is used to send data on the datagram socket. The function
-   * call will block until the data has been sent successfully or an error
-   * occurs.
-   *
-   * @param buffers One ore more data buffers to be sent on the socket.
-   *
-   * @returns The number of bytes sent.
-   *
-   * @throws asio::system_error Thrown on failure.
-   *
-   * @note The send operation can only be used with a connected socket. Use
-   * the send_to function to send data on an unconnected datagram socket.
-   *
-   * @par Example
-   * To send a single data buffer use the @ref buffer function as follows:
-   * @code socket.send(asio::buffer(data, size)); @endcode
-   * See the @ref buffer documentation for information on sending multiple
-   * buffers in one go, and how to use it with arrays, boost::array or
-   * std::vector.
-   */
-  template <typename ConstBufferSequence>
-  std::size_t send(const ConstBufferSequence& buffers)
-  {
-    asio::error_code ec;
-    std::size_t s = this->get_service().send(
-        this->get_implementation(), buffers, 0, ec);
-    asio::detail::throw_error(ec, "send");
-    return s;
-  }
-
-  /// Send some data on a connected socket.
-  /**
-   * This function is used to send data on the datagram socket. The function
-   * call will block until the data has been sent successfully or an error
-   * occurs.
-   *
-   * @param buffers One ore more data buffers to be sent on the socket.
-   *
-   * @param flags Flags specifying how the send call is to be made.
-   *
-   * @returns The number of bytes sent.
-   *
-   * @throws asio::system_error Thrown on failure.
-   *
-   * @note The send operation can only be used with a connected socket. Use
-   * the send_to function to send data on an unconnected datagram socket.
-   */
-  template <typename ConstBufferSequence>
-  std::size_t send(const ConstBufferSequence& buffers,
-      socket_base::message_flags flags)
-  {
-    asio::error_code ec;
-    std::size_t s = this->get_service().send(
-        this->get_implementation(), buffers, flags, ec);
-    asio::detail::throw_error(ec, "send");
-    return s;
-  }
-
-  /// Send some data on a connected socket.
-  /**
-   * This function is used to send data on the datagram socket. The function
-   * call will block until the data has been sent successfully or an error
-   * occurs.
-   *
-   * @param buffers One or more data buffers to be sent on the socket.
-   *
-   * @param flags Flags specifying how the send call is to be made.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   *
-   * @returns The number of bytes sent.
-   *
-   * @note The send operation can only be used with a connected socket. Use
-   * the send_to function to send data on an unconnected datagram socket.
-   */
-  template <typename ConstBufferSequence>
-  std::size_t send(const ConstBufferSequence& buffers,
-      socket_base::message_flags flags, asio::error_code& ec)
-  {
-    return this->get_service().send(
-        this->get_implementation(), buffers, flags, ec);
-  }
-
-  /// Start an asynchronous send on a connected socket.
-  /**
-   * This function is used to asynchronously send data on the datagram socket.
-   * The function call always returns immediately.
-   *
-   * @param buffers One or more data buffers to be sent on the socket. Although
-   * the buffers object may be copied as necessary, ownership of the underlying
-   * memory blocks is retained by the caller, which must guarantee that they
-   * remain valid until the handler is called.
-   *
-   * @param handler The handler to be called when the send operation completes.
-   * Copies will be made of the handler as required. The function signature of
-   * the handler must be:
-   * @code void handler(
-   *   const asio::error_code& error, // Result of operation.
-   *   std::size_t bytes_transferred           // Number of bytes sent.
-   * ); @endcode
-   * Regardless of whether the asynchronous operation completes immediately or
-   * not, the handler will not be invoked from within this function. Invocation
-   * of the handler will be performed in a manner equivalent to using
-   * asio::io_service::post().
-   *
-   * @note The async_send operation can only be used with a connected socket.
-   * Use the async_send_to function to send data on an unconnected datagram
-   * socket.
-   *
-   * @par Example
-   * To send a single data buffer use the @ref buffer function as follows:
-   * @code
-   * socket.async_send(asio::buffer(data, size), handler);
-   * @endcode
-   * See the @ref buffer documentation for information on sending multiple
-   * buffers in one go, and how to use it with arrays, boost::array or
-   * std::vector.
-   */
-  template <typename ConstBufferSequence, typename WriteHandler>
-  ASIO_INITFN_RESULT_TYPE(WriteHandler,
-      void (asio::error_code, std::size_t))
-  async_send(const ConstBufferSequence& buffers,
-      ASIO_MOVE_ARG(WriteHandler) handler)
-  {
-    // If you get an error on the following line it means that your handler does
-    // not meet the documented type requirements for a WriteHandler.
-    ASIO_WRITE_HANDLER_CHECK(WriteHandler, handler) type_check;
-
-    return this->get_service().async_send(this->get_implementation(),
-        buffers, 0, ASIO_MOVE_CAST(WriteHandler)(handler));
-  }
-
-  /// Start an asynchronous send on a connected socket.
-  /**
-   * This function is used to asynchronously send data on the datagram socket.
-   * The function call always returns immediately.
-   *
-   * @param buffers One or more data buffers to be sent on the socket. Although
-   * the buffers object may be copied as necessary, ownership of the underlying
-   * memory blocks is retained by the caller, which must guarantee that they
-   * remain valid until the handler is called.
-   *
-   * @param flags Flags specifying how the send call is to be made.
-   *
-   * @param handler The handler to be called when the send operation completes.
-   * Copies will be made of the handler as required. The function signature of
-   * the handler must be:
-   * @code void handler(
-   *   const asio::error_code& error, // Result of operation.
-   *   std::size_t bytes_transferred           // Number of bytes sent.
-   * ); @endcode
-   * Regardless of whether the asynchronous operation completes immediately or
-   * not, the handler will not be invoked from within this function. Invocation
-   * of the handler will be performed in a manner equivalent to using
-   * asio::io_service::post().
-   *
-   * @note The async_send operation can only be used with a connected socket.
-   * Use the async_send_to function to send data on an unconnected datagram
-   * socket.
-   */
-  template <typename ConstBufferSequence, typename WriteHandler>
-  ASIO_INITFN_RESULT_TYPE(WriteHandler,
-      void (asio::error_code, std::size_t))
-  async_send(const ConstBufferSequence& buffers,
-      socket_base::message_flags flags,
-      ASIO_MOVE_ARG(WriteHandler) handler)
-  {
-    // If you get an error on the following line it means that your handler does
-    // not meet the documented type requirements for a WriteHandler.
-    ASIO_WRITE_HANDLER_CHECK(WriteHandler, handler) type_check;
-
-    return this->get_service().async_send(this->get_implementation(),
-        buffers, flags, ASIO_MOVE_CAST(WriteHandler)(handler));
-  }
-
-  /// Send a datagram to the specified endpoint.
-  /**
-   * This function is used to send a datagram to the specified remote endpoint.
-   * The function call will block until the data has been sent successfully or
-   * an error occurs.
-   *
-   * @param buffers One or more data buffers to be sent to the remote endpoint.
-   *
-   * @param destination The remote endpoint to which the data will be sent.
-   *
-   * @returns The number of bytes sent.
-   *
-   * @throws asio::system_error Thrown on failure.
-   *
-   * @par Example
-   * To send a single data buffer use the @ref buffer function as follows:
-   * @code
-   * asio::ip::udp::endpoint destination(
-   *     asio::ip::address::from_string("1.2.3.4"), 12345);
-   * socket.send_to(asio::buffer(data, size), destination);
-   * @endcode
-   * See the @ref buffer documentation for information on sending multiple
-   * buffers in one go, and how to use it with arrays, boost::array or
-   * std::vector.
-   */
-  template <typename ConstBufferSequence>
-  std::size_t send_to(const ConstBufferSequence& buffers,
-      const endpoint_type& destination)
-  {
-    asio::error_code ec;
-    std::size_t s = this->get_service().send_to(
-        this->get_implementation(), buffers, destination, 0, ec);
-    asio::detail::throw_error(ec, "send_to");
-    return s;
-  }
-
-  /// Send a datagram to the specified endpoint.
-  /**
-   * This function is used to send a datagram to the specified remote endpoint.
-   * The function call will block until the data has been sent successfully or
-   * an error occurs.
-   *
-   * @param buffers One or more data buffers to be sent to the remote endpoint.
-   *
-   * @param destination The remote endpoint to which the data will be sent.
-   *
-   * @param flags Flags specifying how the send call is to be made.
-   *
-   * @returns The number of bytes sent.
-   *
-   * @throws asio::system_error Thrown on failure.
-   */
-  template <typename ConstBufferSequence>
-  std::size_t send_to(const ConstBufferSequence& buffers,
-      const endpoint_type& destination, socket_base::message_flags flags)
-  {
-    asio::error_code ec;
-    std::size_t s = this->get_service().send_to(
-        this->get_implementation(), buffers, destination, flags, ec);
-    asio::detail::throw_error(ec, "send_to");
-    return s;
-  }
-
-  /// Send a datagram to the specified endpoint.
-  /**
-   * This function is used to send a datagram to the specified remote endpoint.
-   * The function call will block until the data has been sent successfully or
-   * an error occurs.
-   *
-   * @param buffers One or more data buffers to be sent to the remote endpoint.
-   *
-   * @param destination The remote endpoint to which the data will be sent.
-   *
-   * @param flags Flags specifying how the send call is to be made.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   *
-   * @returns The number of bytes sent.
-   */
-  template <typename ConstBufferSequence>
-  std::size_t send_to(const ConstBufferSequence& buffers,
-      const endpoint_type& destination, socket_base::message_flags flags,
-      asio::error_code& ec)
-  {
-    return this->get_service().send_to(this->get_implementation(),
-        buffers, destination, flags, ec);
-  }
-
-  /// Start an asynchronous send.
-  /**
-   * This function is used to asynchronously send a datagram to the specified
-   * remote endpoint. The function call always returns immediately.
-   *
-   * @param buffers One or more data buffers to be sent to the remote endpoint.
-   * Although the buffers object may be copied as necessary, ownership of the
-   * underlying memory blocks is retained by the caller, which must guarantee
-   * that they remain valid until the handler is called.
-   *
-   * @param destination The remote endpoint to which the data will be sent.
-   * Copies will be made of the endpoint as required.
-   *
-   * @param handler The handler to be called when the send operation completes.
-   * Copies will be made of the handler as required. The function signature of
-   * the handler must be:
-   * @code void handler(
-   *   const asio::error_code& error, // Result of operation.
-   *   std::size_t bytes_transferred           // Number of bytes sent.
-   * ); @endcode
-   * Regardless of whether the asynchronous operation completes immediately or
-   * not, the handler will not be invoked from within this function. Invocation
-   * of the handler will be performed in a manner equivalent to using
-   * asio::io_service::post().
-   *
-   * @par Example
-   * To send a single data buffer use the @ref buffer function as follows:
-   * @code
-   * asio::ip::udp::endpoint destination(
-   *     asio::ip::address::from_string("1.2.3.4"), 12345);
-   * socket.async_send_to(
-   *     asio::buffer(data, size), destination, handler);
-   * @endcode
-   * See the @ref buffer documentation for information on sending multiple
-   * buffers in one go, and how to use it with arrays, boost::array or
-   * std::vector.
-   */
-  template <typename ConstBufferSequence, typename WriteHandler>
-  ASIO_INITFN_RESULT_TYPE(WriteHandler,
-      void (asio::error_code, std::size_t))
-  async_send_to(const ConstBufferSequence& buffers,
-      const endpoint_type& destination,
-      ASIO_MOVE_ARG(WriteHandler) handler)
-  {
-    // If you get an error on the following line it means that your handler does
-    // not meet the documented type requirements for a WriteHandler.
-    ASIO_WRITE_HANDLER_CHECK(WriteHandler, handler) type_check;
-
-    return this->get_service().async_send_to(
-        this->get_implementation(), buffers, destination, 0,
-        ASIO_MOVE_CAST(WriteHandler)(handler));
-  }
-
-  /// Start an asynchronous send.
-  /**
-   * This function is used to asynchronously send a datagram to the specified
-   * remote endpoint. The function call always returns immediately.
-   *
-   * @param buffers One or more data buffers to be sent to the remote endpoint.
-   * Although the buffers object may be copied as necessary, ownership of the
-   * underlying memory blocks is retained by the caller, which must guarantee
-   * that they remain valid until the handler is called.
-   *
-   * @param flags Flags specifying how the send call is to be made.
-   *
-   * @param destination The remote endpoint to which the data will be sent.
-   * Copies will be made of the endpoint as required.
-   *
-   * @param handler The handler to be called when the send operation completes.
-   * Copies will be made of the handler as required. The function signature of
-   * the handler must be:
-   * @code void handler(
-   *   const asio::error_code& error, // Result of operation.
-   *   std::size_t bytes_transferred           // Number of bytes sent.
-   * ); @endcode
-   * Regardless of whether the asynchronous operation completes immediately or
-   * not, the handler will not be invoked from within this function. Invocation
-   * of the handler will be performed in a manner equivalent to using
-   * asio::io_service::post().
-   */
-  template <typename ConstBufferSequence, typename WriteHandler>
-  ASIO_INITFN_RESULT_TYPE(WriteHandler,
-      void (asio::error_code, std::size_t))
-  async_send_to(const ConstBufferSequence& buffers,
-      const endpoint_type& destination, socket_base::message_flags flags,
-      ASIO_MOVE_ARG(WriteHandler) handler)
-  {
-    // If you get an error on the following line it means that your handler does
-    // not meet the documented type requirements for a WriteHandler.
-    ASIO_WRITE_HANDLER_CHECK(WriteHandler, handler) type_check;
-
-    return this->get_service().async_send_to(
-        this->get_implementation(), buffers, destination, flags,
-        ASIO_MOVE_CAST(WriteHandler)(handler));
-  }
-
-  /// Receive some data on a connected socket.
-  /**
-   * This function is used to receive data on the datagram socket. The function
-   * call will block until data has been received successfully or an error
-   * occurs.
-   *
-   * @param buffers One or more buffers into which the data will be received.
-   *
-   * @returns The number of bytes received.
-   *
-   * @throws asio::system_error Thrown on failure.
-   *
-   * @note The receive operation can only be used with a connected socket. Use
-   * the receive_from function to receive data on an unconnected datagram
-   * socket.
-   *
-   * @par Example
-   * To receive into a single data buffer use the @ref buffer function as
-   * follows:
-   * @code socket.receive(asio::buffer(data, size)); @endcode
-   * See the @ref buffer documentation for information on receiving into
-   * multiple buffers in one go, and how to use it with arrays, boost::array or
-   * std::vector.
-   */
-  template <typename MutableBufferSequence>
-  std::size_t receive(const MutableBufferSequence& buffers)
-  {
-    asio::error_code ec;
-    std::size_t s = this->get_service().receive(
-        this->get_implementation(), buffers, 0, ec);
-    asio::detail::throw_error(ec, "receive");
-    return s;
-  }
-
-  /// Receive some data on a connected socket.
-  /**
-   * This function is used to receive data on the datagram socket. The function
-   * call will block until data has been received successfully or an error
-   * occurs.
-   *
-   * @param buffers One or more buffers into which the data will be received.
-   *
-   * @param flags Flags specifying how the receive call is to be made.
-   *
-   * @returns The number of bytes received.
-   *
-   * @throws asio::system_error Thrown on failure.
-   *
-   * @note The receive operation can only be used with a connected socket. Use
-   * the receive_from function to receive data on an unconnected datagram
-   * socket.
-   */
-  template <typename MutableBufferSequence>
-  std::size_t receive(const MutableBufferSequence& buffers,
-      socket_base::message_flags flags)
-  {
-    asio::error_code ec;
-    std::size_t s = this->get_service().receive(
-        this->get_implementation(), buffers, flags, ec);
-    asio::detail::throw_error(ec, "receive");
-    return s;
-  }
-
-  /// Receive some data on a connected socket.
-  /**
-   * This function is used to receive data on the datagram socket. The function
-   * call will block until data has been received successfully or an error
-   * occurs.
-   *
-   * @param buffers One or more buffers into which the data will be received.
-   *
-   * @param flags Flags specifying how the receive call is to be made.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   *
-   * @returns The number of bytes received.
-   *
-   * @note The receive operation can only be used with a connected socket. Use
-   * the receive_from function to receive data on an unconnected datagram
-   * socket.
-   */
-  template <typename MutableBufferSequence>
-  std::size_t receive(const MutableBufferSequence& buffers,
-      socket_base::message_flags flags, asio::error_code& ec)
-  {
-    return this->get_service().receive(
-        this->get_implementation(), buffers, flags, ec);
-  }
-
-  /// Start an asynchronous receive on a connected socket.
-  /**
-   * This function is used to asynchronously receive data from the datagram
-   * socket. The function call always returns immediately.
-   *
-   * @param buffers One or more buffers into which the data will be received.
-   * Although the buffers object may be copied as necessary, ownership of the
-   * underlying memory blocks is retained by the caller, which must guarantee
-   * that they remain valid until the handler is called.
-   *
-   * @param handler The handler to be called when the receive operation
-   * completes. Copies will be made of the handler as required. The function
-   * signature of the handler must be:
-   * @code void handler(
-   *   const asio::error_code& error, // Result of operation.
-   *   std::size_t bytes_transferred           // Number of bytes received.
-   * ); @endcode
-   * Regardless of whether the asynchronous operation completes immediately or
-   * not, the handler will not be invoked from within this function. Invocation
-   * of the handler will be performed in a manner equivalent to using
-   * asio::io_service::post().
-   *
-   * @note The async_receive operation can only be used with a connected socket.
-   * Use the async_receive_from function to receive data on an unconnected
-   * datagram socket.
-   *
-   * @par Example
-   * To receive into a single data buffer use the @ref buffer function as
-   * follows:
-   * @code
-   * socket.async_receive(asio::buffer(data, size), handler);
-   * @endcode
-   * See the @ref buffer documentation for information on receiving into
-   * multiple buffers in one go, and how to use it with arrays, boost::array or
-   * std::vector.
-   */
-  template <typename MutableBufferSequence, typename ReadHandler>
-  ASIO_INITFN_RESULT_TYPE(ReadHandler,
-      void (asio::error_code, std::size_t))
-  async_receive(const MutableBufferSequence& buffers,
-      ASIO_MOVE_ARG(ReadHandler) handler)
-  {
-    // If you get an error on the following line it means that your handler does
-    // not meet the documented type requirements for a ReadHandler.
-    ASIO_READ_HANDLER_CHECK(ReadHandler, handler) type_check;
-
-    return this->get_service().async_receive(this->get_implementation(),
-        buffers, 0, ASIO_MOVE_CAST(ReadHandler)(handler));
-  }
-
-  /// Start an asynchronous receive on a connected socket.
-  /**
-   * This function is used to asynchronously receive data from the datagram
-   * socket. The function call always returns immediately.
-   *
-   * @param buffers One or more buffers into which the data will be received.
-   * Although the buffers object may be copied as necessary, ownership of the
-   * underlying memory blocks is retained by the caller, which must guarantee
-   * that they remain valid until the handler is called.
-   *
-   * @param flags Flags specifying how the receive call is to be made.
-   *
-   * @param handler The handler to be called when the receive operation
-   * completes. Copies will be made of the handler as required. The function
-   * signature of the handler must be:
-   * @code void handler(
-   *   const asio::error_code& error, // Result of operation.
-   *   std::size_t bytes_transferred           // Number of bytes received.
-   * ); @endcode
-   * Regardless of whether the asynchronous operation completes immediately or
-   * not, the handler will not be invoked from within this function. Invocation
-   * of the handler will be performed in a manner equivalent to using
-   * asio::io_service::post().
-   *
-   * @note The async_receive operation can only be used with a connected socket.
-   * Use the async_receive_from function to receive data on an unconnected
-   * datagram socket.
-   */
-  template <typename MutableBufferSequence, typename ReadHandler>
-  ASIO_INITFN_RESULT_TYPE(ReadHandler,
-      void (asio::error_code, std::size_t))
-  async_receive(const MutableBufferSequence& buffers,
-      socket_base::message_flags flags,
-      ASIO_MOVE_ARG(ReadHandler) handler)
-  {
-    // If you get an error on the following line it means that your handler does
-    // not meet the documented type requirements for a ReadHandler.
-    ASIO_READ_HANDLER_CHECK(ReadHandler, handler) type_check;
-
-    return this->get_service().async_receive(this->get_implementation(),
-        buffers, flags, ASIO_MOVE_CAST(ReadHandler)(handler));
-  }
-
-  /// Receive a datagram with the endpoint of the sender.
-  /**
-   * This function is used to receive a datagram. The function call will block
-   * until data has been received successfully or an error occurs.
-   *
-   * @param buffers One or more buffers into which the data will be received.
-   *
-   * @param sender_endpoint An endpoint object that receives the endpoint of
-   * the remote sender of the datagram.
-   *
-   * @returns The number of bytes received.
-   *
-   * @throws asio::system_error Thrown on failure.
-   *
-   * @par Example
-   * To receive into a single data buffer use the @ref buffer function as
-   * follows:
-   * @code
-   * asio::ip::udp::endpoint sender_endpoint;
-   * socket.receive_from(
-   *     asio::buffer(data, size), sender_endpoint);
-   * @endcode
-   * See the @ref buffer documentation for information on receiving into
-   * multiple buffers in one go, and how to use it with arrays, boost::array or
-   * std::vector.
-   */
-  template <typename MutableBufferSequence>
-  std::size_t receive_from(const MutableBufferSequence& buffers,
-      endpoint_type& sender_endpoint)
-  {
-    asio::error_code ec;
-    std::size_t s = this->get_service().receive_from(
-        this->get_implementation(), buffers, sender_endpoint, 0, ec);
-    asio::detail::throw_error(ec, "receive_from");
-    return s;
-  }
-  
-  /// Receive a datagram with the endpoint of the sender.
-  /**
-   * This function is used to receive a datagram. The function call will block
-   * until data has been received successfully or an error occurs.
-   *
-   * @param buffers One or more buffers into which the data will be received.
-   *
-   * @param sender_endpoint An endpoint object that receives the endpoint of
-   * the remote sender of the datagram.
-   *
-   * @param flags Flags specifying how the receive call is to be made.
-   *
-   * @returns The number of bytes received.
-   *
-   * @throws asio::system_error Thrown on failure.
-   */
-  template <typename MutableBufferSequence>
-  std::size_t receive_from(const MutableBufferSequence& buffers,
-      endpoint_type& sender_endpoint, socket_base::message_flags flags)
-  {
-    asio::error_code ec;
-    std::size_t s = this->get_service().receive_from(
-        this->get_implementation(), buffers, sender_endpoint, flags, ec);
-    asio::detail::throw_error(ec, "receive_from");
-    return s;
-  }
-  
-  /// Receive a datagram with the endpoint of the sender.
-  /**
-   * This function is used to receive a datagram. The function call will block
-   * until data has been received successfully or an error occurs.
-   *
-   * @param buffers One or more buffers into which the data will be received.
-   *
-   * @param sender_endpoint An endpoint object that receives the endpoint of
-   * the remote sender of the datagram.
-   *
-   * @param flags Flags specifying how the receive call is to be made.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   *
-   * @returns The number of bytes received.
-   */
-  template <typename MutableBufferSequence>
-  std::size_t receive_from(const MutableBufferSequence& buffers,
-      endpoint_type& sender_endpoint, socket_base::message_flags flags,
-      asio::error_code& ec)
-  {
-    return this->get_service().receive_from(this->get_implementation(),
-        buffers, sender_endpoint, flags, ec);
-  }
-
-  /// Start an asynchronous receive.
-  /**
-   * This function is used to asynchronously receive a datagram. The function
-   * call always returns immediately.
-   *
-   * @param buffers One or more buffers into which the data will be received.
-   * Although the buffers object may be copied as necessary, ownership of the
-   * underlying memory blocks is retained by the caller, which must guarantee
-   * that they remain valid until the handler is called.
-   *
-   * @param sender_endpoint An endpoint object that receives the endpoint of
-   * the remote sender of the datagram. Ownership of the sender_endpoint object
-   * is retained by the caller, which must guarantee that it is valid until the
-   * handler is called.
-   *
-   * @param handler The handler to be called when the receive operation
-   * completes. Copies will be made of the handler as required. The function
-   * signature of the handler must be:
-   * @code void handler(
-   *   const asio::error_code& error, // Result of operation.
-   *   std::size_t bytes_transferred           // Number of bytes received.
-   * ); @endcode
-   * Regardless of whether the asynchronous operation completes immediately or
-   * not, the handler will not be invoked from within this function. Invocation
-   * of the handler will be performed in a manner equivalent to using
-   * asio::io_service::post().
-   *
-   * @par Example
-   * To receive into a single data buffer use the @ref buffer function as
-   * follows:
-   * @code socket.async_receive_from(
-   *     asio::buffer(data, size), sender_endpoint, handler); @endcode
-   * See the @ref buffer documentation for information on receiving into
-   * multiple buffers in one go, and how to use it with arrays, boost::array or
-   * std::vector.
-   */
-  template <typename MutableBufferSequence, typename ReadHandler>
-  ASIO_INITFN_RESULT_TYPE(ReadHandler,
-      void (asio::error_code, std::size_t))
-  async_receive_from(const MutableBufferSequence& buffers,
-      endpoint_type& sender_endpoint,
-      ASIO_MOVE_ARG(ReadHandler) handler)
-  {
-    // If you get an error on the following line it means that your handler does
-    // not meet the documented type requirements for a ReadHandler.
-    ASIO_READ_HANDLER_CHECK(ReadHandler, handler) type_check;
-
-    return this->get_service().async_receive_from(
-        this->get_implementation(), buffers, sender_endpoint, 0,
-        ASIO_MOVE_CAST(ReadHandler)(handler));
-  }
-
-  /// Start an asynchronous receive.
-  /**
-   * This function is used to asynchronously receive a datagram. The function
-   * call always returns immediately.
-   *
-   * @param buffers One or more buffers into which the data will be received.
-   * Although the buffers object may be copied as necessary, ownership of the
-   * underlying memory blocks is retained by the caller, which must guarantee
-   * that they remain valid until the handler is called.
-   *
-   * @param sender_endpoint An endpoint object that receives the endpoint of
-   * the remote sender of the datagram. Ownership of the sender_endpoint object
-   * is retained by the caller, which must guarantee that it is valid until the
-   * handler is called.
-   *
-   * @param flags Flags specifying how the receive call is to be made.
-   *
-   * @param handler The handler to be called when the receive operation
-   * completes. Copies will be made of the handler as required. The function
-   * signature of the handler must be:
-   * @code void handler(
-   *   const asio::error_code& error, // Result of operation.
-   *   std::size_t bytes_transferred           // Number of bytes received.
-   * ); @endcode
-   * Regardless of whether the asynchronous operation completes immediately or
-   * not, the handler will not be invoked from within this function. Invocation
-   * of the handler will be performed in a manner equivalent to using
-   * asio::io_service::post().
-   */
-  template <typename MutableBufferSequence, typename ReadHandler>
-  ASIO_INITFN_RESULT_TYPE(ReadHandler,
-      void (asio::error_code, std::size_t))
-  async_receive_from(const MutableBufferSequence& buffers,
-      endpoint_type& sender_endpoint, socket_base::message_flags flags,
-      ASIO_MOVE_ARG(ReadHandler) handler)
-  {
-    // If you get an error on the following line it means that your handler does
-    // not meet the documented type requirements for a ReadHandler.
-    ASIO_READ_HANDLER_CHECK(ReadHandler, handler) type_check;
-
-    return this->get_service().async_receive_from(
-        this->get_implementation(), buffers, sender_endpoint, flags,
-        ASIO_MOVE_CAST(ReadHandler)(handler));
-  }
-};
-
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_BASIC_DATAGRAM_SOCKET_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/basic_deadline_timer.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/basic_deadline_timer.hpp
deleted file mode 100644
index d0fc37150807..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/basic_deadline_timer.hpp
+++ /dev/null
@@ -1,520 +0,0 @@
-//
-// basic_deadline_timer.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_BASIC_DEADLINE_TIMER_HPP
-#define ASIO_BASIC_DEADLINE_TIMER_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_HAS_BOOST_DATE_TIME) \
-  || defined(ASIO_CPP11_DATE_TIME) \
-  || defined(GENERATING_DOCUMENTATION)
-
-#include <cstddef>
-#include "asio/basic_io_object.hpp"
-#include "asio/deadline_timer_service.hpp"
-#include "asio/detail/handler_type_requirements.hpp"
-#include "asio/detail/throw_error.hpp"
-#include "asio/error.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-
-/// Provides waitable timer functionality.
-/**
- * The basic_deadline_timer class template provides the ability to perform a
- * blocking or asynchronous wait for a timer to expire.
- *
- * A deadline timer is always in one of two states: "expired" or "not expired".
- * If the wait() or async_wait() function is called on an expired timer, the
- * wait operation will complete immediately.
- *
- * Most applications will use the asio::deadline_timer typedef.
- *
- * @par Thread Safety
- * @e Distinct @e objects: Safe.@n
- * @e Shared @e objects: Unsafe.
- *
- * @par Examples
- * Performing a blocking wait:
- * @code
- * // Construct a timer without setting an expiry time.
- * asio::deadline_timer timer(io_service);
- *
- * // Set an expiry time relative to now.
- * timer.expires_from_now(boost::posix_time::seconds(5));
- *
- * // Wait for the timer to expire.
- * timer.wait();
- * @endcode
- *
- * @par 
- * Performing an asynchronous wait:
- * @code
- * void handler(const asio::error_code& error)
- * {
- *   if (!error)
- *   {
- *     // Timer expired.
- *   }
- * }
- *
- * ...
- *
- * // Construct a timer with an absolute expiry time.
- * asio::deadline_timer timer(io_service,
- *     boost::posix_time::time_from_string("2005-12-07 23:59:59.000"));
- *
- * // Start an asynchronous wait.
- * timer.async_wait(handler);
- * @endcode
- *
- * @par Changing an active deadline_timer's expiry time
- *
- * Changing the expiry time of a timer while there are pending asynchronous
- * waits causes those wait operations to be cancelled. To ensure that the action
- * associated with the timer is performed only once, use something like this:
- * used:
- *
- * @code
- * void on_some_event()
- * {
- *   if (my_timer.expires_from_now(seconds(5)) > 0)
- *   {
- *     // We managed to cancel the timer. Start new asynchronous wait.
- *     my_timer.async_wait(on_timeout);
- *   }
- *   else
- *   {
- *     // Too late, timer has already expired!
- *   }
- * }
- *
- * void on_timeout(const asio::error_code& e)
- * {
- *   if (e != asio::error::operation_aborted)
- *   {
- *     // Timer was not cancelled, take necessary action.
- *   }
- * }
- * @endcode
- *
- * @li The asio::basic_deadline_timer::expires_from_now() function
- * cancels any pending asynchronous waits, and returns the number of
- * asynchronous waits that were cancelled. If it returns 0 then you were too
- * late and the wait handler has already been executed, or will soon be
- * executed. If it returns 1 then the wait handler was successfully cancelled.
- *
- * @li If a wait handler is cancelled, the asio::error_code passed to
- * it contains the value asio::error::operation_aborted.
- */
-template <typename Time,
-    typename TimeTraits = asio::time_traits<Time>,
-    typename TimerService = deadline_timer_service<Time, TimeTraits> >
-class basic_deadline_timer
-  : public basic_io_object<TimerService>
-{
-public:
-  /// The time traits type.
-  typedef TimeTraits traits_type;
-
-  /// The time type.
-  typedef typename traits_type::time_type time_type;
-
-  /// The duration type.
-  typedef typename traits_type::duration_type duration_type;
-
-  /// Constructor.
-  /**
-   * This constructor creates a timer without setting an expiry time. The
-   * expires_at() or expires_from_now() functions must be called to set an
-   * expiry time before the timer can be waited on.
-   *
-   * @param io_service The io_service object that the timer will use to dispatch
-   * handlers for any asynchronous operations performed on the timer.
-   */
-  explicit basic_deadline_timer(asio::io_service& io_service)
-    : basic_io_object<TimerService>(io_service)
-  {
-  }
-
-  /// Constructor to set a particular expiry time as an absolute time.
-  /**
-   * This constructor creates a timer and sets the expiry time.
-   *
-   * @param io_service The io_service object that the timer will use to dispatch
-   * handlers for any asynchronous operations performed on the timer.
-   *
-   * @param expiry_time The expiry time to be used for the timer, expressed
-   * as an absolute time.
-   */
-  basic_deadline_timer(asio::io_service& io_service,
-      const time_type& expiry_time)
-    : basic_io_object<TimerService>(io_service)
-  {
-    asio::error_code ec;
-    this->service.expires_at(this->implementation, expiry_time, ec);
-    asio::detail::throw_error(ec, "expires_at");
-  }
-
-  /// Constructor to set a particular expiry time relative to now.
-  /**
-   * This constructor creates a timer and sets the expiry time.
-   *
-   * @param io_service The io_service object that the timer will use to dispatch
-   * handlers for any asynchronous operations performed on the timer.
-   *
-   * @param expiry_time The expiry time to be used for the timer, relative to
-   * now.
-   */
-  basic_deadline_timer(asio::io_service& io_service,
-      const duration_type& expiry_time)
-    : basic_io_object<TimerService>(io_service)
-  {
-    asio::error_code ec;
-    this->service.expires_from_now(this->implementation, expiry_time, ec);
-    asio::detail::throw_error(ec, "expires_from_now");
-  }
-
-  /// Cancel any asynchronous operations that are waiting on the timer.
-  /**
-   * This function forces the completion of any pending asynchronous wait
-   * operations against the timer. The handler for each cancelled operation will
-   * be invoked with the asio::error::operation_aborted error code.
-   *
-   * Cancelling the timer does not change the expiry time.
-   *
-   * @return The number of asynchronous operations that were cancelled.
-   *
-   * @throws asio::system_error Thrown on failure.
-   *
-   * @note If the timer has already expired when cancel() is called, then the
-   * handlers for asynchronous wait operations will:
-   *
-   * @li have already been invoked; or
-   *
-   * @li have been queued for invocation in the near future.
-   *
-   * These handlers can no longer be cancelled, and therefore are passed an
-   * error code that indicates the successful completion of the wait operation.
-   */
-  std::size_t cancel()
-  {
-    asio::error_code ec;
-    std::size_t s = this->service.cancel(this->implementation, ec);
-    asio::detail::throw_error(ec, "cancel");
-    return s;
-  }
-
-  /// Cancel any asynchronous operations that are waiting on the timer.
-  /**
-   * This function forces the completion of any pending asynchronous wait
-   * operations against the timer. The handler for each cancelled operation will
-   * be invoked with the asio::error::operation_aborted error code.
-   *
-   * Cancelling the timer does not change the expiry time.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   *
-   * @return The number of asynchronous operations that were cancelled.
-   *
-   * @note If the timer has already expired when cancel() is called, then the
-   * handlers for asynchronous wait operations will:
-   *
-   * @li have already been invoked; or
-   *
-   * @li have been queued for invocation in the near future.
-   *
-   * These handlers can no longer be cancelled, and therefore are passed an
-   * error code that indicates the successful completion of the wait operation.
-   */
-  std::size_t cancel(asio::error_code& ec)
-  {
-    return this->service.cancel(this->implementation, ec);
-  }
-
-  /// Cancels one asynchronous operation that is waiting on the timer.
-  /**
-   * This function forces the completion of one pending asynchronous wait
-   * operation against the timer. Handlers are cancelled in FIFO order. The
-   * handler for the cancelled operation will be invoked with the
-   * asio::error::operation_aborted error code.
-   *
-   * Cancelling the timer does not change the expiry time.
-   *
-   * @return The number of asynchronous operations that were cancelled. That is,
-   * either 0 or 1.
-   *
-   * @throws asio::system_error Thrown on failure.
-   *
-   * @note If the timer has already expired when cancel_one() is called, then
-   * the handlers for asynchronous wait operations will:
-   *
-   * @li have already been invoked; or
-   *
-   * @li have been queued for invocation in the near future.
-   *
-   * These handlers can no longer be cancelled, and therefore are passed an
-   * error code that indicates the successful completion of the wait operation.
-   */
-  std::size_t cancel_one()
-  {
-    asio::error_code ec;
-    std::size_t s = this->service.cancel_one(this->implementation, ec);
-    asio::detail::throw_error(ec, "cancel_one");
-    return s;
-  }
-
-  /// Cancels one asynchronous operation that is waiting on the timer.
-  /**
-   * This function forces the completion of one pending asynchronous wait
-   * operation against the timer. Handlers are cancelled in FIFO order. The
-   * handler for the cancelled operation will be invoked with the
-   * asio::error::operation_aborted error code.
-   *
-   * Cancelling the timer does not change the expiry time.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   *
-   * @return The number of asynchronous operations that were cancelled. That is,
-   * either 0 or 1.
-   *
-   * @note If the timer has already expired when cancel_one() is called, then
-   * the handlers for asynchronous wait operations will:
-   *
-   * @li have already been invoked; or
-   *
-   * @li have been queued for invocation in the near future.
-   *
-   * These handlers can no longer be cancelled, and therefore are passed an
-   * error code that indicates the successful completion of the wait operation.
-   */
-  std::size_t cancel_one(asio::error_code& ec)
-  {
-    return this->service.cancel_one(this->implementation, ec);
-  }
-
-  /// Get the timer's expiry time as an absolute time.
-  /**
-   * This function may be used to obtain the timer's current expiry time.
-   * Whether the timer has expired or not does not affect this value.
-   */
-  time_type expires_at() const
-  {
-    return this->service.expires_at(this->implementation);
-  }
-
-  /// Set the timer's expiry time as an absolute time.
-  /**
-   * This function sets the expiry time. Any pending asynchronous wait
-   * operations will be cancelled. The handler for each cancelled operation will
-   * be invoked with the asio::error::operation_aborted error code.
-   *
-   * @param expiry_time The expiry time to be used for the timer.
-   *
-   * @return The number of asynchronous operations that were cancelled.
-   *
-   * @throws asio::system_error Thrown on failure.
-   *
-   * @note If the timer has already expired when expires_at() is called, then
-   * the handlers for asynchronous wait operations will:
-   *
-   * @li have already been invoked; or
-   *
-   * @li have been queued for invocation in the near future.
-   *
-   * These handlers can no longer be cancelled, and therefore are passed an
-   * error code that indicates the successful completion of the wait operation.
-   */
-  std::size_t expires_at(const time_type& expiry_time)
-  {
-    asio::error_code ec;
-    std::size_t s = this->service.expires_at(
-        this->implementation, expiry_time, ec);
-    asio::detail::throw_error(ec, "expires_at");
-    return s;
-  }
-
-  /// Set the timer's expiry time as an absolute time.
-  /**
-   * This function sets the expiry time. Any pending asynchronous wait
-   * operations will be cancelled. The handler for each cancelled operation will
-   * be invoked with the asio::error::operation_aborted error code.
-   *
-   * @param expiry_time The expiry time to be used for the timer.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   *
-   * @return The number of asynchronous operations that were cancelled.
-   *
-   * @note If the timer has already expired when expires_at() is called, then
-   * the handlers for asynchronous wait operations will:
-   *
-   * @li have already been invoked; or
-   *
-   * @li have been queued for invocation in the near future.
-   *
-   * These handlers can no longer be cancelled, and therefore are passed an
-   * error code that indicates the successful completion of the wait operation.
-   */
-  std::size_t expires_at(const time_type& expiry_time,
-      asio::error_code& ec)
-  {
-    return this->service.expires_at(this->implementation, expiry_time, ec);
-  }
-
-  /// Get the timer's expiry time relative to now.
-  /**
-   * This function may be used to obtain the timer's current expiry time.
-   * Whether the timer has expired or not does not affect this value.
-   */
-  duration_type expires_from_now() const
-  {
-    return this->service.expires_from_now(this->implementation);
-  }
-
-  /// Set the timer's expiry time relative to now.
-  /**
-   * This function sets the expiry time. Any pending asynchronous wait
-   * operations will be cancelled. The handler for each cancelled operation will
-   * be invoked with the asio::error::operation_aborted error code.
-   *
-   * @param expiry_time The expiry time to be used for the timer.
-   *
-   * @return The number of asynchronous operations that were cancelled.
-   *
-   * @throws asio::system_error Thrown on failure.
-   *
-   * @note If the timer has already expired when expires_from_now() is called,
-   * then the handlers for asynchronous wait operations will:
-   *
-   * @li have already been invoked; or
-   *
-   * @li have been queued for invocation in the near future.
-   *
-   * These handlers can no longer be cancelled, and therefore are passed an
-   * error code that indicates the successful completion of the wait operation.
-   */
-  std::size_t expires_from_now(const duration_type& expiry_time)
-  {
-    asio::error_code ec;
-    std::size_t s = this->service.expires_from_now(
-        this->implementation, expiry_time, ec);
-    asio::detail::throw_error(ec, "expires_from_now");
-    return s;
-  }
-
-  /// Set the timer's expiry time relative to now.
-  /**
-   * This function sets the expiry time. Any pending asynchronous wait
-   * operations will be cancelled. The handler for each cancelled operation will
-   * be invoked with the asio::error::operation_aborted error code.
-   *
-   * @param expiry_time The expiry time to be used for the timer.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   *
-   * @return The number of asynchronous operations that were cancelled.
-   *
-   * @note If the timer has already expired when expires_from_now() is called,
-   * then the handlers for asynchronous wait operations will:
-   *
-   * @li have already been invoked; or
-   *
-   * @li have been queued for invocation in the near future.
-   *
-   * These handlers can no longer be cancelled, and therefore are passed an
-   * error code that indicates the successful completion of the wait operation.
-   */
-  std::size_t expires_from_now(const duration_type& expiry_time,
-      asio::error_code& ec)
-  {
-    return this->service.expires_from_now(
-        this->implementation, expiry_time, ec);
-  }
-
-  /// Perform a blocking wait on the timer.
-  /**
-   * This function is used to wait for the timer to expire. This function
-   * blocks and does not return until the timer has expired.
-   *
-   * @throws asio::system_error Thrown on failure.
-   */
-  void wait()
-  {
-    asio::error_code ec;
-    this->service.wait(this->implementation, ec);
-    asio::detail::throw_error(ec, "wait");
-  }
-
-  /// Perform a blocking wait on the timer.
-  /**
-   * This function is used to wait for the timer to expire. This function
-   * blocks and does not return until the timer has expired.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   */
-  void wait(asio::error_code& ec)
-  {
-    this->service.wait(this->implementation, ec);
-  }
-
-  /// Start an asynchronous wait on the timer.
-  /**
-   * This function may be used to initiate an asynchronous wait against the
-   * timer. It always returns immediately.
-   *
-   * For each call to async_wait(), the supplied handler will be called exactly
-   * once. The handler will be called when:
-   *
-   * @li The timer has expired.
-   *
-   * @li The timer was cancelled, in which case the handler is passed the error
-   * code asio::error::operation_aborted.
-   *
-   * @param handler The handler to be called when the timer expires. Copies
-   * will be made of the handler as required. The function signature of the
-   * handler must be:
-   * @code void handler(
-   *   const asio::error_code& error // Result of operation.
-   * ); @endcode
-   * Regardless of whether the asynchronous operation completes immediately or
-   * not, the handler will not be invoked from within this function. Invocation
-   * of the handler will be performed in a manner equivalent to using
-   * asio::io_service::post().
-   */
-  template <typename WaitHandler>
-  ASIO_INITFN_RESULT_TYPE(WaitHandler,
-      void (asio::error_code))
-  async_wait(ASIO_MOVE_ARG(WaitHandler) handler)
-  {
-    // If you get an error on the following line it means that your handler does
-    // not meet the documented type requirements for a WaitHandler.
-    ASIO_WAIT_HANDLER_CHECK(WaitHandler, handler) type_check;
-
-    return this->service.async_wait(this->implementation,
-        ASIO_MOVE_CAST(WaitHandler)(handler));
-  }
-};
-
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // defined(ASIO_HAS_BOOST_DATE_TIME)
-       // || defined(ASIO_CPP11_DATE_TIME)
-       // || defined(GENERATING_DOCUMENTATION)
-
-#endif // ASIO_BASIC_DEADLINE_TIMER_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/basic_io_object.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/basic_io_object.hpp
deleted file mode 100644
index 6154d92f3616..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/basic_io_object.hpp
+++ /dev/null
@@ -1,240 +0,0 @@
-//
-// basic_io_object.hpp
-// ~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_BASIC_IO_OBJECT_HPP
-#define ASIO_BASIC_IO_OBJECT_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include "asio/io_service.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-
-#if defined(ASIO_HAS_MOVE)
-namespace detail
-{
-  // Type trait used to determine whether a service supports move.
-  template <typename IoObjectService>
-  class service_has_move
-  {
-  private:
-    typedef IoObjectService service_type;
-    typedef typename service_type::implementation_type implementation_type;
-
-    template <typename T, typename U>
-    static auto eval(T* t, U* u) -> decltype(t->move_construct(*u, *u), char());
-    static char (&eval(...))[2];
-
-  public:
-    static const bool value =
-      sizeof(service_has_move::eval(
-        static_cast<service_type*>(0),
-        static_cast<implementation_type*>(0))) == 1;
-  };
-}
-#endif // defined(ASIO_HAS_MOVE)
-
-/// Base class for all I/O objects.
-/**
- * @note All I/O objects are non-copyable. However, when using C++0x, certain
- * I/O objects do support move construction and move assignment.
- */
-#if !defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
-template <typename IoObjectService>
-#else
-template <typename IoObjectService,
-    bool Movable = detail::service_has_move<IoObjectService>::value>
-#endif
-class basic_io_object
-{
-public:
-  /// The type of the service that will be used to provide I/O operations.
-  typedef IoObjectService service_type;
-
-  /// The underlying implementation type of I/O object.
-  typedef typename service_type::implementation_type implementation_type;
-
-  /// Get the io_service associated with the object.
-  /**
-   * This function may be used to obtain the io_service object that the I/O
-   * object uses to dispatch handlers for asynchronous operations.
-   *
-   * @return A reference to the io_service object that the I/O object will use
-   * to dispatch handlers. Ownership is not transferred to the caller.
-   */
-  asio::io_service& get_io_service()
-  {
-    return service.get_io_service();
-  }
-
-protected:
-  /// Construct a basic_io_object.
-  /**
-   * Performs:
-   * @code get_service().construct(get_implementation()); @endcode
-   */
-  explicit basic_io_object(asio::io_service& io_service)
-    : service(asio::use_service<IoObjectService>(io_service))
-  {
-    service.construct(implementation);
-  }
-
-#if defined(GENERATING_DOCUMENTATION)
-  /// Move-construct a basic_io_object.
-  /**
-   * Performs:
-   * @code get_service().move_construct(
-   *     get_implementation(), other.get_implementation()); @endcode
-   *
-   * @note Available only for services that support movability,
-   */
-  basic_io_object(basic_io_object&& other);
-
-  /// Move-assign a basic_io_object.
-  /**
-   * Performs:
-   * @code get_service().move_assign(get_implementation(),
-   *     other.get_service(), other.get_implementation()); @endcode
-   *
-   * @note Available only for services that support movability,
-   */
-  basic_io_object& operator=(basic_io_object&& other);
-#endif // defined(GENERATING_DOCUMENTATION)
-
-  /// Protected destructor to prevent deletion through this type.
-  /**
-   * Performs:
-   * @code get_service().destroy(get_implementation()); @endcode
-   */
-  ~basic_io_object()
-  {
-    service.destroy(implementation);
-  }
-
-  /// Get the service associated with the I/O object.
-  service_type& get_service()
-  {
-    return service;
-  }
-
-  /// Get the service associated with the I/O object.
-  const service_type& get_service() const
-  {
-    return service;
-  }
-
-  /// (Deprecated: Use get_service().) The service associated with the I/O
-  /// object.
-  /**
-   * @note Available only for services that do not support movability.
-   */
-  service_type& service;
-
-  /// Get the underlying implementation of the I/O object.
-  implementation_type& get_implementation()
-  {
-    return implementation;
-  }
-
-  /// Get the underlying implementation of the I/O object.
-  const implementation_type& get_implementation() const
-  {
-    return implementation;
-  }
-
-  /// (Deprecated: Use get_implementation().) The underlying implementation of
-  /// the I/O object.
-  implementation_type implementation;
-
-private:
-  basic_io_object(const basic_io_object&);
-  basic_io_object& operator=(const basic_io_object&);
-};
-
-#if defined(ASIO_HAS_MOVE)
-// Specialisation for movable objects.
-template <typename IoObjectService>
-class basic_io_object<IoObjectService, true>
-{
-public:
-  typedef IoObjectService service_type;
-  typedef typename service_type::implementation_type implementation_type;
-
-  asio::io_service& get_io_service()
-  {
-    return service_->get_io_service();
-  }
-
-protected:
-  explicit basic_io_object(asio::io_service& io_service)
-    : service_(&asio::use_service<IoObjectService>(io_service))
-  {
-    service_->construct(implementation);
-  }
-
-  basic_io_object(basic_io_object&& other)
-    : service_(&other.get_service())
-  {
-    service_->move_construct(implementation, other.implementation);
-  }
-
-  ~basic_io_object()
-  {
-    service_->destroy(implementation);
-  }
-
-  basic_io_object& operator=(basic_io_object&& other)
-  {
-    service_->move_assign(implementation,
-        *other.service_, other.implementation);
-    service_ = other.service_;
-    return *this;
-  }
-
-  service_type& get_service()
-  {
-    return *service_;
-  }
-
-  const service_type& get_service() const
-  {
-    return *service_;
-  }
-
-  implementation_type& get_implementation()
-  {
-    return implementation;
-  }
-
-  const implementation_type& get_implementation() const
-  {
-    return implementation;
-  }
-
-  implementation_type implementation;
-
-private:
-  basic_io_object(const basic_io_object&);
-  void operator=(const basic_io_object&);
-
-  IoObjectService* service_;
-};
-#endif // defined(ASIO_HAS_MOVE)
-
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_BASIC_IO_OBJECT_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/basic_raw_socket.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/basic_raw_socket.hpp
deleted file mode 100644
index b0f3f186b2b5..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/basic_raw_socket.hpp
+++ /dev/null
@@ -1,940 +0,0 @@
-//
-// basic_raw_socket.hpp
-// ~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_BASIC_RAW_SOCKET_HPP
-#define ASIO_BASIC_RAW_SOCKET_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include <cstddef>
-#include "asio/basic_socket.hpp"
-#include "asio/detail/handler_type_requirements.hpp"
-#include "asio/detail/throw_error.hpp"
-#include "asio/detail/type_traits.hpp"
-#include "asio/error.hpp"
-#include "asio/raw_socket_service.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-
-/// Provides raw-oriented socket functionality.
-/**
- * The basic_raw_socket class template provides asynchronous and blocking
- * raw-oriented socket functionality.
- *
- * @par Thread Safety
- * @e Distinct @e objects: Safe.@n
- * @e Shared @e objects: Unsafe.
- */
-template <typename Protocol,
-    typename RawSocketService = raw_socket_service<Protocol> >
-class basic_raw_socket
-  : public basic_socket<Protocol, RawSocketService>
-{
-public:
-  /// (Deprecated: Use native_handle_type.) The native representation of a
-  /// socket.
-  typedef typename RawSocketService::native_handle_type native_type;
-
-  /// The native representation of a socket.
-  typedef typename RawSocketService::native_handle_type native_handle_type;
-
-  /// The protocol type.
-  typedef Protocol protocol_type;
-
-  /// The endpoint type.
-  typedef typename Protocol::endpoint endpoint_type;
-
-  /// Construct a basic_raw_socket without opening it.
-  /**
-   * This constructor creates a raw socket without opening it. The open()
-   * function must be called before data can be sent or received on the socket.
-   *
-   * @param io_service The io_service object that the raw socket will use
-   * to dispatch handlers for any asynchronous operations performed on the
-   * socket.
-   */
-  explicit basic_raw_socket(asio::io_service& io_service)
-    : basic_socket<Protocol, RawSocketService>(io_service)
-  {
-  }
-
-  /// Construct and open a basic_raw_socket.
-  /**
-   * This constructor creates and opens a raw socket.
-   *
-   * @param io_service The io_service object that the raw socket will use
-   * to dispatch handlers for any asynchronous operations performed on the
-   * socket.
-   *
-   * @param protocol An object specifying protocol parameters to be used.
-   *
-   * @throws asio::system_error Thrown on failure.
-   */
-  basic_raw_socket(asio::io_service& io_service,
-      const protocol_type& protocol)
-    : basic_socket<Protocol, RawSocketService>(io_service, protocol)
-  {
-  }
-
-  /// Construct a basic_raw_socket, opening it and binding it to the given
-  /// local endpoint.
-  /**
-   * This constructor creates a raw socket and automatically opens it bound
-   * to the specified endpoint on the local machine. The protocol used is the
-   * protocol associated with the given endpoint.
-   *
-   * @param io_service The io_service object that the raw socket will use
-   * to dispatch handlers for any asynchronous operations performed on the
-   * socket.
-   *
-   * @param endpoint An endpoint on the local machine to which the raw
-   * socket will be bound.
-   *
-   * @throws asio::system_error Thrown on failure.
-   */
-  basic_raw_socket(asio::io_service& io_service,
-      const endpoint_type& endpoint)
-    : basic_socket<Protocol, RawSocketService>(io_service, endpoint)
-  {
-  }
-
-  /// Construct a basic_raw_socket on an existing native socket.
-  /**
-   * This constructor creates a raw socket object to hold an existing
-   * native socket.
-   *
-   * @param io_service The io_service object that the raw socket will use
-   * to dispatch handlers for any asynchronous operations performed on the
-   * socket.
-   *
-   * @param protocol An object specifying protocol parameters to be used.
-   *
-   * @param native_socket The new underlying socket implementation.
-   *
-   * @throws asio::system_error Thrown on failure.
-   */
-  basic_raw_socket(asio::io_service& io_service,
-      const protocol_type& protocol, const native_handle_type& native_socket)
-    : basic_socket<Protocol, RawSocketService>(
-        io_service, protocol, native_socket)
-  {
-  }
-
-#if defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
-  /// Move-construct a basic_raw_socket from another.
-  /**
-   * This constructor moves a raw socket from one object to another.
-   *
-   * @param other The other basic_raw_socket object from which the move
-   * will occur.
-   *
-   * @note Following the move, the moved-from object is in the same state as if
-   * constructed using the @c basic_raw_socket(io_service&) constructor.
-   */
-  basic_raw_socket(basic_raw_socket&& other)
-    : basic_socket<Protocol, RawSocketService>(
-        ASIO_MOVE_CAST(basic_raw_socket)(other))
-  {
-  }
-
-  /// Move-assign a basic_raw_socket from another.
-  /**
-   * This assignment operator moves a raw socket from one object to another.
-   *
-   * @param other The other basic_raw_socket object from which the move
-   * will occur.
-   *
-   * @note Following the move, the moved-from object is in the same state as if
-   * constructed using the @c basic_raw_socket(io_service&) constructor.
-   */
-  basic_raw_socket& operator=(basic_raw_socket&& other)
-  {
-    basic_socket<Protocol, RawSocketService>::operator=(
-        ASIO_MOVE_CAST(basic_raw_socket)(other));
-    return *this;
-  }
-
-  /// Move-construct a basic_raw_socket from a socket of another protocol type.
-  /**
-   * This constructor moves a raw socket from one object to another.
-   *
-   * @param other The other basic_raw_socket object from which the move will
-   * occur.
-   *
-   * @note Following the move, the moved-from object is in the same state as if
-   * constructed using the @c basic_raw_socket(io_service&) constructor.
-   */
-  template <typename Protocol1, typename RawSocketService1>
-  basic_raw_socket(basic_raw_socket<Protocol1, RawSocketService1>&& other,
-      typename enable_if<is_convertible<Protocol1, Protocol>::value>::type* = 0)
-    : basic_socket<Protocol, RawSocketService>(
-        ASIO_MOVE_CAST2(basic_raw_socket<
-          Protocol1, RawSocketService1>)(other))
-  {
-  }
-
-  /// Move-assign a basic_raw_socket from a socket of another protocol type.
-  /**
-   * This assignment operator moves a raw socket from one object to another.
-   *
-   * @param other The other basic_raw_socket object from which the move
-   * will occur.
-   *
-   * @note Following the move, the moved-from object is in the same state as if
-   * constructed using the @c basic_raw_socket(io_service&) constructor.
-   */
-  template <typename Protocol1, typename RawSocketService1>
-  typename enable_if<is_convertible<Protocol1, Protocol>::value,
-      basic_raw_socket>::type& operator=(
-        basic_raw_socket<Protocol1, RawSocketService1>&& other)
-  {
-    basic_socket<Protocol, RawSocketService>::operator=(
-        ASIO_MOVE_CAST2(basic_raw_socket<
-          Protocol1, RawSocketService1>)(other));
-    return *this;
-  }
-#endif // defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
-
-  /// Send some data on a connected socket.
-  /**
-   * This function is used to send data on the raw socket. The function call
-   * will block until the data has been sent successfully or an error occurs.
-   *
-   * @param buffers One ore more data buffers to be sent on the socket.
-   *
-   * @returns The number of bytes sent.
-   *
-   * @throws asio::system_error Thrown on failure.
-   *
-   * @note The send operation can only be used with a connected socket. Use
-   * the send_to function to send data on an unconnected raw socket.
-   *
-   * @par Example
-   * To send a single data buffer use the @ref buffer function as follows:
-   * @code socket.send(asio::buffer(data, size)); @endcode
-   * See the @ref buffer documentation for information on sending multiple
-   * buffers in one go, and how to use it with arrays, boost::array or
-   * std::vector.
-   */
-  template <typename ConstBufferSequence>
-  std::size_t send(const ConstBufferSequence& buffers)
-  {
-    asio::error_code ec;
-    std::size_t s = this->get_service().send(
-        this->get_implementation(), buffers, 0, ec);
-    asio::detail::throw_error(ec, "send");
-    return s;
-  }
-
-  /// Send some data on a connected socket.
-  /**
-   * This function is used to send data on the raw socket. The function call
-   * will block until the data has been sent successfully or an error occurs.
-   *
-   * @param buffers One ore more data buffers to be sent on the socket.
-   *
-   * @param flags Flags specifying how the send call is to be made.
-   *
-   * @returns The number of bytes sent.
-   *
-   * @throws asio::system_error Thrown on failure.
-   *
-   * @note The send operation can only be used with a connected socket. Use
-   * the send_to function to send data on an unconnected raw socket.
-   */
-  template <typename ConstBufferSequence>
-  std::size_t send(const ConstBufferSequence& buffers,
-      socket_base::message_flags flags)
-  {
-    asio::error_code ec;
-    std::size_t s = this->get_service().send(
-        this->get_implementation(), buffers, flags, ec);
-    asio::detail::throw_error(ec, "send");
-    return s;
-  }
-
-  /// Send some data on a connected socket.
-  /**
-   * This function is used to send data on the raw socket. The function call
-   * will block until the data has been sent successfully or an error occurs.
-   *
-   * @param buffers One or more data buffers to be sent on the socket.
-   *
-   * @param flags Flags specifying how the send call is to be made.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   *
-   * @returns The number of bytes sent.
-   *
-   * @note The send operation can only be used with a connected socket. Use
-   * the send_to function to send data on an unconnected raw socket.
-   */
-  template <typename ConstBufferSequence>
-  std::size_t send(const ConstBufferSequence& buffers,
-      socket_base::message_flags flags, asio::error_code& ec)
-  {
-    return this->get_service().send(
-        this->get_implementation(), buffers, flags, ec);
-  }
-
-  /// Start an asynchronous send on a connected socket.
-  /**
-   * This function is used to send data on the raw socket. The function call
-   * will block until the data has been sent successfully or an error occurs.
-   *
-   * @param buffers One or more data buffers to be sent on the socket. Although
-   * the buffers object may be copied as necessary, ownership of the underlying
-   * memory blocks is retained by the caller, which must guarantee that they
-   * remain valid until the handler is called.
-   *
-   * @param handler The handler to be called when the send operation completes.
-   * Copies will be made of the handler as required. The function signature of
-   * the handler must be:
-   * @code void handler(
-   *   const asio::error_code& error, // Result of operation.
-   *   std::size_t bytes_transferred           // Number of bytes sent.
-   * ); @endcode
-   * Regardless of whether the asynchronous operation completes immediately or
-   * not, the handler will not be invoked from within this function. Invocation
-   * of the handler will be performed in a manner equivalent to using
-   * asio::io_service::post().
-   *
-   * @note The async_send operation can only be used with a connected socket.
-   * Use the async_send_to function to send data on an unconnected raw
-   * socket.
-   *
-   * @par Example
-   * To send a single data buffer use the @ref buffer function as follows:
-   * @code
-   * socket.async_send(asio::buffer(data, size), handler);
-   * @endcode
-   * See the @ref buffer documentation for information on sending multiple
-   * buffers in one go, and how to use it with arrays, boost::array or
-   * std::vector.
-   */
-  template <typename ConstBufferSequence, typename WriteHandler>
-  ASIO_INITFN_RESULT_TYPE(WriteHandler,
-      void (asio::error_code, std::size_t))
-  async_send(const ConstBufferSequence& buffers,
-      ASIO_MOVE_ARG(WriteHandler) handler)
-  {
-    // If you get an error on the following line it means that your handler does
-    // not meet the documented type requirements for a WriteHandler.
-    ASIO_WRITE_HANDLER_CHECK(WriteHandler, handler) type_check;
-
-    return this->get_service().async_send(this->get_implementation(),
-        buffers, 0, ASIO_MOVE_CAST(WriteHandler)(handler));
-  }
-
-  /// Start an asynchronous send on a connected socket.
-  /**
-   * This function is used to send data on the raw socket. The function call
-   * will block until the data has been sent successfully or an error occurs.
-   *
-   * @param buffers One or more data buffers to be sent on the socket. Although
-   * the buffers object may be copied as necessary, ownership of the underlying
-   * memory blocks is retained by the caller, which must guarantee that they
-   * remain valid until the handler is called.
-   *
-   * @param flags Flags specifying how the send call is to be made.
-   *
-   * @param handler The handler to be called when the send operation completes.
-   * Copies will be made of the handler as required. The function signature of
-   * the handler must be:
-   * @code void handler(
-   *   const asio::error_code& error, // Result of operation.
-   *   std::size_t bytes_transferred           // Number of bytes sent.
-   * ); @endcode
-   * Regardless of whether the asynchronous operation completes immediately or
-   * not, the handler will not be invoked from within this function. Invocation
-   * of the handler will be performed in a manner equivalent to using
-   * asio::io_service::post().
-   *
-   * @note The async_send operation can only be used with a connected socket.
-   * Use the async_send_to function to send data on an unconnected raw
-   * socket.
-   */
-  template <typename ConstBufferSequence, typename WriteHandler>
-  ASIO_INITFN_RESULT_TYPE(WriteHandler,
-      void (asio::error_code, std::size_t))
-  async_send(const ConstBufferSequence& buffers,
-      socket_base::message_flags flags,
-      ASIO_MOVE_ARG(WriteHandler) handler)
-  {
-    // If you get an error on the following line it means that your handler does
-    // not meet the documented type requirements for a WriteHandler.
-    ASIO_WRITE_HANDLER_CHECK(WriteHandler, handler) type_check;
-
-    return this->get_service().async_send(this->get_implementation(),
-        buffers, flags, ASIO_MOVE_CAST(WriteHandler)(handler));
-  }
-
-  /// Send raw data to the specified endpoint.
-  /**
-   * This function is used to send raw data to the specified remote endpoint.
-   * The function call will block until the data has been sent successfully or
-   * an error occurs.
-   *
-   * @param buffers One or more data buffers to be sent to the remote endpoint.
-   *
-   * @param destination The remote endpoint to which the data will be sent.
-   *
-   * @returns The number of bytes sent.
-   *
-   * @throws asio::system_error Thrown on failure.
-   *
-   * @par Example
-   * To send a single data buffer use the @ref buffer function as follows:
-   * @code
-   * asio::ip::udp::endpoint destination(
-   *     asio::ip::address::from_string("1.2.3.4"), 12345);
-   * socket.send_to(asio::buffer(data, size), destination);
-   * @endcode
-   * See the @ref buffer documentation for information on sending multiple
-   * buffers in one go, and how to use it with arrays, boost::array or
-   * std::vector.
-   */
-  template <typename ConstBufferSequence>
-  std::size_t send_to(const ConstBufferSequence& buffers,
-      const endpoint_type& destination)
-  {
-    asio::error_code ec;
-    std::size_t s = this->get_service().send_to(
-        this->get_implementation(), buffers, destination, 0, ec);
-    asio::detail::throw_error(ec, "send_to");
-    return s;
-  }
-
-  /// Send raw data to the specified endpoint.
-  /**
-   * This function is used to send raw data to the specified remote endpoint.
-   * The function call will block until the data has been sent successfully or
-   * an error occurs.
-   *
-   * @param buffers One or more data buffers to be sent to the remote endpoint.
-   *
-   * @param destination The remote endpoint to which the data will be sent.
-   *
-   * @param flags Flags specifying how the send call is to be made.
-   *
-   * @returns The number of bytes sent.
-   *
-   * @throws asio::system_error Thrown on failure.
-   */
-  template <typename ConstBufferSequence>
-  std::size_t send_to(const ConstBufferSequence& buffers,
-      const endpoint_type& destination, socket_base::message_flags flags)
-  {
-    asio::error_code ec;
-    std::size_t s = this->get_service().send_to(
-        this->get_implementation(), buffers, destination, flags, ec);
-    asio::detail::throw_error(ec, "send_to");
-    return s;
-  }
-
-  /// Send raw data to the specified endpoint.
-  /**
-   * This function is used to send raw data to the specified remote endpoint.
-   * The function call will block until the data has been sent successfully or
-   * an error occurs.
-   *
-   * @param buffers One or more data buffers to be sent to the remote endpoint.
-   *
-   * @param destination The remote endpoint to which the data will be sent.
-   *
-   * @param flags Flags specifying how the send call is to be made.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   *
-   * @returns The number of bytes sent.
-   */
-  template <typename ConstBufferSequence>
-  std::size_t send_to(const ConstBufferSequence& buffers,
-      const endpoint_type& destination, socket_base::message_flags flags,
-      asio::error_code& ec)
-  {
-    return this->get_service().send_to(this->get_implementation(),
-        buffers, destination, flags, ec);
-  }
-
-  /// Start an asynchronous send.
-  /**
-   * This function is used to asynchronously send raw data to the specified
-   * remote endpoint. The function call always returns immediately.
-   *
-   * @param buffers One or more data buffers to be sent to the remote endpoint.
-   * Although the buffers object may be copied as necessary, ownership of the
-   * underlying memory blocks is retained by the caller, which must guarantee
-   * that they remain valid until the handler is called.
-   *
-   * @param destination The remote endpoint to which the data will be sent.
-   * Copies will be made of the endpoint as required.
-   *
-   * @param handler The handler to be called when the send operation completes.
-   * Copies will be made of the handler as required. The function signature of
-   * the handler must be:
-   * @code void handler(
-   *   const asio::error_code& error, // Result of operation.
-   *   std::size_t bytes_transferred           // Number of bytes sent.
-   * ); @endcode
-   * Regardless of whether the asynchronous operation completes immediately or
-   * not, the handler will not be invoked from within this function. Invocation
-   * of the handler will be performed in a manner equivalent to using
-   * asio::io_service::post().
-   *
-   * @par Example
-   * To send a single data buffer use the @ref buffer function as follows:
-   * @code
-   * asio::ip::udp::endpoint destination(
-   *     asio::ip::address::from_string("1.2.3.4"), 12345);
-   * socket.async_send_to(
-   *     asio::buffer(data, size), destination, handler);
-   * @endcode
-   * See the @ref buffer documentation for information on sending multiple
-   * buffers in one go, and how to use it with arrays, boost::array or
-   * std::vector.
-   */
-  template <typename ConstBufferSequence, typename WriteHandler>
-  ASIO_INITFN_RESULT_TYPE(WriteHandler,
-      void (asio::error_code, std::size_t))
-  async_send_to(const ConstBufferSequence& buffers,
-      const endpoint_type& destination,
-      ASIO_MOVE_ARG(WriteHandler) handler)
-  {
-    // If you get an error on the following line it means that your handler does
-    // not meet the documented type requirements for a WriteHandler.
-    ASIO_WRITE_HANDLER_CHECK(WriteHandler, handler) type_check;
-
-    return this->get_service().async_send_to(this->get_implementation(),
-        buffers, destination, 0, ASIO_MOVE_CAST(WriteHandler)(handler));
-  }
-
-  /// Start an asynchronous send.
-  /**
-   * This function is used to asynchronously send raw data to the specified
-   * remote endpoint. The function call always returns immediately.
-   *
-   * @param buffers One or more data buffers to be sent to the remote endpoint.
-   * Although the buffers object may be copied as necessary, ownership of the
-   * underlying memory blocks is retained by the caller, which must guarantee
-   * that they remain valid until the handler is called.
-   *
-   * @param flags Flags specifying how the send call is to be made.
-   *
-   * @param destination The remote endpoint to which the data will be sent.
-   * Copies will be made of the endpoint as required.
-   *
-   * @param handler The handler to be called when the send operation completes.
-   * Copies will be made of the handler as required. The function signature of
-   * the handler must be:
-   * @code void handler(
-   *   const asio::error_code& error, // Result of operation.
-   *   std::size_t bytes_transferred           // Number of bytes sent.
-   * ); @endcode
-   * Regardless of whether the asynchronous operation completes immediately or
-   * not, the handler will not be invoked from within this function. Invocation
-   * of the handler will be performed in a manner equivalent to using
-   * asio::io_service::post().
-   */
-  template <typename ConstBufferSequence, typename WriteHandler>
-  ASIO_INITFN_RESULT_TYPE(WriteHandler,
-      void (asio::error_code, std::size_t))
-  async_send_to(const ConstBufferSequence& buffers,
-      const endpoint_type& destination, socket_base::message_flags flags,
-      ASIO_MOVE_ARG(WriteHandler) handler)
-  {
-    // If you get an error on the following line it means that your handler does
-    // not meet the documented type requirements for a WriteHandler.
-    ASIO_WRITE_HANDLER_CHECK(WriteHandler, handler) type_check;
-
-    return this->get_service().async_send_to(
-        this->get_implementation(), buffers, destination, flags,
-        ASIO_MOVE_CAST(WriteHandler)(handler));
-  }
-
-  /// Receive some data on a connected socket.
-  /**
-   * This function is used to receive data on the raw socket. The function
-   * call will block until data has been received successfully or an error
-   * occurs.
-   *
-   * @param buffers One or more buffers into which the data will be received.
-   *
-   * @returns The number of bytes received.
-   *
-   * @throws asio::system_error Thrown on failure.
-   *
-   * @note The receive operation can only be used with a connected socket. Use
-   * the receive_from function to receive data on an unconnected raw
-   * socket.
-   *
-   * @par Example
-   * To receive into a single data buffer use the @ref buffer function as
-   * follows:
-   * @code socket.receive(asio::buffer(data, size)); @endcode
-   * See the @ref buffer documentation for information on receiving into
-   * multiple buffers in one go, and how to use it with arrays, boost::array or
-   * std::vector.
-   */
-  template <typename MutableBufferSequence>
-  std::size_t receive(const MutableBufferSequence& buffers)
-  {
-    asio::error_code ec;
-    std::size_t s = this->get_service().receive(
-        this->get_implementation(), buffers, 0, ec);
-    asio::detail::throw_error(ec, "receive");
-    return s;
-  }
-
-  /// Receive some data on a connected socket.
-  /**
-   * This function is used to receive data on the raw socket. The function
-   * call will block until data has been received successfully or an error
-   * occurs.
-   *
-   * @param buffers One or more buffers into which the data will be received.
-   *
-   * @param flags Flags specifying how the receive call is to be made.
-   *
-   * @returns The number of bytes received.
-   *
-   * @throws asio::system_error Thrown on failure.
-   *
-   * @note The receive operation can only be used with a connected socket. Use
-   * the receive_from function to receive data on an unconnected raw
-   * socket.
-   */
-  template <typename MutableBufferSequence>
-  std::size_t receive(const MutableBufferSequence& buffers,
-      socket_base::message_flags flags)
-  {
-    asio::error_code ec;
-    std::size_t s = this->get_service().receive(
-        this->get_implementation(), buffers, flags, ec);
-    asio::detail::throw_error(ec, "receive");
-    return s;
-  }
-
-  /// Receive some data on a connected socket.
-  /**
-   * This function is used to receive data on the raw socket. The function
-   * call will block until data has been received successfully or an error
-   * occurs.
-   *
-   * @param buffers One or more buffers into which the data will be received.
-   *
-   * @param flags Flags specifying how the receive call is to be made.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   *
-   * @returns The number of bytes received.
-   *
-   * @note The receive operation can only be used with a connected socket. Use
-   * the receive_from function to receive data on an unconnected raw
-   * socket.
-   */
-  template <typename MutableBufferSequence>
-  std::size_t receive(const MutableBufferSequence& buffers,
-      socket_base::message_flags flags, asio::error_code& ec)
-  {
-    return this->get_service().receive(
-        this->get_implementation(), buffers, flags, ec);
-  }
-
-  /// Start an asynchronous receive on a connected socket.
-  /**
-   * This function is used to asynchronously receive data from the raw
-   * socket. The function call always returns immediately.
-   *
-   * @param buffers One or more buffers into which the data will be received.
-   * Although the buffers object may be copied as necessary, ownership of the
-   * underlying memory blocks is retained by the caller, which must guarantee
-   * that they remain valid until the handler is called.
-   *
-   * @param handler The handler to be called when the receive operation
-   * completes. Copies will be made of the handler as required. The function
-   * signature of the handler must be:
-   * @code void handler(
-   *   const asio::error_code& error, // Result of operation.
-   *   std::size_t bytes_transferred           // Number of bytes received.
-   * ); @endcode
-   * Regardless of whether the asynchronous operation completes immediately or
-   * not, the handler will not be invoked from within this function. Invocation
-   * of the handler will be performed in a manner equivalent to using
-   * asio::io_service::post().
-   *
-   * @note The async_receive operation can only be used with a connected socket.
-   * Use the async_receive_from function to receive data on an unconnected
-   * raw socket.
-   *
-   * @par Example
-   * To receive into a single data buffer use the @ref buffer function as
-   * follows:
-   * @code
-   * socket.async_receive(asio::buffer(data, size), handler);
-   * @endcode
-   * See the @ref buffer documentation for information on receiving into
-   * multiple buffers in one go, and how to use it with arrays, boost::array or
-   * std::vector.
-   */
-  template <typename MutableBufferSequence, typename ReadHandler>
-  ASIO_INITFN_RESULT_TYPE(ReadHandler,
-      void (asio::error_code, std::size_t))
-  async_receive(const MutableBufferSequence& buffers,
-      ASIO_MOVE_ARG(ReadHandler) handler)
-  {
-    // If you get an error on the following line it means that your handler does
-    // not meet the documented type requirements for a ReadHandler.
-    ASIO_READ_HANDLER_CHECK(ReadHandler, handler) type_check;
-
-    return this->get_service().async_receive(this->get_implementation(),
-        buffers, 0, ASIO_MOVE_CAST(ReadHandler)(handler));
-  }
-
-  /// Start an asynchronous receive on a connected socket.
-  /**
-   * This function is used to asynchronously receive data from the raw
-   * socket. The function call always returns immediately.
-   *
-   * @param buffers One or more buffers into which the data will be received.
-   * Although the buffers object may be copied as necessary, ownership of the
-   * underlying memory blocks is retained by the caller, which must guarantee
-   * that they remain valid until the handler is called.
-   *
-   * @param flags Flags specifying how the receive call is to be made.
-   *
-   * @param handler The handler to be called when the receive operation
-   * completes. Copies will be made of the handler as required. The function
-   * signature of the handler must be:
-   * @code void handler(
-   *   const asio::error_code& error, // Result of operation.
-   *   std::size_t bytes_transferred           // Number of bytes received.
-   * ); @endcode
-   * Regardless of whether the asynchronous operation completes immediately or
-   * not, the handler will not be invoked from within this function. Invocation
-   * of the handler will be performed in a manner equivalent to using
-   * asio::io_service::post().
-   *
-   * @note The async_receive operation can only be used with a connected socket.
-   * Use the async_receive_from function to receive data on an unconnected
-   * raw socket.
-   */
-  template <typename MutableBufferSequence, typename ReadHandler>
-  ASIO_INITFN_RESULT_TYPE(ReadHandler,
-      void (asio::error_code, std::size_t))
-  async_receive(const MutableBufferSequence& buffers,
-      socket_base::message_flags flags,
-      ASIO_MOVE_ARG(ReadHandler) handler)
-  {
-    // If you get an error on the following line it means that your handler does
-    // not meet the documented type requirements for a ReadHandler.
-    ASIO_READ_HANDLER_CHECK(ReadHandler, handler) type_check;
-
-    return this->get_service().async_receive(this->get_implementation(),
-        buffers, flags, ASIO_MOVE_CAST(ReadHandler)(handler));
-  }
-
-  /// Receive raw data with the endpoint of the sender.
-  /**
-   * This function is used to receive raw data. The function call will block
-   * until data has been received successfully or an error occurs.
-   *
-   * @param buffers One or more buffers into which the data will be received.
-   *
-   * @param sender_endpoint An endpoint object that receives the endpoint of
-   * the remote sender of the data.
-   *
-   * @returns The number of bytes received.
-   *
-   * @throws asio::system_error Thrown on failure.
-   *
-   * @par Example
-   * To receive into a single data buffer use the @ref buffer function as
-   * follows:
-   * @code
-   * asio::ip::udp::endpoint sender_endpoint;
-   * socket.receive_from(
-   *     asio::buffer(data, size), sender_endpoint);
-   * @endcode
-   * See the @ref buffer documentation for information on receiving into
-   * multiple buffers in one go, and how to use it with arrays, boost::array or
-   * std::vector.
-   */
-  template <typename MutableBufferSequence>
-  std::size_t receive_from(const MutableBufferSequence& buffers,
-      endpoint_type& sender_endpoint)
-  {
-    asio::error_code ec;
-    std::size_t s = this->get_service().receive_from(
-        this->get_implementation(), buffers, sender_endpoint, 0, ec);
-    asio::detail::throw_error(ec, "receive_from");
-    return s;
-  }
-  
-  /// Receive raw data with the endpoint of the sender.
-  /**
-   * This function is used to receive raw data. The function call will block
-   * until data has been received successfully or an error occurs.
-   *
-   * @param buffers One or more buffers into which the data will be received.
-   *
-   * @param sender_endpoint An endpoint object that receives the endpoint of
-   * the remote sender of the data.
-   *
-   * @param flags Flags specifying how the receive call is to be made.
-   *
-   * @returns The number of bytes received.
-   *
-   * @throws asio::system_error Thrown on failure.
-   */
-  template <typename MutableBufferSequence>
-  std::size_t receive_from(const MutableBufferSequence& buffers,
-      endpoint_type& sender_endpoint, socket_base::message_flags flags)
-  {
-    asio::error_code ec;
-    std::size_t s = this->get_service().receive_from(
-        this->get_implementation(), buffers, sender_endpoint, flags, ec);
-    asio::detail::throw_error(ec, "receive_from");
-    return s;
-  }
-  
-  /// Receive raw data with the endpoint of the sender.
-  /**
-   * This function is used to receive raw data. The function call will block
-   * until data has been received successfully or an error occurs.
-   *
-   * @param buffers One or more buffers into which the data will be received.
-   *
-   * @param sender_endpoint An endpoint object that receives the endpoint of
-   * the remote sender of the data.
-   *
-   * @param flags Flags specifying how the receive call is to be made.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   *
-   * @returns The number of bytes received.
-   */
-  template <typename MutableBufferSequence>
-  std::size_t receive_from(const MutableBufferSequence& buffers,
-      endpoint_type& sender_endpoint, socket_base::message_flags flags,
-      asio::error_code& ec)
-  {
-    return this->get_service().receive_from(this->get_implementation(),
-        buffers, sender_endpoint, flags, ec);
-  }
-
-  /// Start an asynchronous receive.
-  /**
-   * This function is used to asynchronously receive raw data. The function
-   * call always returns immediately.
-   *
-   * @param buffers One or more buffers into which the data will be received.
-   * Although the buffers object may be copied as necessary, ownership of the
-   * underlying memory blocks is retained by the caller, which must guarantee
-   * that they remain valid until the handler is called.
-   *
-   * @param sender_endpoint An endpoint object that receives the endpoint of
-   * the remote sender of the data. Ownership of the sender_endpoint object
-   * is retained by the caller, which must guarantee that it is valid until the
-   * handler is called.
-   *
-   * @param handler The handler to be called when the receive operation
-   * completes. Copies will be made of the handler as required. The function
-   * signature of the handler must be:
-   * @code void handler(
-   *   const asio::error_code& error, // Result of operation.
-   *   std::size_t bytes_transferred           // Number of bytes received.
-   * ); @endcode
-   * Regardless of whether the asynchronous operation completes immediately or
-   * not, the handler will not be invoked from within this function. Invocation
-   * of the handler will be performed in a manner equivalent to using
-   * asio::io_service::post().
-   *
-   * @par Example
-   * To receive into a single data buffer use the @ref buffer function as
-   * follows:
-   * @code socket.async_receive_from(
-   *     asio::buffer(data, size), 0, sender_endpoint, handler); @endcode
-   * See the @ref buffer documentation for information on receiving into
-   * multiple buffers in one go, and how to use it with arrays, boost::array or
-   * std::vector.
-   */
-  template <typename MutableBufferSequence, typename ReadHandler>
-  ASIO_INITFN_RESULT_TYPE(ReadHandler,
-      void (asio::error_code, std::size_t))
-  async_receive_from(const MutableBufferSequence& buffers,
-      endpoint_type& sender_endpoint,
-      ASIO_MOVE_ARG(ReadHandler) handler)
-  {
-    // If you get an error on the following line it means that your handler does
-    // not meet the documented type requirements for a ReadHandler.
-    ASIO_READ_HANDLER_CHECK(ReadHandler, handler) type_check;
-
-    return this->get_service().async_receive_from(
-        this->get_implementation(), buffers, sender_endpoint, 0,
-        ASIO_MOVE_CAST(ReadHandler)(handler));
-  }
-
-  /// Start an asynchronous receive.
-  /**
-   * This function is used to asynchronously receive raw data. The function
-   * call always returns immediately.
-   *
-   * @param buffers One or more buffers into which the data will be received.
-   * Although the buffers object may be copied as necessary, ownership of the
-   * underlying memory blocks is retained by the caller, which must guarantee
-   * that they remain valid until the handler is called.
-   *
-   * @param sender_endpoint An endpoint object that receives the endpoint of
-   * the remote sender of the data. Ownership of the sender_endpoint object
-   * is retained by the caller, which must guarantee that it is valid until the
-   * handler is called.
-   *
-   * @param flags Flags specifying how the receive call is to be made.
-   *
-   * @param handler The handler to be called when the receive operation
-   * completes. Copies will be made of the handler as required. The function
-   * signature of the handler must be:
-   * @code void handler(
-   *   const asio::error_code& error, // Result of operation.
-   *   std::size_t bytes_transferred           // Number of bytes received.
-   * ); @endcode
-   * Regardless of whether the asynchronous operation completes immediately or
-   * not, the handler will not be invoked from within this function. Invocation
-   * of the handler will be performed in a manner equivalent to using
-   * asio::io_service::post().
-   */
-  template <typename MutableBufferSequence, typename ReadHandler>
-  ASIO_INITFN_RESULT_TYPE(ReadHandler,
-      void (asio::error_code, std::size_t))
-  async_receive_from(const MutableBufferSequence& buffers,
-      endpoint_type& sender_endpoint, socket_base::message_flags flags,
-      ASIO_MOVE_ARG(ReadHandler) handler)
-  {
-    // If you get an error on the following line it means that your handler does
-    // not meet the documented type requirements for a ReadHandler.
-    ASIO_READ_HANDLER_CHECK(ReadHandler, handler) type_check;
-
-    return this->get_service().async_receive_from(
-        this->get_implementation(), buffers, sender_endpoint, flags,
-        ASIO_MOVE_CAST(ReadHandler)(handler));
-  }
-};
-
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_BASIC_RAW_SOCKET_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/basic_seq_packet_socket.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/basic_seq_packet_socket.hpp
deleted file mode 100644
index a3d720ebe0b8..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/basic_seq_packet_socket.hpp
+++ /dev/null
@@ -1,565 +0,0 @@
-//
-// basic_seq_packet_socket.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_BASIC_SEQ_PACKET_SOCKET_HPP
-#define ASIO_BASIC_SEQ_PACKET_SOCKET_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include <cstddef>
-#include "asio/basic_socket.hpp"
-#include "asio/detail/handler_type_requirements.hpp"
-#include "asio/detail/throw_error.hpp"
-#include "asio/error.hpp"
-#include "asio/seq_packet_socket_service.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-
-/// Provides sequenced packet socket functionality.
-/**
- * The basic_seq_packet_socket class template provides asynchronous and blocking
- * sequenced packet socket functionality.
- *
- * @par Thread Safety
- * @e Distinct @e objects: Safe.@n
- * @e Shared @e objects: Unsafe.
- */
-template <typename Protocol,
-    typename SeqPacketSocketService = seq_packet_socket_service<Protocol> >
-class basic_seq_packet_socket
-  : public basic_socket<Protocol, SeqPacketSocketService>
-{
-public:
-  /// (Deprecated: Use native_handle_type.) The native representation of a
-  /// socket.
-  typedef typename SeqPacketSocketService::native_handle_type native_type;
-
-  /// The native representation of a socket.
-  typedef typename SeqPacketSocketService::native_handle_type
-    native_handle_type;
-
-  /// The protocol type.
-  typedef Protocol protocol_type;
-
-  /// The endpoint type.
-  typedef typename Protocol::endpoint endpoint_type;
-
-  /// Construct a basic_seq_packet_socket without opening it.
-  /**
-   * This constructor creates a sequenced packet socket without opening it. The
-   * socket needs to be opened and then connected or accepted before data can
-   * be sent or received on it.
-   *
-   * @param io_service The io_service object that the sequenced packet socket
-   * will use to dispatch handlers for any asynchronous operations performed on
-   * the socket.
-   */
-  explicit basic_seq_packet_socket(asio::io_service& io_service)
-    : basic_socket<Protocol, SeqPacketSocketService>(io_service)
-  {
-  }
-
-  /// Construct and open a basic_seq_packet_socket.
-  /**
-   * This constructor creates and opens a sequenced_packet socket. The socket
-   * needs to be connected or accepted before data can be sent or received on
-   * it.
-   *
-   * @param io_service The io_service object that the sequenced packet socket
-   * will use to dispatch handlers for any asynchronous operations performed on
-   * the socket.
-   *
-   * @param protocol An object specifying protocol parameters to be used.
-   *
-   * @throws asio::system_error Thrown on failure.
-   */
-  basic_seq_packet_socket(asio::io_service& io_service,
-      const protocol_type& protocol)
-    : basic_socket<Protocol, SeqPacketSocketService>(io_service, protocol)
-  {
-  }
-
-  /// Construct a basic_seq_packet_socket, opening it and binding it to the
-  /// given local endpoint.
-  /**
-   * This constructor creates a sequenced packet socket and automatically opens
-   * it bound to the specified endpoint on the local machine. The protocol used
-   * is the protocol associated with the given endpoint.
-   *
-   * @param io_service The io_service object that the sequenced packet socket
-   * will use to dispatch handlers for any asynchronous operations performed on
-   * the socket.
-   *
-   * @param endpoint An endpoint on the local machine to which the sequenced
-   * packet socket will be bound.
-   *
-   * @throws asio::system_error Thrown on failure.
-   */
-  basic_seq_packet_socket(asio::io_service& io_service,
-      const endpoint_type& endpoint)
-    : basic_socket<Protocol, SeqPacketSocketService>(io_service, endpoint)
-  {
-  }
-
-  /// Construct a basic_seq_packet_socket on an existing native socket.
-  /**
-   * This constructor creates a sequenced packet socket object to hold an
-   * existing native socket.
-   *
-   * @param io_service The io_service object that the sequenced packet socket
-   * will use to dispatch handlers for any asynchronous operations performed on
-   * the socket.
-   *
-   * @param protocol An object specifying protocol parameters to be used.
-   *
-   * @param native_socket The new underlying socket implementation.
-   *
-   * @throws asio::system_error Thrown on failure.
-   */
-  basic_seq_packet_socket(asio::io_service& io_service,
-      const protocol_type& protocol, const native_handle_type& native_socket)
-    : basic_socket<Protocol, SeqPacketSocketService>(
-        io_service, protocol, native_socket)
-  {
-  }
-
-#if defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
-  /// Move-construct a basic_seq_packet_socket from another.
-  /**
-   * This constructor moves a sequenced packet socket from one object to
-   * another.
-   *
-   * @param other The other basic_seq_packet_socket object from which the move
-   * will occur.
-   *
-   * @note Following the move, the moved-from object is in the same state as if
-   * constructed using the @c basic_seq_packet_socket(io_service&) constructor.
-   */
-  basic_seq_packet_socket(basic_seq_packet_socket&& other)
-    : basic_socket<Protocol, SeqPacketSocketService>(
-        ASIO_MOVE_CAST(basic_seq_packet_socket)(other))
-  {
-  }
-
-  /// Move-assign a basic_seq_packet_socket from another.
-  /**
-   * This assignment operator moves a sequenced packet socket from one object to
-   * another.
-   *
-   * @param other The other basic_seq_packet_socket object from which the move
-   * will occur.
-   *
-   * @note Following the move, the moved-from object is in the same state as if
-   * constructed using the @c basic_seq_packet_socket(io_service&) constructor.
-   */
-  basic_seq_packet_socket& operator=(basic_seq_packet_socket&& other)
-  {
-    basic_socket<Protocol, SeqPacketSocketService>::operator=(
-        ASIO_MOVE_CAST(basic_seq_packet_socket)(other));
-    return *this;
-  }
-
-  /// Move-construct a basic_seq_packet_socket from a socket of another protocol
-  /// type.
-  /**
-   * This constructor moves a sequenced packet socket from one object to
-   * another.
-   *
-   * @param other The other basic_seq_packet_socket object from which the move
-   * will occur.
-   *
-   * @note Following the move, the moved-from object is in the same state as if
-   * constructed using the @c basic_seq_packet_socket(io_service&) constructor.
-   */
-  template <typename Protocol1, typename SeqPacketSocketService1>
-  basic_seq_packet_socket(
-      basic_seq_packet_socket<Protocol1, SeqPacketSocketService1>&& other,
-      typename enable_if<is_convertible<Protocol1, Protocol>::value>::type* = 0)
-    : basic_socket<Protocol, SeqPacketSocketService>(
-        ASIO_MOVE_CAST2(basic_seq_packet_socket<
-          Protocol1, SeqPacketSocketService1>)(other))
-  {
-  }
-
-  /// Move-assign a basic_seq_packet_socket from a socket of another protocol
-  /// type.
-  /**
-   * This assignment operator moves a sequenced packet socket from one object to
-   * another.
-   *
-   * @param other The other basic_seq_packet_socket object from which the move
-   * will occur.
-   *
-   * @note Following the move, the moved-from object is in the same state as if
-   * constructed using the @c basic_seq_packet_socket(io_service&) constructor.
-   */
-  template <typename Protocol1, typename SeqPacketSocketService1>
-  typename enable_if<is_convertible<Protocol1, Protocol>::value,
-      basic_seq_packet_socket>::type& operator=(
-        basic_seq_packet_socket<Protocol1, SeqPacketSocketService1>&& other)
-  {
-    basic_socket<Protocol, SeqPacketSocketService>::operator=(
-        ASIO_MOVE_CAST2(basic_seq_packet_socket<
-          Protocol1, SeqPacketSocketService1>)(other));
-    return *this;
-  }
-#endif // defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
-
-  /// Send some data on the socket.
-  /**
-   * This function is used to send data on the sequenced packet socket. The
-   * function call will block until the data has been sent successfully, or an
-   * until error occurs.
-   *
-   * @param buffers One or more data buffers to be sent on the socket.
-   *
-   * @param flags Flags specifying how the send call is to be made.
-   *
-   * @returns The number of bytes sent.
-   *
-   * @throws asio::system_error Thrown on failure.
-   *
-   * @par Example
-   * To send a single data buffer use the @ref buffer function as follows:
-   * @code
-   * socket.send(asio::buffer(data, size), 0);
-   * @endcode
-   * See the @ref buffer documentation for information on sending multiple
-   * buffers in one go, and how to use it with arrays, boost::array or
-   * std::vector.
-   */
-  template <typename ConstBufferSequence>
-  std::size_t send(const ConstBufferSequence& buffers,
-      socket_base::message_flags flags)
-  {
-    asio::error_code ec;
-    std::size_t s = this->get_service().send(
-        this->get_implementation(), buffers, flags, ec);
-    asio::detail::throw_error(ec, "send");
-    return s;
-  }
-
-  /// Send some data on the socket.
-  /**
-   * This function is used to send data on the sequenced packet socket. The
-   * function call will block the data has been sent successfully, or an until
-   * error occurs.
-   *
-   * @param buffers One or more data buffers to be sent on the socket.
-   *
-   * @param flags Flags specifying how the send call is to be made.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   *
-   * @returns The number of bytes sent. Returns 0 if an error occurred.
-   *
-   * @note The send operation may not transmit all of the data to the peer.
-   * Consider using the @ref write function if you need to ensure that all data
-   * is written before the blocking operation completes.
-   */
-  template <typename ConstBufferSequence>
-  std::size_t send(const ConstBufferSequence& buffers,
-      socket_base::message_flags flags, asio::error_code& ec)
-  {
-    return this->get_service().send(
-        this->get_implementation(), buffers, flags, ec);
-  }
-
-  /// Start an asynchronous send.
-  /**
-   * This function is used to asynchronously send data on the sequenced packet
-   * socket. The function call always returns immediately.
-   *
-   * @param buffers One or more data buffers to be sent on the socket. Although
-   * the buffers object may be copied as necessary, ownership of the underlying
-   * memory blocks is retained by the caller, which must guarantee that they
-   * remain valid until the handler is called.
-   *
-   * @param flags Flags specifying how the send call is to be made.
-   *
-   * @param handler The handler to be called when the send operation completes.
-   * Copies will be made of the handler as required. The function signature of
-   * the handler must be:
-   * @code void handler(
-   *   const asio::error_code& error, // Result of operation.
-   *   std::size_t bytes_transferred           // Number of bytes sent.
-   * ); @endcode
-   * Regardless of whether the asynchronous operation completes immediately or
-   * not, the handler will not be invoked from within this function. Invocation
-   * of the handler will be performed in a manner equivalent to using
-   * asio::io_service::post().
-   *
-   * @par Example
-   * To send a single data buffer use the @ref buffer function as follows:
-   * @code
-   * socket.async_send(asio::buffer(data, size), 0, handler);
-   * @endcode
-   * See the @ref buffer documentation for information on sending multiple
-   * buffers in one go, and how to use it with arrays, boost::array or
-   * std::vector.
-   */
-  template <typename ConstBufferSequence, typename WriteHandler>
-  ASIO_INITFN_RESULT_TYPE(WriteHandler,
-      void (asio::error_code, std::size_t))
-  async_send(const ConstBufferSequence& buffers,
-      socket_base::message_flags flags,
-      ASIO_MOVE_ARG(WriteHandler) handler)
-  {
-    // If you get an error on the following line it means that your handler does
-    // not meet the documented type requirements for a WriteHandler.
-    ASIO_WRITE_HANDLER_CHECK(WriteHandler, handler) type_check;
-
-    return this->get_service().async_send(this->get_implementation(),
-        buffers, flags, ASIO_MOVE_CAST(WriteHandler)(handler));
-  }
-
-  /// Receive some data on the socket.
-  /**
-   * This function is used to receive data on the sequenced packet socket. The
-   * function call will block until data has been received successfully, or
-   * until an error occurs.
-   *
-   * @param buffers One or more buffers into which the data will be received.
-   *
-   * @param out_flags After the receive call completes, contains flags
-   * associated with the received data. For example, if the
-   * socket_base::message_end_of_record bit is set then the received data marks
-   * the end of a record.
-   *
-   * @returns The number of bytes received.
-   *
-   * @throws asio::system_error Thrown on failure. An error code of
-   * asio::error::eof indicates that the connection was closed by the
-   * peer.
-   *
-   * @par Example
-   * To receive into a single data buffer use the @ref buffer function as
-   * follows:
-   * @code
-   * socket.receive(asio::buffer(data, size), out_flags);
-   * @endcode
-   * See the @ref buffer documentation for information on receiving into
-   * multiple buffers in one go, and how to use it with arrays, boost::array or
-   * std::vector.
-   */
-  template <typename MutableBufferSequence>
-  std::size_t receive(const MutableBufferSequence& buffers,
-      socket_base::message_flags& out_flags)
-  {
-    asio::error_code ec;
-    std::size_t s = this->get_service().receive(
-        this->get_implementation(), buffers, 0, out_flags, ec);
-    asio::detail::throw_error(ec, "receive");
-    return s;
-  }
-
-  /// Receive some data on the socket.
-  /**
-   * This function is used to receive data on the sequenced packet socket. The
-   * function call will block until data has been received successfully, or
-   * until an error occurs.
-   *
-   * @param buffers One or more buffers into which the data will be received.
-   *
-   * @param in_flags Flags specifying how the receive call is to be made.
-   *
-   * @param out_flags After the receive call completes, contains flags
-   * associated with the received data. For example, if the
-   * socket_base::message_end_of_record bit is set then the received data marks
-   * the end of a record.
-   *
-   * @returns The number of bytes received.
-   *
-   * @throws asio::system_error Thrown on failure. An error code of
-   * asio::error::eof indicates that the connection was closed by the
-   * peer.
-   *
-   * @note The receive operation may not receive all of the requested number of
-   * bytes. Consider using the @ref read function if you need to ensure that the
-   * requested amount of data is read before the blocking operation completes.
-   *
-   * @par Example
-   * To receive into a single data buffer use the @ref buffer function as
-   * follows:
-   * @code
-   * socket.receive(asio::buffer(data, size), 0, out_flags);
-   * @endcode
-   * See the @ref buffer documentation for information on receiving into
-   * multiple buffers in one go, and how to use it with arrays, boost::array or
-   * std::vector.
-   */
-  template <typename MutableBufferSequence>
-  std::size_t receive(const MutableBufferSequence& buffers,
-      socket_base::message_flags in_flags,
-      socket_base::message_flags& out_flags)
-  {
-    asio::error_code ec;
-    std::size_t s = this->get_service().receive(
-        this->get_implementation(), buffers, in_flags, out_flags, ec);
-    asio::detail::throw_error(ec, "receive");
-    return s;
-  }
-
-  /// Receive some data on a connected socket.
-  /**
-   * This function is used to receive data on the sequenced packet socket. The
-   * function call will block until data has been received successfully, or
-   * until an error occurs.
-   *
-   * @param buffers One or more buffers into which the data will be received.
-   *
-   * @param in_flags Flags specifying how the receive call is to be made.
-   *
-   * @param out_flags After the receive call completes, contains flags
-   * associated with the received data. For example, if the
-   * socket_base::message_end_of_record bit is set then the received data marks
-   * the end of a record.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   *
-   * @returns The number of bytes received. Returns 0 if an error occurred.
-   *
-   * @note The receive operation may not receive all of the requested number of
-   * bytes. Consider using the @ref read function if you need to ensure that the
-   * requested amount of data is read before the blocking operation completes.
-   */
-  template <typename MutableBufferSequence>
-  std::size_t receive(const MutableBufferSequence& buffers,
-      socket_base::message_flags in_flags,
-      socket_base::message_flags& out_flags, asio::error_code& ec)
-  {
-    return this->get_service().receive(this->get_implementation(),
-        buffers, in_flags, out_flags, ec);
-  }
-
-  /// Start an asynchronous receive.
-  /**
-   * This function is used to asynchronously receive data from the sequenced
-   * packet socket. The function call always returns immediately.
-   *
-   * @param buffers One or more buffers into which the data will be received.
-   * Although the buffers object may be copied as necessary, ownership of the
-   * underlying memory blocks is retained by the caller, which must guarantee
-   * that they remain valid until the handler is called.
-   *
-   * @param out_flags Once the asynchronous operation completes, contains flags
-   * associated with the received data. For example, if the
-   * socket_base::message_end_of_record bit is set then the received data marks
-   * the end of a record. The caller must guarantee that the referenced
-   * variable remains valid until the handler is called.
-   *
-   * @param handler The handler to be called when the receive operation
-   * completes. Copies will be made of the handler as required. The function
-   * signature of the handler must be:
-   * @code void handler(
-   *   const asio::error_code& error, // Result of operation.
-   *   std::size_t bytes_transferred           // Number of bytes received.
-   * ); @endcode
-   * Regardless of whether the asynchronous operation completes immediately or
-   * not, the handler will not be invoked from within this function. Invocation
-   * of the handler will be performed in a manner equivalent to using
-   * asio::io_service::post().
-   *
-   * @par Example
-   * To receive into a single data buffer use the @ref buffer function as
-   * follows:
-   * @code
-   * socket.async_receive(asio::buffer(data, size), out_flags, handler);
-   * @endcode
-   * See the @ref buffer documentation for information on receiving into
-   * multiple buffers in one go, and how to use it with arrays, boost::array or
-   * std::vector.
-   */
-  template <typename MutableBufferSequence, typename ReadHandler>
-  ASIO_INITFN_RESULT_TYPE(ReadHandler,
-      void (asio::error_code, std::size_t))
-  async_receive(const MutableBufferSequence& buffers,
-      socket_base::message_flags& out_flags,
-      ASIO_MOVE_ARG(ReadHandler) handler)
-  {
-    // If you get an error on the following line it means that your handler does
-    // not meet the documented type requirements for a ReadHandler.
-    ASIO_READ_HANDLER_CHECK(ReadHandler, handler) type_check;
-
-    return this->get_service().async_receive(
-        this->get_implementation(), buffers, 0, out_flags,
-        ASIO_MOVE_CAST(ReadHandler)(handler));
-  }
-
-  /// Start an asynchronous receive.
-  /**
-   * This function is used to asynchronously receive data from the sequenced
-   * data socket. The function call always returns immediately.
-   *
-   * @param buffers One or more buffers into which the data will be received.
-   * Although the buffers object may be copied as necessary, ownership of the
-   * underlying memory blocks is retained by the caller, which must guarantee
-   * that they remain valid until the handler is called.
-   *
-   * @param in_flags Flags specifying how the receive call is to be made.
-   *
-   * @param out_flags Once the asynchronous operation completes, contains flags
-   * associated with the received data. For example, if the
-   * socket_base::message_end_of_record bit is set then the received data marks
-   * the end of a record. The caller must guarantee that the referenced
-   * variable remains valid until the handler is called.
-   *
-   * @param handler The handler to be called when the receive operation
-   * completes. Copies will be made of the handler as required. The function
-   * signature of the handler must be:
-   * @code void handler(
-   *   const asio::error_code& error, // Result of operation.
-   *   std::size_t bytes_transferred           // Number of bytes received.
-   * ); @endcode
-   * Regardless of whether the asynchronous operation completes immediately or
-   * not, the handler will not be invoked from within this function. Invocation
-   * of the handler will be performed in a manner equivalent to using
-   * asio::io_service::post().
-   *
-   * @par Example
-   * To receive into a single data buffer use the @ref buffer function as
-   * follows:
-   * @code
-   * socket.async_receive(
-   *     asio::buffer(data, size),
-   *     0, out_flags, handler);
-   * @endcode
-   * See the @ref buffer documentation for information on receiving into
-   * multiple buffers in one go, and how to use it with arrays, boost::array or
-   * std::vector.
-   */
-  template <typename MutableBufferSequence, typename ReadHandler>
-  ASIO_INITFN_RESULT_TYPE(ReadHandler,
-      void (asio::error_code, std::size_t))
-  async_receive(const MutableBufferSequence& buffers,
-      socket_base::message_flags in_flags,
-      socket_base::message_flags& out_flags,
-      ASIO_MOVE_ARG(ReadHandler) handler)
-  {
-    // If you get an error on the following line it means that your handler does
-    // not meet the documented type requirements for a ReadHandler.
-    ASIO_READ_HANDLER_CHECK(ReadHandler, handler) type_check;
-
-    return this->get_service().async_receive(
-        this->get_implementation(), buffers, in_flags, out_flags,
-        ASIO_MOVE_CAST(ReadHandler)(handler));
-  }
-};
-
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_BASIC_SEQ_PACKET_SOCKET_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/basic_serial_port.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/basic_serial_port.hpp
deleted file mode 100644
index 007d293fed1d..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/basic_serial_port.hpp
+++ /dev/null
@@ -1,695 +0,0 @@
-//
-// basic_serial_port.hpp
-// ~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-// Copyright (c) 2008 Rep Invariant Systems, Inc. (info@repinvariant.com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_BASIC_SERIAL_PORT_HPP
-#define ASIO_BASIC_SERIAL_PORT_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_HAS_SERIAL_PORT) \
-  || defined(GENERATING_DOCUMENTATION)
-
-#include <string>
-#include "asio/basic_io_object.hpp"
-#include "asio/detail/handler_type_requirements.hpp"
-#include "asio/detail/throw_error.hpp"
-#include "asio/error.hpp"
-#include "asio/serial_port_base.hpp"
-#include "asio/serial_port_service.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-
-/// Provides serial port functionality.
-/**
- * The basic_serial_port class template provides functionality that is common
- * to all serial ports.
- *
- * @par Thread Safety
- * @e Distinct @e objects: Safe.@n
- * @e Shared @e objects: Unsafe.
- */
-template <typename SerialPortService = serial_port_service>
-class basic_serial_port
-  : public basic_io_object<SerialPortService>,
-    public serial_port_base
-{
-public:
-  /// (Deprecated: Use native_handle_type.) The native representation of a
-  /// serial port.
-  typedef typename SerialPortService::native_handle_type native_type;
-
-  /// The native representation of a serial port.
-  typedef typename SerialPortService::native_handle_type native_handle_type;
-
-  /// A basic_serial_port is always the lowest layer.
-  typedef basic_serial_port<SerialPortService> lowest_layer_type;
-
-  /// Construct a basic_serial_port without opening it.
-  /**
-   * This constructor creates a serial port without opening it.
-   *
-   * @param io_service The io_service object that the serial port will use to
-   * dispatch handlers for any asynchronous operations performed on the port.
-   */
-  explicit basic_serial_port(asio::io_service& io_service)
-    : basic_io_object<SerialPortService>(io_service)
-  {
-  }
-
-  /// Construct and open a basic_serial_port.
-  /**
-   * This constructor creates and opens a serial port for the specified device
-   * name.
-   *
-   * @param io_service The io_service object that the serial port will use to
-   * dispatch handlers for any asynchronous operations performed on the port.
-   *
-   * @param device The platform-specific device name for this serial
-   * port.
-   */
-  explicit basic_serial_port(asio::io_service& io_service,
-      const char* device)
-    : basic_io_object<SerialPortService>(io_service)
-  {
-    asio::error_code ec;
-    this->get_service().open(this->get_implementation(), device, ec);
-    asio::detail::throw_error(ec, "open");
-  }
-
-  /// Construct and open a basic_serial_port.
-  /**
-   * This constructor creates and opens a serial port for the specified device
-   * name.
-   *
-   * @param io_service The io_service object that the serial port will use to
-   * dispatch handlers for any asynchronous operations performed on the port.
-   *
-   * @param device The platform-specific device name for this serial
-   * port.
-   */
-  explicit basic_serial_port(asio::io_service& io_service,
-      const std::string& device)
-    : basic_io_object<SerialPortService>(io_service)
-  {
-    asio::error_code ec;
-    this->get_service().open(this->get_implementation(), device, ec);
-    asio::detail::throw_error(ec, "open");
-  }
-
-  /// Construct a basic_serial_port on an existing native serial port.
-  /**
-   * This constructor creates a serial port object to hold an existing native
-   * serial port.
-   *
-   * @param io_service The io_service object that the serial port will use to
-   * dispatch handlers for any asynchronous operations performed on the port.
-   *
-   * @param native_serial_port A native serial port.
-   *
-   * @throws asio::system_error Thrown on failure.
-   */
-  basic_serial_port(asio::io_service& io_service,
-      const native_handle_type& native_serial_port)
-    : basic_io_object<SerialPortService>(io_service)
-  {
-    asio::error_code ec;
-    this->get_service().assign(this->get_implementation(),
-        native_serial_port, ec);
-    asio::detail::throw_error(ec, "assign");
-  }
-
-#if defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
-  /// Move-construct a basic_serial_port from another.
-  /**
-   * This constructor moves a serial port from one object to another.
-   *
-   * @param other The other basic_serial_port object from which the move will
-   * occur.
-   *
-   * @note Following the move, the moved-from object is in the same state as if
-   * constructed using the @c basic_serial_port(io_service&) constructor.
-   */
-  basic_serial_port(basic_serial_port&& other)
-    : basic_io_object<SerialPortService>(
-        ASIO_MOVE_CAST(basic_serial_port)(other))
-  {
-  }
-
-  /// Move-assign a basic_serial_port from another.
-  /**
-   * This assignment operator moves a serial port from one object to another.
-   *
-   * @param other The other basic_serial_port object from which the move will
-   * occur.
-   *
-   * @note Following the move, the moved-from object is in the same state as if
-   * constructed using the @c basic_serial_port(io_service&) constructor.
-   */
-  basic_serial_port& operator=(basic_serial_port&& other)
-  {
-    basic_io_object<SerialPortService>::operator=(
-        ASIO_MOVE_CAST(basic_serial_port)(other));
-    return *this;
-  }
-#endif // defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
-
-  /// Get a reference to the lowest layer.
-  /**
-   * This function returns a reference to the lowest layer in a stack of
-   * layers. Since a basic_serial_port cannot contain any further layers, it
-   * simply returns a reference to itself.
-   *
-   * @return A reference to the lowest layer in the stack of layers. Ownership
-   * is not transferred to the caller.
-   */
-  lowest_layer_type& lowest_layer()
-  {
-    return *this;
-  }
-
-  /// Get a const reference to the lowest layer.
-  /**
-   * This function returns a const reference to the lowest layer in a stack of
-   * layers. Since a basic_serial_port cannot contain any further layers, it
-   * simply returns a reference to itself.
-   *
-   * @return A const reference to the lowest layer in the stack of layers.
-   * Ownership is not transferred to the caller.
-   */
-  const lowest_layer_type& lowest_layer() const
-  {
-    return *this;
-  }
-
-  /// Open the serial port using the specified device name.
-  /**
-   * This function opens the serial port for the specified device name.
-   *
-   * @param device The platform-specific device name.
-   *
-   * @throws asio::system_error Thrown on failure.
-   */
-  void open(const std::string& device)
-  {
-    asio::error_code ec;
-    this->get_service().open(this->get_implementation(), device, ec);
-    asio::detail::throw_error(ec, "open");
-  }
-
-  /// Open the serial port using the specified device name.
-  /**
-   * This function opens the serial port using the given platform-specific
-   * device name.
-   *
-   * @param device The platform-specific device name.
-   *
-   * @param ec Set the indicate what error occurred, if any.
-   */
-  asio::error_code open(const std::string& device,
-      asio::error_code& ec)
-  {
-    return this->get_service().open(this->get_implementation(), device, ec);
-  }
-
-  /// Assign an existing native serial port to the serial port.
-  /*
-   * This function opens the serial port to hold an existing native serial port.
-   *
-   * @param native_serial_port A native serial port.
-   *
-   * @throws asio::system_error Thrown on failure.
-   */
-  void assign(const native_handle_type& native_serial_port)
-  {
-    asio::error_code ec;
-    this->get_service().assign(this->get_implementation(),
-        native_serial_port, ec);
-    asio::detail::throw_error(ec, "assign");
-  }
-
-  /// Assign an existing native serial port to the serial port.
-  /*
-   * This function opens the serial port to hold an existing native serial port.
-   *
-   * @param native_serial_port A native serial port.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   */
-  asio::error_code assign(const native_handle_type& native_serial_port,
-      asio::error_code& ec)
-  {
-    return this->get_service().assign(this->get_implementation(),
-        native_serial_port, ec);
-  }
-
-  /// Determine whether the serial port is open.
-  bool is_open() const
-  {
-    return this->get_service().is_open(this->get_implementation());
-  }
-
-  /// Close the serial port.
-  /**
-   * This function is used to close the serial port. Any asynchronous read or
-   * write operations will be cancelled immediately, and will complete with the
-   * asio::error::operation_aborted error.
-   *
-   * @throws asio::system_error Thrown on failure.
-   */
-  void close()
-  {
-    asio::error_code ec;
-    this->get_service().close(this->get_implementation(), ec);
-    asio::detail::throw_error(ec, "close");
-  }
-
-  /// Close the serial port.
-  /**
-   * This function is used to close the serial port. Any asynchronous read or
-   * write operations will be cancelled immediately, and will complete with the
-   * asio::error::operation_aborted error.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   */
-  asio::error_code close(asio::error_code& ec)
-  {
-    return this->get_service().close(this->get_implementation(), ec);
-  }
-
-  /// (Deprecated: Use native_handle().) Get the native serial port
-  /// representation.
-  /**
-   * This function may be used to obtain the underlying representation of the
-   * serial port. This is intended to allow access to native serial port
-   * functionality that is not otherwise provided.
-   */
-  native_type native()
-  {
-    return this->get_service().native_handle(this->get_implementation());
-  }
-
-  /// Get the native serial port representation.
-  /**
-   * This function may be used to obtain the underlying representation of the
-   * serial port. This is intended to allow access to native serial port
-   * functionality that is not otherwise provided.
-   */
-  native_handle_type native_handle()
-  {
-    return this->get_service().native_handle(this->get_implementation());
-  }
-
-  /// Cancel all asynchronous operations associated with the serial port.
-  /**
-   * This function causes all outstanding asynchronous read or write operations
-   * to finish immediately, and the handlers for cancelled operations will be
-   * passed the asio::error::operation_aborted error.
-   *
-   * @throws asio::system_error Thrown on failure.
-   */
-  void cancel()
-  {
-    asio::error_code ec;
-    this->get_service().cancel(this->get_implementation(), ec);
-    asio::detail::throw_error(ec, "cancel");
-  }
-
-  /// Cancel all asynchronous operations associated with the serial port.
-  /**
-   * This function causes all outstanding asynchronous read or write operations
-   * to finish immediately, and the handlers for cancelled operations will be
-   * passed the asio::error::operation_aborted error.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   */
-  asio::error_code cancel(asio::error_code& ec)
-  {
-    return this->get_service().cancel(this->get_implementation(), ec);
-  }
-
-  /// Send a break sequence to the serial port.
-  /**
-   * This function causes a break sequence of platform-specific duration to be
-   * sent out the serial port.
-   *
-   * @throws asio::system_error Thrown on failure.
-   */
-  void send_break()
-  {
-    asio::error_code ec;
-    this->get_service().send_break(this->get_implementation(), ec);
-    asio::detail::throw_error(ec, "send_break");
-  }
-
-  /// Send a break sequence to the serial port.
-  /**
-   * This function causes a break sequence of platform-specific duration to be
-   * sent out the serial port.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   */
-  asio::error_code send_break(asio::error_code& ec)
-  {
-    return this->get_service().send_break(this->get_implementation(), ec);
-  }
-
-  /// Set an option on the serial port.
-  /**
-   * This function is used to set an option on the serial port.
-   *
-   * @param option The option value to be set on the serial port.
-   *
-   * @throws asio::system_error Thrown on failure.
-   *
-   * @sa SettableSerialPortOption @n
-   * asio::serial_port_base::baud_rate @n
-   * asio::serial_port_base::flow_control @n
-   * asio::serial_port_base::parity @n
-   * asio::serial_port_base::stop_bits @n
-   * asio::serial_port_base::character_size
-   */
-  template <typename SettableSerialPortOption>
-  void set_option(const SettableSerialPortOption& option)
-  {
-    asio::error_code ec;
-    this->get_service().set_option(this->get_implementation(), option, ec);
-    asio::detail::throw_error(ec, "set_option");
-  }
-
-  /// Set an option on the serial port.
-  /**
-   * This function is used to set an option on the serial port.
-   *
-   * @param option The option value to be set on the serial port.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   *
-   * @sa SettableSerialPortOption @n
-   * asio::serial_port_base::baud_rate @n
-   * asio::serial_port_base::flow_control @n
-   * asio::serial_port_base::parity @n
-   * asio::serial_port_base::stop_bits @n
-   * asio::serial_port_base::character_size
-   */
-  template <typename SettableSerialPortOption>
-  asio::error_code set_option(const SettableSerialPortOption& option,
-      asio::error_code& ec)
-  {
-    return this->get_service().set_option(
-        this->get_implementation(), option, ec);
-  }
-
-  /// Get an option from the serial port.
-  /**
-   * This function is used to get the current value of an option on the serial
-   * port.
-   *
-   * @param option The option value to be obtained from the serial port.
-   *
-   * @throws asio::system_error Thrown on failure.
-   *
-   * @sa GettableSerialPortOption @n
-   * asio::serial_port_base::baud_rate @n
-   * asio::serial_port_base::flow_control @n
-   * asio::serial_port_base::parity @n
-   * asio::serial_port_base::stop_bits @n
-   * asio::serial_port_base::character_size
-   */
-  template <typename GettableSerialPortOption>
-  void get_option(GettableSerialPortOption& option)
-  {
-    asio::error_code ec;
-    this->get_service().get_option(this->get_implementation(), option, ec);
-    asio::detail::throw_error(ec, "get_option");
-  }
-
-  /// Get an option from the serial port.
-  /**
-   * This function is used to get the current value of an option on the serial
-   * port.
-   *
-   * @param option The option value to be obtained from the serial port.
-   *
-   * @param ec Set to indicate what error occured, if any.
-   *
-   * @sa GettableSerialPortOption @n
-   * asio::serial_port_base::baud_rate @n
-   * asio::serial_port_base::flow_control @n
-   * asio::serial_port_base::parity @n
-   * asio::serial_port_base::stop_bits @n
-   * asio::serial_port_base::character_size
-   */
-  template <typename GettableSerialPortOption>
-  asio::error_code get_option(GettableSerialPortOption& option,
-      asio::error_code& ec)
-  {
-    return this->get_service().get_option(
-        this->get_implementation(), option, ec);
-  }
-
-  /// Write some data to the serial port.
-  /**
-   * This function is used to write data to the serial port. The function call
-   * will block until one or more bytes of the data has been written
-   * successfully, or until an error occurs.
-   *
-   * @param buffers One or more data buffers to be written to the serial port.
-   *
-   * @returns The number of bytes written.
-   *
-   * @throws asio::system_error Thrown on failure. An error code of
-   * asio::error::eof indicates that the connection was closed by the
-   * peer.
-   *
-   * @note The write_some operation may not transmit all of the data to the
-   * peer. Consider using the @ref write function if you need to ensure that
-   * all data is written before the blocking operation completes.
-   *
-   * @par Example
-   * To write a single data buffer use the @ref buffer function as follows:
-   * @code
-   * serial_port.write_some(asio::buffer(data, size));
-   * @endcode
-   * See the @ref buffer documentation for information on writing multiple
-   * buffers in one go, and how to use it with arrays, boost::array or
-   * std::vector.
-   */
-  template <typename ConstBufferSequence>
-  std::size_t write_some(const ConstBufferSequence& buffers)
-  {
-    asio::error_code ec;
-    std::size_t s = this->get_service().write_some(
-        this->get_implementation(), buffers, ec);
-    asio::detail::throw_error(ec, "write_some");
-    return s;
-  }
-
-  /// Write some data to the serial port.
-  /**
-   * This function is used to write data to the serial port. The function call
-   * will block until one or more bytes of the data has been written
-   * successfully, or until an error occurs.
-   *
-   * @param buffers One or more data buffers to be written to the serial port.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   *
-   * @returns The number of bytes written. Returns 0 if an error occurred.
-   *
-   * @note The write_some operation may not transmit all of the data to the
-   * peer. Consider using the @ref write function if you need to ensure that
-   * all data is written before the blocking operation completes.
-   */
-  template <typename ConstBufferSequence>
-  std::size_t write_some(const ConstBufferSequence& buffers,
-      asio::error_code& ec)
-  {
-    return this->get_service().write_some(
-        this->get_implementation(), buffers, ec);
-  }
-
-  /// Start an asynchronous write.
-  /**
-   * This function is used to asynchronously write data to the serial port.
-   * The function call always returns immediately.
-   *
-   * @param buffers One or more data buffers to be written to the serial port.
-   * Although the buffers object may be copied as necessary, ownership of the
-   * underlying memory blocks is retained by the caller, which must guarantee
-   * that they remain valid until the handler is called.
-   *
-   * @param handler The handler to be called when the write operation completes.
-   * Copies will be made of the handler as required. The function signature of
-   * the handler must be:
-   * @code void handler(
-   *   const asio::error_code& error, // Result of operation.
-   *   std::size_t bytes_transferred           // Number of bytes written.
-   * ); @endcode
-   * Regardless of whether the asynchronous operation completes immediately or
-   * not, the handler will not be invoked from within this function. Invocation
-   * of the handler will be performed in a manner equivalent to using
-   * asio::io_service::post().
-   *
-   * @note The write operation may not transmit all of the data to the peer.
-   * Consider using the @ref async_write function if you need to ensure that all
-   * data is written before the asynchronous operation completes.
-   *
-   * @par Example
-   * To write a single data buffer use the @ref buffer function as follows:
-   * @code
-   * serial_port.async_write_some(asio::buffer(data, size), handler);
-   * @endcode
-   * See the @ref buffer documentation for information on writing multiple
-   * buffers in one go, and how to use it with arrays, boost::array or
-   * std::vector.
-   */
-  template <typename ConstBufferSequence, typename WriteHandler>
-  ASIO_INITFN_RESULT_TYPE(WriteHandler,
-      void (asio::error_code, std::size_t))
-  async_write_some(const ConstBufferSequence& buffers,
-      ASIO_MOVE_ARG(WriteHandler) handler)
-  {
-    // If you get an error on the following line it means that your handler does
-    // not meet the documented type requirements for a WriteHandler.
-    ASIO_WRITE_HANDLER_CHECK(WriteHandler, handler) type_check;
-
-    return this->get_service().async_write_some(this->get_implementation(),
-        buffers, ASIO_MOVE_CAST(WriteHandler)(handler));
-  }
-
-  /// Read some data from the serial port.
-  /**
-   * This function is used to read data from the serial port. The function
-   * call will block until one or more bytes of data has been read successfully,
-   * or until an error occurs.
-   *
-   * @param buffers One or more buffers into which the data will be read.
-   *
-   * @returns The number of bytes read.
-   *
-   * @throws asio::system_error Thrown on failure. An error code of
-   * asio::error::eof indicates that the connection was closed by the
-   * peer.
-   *
-   * @note The read_some operation may not read all of the requested number of
-   * bytes. Consider using the @ref read function if you need to ensure that
-   * the requested amount of data is read before the blocking operation
-   * completes.
-   *
-   * @par Example
-   * To read into a single data buffer use the @ref buffer function as follows:
-   * @code
-   * serial_port.read_some(asio::buffer(data, size));
-   * @endcode
-   * See the @ref buffer documentation for information on reading into multiple
-   * buffers in one go, and how to use it with arrays, boost::array or
-   * std::vector.
-   */
-  template <typename MutableBufferSequence>
-  std::size_t read_some(const MutableBufferSequence& buffers)
-  {
-    asio::error_code ec;
-    std::size_t s = this->get_service().read_some(
-        this->get_implementation(), buffers, ec);
-    asio::detail::throw_error(ec, "read_some");
-    return s;
-  }
-
-  /// Read some data from the serial port.
-  /**
-   * This function is used to read data from the serial port. The function
-   * call will block until one or more bytes of data has been read successfully,
-   * or until an error occurs.
-   *
-   * @param buffers One or more buffers into which the data will be read.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   *
-   * @returns The number of bytes read. Returns 0 if an error occurred.
-   *
-   * @note The read_some operation may not read all of the requested number of
-   * bytes. Consider using the @ref read function if you need to ensure that
-   * the requested amount of data is read before the blocking operation
-   * completes.
-   */
-  template <typename MutableBufferSequence>
-  std::size_t read_some(const MutableBufferSequence& buffers,
-      asio::error_code& ec)
-  {
-    return this->get_service().read_some(
-        this->get_implementation(), buffers, ec);
-  }
-
-  /// Start an asynchronous read.
-  /**
-   * This function is used to asynchronously read data from the serial port.
-   * The function call always returns immediately.
-   *
-   * @param buffers One or more buffers into which the data will be read.
-   * Although the buffers object may be copied as necessary, ownership of the
-   * underlying memory blocks is retained by the caller, which must guarantee
-   * that they remain valid until the handler is called.
-   *
-   * @param handler The handler to be called when the read operation completes.
-   * Copies will be made of the handler as required. The function signature of
-   * the handler must be:
-   * @code void handler(
-   *   const asio::error_code& error, // Result of operation.
-   *   std::size_t bytes_transferred           // Number of bytes read.
-   * ); @endcode
-   * Regardless of whether the asynchronous operation completes immediately or
-   * not, the handler will not be invoked from within this function. Invocation
-   * of the handler will be performed in a manner equivalent to using
-   * asio::io_service::post().
-   *
-   * @note The read operation may not read all of the requested number of bytes.
-   * Consider using the @ref async_read function if you need to ensure that the
-   * requested amount of data is read before the asynchronous operation
-   * completes.
-   *
-   * @par Example
-   * To read into a single data buffer use the @ref buffer function as follows:
-   * @code
-   * serial_port.async_read_some(asio::buffer(data, size), handler);
-   * @endcode
-   * See the @ref buffer documentation for information on reading into multiple
-   * buffers in one go, and how to use it with arrays, boost::array or
-   * std::vector.
-   */
-  template <typename MutableBufferSequence, typename ReadHandler>
-  ASIO_INITFN_RESULT_TYPE(ReadHandler,
-      void (asio::error_code, std::size_t))
-  async_read_some(const MutableBufferSequence& buffers,
-      ASIO_MOVE_ARG(ReadHandler) handler)
-  {
-    // If you get an error on the following line it means that your handler does
-    // not meet the documented type requirements for a ReadHandler.
-    ASIO_READ_HANDLER_CHECK(ReadHandler, handler) type_check;
-
-    return this->get_service().async_read_some(this->get_implementation(),
-        buffers, ASIO_MOVE_CAST(ReadHandler)(handler));
-  }
-};
-
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // defined(ASIO_HAS_SERIAL_PORT)
-       //   || defined(GENERATING_DOCUMENTATION)
-
-#endif // ASIO_BASIC_SERIAL_PORT_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/basic_signal_set.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/basic_signal_set.hpp
deleted file mode 100644
index 2dd71ceec701..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/basic_signal_set.hpp
+++ /dev/null
@@ -1,384 +0,0 @@
-//
-// basic_signal_set.hpp
-// ~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_BASIC_SIGNAL_SET_HPP
-#define ASIO_BASIC_SIGNAL_SET_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#include "asio/basic_io_object.hpp"
-#include "asio/detail/handler_type_requirements.hpp"
-#include "asio/detail/throw_error.hpp"
-#include "asio/error.hpp"
-#include "asio/signal_set_service.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-
-/// Provides signal functionality.
-/**
- * The basic_signal_set class template provides the ability to perform an
- * asynchronous wait for one or more signals to occur.
- *
- * Most applications will use the asio::signal_set typedef.
- *
- * @par Thread Safety
- * @e Distinct @e objects: Safe.@n
- * @e Shared @e objects: Unsafe.
- *
- * @par Example
- * Performing an asynchronous wait:
- * @code
- * void handler(
- *     const asio::error_code& error,
- *     int signal_number)
- * {
- *   if (!error)
- *   {
- *     // A signal occurred.
- *   }
- * }
- *
- * ...
- *
- * // Construct a signal set registered for process termination.
- * asio::signal_set signals(io_service, SIGINT, SIGTERM);
- *
- * // Start an asynchronous wait for one of the signals to occur.
- * signals.async_wait(handler);
- * @endcode
- *
- * @par Queueing of signal notifications
- *
- * If a signal is registered with a signal_set, and the signal occurs when
- * there are no waiting handlers, then the signal notification is queued. The
- * next async_wait operation on that signal_set will dequeue the notification.
- * If multiple notifications are queued, subsequent async_wait operations
- * dequeue them one at a time. Signal notifications are dequeued in order of
- * ascending signal number.
- *
- * If a signal number is removed from a signal_set (using the @c remove or @c
- * erase member functions) then any queued notifications for that signal are
- * discarded.
- *
- * @par Multiple registration of signals
- *
- * The same signal number may be registered with different signal_set objects.
- * When the signal occurs, one handler is called for each signal_set object.
- *
- * Note that multiple registration only works for signals that are registered
- * using Asio. The application must not also register a signal handler using
- * functions such as @c signal() or @c sigaction().
- *
- * @par Signal masking on POSIX platforms
- *
- * POSIX allows signals to be blocked using functions such as @c sigprocmask()
- * and @c pthread_sigmask(). For signals to be delivered, programs must ensure
- * that any signals registered using signal_set objects are unblocked in at
- * least one thread.
- */
-template <typename SignalSetService = signal_set_service>
-class basic_signal_set
-  : public basic_io_object<SignalSetService>
-{
-public:
-  /// Construct a signal set without adding any signals.
-  /**
-   * This constructor creates a signal set without registering for any signals.
-   *
-   * @param io_service The io_service object that the signal set will use to
-   * dispatch handlers for any asynchronous operations performed on the set.
-   */
-  explicit basic_signal_set(asio::io_service& io_service)
-    : basic_io_object<SignalSetService>(io_service)
-  {
-  }
-
-  /// Construct a signal set and add one signal.
-  /**
-   * This constructor creates a signal set and registers for one signal.
-   *
-   * @param io_service The io_service object that the signal set will use to
-   * dispatch handlers for any asynchronous operations performed on the set.
-   *
-   * @param signal_number_1 The signal number to be added.
-   *
-   * @note This constructor is equivalent to performing:
-   * @code asio::signal_set signals(io_service);
-   * signals.add(signal_number_1); @endcode
-   */
-  basic_signal_set(asio::io_service& io_service, int signal_number_1)
-    : basic_io_object<SignalSetService>(io_service)
-  {
-    asio::error_code ec;
-    this->service.add(this->implementation, signal_number_1, ec);
-    asio::detail::throw_error(ec, "add");
-  }
-
-  /// Construct a signal set and add two signals.
-  /**
-   * This constructor creates a signal set and registers for two signals.
-   *
-   * @param io_service The io_service object that the signal set will use to
-   * dispatch handlers for any asynchronous operations performed on the set.
-   *
-   * @param signal_number_1 The first signal number to be added.
-   *
-   * @param signal_number_2 The second signal number to be added.
-   *
-   * @note This constructor is equivalent to performing:
-   * @code asio::signal_set signals(io_service);
-   * signals.add(signal_number_1);
-   * signals.add(signal_number_2); @endcode
-   */
-  basic_signal_set(asio::io_service& io_service, int signal_number_1,
-      int signal_number_2)
-    : basic_io_object<SignalSetService>(io_service)
-  {
-    asio::error_code ec;
-    this->service.add(this->implementation, signal_number_1, ec);
-    asio::detail::throw_error(ec, "add");
-    this->service.add(this->implementation, signal_number_2, ec);
-    asio::detail::throw_error(ec, "add");
-  }
-
-  /// Construct a signal set and add three signals.
-  /**
-   * This constructor creates a signal set and registers for three signals.
-   *
-   * @param io_service The io_service object that the signal set will use to
-   * dispatch handlers for any asynchronous operations performed on the set.
-   *
-   * @param signal_number_1 The first signal number to be added.
-   *
-   * @param signal_number_2 The second signal number to be added.
-   *
-   * @param signal_number_3 The third signal number to be added.
-   *
-   * @note This constructor is equivalent to performing:
-   * @code asio::signal_set signals(io_service);
-   * signals.add(signal_number_1);
-   * signals.add(signal_number_2);
-   * signals.add(signal_number_3); @endcode
-   */
-  basic_signal_set(asio::io_service& io_service, int signal_number_1,
-      int signal_number_2, int signal_number_3)
-    : basic_io_object<SignalSetService>(io_service)
-  {
-    asio::error_code ec;
-    this->service.add(this->implementation, signal_number_1, ec);
-    asio::detail::throw_error(ec, "add");
-    this->service.add(this->implementation, signal_number_2, ec);
-    asio::detail::throw_error(ec, "add");
-    this->service.add(this->implementation, signal_number_3, ec);
-    asio::detail::throw_error(ec, "add");
-  }
-
-  /// Add a signal to a signal_set.
-  /**
-   * This function adds the specified signal to the set. It has no effect if the
-   * signal is already in the set.
-   *
-   * @param signal_number The signal to be added to the set.
-   *
-   * @throws asio::system_error Thrown on failure.
-   */
-  void add(int signal_number)
-  {
-    asio::error_code ec;
-    this->service.add(this->implementation, signal_number, ec);
-    asio::detail::throw_error(ec, "add");
-  }
-
-  /// Add a signal to a signal_set.
-  /**
-   * This function adds the specified signal to the set. It has no effect if the
-   * signal is already in the set.
-   *
-   * @param signal_number The signal to be added to the set.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   */
-  asio::error_code add(int signal_number,
-      asio::error_code& ec)
-  {
-    return this->service.add(this->implementation, signal_number, ec);
-  }
-
-  /// Remove a signal from a signal_set.
-  /**
-   * This function removes the specified signal from the set. It has no effect
-   * if the signal is not in the set.
-   *
-   * @param signal_number The signal to be removed from the set.
-   *
-   * @throws asio::system_error Thrown on failure.
-   *
-   * @note Removes any notifications that have been queued for the specified
-   * signal number.
-   */
-  void remove(int signal_number)
-  {
-    asio::error_code ec;
-    this->service.remove(this->implementation, signal_number, ec);
-    asio::detail::throw_error(ec, "remove");
-  }
-
-  /// Remove a signal from a signal_set.
-  /**
-   * This function removes the specified signal from the set. It has no effect
-   * if the signal is not in the set.
-   *
-   * @param signal_number The signal to be removed from the set.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   *
-   * @note Removes any notifications that have been queued for the specified
-   * signal number.
-   */
-  asio::error_code remove(int signal_number,
-      asio::error_code& ec)
-  {
-    return this->service.remove(this->implementation, signal_number, ec);
-  }
-
-  /// Remove all signals from a signal_set.
-  /**
-   * This function removes all signals from the set. It has no effect if the set
-   * is already empty.
-   *
-   * @throws asio::system_error Thrown on failure.
-   *
-   * @note Removes all queued notifications.
-   */
-  void clear()
-  {
-    asio::error_code ec;
-    this->service.clear(this->implementation, ec);
-    asio::detail::throw_error(ec, "clear");
-  }
-
-  /// Remove all signals from a signal_set.
-  /**
-   * This function removes all signals from the set. It has no effect if the set
-   * is already empty.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   *
-   * @note Removes all queued notifications.
-   */
-  asio::error_code clear(asio::error_code& ec)
-  {
-    return this->service.clear(this->implementation, ec);
-  }
-
-  /// Cancel all operations associated with the signal set.
-  /**
-   * This function forces the completion of any pending asynchronous wait
-   * operations against the signal set. The handler for each cancelled
-   * operation will be invoked with the asio::error::operation_aborted
-   * error code.
-   *
-   * Cancellation does not alter the set of registered signals.
-   *
-   * @throws asio::system_error Thrown on failure.
-   *
-   * @note If a registered signal occurred before cancel() is called, then the
-   * handlers for asynchronous wait operations will:
-   *
-   * @li have already been invoked; or
-   *
-   * @li have been queued for invocation in the near future.
-   *
-   * These handlers can no longer be cancelled, and therefore are passed an
-   * error code that indicates the successful completion of the wait operation.
-   */
-  void cancel()
-  {
-    asio::error_code ec;
-    this->service.cancel(this->implementation, ec);
-    asio::detail::throw_error(ec, "cancel");
-  }
-
-  /// Cancel all operations associated with the signal set.
-  /**
-   * This function forces the completion of any pending asynchronous wait
-   * operations against the signal set. The handler for each cancelled
-   * operation will be invoked with the asio::error::operation_aborted
-   * error code.
-   *
-   * Cancellation does not alter the set of registered signals.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   *
-   * @note If a registered signal occurred before cancel() is called, then the
-   * handlers for asynchronous wait operations will:
-   *
-   * @li have already been invoked; or
-   *
-   * @li have been queued for invocation in the near future.
-   *
-   * These handlers can no longer be cancelled, and therefore are passed an
-   * error code that indicates the successful completion of the wait operation.
-   */
-  asio::error_code cancel(asio::error_code& ec)
-  {
-    return this->service.cancel(this->implementation, ec);
-  }
-
-  /// Start an asynchronous operation to wait for a signal to be delivered.
-  /**
-   * This function may be used to initiate an asynchronous wait against the
-   * signal set. It always returns immediately.
-   *
-   * For each call to async_wait(), the supplied handler will be called exactly
-   * once. The handler will be called when:
-   *
-   * @li One of the registered signals in the signal set occurs; or
-   *
-   * @li The signal set was cancelled, in which case the handler is passed the
-   * error code asio::error::operation_aborted.
-   *
-   * @param handler The handler to be called when the signal occurs. Copies
-   * will be made of the handler as required. The function signature of the
-   * handler must be:
-   * @code void handler(
-   *   const asio::error_code& error, // Result of operation.
-   *   int signal_number // Indicates which signal occurred.
-   * ); @endcode
-   * Regardless of whether the asynchronous operation completes immediately or
-   * not, the handler will not be invoked from within this function. Invocation
-   * of the handler will be performed in a manner equivalent to using
-   * asio::io_service::post().
-   */
-  template <typename SignalHandler>
-  ASIO_INITFN_RESULT_TYPE(SignalHandler,
-      void (asio::error_code, int))
-  async_wait(ASIO_MOVE_ARG(SignalHandler) handler)
-  {
-    // If you get an error on the following line it means that your handler does
-    // not meet the documented type requirements for a SignalHandler.
-    ASIO_SIGNAL_HANDLER_CHECK(SignalHandler, handler) type_check;
-
-    return this->service.async_wait(this->implementation,
-        ASIO_MOVE_CAST(SignalHandler)(handler));
-  }
-};
-
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_BASIC_SIGNAL_SET_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/basic_socket.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/basic_socket.hpp
deleted file mode 100644
index be4fb3c2c3af..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/basic_socket.hpp
+++ /dev/null
@@ -1,1518 +0,0 @@
-//
-// basic_socket.hpp
-// ~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_BASIC_SOCKET_HPP
-#define ASIO_BASIC_SOCKET_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include "asio/async_result.hpp"
-#include "asio/basic_io_object.hpp"
-#include "asio/detail/handler_type_requirements.hpp"
-#include "asio/detail/throw_error.hpp"
-#include "asio/detail/type_traits.hpp"
-#include "asio/error.hpp"
-#include "asio/socket_base.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-
-/// Provides socket functionality.
-/**
- * The basic_socket class template provides functionality that is common to both
- * stream-oriented and datagram-oriented sockets.
- *
- * @par Thread Safety
- * @e Distinct @e objects: Safe.@n
- * @e Shared @e objects: Unsafe.
- */
-template <typename Protocol, typename SocketService>
-class basic_socket
-  : public basic_io_object<SocketService>,
-    public socket_base
-{
-public:
-  /// (Deprecated: Use native_handle_type.) The native representation of a
-  /// socket.
-  typedef typename SocketService::native_handle_type native_type;
-
-  /// The native representation of a socket.
-  typedef typename SocketService::native_handle_type native_handle_type;
-
-  /// The protocol type.
-  typedef Protocol protocol_type;
-
-  /// The endpoint type.
-  typedef typename Protocol::endpoint endpoint_type;
-
-  /// A basic_socket is always the lowest layer.
-  typedef basic_socket<Protocol, SocketService> lowest_layer_type;
-
-  /// Construct a basic_socket without opening it.
-  /**
-   * This constructor creates a socket without opening it.
-   *
-   * @param io_service The io_service object that the socket will use to
-   * dispatch handlers for any asynchronous operations performed on the socket.
-   */
-  explicit basic_socket(asio::io_service& io_service)
-    : basic_io_object<SocketService>(io_service)
-  {
-  }
-
-  /// Construct and open a basic_socket.
-  /**
-   * This constructor creates and opens a socket.
-   *
-   * @param io_service The io_service object that the socket will use to
-   * dispatch handlers for any asynchronous operations performed on the socket.
-   *
-   * @param protocol An object specifying protocol parameters to be used.
-   *
-   * @throws asio::system_error Thrown on failure.
-   */
-  basic_socket(asio::io_service& io_service,
-      const protocol_type& protocol)
-    : basic_io_object<SocketService>(io_service)
-  {
-    asio::error_code ec;
-    this->get_service().open(this->get_implementation(), protocol, ec);
-    asio::detail::throw_error(ec, "open");
-  }
-
-  /// Construct a basic_socket, opening it and binding it to the given local
-  /// endpoint.
-  /**
-   * This constructor creates a socket and automatically opens it bound to the
-   * specified endpoint on the local machine. The protocol used is the protocol
-   * associated with the given endpoint.
-   *
-   * @param io_service The io_service object that the socket will use to
-   * dispatch handlers for any asynchronous operations performed on the socket.
-   *
-   * @param endpoint An endpoint on the local machine to which the socket will
-   * be bound.
-   *
-   * @throws asio::system_error Thrown on failure.
-   */
-  basic_socket(asio::io_service& io_service,
-      const endpoint_type& endpoint)
-    : basic_io_object<SocketService>(io_service)
-  {
-    asio::error_code ec;
-    const protocol_type protocol = endpoint.protocol();
-    this->get_service().open(this->get_implementation(), protocol, ec);
-    asio::detail::throw_error(ec, "open");
-    this->get_service().bind(this->get_implementation(), endpoint, ec);
-    asio::detail::throw_error(ec, "bind");
-  }
-
-  /// Construct a basic_socket on an existing native socket.
-  /**
-   * This constructor creates a socket object to hold an existing native socket.
-   *
-   * @param io_service The io_service object that the socket will use to
-   * dispatch handlers for any asynchronous operations performed on the socket.
-   *
-   * @param protocol An object specifying protocol parameters to be used.
-   *
-   * @param native_socket A native socket.
-   *
-   * @throws asio::system_error Thrown on failure.
-   */
-  basic_socket(asio::io_service& io_service,
-      const protocol_type& protocol, const native_handle_type& native_socket)
-    : basic_io_object<SocketService>(io_service)
-  {
-    asio::error_code ec;
-    this->get_service().assign(this->get_implementation(),
-        protocol, native_socket, ec);
-    asio::detail::throw_error(ec, "assign");
-  }
-
-#if defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
-  /// Move-construct a basic_socket from another.
-  /**
-   * This constructor moves a socket from one object to another.
-   *
-   * @param other The other basic_socket object from which the move will
-   * occur.
-   *
-   * @note Following the move, the moved-from object is in the same state as if
-   * constructed using the @c basic_socket(io_service&) constructor.
-   */
-  basic_socket(basic_socket&& other)
-    : basic_io_object<SocketService>(
-        ASIO_MOVE_CAST(basic_socket)(other))
-  {
-  }
-
-  /// Move-assign a basic_socket from another.
-  /**
-   * This assignment operator moves a socket from one object to another.
-   *
-   * @param other The other basic_socket object from which the move will
-   * occur.
-   *
-   * @note Following the move, the moved-from object is in the same state as if
-   * constructed using the @c basic_socket(io_service&) constructor.
-   */
-  basic_socket& operator=(basic_socket&& other)
-  {
-    basic_io_object<SocketService>::operator=(
-        ASIO_MOVE_CAST(basic_socket)(other));
-    return *this;
-  }
-
-  // All sockets have access to each other's implementations.
-  template <typename Protocol1, typename SocketService1>
-  friend class basic_socket;
-
-  /// Move-construct a basic_socket from a socket of another protocol type.
-  /**
-   * This constructor moves a socket from one object to another.
-   *
-   * @param other The other basic_socket object from which the move will
-   * occur.
-   *
-   * @note Following the move, the moved-from object is in the same state as if
-   * constructed using the @c basic_socket(io_service&) constructor.
-   */
-  template <typename Protocol1, typename SocketService1>
-  basic_socket(basic_socket<Protocol1, SocketService1>&& other,
-      typename enable_if<is_convertible<Protocol1, Protocol>::value>::type* = 0)
-    : basic_io_object<SocketService>(other.get_io_service())
-  {
-    this->get_service().template converting_move_construct<Protocol1>(
-        this->get_implementation(), other.get_implementation());
-  }
-
-  /// Move-assign a basic_socket from a socket of another protocol type.
-  /**
-   * This assignment operator moves a socket from one object to another.
-   *
-   * @param other The other basic_socket object from which the move will
-   * occur.
-   *
-   * @note Following the move, the moved-from object is in the same state as if
-   * constructed using the @c basic_socket(io_service&) constructor.
-   */
-  template <typename Protocol1, typename SocketService1>
-  typename enable_if<is_convertible<Protocol1, Protocol>::value,
-      basic_socket>::type& operator=(
-        basic_socket<Protocol1, SocketService1>&& other)
-  {
-    basic_socket tmp(ASIO_MOVE_CAST2(basic_socket<
-            Protocol1, SocketService1>)(other));
-    basic_io_object<SocketService>::operator=(
-        ASIO_MOVE_CAST(basic_socket)(tmp));
-    return *this;
-  }
-#endif // defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
-
-  /// Get a reference to the lowest layer.
-  /**
-   * This function returns a reference to the lowest layer in a stack of
-   * layers. Since a basic_socket cannot contain any further layers, it simply
-   * returns a reference to itself.
-   *
-   * @return A reference to the lowest layer in the stack of layers. Ownership
-   * is not transferred to the caller.
-   */
-  lowest_layer_type& lowest_layer()
-  {
-    return *this;
-  }
-
-  /// Get a const reference to the lowest layer.
-  /**
-   * This function returns a const reference to the lowest layer in a stack of
-   * layers. Since a basic_socket cannot contain any further layers, it simply
-   * returns a reference to itself.
-   *
-   * @return A const reference to the lowest layer in the stack of layers.
-   * Ownership is not transferred to the caller.
-   */
-  const lowest_layer_type& lowest_layer() const
-  {
-    return *this;
-  }
-
-  /// Open the socket using the specified protocol.
-  /**
-   * This function opens the socket so that it will use the specified protocol.
-   *
-   * @param protocol An object specifying protocol parameters to be used.
-   *
-   * @throws asio::system_error Thrown on failure.
-   *
-   * @par Example
-   * @code
-   * asio::ip::tcp::socket socket(io_service);
-   * socket.open(asio::ip::tcp::v4());
-   * @endcode
-   */
-  void open(const protocol_type& protocol = protocol_type())
-  {
-    asio::error_code ec;
-    this->get_service().open(this->get_implementation(), protocol, ec);
-    asio::detail::throw_error(ec, "open");
-  }
-
-  /// Open the socket using the specified protocol.
-  /**
-   * This function opens the socket so that it will use the specified protocol.
-   *
-   * @param protocol An object specifying which protocol is to be used.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   *
-   * @par Example
-   * @code
-   * asio::ip::tcp::socket socket(io_service);
-   * asio::error_code ec;
-   * socket.open(asio::ip::tcp::v4(), ec);
-   * if (ec)
-   * {
-   *   // An error occurred.
-   * }
-   * @endcode
-   */
-  asio::error_code open(const protocol_type& protocol,
-      asio::error_code& ec)
-  {
-    return this->get_service().open(this->get_implementation(), protocol, ec);
-  }
-
-  /// Assign an existing native socket to the socket.
-  /*
-   * This function opens the socket to hold an existing native socket.
-   *
-   * @param protocol An object specifying which protocol is to be used.
-   *
-   * @param native_socket A native socket.
-   *
-   * @throws asio::system_error Thrown on failure.
-   */
-  void assign(const protocol_type& protocol,
-      const native_handle_type& native_socket)
-  {
-    asio::error_code ec;
-    this->get_service().assign(this->get_implementation(),
-        protocol, native_socket, ec);
-    asio::detail::throw_error(ec, "assign");
-  }
-
-  /// Assign an existing native socket to the socket.
-  /*
-   * This function opens the socket to hold an existing native socket.
-   *
-   * @param protocol An object specifying which protocol is to be used.
-   *
-   * @param native_socket A native socket.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   */
-  asio::error_code assign(const protocol_type& protocol,
-      const native_handle_type& native_socket, asio::error_code& ec)
-  {
-    return this->get_service().assign(this->get_implementation(),
-        protocol, native_socket, ec);
-  }
-
-  /// Determine whether the socket is open.
-  bool is_open() const
-  {
-    return this->get_service().is_open(this->get_implementation());
-  }
-
-  /// Close the socket.
-  /**
-   * This function is used to close the socket. Any asynchronous send, receive
-   * or connect operations will be cancelled immediately, and will complete
-   * with the asio::error::operation_aborted error.
-   *
-   * @throws asio::system_error Thrown on failure. Note that, even if
-   * the function indicates an error, the underlying descriptor is closed.
-   *
-   * @note For portable behaviour with respect to graceful closure of a
-   * connected socket, call shutdown() before closing the socket.
-   */
-  void close()
-  {
-    asio::error_code ec;
-    this->get_service().close(this->get_implementation(), ec);
-    asio::detail::throw_error(ec, "close");
-  }
-
-  /// Close the socket.
-  /**
-   * This function is used to close the socket. Any asynchronous send, receive
-   * or connect operations will be cancelled immediately, and will complete
-   * with the asio::error::operation_aborted error.
-   *
-   * @param ec Set to indicate what error occurred, if any. Note that, even if
-   * the function indicates an error, the underlying descriptor is closed.
-   *
-   * @par Example
-   * @code
-   * asio::ip::tcp::socket socket(io_service);
-   * ...
-   * asio::error_code ec;
-   * socket.close(ec);
-   * if (ec)
-   * {
-   *   // An error occurred.
-   * }
-   * @endcode
-   *
-   * @note For portable behaviour with respect to graceful closure of a
-   * connected socket, call shutdown() before closing the socket.
-   */
-  asio::error_code close(asio::error_code& ec)
-  {
-    return this->get_service().close(this->get_implementation(), ec);
-  }
-
-  /// (Deprecated: Use native_handle().) Get the native socket representation.
-  /**
-   * This function may be used to obtain the underlying representation of the
-   * socket. This is intended to allow access to native socket functionality
-   * that is not otherwise provided.
-   */
-  native_type native()
-  {
-    return this->get_service().native_handle(this->get_implementation());
-  }
-
-  /// Get the native socket representation.
-  /**
-   * This function may be used to obtain the underlying representation of the
-   * socket. This is intended to allow access to native socket functionality
-   * that is not otherwise provided.
-   */
-  native_handle_type native_handle()
-  {
-    return this->get_service().native_handle(this->get_implementation());
-  }
-
-  /// Cancel all asynchronous operations associated with the socket.
-  /**
-   * This function causes all outstanding asynchronous connect, send and receive
-   * operations to finish immediately, and the handlers for cancelled operations
-   * will be passed the asio::error::operation_aborted error.
-   *
-   * @throws asio::system_error Thrown on failure.
-   *
-   * @note Calls to cancel() will always fail with
-   * asio::error::operation_not_supported when run on Windows XP, Windows
-   * Server 2003, and earlier versions of Windows, unless
-   * ASIO_ENABLE_CANCELIO is defined. However, the CancelIo function has
-   * two issues that should be considered before enabling its use:
-   *
-   * @li It will only cancel asynchronous operations that were initiated in the
-   * current thread.
-   *
-   * @li It can appear to complete without error, but the request to cancel the
-   * unfinished operations may be silently ignored by the operating system.
-   * Whether it works or not seems to depend on the drivers that are installed.
-   *
-   * For portable cancellation, consider using one of the following
-   * alternatives:
-   *
-   * @li Disable asio's I/O completion port backend by defining
-   * ASIO_DISABLE_IOCP.
-   *
-   * @li Use the close() function to simultaneously cancel the outstanding
-   * operations and close the socket.
-   *
-   * When running on Windows Vista, Windows Server 2008, and later, the
-   * CancelIoEx function is always used. This function does not have the
-   * problems described above.
-   */
-#if defined(ASIO_MSVC) && (ASIO_MSVC >= 1400) \
-  && (!defined(_WIN32_WINNT) || _WIN32_WINNT < 0x0600) \
-  && !defined(ASIO_ENABLE_CANCELIO)
-  __declspec(deprecated("By default, this function always fails with "
-        "operation_not_supported when used on Windows XP, Windows Server 2003, "
-        "or earlier. Consult documentation for details."))
-#endif
-  void cancel()
-  {
-    asio::error_code ec;
-    this->get_service().cancel(this->get_implementation(), ec);
-    asio::detail::throw_error(ec, "cancel");
-  }
-
-  /// Cancel all asynchronous operations associated with the socket.
-  /**
-   * This function causes all outstanding asynchronous connect, send and receive
-   * operations to finish immediately, and the handlers for cancelled operations
-   * will be passed the asio::error::operation_aborted error.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   *
-   * @note Calls to cancel() will always fail with
-   * asio::error::operation_not_supported when run on Windows XP, Windows
-   * Server 2003, and earlier versions of Windows, unless
-   * ASIO_ENABLE_CANCELIO is defined. However, the CancelIo function has
-   * two issues that should be considered before enabling its use:
-   *
-   * @li It will only cancel asynchronous operations that were initiated in the
-   * current thread.
-   *
-   * @li It can appear to complete without error, but the request to cancel the
-   * unfinished operations may be silently ignored by the operating system.
-   * Whether it works or not seems to depend on the drivers that are installed.
-   *
-   * For portable cancellation, consider using one of the following
-   * alternatives:
-   *
-   * @li Disable asio's I/O completion port backend by defining
-   * ASIO_DISABLE_IOCP.
-   *
-   * @li Use the close() function to simultaneously cancel the outstanding
-   * operations and close the socket.
-   *
-   * When running on Windows Vista, Windows Server 2008, and later, the
-   * CancelIoEx function is always used. This function does not have the
-   * problems described above.
-   */
-#if defined(ASIO_MSVC) && (ASIO_MSVC >= 1400) \
-  && (!defined(_WIN32_WINNT) || _WIN32_WINNT < 0x0600) \
-  && !defined(ASIO_ENABLE_CANCELIO)
-  __declspec(deprecated("By default, this function always fails with "
-        "operation_not_supported when used on Windows XP, Windows Server 2003, "
-        "or earlier. Consult documentation for details."))
-#endif
-  asio::error_code cancel(asio::error_code& ec)
-  {
-    return this->get_service().cancel(this->get_implementation(), ec);
-  }
-
-  /// Determine whether the socket is at the out-of-band data mark.
-  /**
-   * This function is used to check whether the socket input is currently
-   * positioned at the out-of-band data mark.
-   *
-   * @return A bool indicating whether the socket is at the out-of-band data
-   * mark.
-   *
-   * @throws asio::system_error Thrown on failure.
-   */
-  bool at_mark() const
-  {
-    asio::error_code ec;
-    bool b = this->get_service().at_mark(this->get_implementation(), ec);
-    asio::detail::throw_error(ec, "at_mark");
-    return b;
-  }
-
-  /// Determine whether the socket is at the out-of-band data mark.
-  /**
-   * This function is used to check whether the socket input is currently
-   * positioned at the out-of-band data mark.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   *
-   * @return A bool indicating whether the socket is at the out-of-band data
-   * mark.
-   */
-  bool at_mark(asio::error_code& ec) const
-  {
-    return this->get_service().at_mark(this->get_implementation(), ec);
-  }
-
-  /// Determine the number of bytes available for reading.
-  /**
-   * This function is used to determine the number of bytes that may be read
-   * without blocking.
-   *
-   * @return The number of bytes that may be read without blocking, or 0 if an
-   * error occurs.
-   *
-   * @throws asio::system_error Thrown on failure.
-   */
-  std::size_t available() const
-  {
-    asio::error_code ec;
-    std::size_t s = this->get_service().available(
-        this->get_implementation(), ec);
-    asio::detail::throw_error(ec, "available");
-    return s;
-  }
-
-  /// Determine the number of bytes available for reading.
-  /**
-   * This function is used to determine the number of bytes that may be read
-   * without blocking.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   *
-   * @return The number of bytes that may be read without blocking, or 0 if an
-   * error occurs.
-   */
-  std::size_t available(asio::error_code& ec) const
-  {
-    return this->get_service().available(this->get_implementation(), ec);
-  }
-
-  /// Bind the socket to the given local endpoint.
-  /**
-   * This function binds the socket to the specified endpoint on the local
-   * machine.
-   *
-   * @param endpoint An endpoint on the local machine to which the socket will
-   * be bound.
-   *
-   * @throws asio::system_error Thrown on failure.
-   *
-   * @par Example
-   * @code
-   * asio::ip::tcp::socket socket(io_service);
-   * socket.open(asio::ip::tcp::v4());
-   * socket.bind(asio::ip::tcp::endpoint(
-   *       asio::ip::tcp::v4(), 12345));
-   * @endcode
-   */
-  void bind(const endpoint_type& endpoint)
-  {
-    asio::error_code ec;
-    this->get_service().bind(this->get_implementation(), endpoint, ec);
-    asio::detail::throw_error(ec, "bind");
-  }
-
-  /// Bind the socket to the given local endpoint.
-  /**
-   * This function binds the socket to the specified endpoint on the local
-   * machine.
-   *
-   * @param endpoint An endpoint on the local machine to which the socket will
-   * be bound.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   *
-   * @par Example
-   * @code
-   * asio::ip::tcp::socket socket(io_service);
-   * socket.open(asio::ip::tcp::v4());
-   * asio::error_code ec;
-   * socket.bind(asio::ip::tcp::endpoint(
-   *       asio::ip::tcp::v4(), 12345), ec);
-   * if (ec)
-   * {
-   *   // An error occurred.
-   * }
-   * @endcode
-   */
-  asio::error_code bind(const endpoint_type& endpoint,
-      asio::error_code& ec)
-  {
-    return this->get_service().bind(this->get_implementation(), endpoint, ec);
-  }
-
-  /// Connect the socket to the specified endpoint.
-  /**
-   * This function is used to connect a socket to the specified remote endpoint.
-   * The function call will block until the connection is successfully made or
-   * an error occurs.
-   *
-   * The socket is automatically opened if it is not already open. If the
-   * connect fails, and the socket was automatically opened, the socket is
-   * not returned to the closed state.
-   *
-   * @param peer_endpoint The remote endpoint to which the socket will be
-   * connected.
-   *
-   * @throws asio::system_error Thrown on failure.
-   *
-   * @par Example
-   * @code
-   * asio::ip::tcp::socket socket(io_service);
-   * asio::ip::tcp::endpoint endpoint(
-   *     asio::ip::address::from_string("1.2.3.4"), 12345);
-   * socket.connect(endpoint);
-   * @endcode
-   */
-  void connect(const endpoint_type& peer_endpoint)
-  {
-    asio::error_code ec;
-    if (!is_open())
-    {
-      this->get_service().open(this->get_implementation(),
-          peer_endpoint.protocol(), ec);
-      asio::detail::throw_error(ec, "connect");
-    }
-    this->get_service().connect(this->get_implementation(), peer_endpoint, ec);
-    asio::detail::throw_error(ec, "connect");
-  }
-
-  /// Connect the socket to the specified endpoint.
-  /**
-   * This function is used to connect a socket to the specified remote endpoint.
-   * The function call will block until the connection is successfully made or
-   * an error occurs.
-   *
-   * The socket is automatically opened if it is not already open. If the
-   * connect fails, and the socket was automatically opened, the socket is
-   * not returned to the closed state.
-   *
-   * @param peer_endpoint The remote endpoint to which the socket will be
-   * connected.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   *
-   * @par Example
-   * @code
-   * asio::ip::tcp::socket socket(io_service);
-   * asio::ip::tcp::endpoint endpoint(
-   *     asio::ip::address::from_string("1.2.3.4"), 12345);
-   * asio::error_code ec;
-   * socket.connect(endpoint, ec);
-   * if (ec)
-   * {
-   *   // An error occurred.
-   * }
-   * @endcode
-   */
-  asio::error_code connect(const endpoint_type& peer_endpoint,
-      asio::error_code& ec)
-  {
-    if (!is_open())
-    {
-      if (this->get_service().open(this->get_implementation(),
-            peer_endpoint.protocol(), ec))
-      {
-        return ec;
-      }
-    }
-
-    return this->get_service().connect(
-        this->get_implementation(), peer_endpoint, ec);
-  }
-
-  /// Start an asynchronous connect.
-  /**
-   * This function is used to asynchronously connect a socket to the specified
-   * remote endpoint. The function call always returns immediately.
-   *
-   * The socket is automatically opened if it is not already open. If the
-   * connect fails, and the socket was automatically opened, the socket is
-   * not returned to the closed state.
-   *
-   * @param peer_endpoint The remote endpoint to which the socket will be
-   * connected. Copies will be made of the endpoint object as required.
-   *
-   * @param handler The handler to be called when the connection operation
-   * completes. Copies will be made of the handler as required. The function
-   * signature of the handler must be:
-   * @code void handler(
-   *   const asio::error_code& error // Result of operation
-   * ); @endcode
-   * Regardless of whether the asynchronous operation completes immediately or
-   * not, the handler will not be invoked from within this function. Invocation
-   * of the handler will be performed in a manner equivalent to using
-   * asio::io_service::post().
-   *
-   * @par Example
-   * @code
-   * void connect_handler(const asio::error_code& error)
-   * {
-   *   if (!error)
-   *   {
-   *     // Connect succeeded.
-   *   }
-   * }
-   *
-   * ...
-   *
-   * asio::ip::tcp::socket socket(io_service);
-   * asio::ip::tcp::endpoint endpoint(
-   *     asio::ip::address::from_string("1.2.3.4"), 12345);
-   * socket.async_connect(endpoint, connect_handler);
-   * @endcode
-   */
-  template <typename ConnectHandler>
-  ASIO_INITFN_RESULT_TYPE(ConnectHandler,
-      void (asio::error_code))
-  async_connect(const endpoint_type& peer_endpoint,
-      ASIO_MOVE_ARG(ConnectHandler) handler)
-  {
-    // If you get an error on the following line it means that your handler does
-    // not meet the documented type requirements for a ConnectHandler.
-    ASIO_CONNECT_HANDLER_CHECK(ConnectHandler, handler) type_check;
-
-    if (!is_open())
-    {
-      asio::error_code ec;
-      const protocol_type protocol = peer_endpoint.protocol();
-      if (this->get_service().open(this->get_implementation(), protocol, ec))
-      {
-        detail::async_result_init<
-          ConnectHandler, void (asio::error_code)> init(
-            ASIO_MOVE_CAST(ConnectHandler)(handler));
-
-        this->get_io_service().post(
-            asio::detail::bind_handler(
-              ASIO_MOVE_CAST(ASIO_HANDLER_TYPE(
-                ConnectHandler, void (asio::error_code)))(
-                  init.handler), ec));
-
-        return init.result.get();
-      }
-    }
-
-    return this->get_service().async_connect(this->get_implementation(),
-        peer_endpoint, ASIO_MOVE_CAST(ConnectHandler)(handler));
-  }
-
-  /// Set an option on the socket.
-  /**
-   * This function is used to set an option on the socket.
-   *
-   * @param option The new option value to be set on the socket.
-   *
-   * @throws asio::system_error Thrown on failure.
-   *
-   * @sa SettableSocketOption @n
-   * asio::socket_base::broadcast @n
-   * asio::socket_base::do_not_route @n
-   * asio::socket_base::keep_alive @n
-   * asio::socket_base::linger @n
-   * asio::socket_base::receive_buffer_size @n
-   * asio::socket_base::receive_low_watermark @n
-   * asio::socket_base::reuse_address @n
-   * asio::socket_base::send_buffer_size @n
-   * asio::socket_base::send_low_watermark @n
-   * asio::ip::multicast::join_group @n
-   * asio::ip::multicast::leave_group @n
-   * asio::ip::multicast::enable_loopback @n
-   * asio::ip::multicast::outbound_interface @n
-   * asio::ip::multicast::hops @n
-   * asio::ip::tcp::no_delay
-   *
-   * @par Example
-   * Setting the IPPROTO_TCP/TCP_NODELAY option:
-   * @code
-   * asio::ip::tcp::socket socket(io_service);
-   * ...
-   * asio::ip::tcp::no_delay option(true);
-   * socket.set_option(option);
-   * @endcode
-   */
-  template <typename SettableSocketOption>
-  void set_option(const SettableSocketOption& option)
-  {
-    asio::error_code ec;
-    this->get_service().set_option(this->get_implementation(), option, ec);
-    asio::detail::throw_error(ec, "set_option");
-  }
-
-  /// Set an option on the socket.
-  /**
-   * This function is used to set an option on the socket.
-   *
-   * @param option The new option value to be set on the socket.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   *
-   * @sa SettableSocketOption @n
-   * asio::socket_base::broadcast @n
-   * asio::socket_base::do_not_route @n
-   * asio::socket_base::keep_alive @n
-   * asio::socket_base::linger @n
-   * asio::socket_base::receive_buffer_size @n
-   * asio::socket_base::receive_low_watermark @n
-   * asio::socket_base::reuse_address @n
-   * asio::socket_base::send_buffer_size @n
-   * asio::socket_base::send_low_watermark @n
-   * asio::ip::multicast::join_group @n
-   * asio::ip::multicast::leave_group @n
-   * asio::ip::multicast::enable_loopback @n
-   * asio::ip::multicast::outbound_interface @n
-   * asio::ip::multicast::hops @n
-   * asio::ip::tcp::no_delay
-   *
-   * @par Example
-   * Setting the IPPROTO_TCP/TCP_NODELAY option:
-   * @code
-   * asio::ip::tcp::socket socket(io_service);
-   * ...
-   * asio::ip::tcp::no_delay option(true);
-   * asio::error_code ec;
-   * socket.set_option(option, ec);
-   * if (ec)
-   * {
-   *   // An error occurred.
-   * }
-   * @endcode
-   */
-  template <typename SettableSocketOption>
-  asio::error_code set_option(const SettableSocketOption& option,
-      asio::error_code& ec)
-  {
-    return this->get_service().set_option(
-        this->get_implementation(), option, ec);
-  }
-
-  /// Get an option from the socket.
-  /**
-   * This function is used to get the current value of an option on the socket.
-   *
-   * @param option The option value to be obtained from the socket.
-   *
-   * @throws asio::system_error Thrown on failure.
-   *
-   * @sa GettableSocketOption @n
-   * asio::socket_base::broadcast @n
-   * asio::socket_base::do_not_route @n
-   * asio::socket_base::keep_alive @n
-   * asio::socket_base::linger @n
-   * asio::socket_base::receive_buffer_size @n
-   * asio::socket_base::receive_low_watermark @n
-   * asio::socket_base::reuse_address @n
-   * asio::socket_base::send_buffer_size @n
-   * asio::socket_base::send_low_watermark @n
-   * asio::ip::multicast::join_group @n
-   * asio::ip::multicast::leave_group @n
-   * asio::ip::multicast::enable_loopback @n
-   * asio::ip::multicast::outbound_interface @n
-   * asio::ip::multicast::hops @n
-   * asio::ip::tcp::no_delay
-   *
-   * @par Example
-   * Getting the value of the SOL_SOCKET/SO_KEEPALIVE option:
-   * @code
-   * asio::ip::tcp::socket socket(io_service);
-   * ...
-   * asio::ip::tcp::socket::keep_alive option;
-   * socket.get_option(option);
-   * bool is_set = option.value();
-   * @endcode
-   */
-  template <typename GettableSocketOption>
-  void get_option(GettableSocketOption& option) const
-  {
-    asio::error_code ec;
-    this->get_service().get_option(this->get_implementation(), option, ec);
-    asio::detail::throw_error(ec, "get_option");
-  }
-
-  /// Get an option from the socket.
-  /**
-   * This function is used to get the current value of an option on the socket.
-   *
-   * @param option The option value to be obtained from the socket.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   *
-   * @sa GettableSocketOption @n
-   * asio::socket_base::broadcast @n
-   * asio::socket_base::do_not_route @n
-   * asio::socket_base::keep_alive @n
-   * asio::socket_base::linger @n
-   * asio::socket_base::receive_buffer_size @n
-   * asio::socket_base::receive_low_watermark @n
-   * asio::socket_base::reuse_address @n
-   * asio::socket_base::send_buffer_size @n
-   * asio::socket_base::send_low_watermark @n
-   * asio::ip::multicast::join_group @n
-   * asio::ip::multicast::leave_group @n
-   * asio::ip::multicast::enable_loopback @n
-   * asio::ip::multicast::outbound_interface @n
-   * asio::ip::multicast::hops @n
-   * asio::ip::tcp::no_delay
-   *
-   * @par Example
-   * Getting the value of the SOL_SOCKET/SO_KEEPALIVE option:
-   * @code
-   * asio::ip::tcp::socket socket(io_service);
-   * ...
-   * asio::ip::tcp::socket::keep_alive option;
-   * asio::error_code ec;
-   * socket.get_option(option, ec);
-   * if (ec)
-   * {
-   *   // An error occurred.
-   * }
-   * bool is_set = option.value();
-   * @endcode
-   */
-  template <typename GettableSocketOption>
-  asio::error_code get_option(GettableSocketOption& option,
-      asio::error_code& ec) const
-  {
-    return this->get_service().get_option(
-        this->get_implementation(), option, ec);
-  }
-
-  /// Perform an IO control command on the socket.
-  /**
-   * This function is used to execute an IO control command on the socket.
-   *
-   * @param command The IO control command to be performed on the socket.
-   *
-   * @throws asio::system_error Thrown on failure.
-   *
-   * @sa IoControlCommand @n
-   * asio::socket_base::bytes_readable @n
-   * asio::socket_base::non_blocking_io
-   *
-   * @par Example
-   * Getting the number of bytes ready to read:
-   * @code
-   * asio::ip::tcp::socket socket(io_service);
-   * ...
-   * asio::ip::tcp::socket::bytes_readable command;
-   * socket.io_control(command);
-   * std::size_t bytes_readable = command.get();
-   * @endcode
-   */
-  template <typename IoControlCommand>
-  void io_control(IoControlCommand& command)
-  {
-    asio::error_code ec;
-    this->get_service().io_control(this->get_implementation(), command, ec);
-    asio::detail::throw_error(ec, "io_control");
-  }
-
-  /// Perform an IO control command on the socket.
-  /**
-   * This function is used to execute an IO control command on the socket.
-   *
-   * @param command The IO control command to be performed on the socket.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   *
-   * @sa IoControlCommand @n
-   * asio::socket_base::bytes_readable @n
-   * asio::socket_base::non_blocking_io
-   *
-   * @par Example
-   * Getting the number of bytes ready to read:
-   * @code
-   * asio::ip::tcp::socket socket(io_service);
-   * ...
-   * asio::ip::tcp::socket::bytes_readable command;
-   * asio::error_code ec;
-   * socket.io_control(command, ec);
-   * if (ec)
-   * {
-   *   // An error occurred.
-   * }
-   * std::size_t bytes_readable = command.get();
-   * @endcode
-   */
-  template <typename IoControlCommand>
-  asio::error_code io_control(IoControlCommand& command,
-      asio::error_code& ec)
-  {
-    return this->get_service().io_control(
-        this->get_implementation(), command, ec);
-  }
-
-  /// Gets the non-blocking mode of the socket.
-  /**
-   * @returns @c true if the socket's synchronous operations will fail with
-   * asio::error::would_block if they are unable to perform the requested
-   * operation immediately. If @c false, synchronous operations will block
-   * until complete.
-   *
-   * @note The non-blocking mode has no effect on the behaviour of asynchronous
-   * operations. Asynchronous operations will never fail with the error
-   * asio::error::would_block.
-   */
-  bool non_blocking() const
-  {
-    return this->get_service().non_blocking(this->get_implementation());
-  }
-
-  /// Sets the non-blocking mode of the socket.
-  /**
-   * @param mode If @c true, the socket's synchronous operations will fail with
-   * asio::error::would_block if they are unable to perform the requested
-   * operation immediately. If @c false, synchronous operations will block
-   * until complete.
-   *
-   * @throws asio::system_error Thrown on failure.
-   *
-   * @note The non-blocking mode has no effect on the behaviour of asynchronous
-   * operations. Asynchronous operations will never fail with the error
-   * asio::error::would_block.
-   */
-  void non_blocking(bool mode)
-  {
-    asio::error_code ec;
-    this->get_service().non_blocking(this->get_implementation(), mode, ec);
-    asio::detail::throw_error(ec, "non_blocking");
-  }
-
-  /// Sets the non-blocking mode of the socket.
-  /**
-   * @param mode If @c true, the socket's synchronous operations will fail with
-   * asio::error::would_block if they are unable to perform the requested
-   * operation immediately. If @c false, synchronous operations will block
-   * until complete.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   *
-   * @note The non-blocking mode has no effect on the behaviour of asynchronous
-   * operations. Asynchronous operations will never fail with the error
-   * asio::error::would_block.
-   */
-  asio::error_code non_blocking(
-      bool mode, asio::error_code& ec)
-  {
-    return this->get_service().non_blocking(
-        this->get_implementation(), mode, ec);
-  }
-
-  /// Gets the non-blocking mode of the native socket implementation.
-  /**
-   * This function is used to retrieve the non-blocking mode of the underlying
-   * native socket. This mode has no effect on the behaviour of the socket
-   * object's synchronous operations.
-   *
-   * @returns @c true if the underlying socket is in non-blocking mode and
-   * direct system calls may fail with asio::error::would_block (or the
-   * equivalent system error).
-   *
-   * @note The current non-blocking mode is cached by the socket object.
-   * Consequently, the return value may be incorrect if the non-blocking mode
-   * was set directly on the native socket.
-   *
-   * @par Example
-   * This function is intended to allow the encapsulation of arbitrary
-   * non-blocking system calls as asynchronous operations, in a way that is
-   * transparent to the user of the socket object. The following example
-   * illustrates how Linux's @c sendfile system call might be encapsulated:
-   * @code template <typename Handler>
-   * struct sendfile_op
-   * {
-   *   tcp::socket& sock_;
-   *   int fd_;
-   *   Handler handler_;
-   *   off_t offset_;
-   *   std::size_t total_bytes_transferred_;
-   *
-   *   // Function call operator meeting WriteHandler requirements.
-   *   // Used as the handler for the async_write_some operation.
-   *   void operator()(asio::error_code ec, std::size_t)
-   *   {
-   *     // Put the underlying socket into non-blocking mode.
-   *     if (!ec)
-   *       if (!sock_.native_non_blocking())
-   *         sock_.native_non_blocking(true, ec);
-   *
-   *     if (!ec)
-   *     {
-   *       for (;;)
-   *       {
-   *         // Try the system call.
-   *         errno = 0;
-   *         int n = ::sendfile(sock_.native_handle(), fd_, &offset_, 65536);
-   *         ec = asio::error_code(n < 0 ? errno : 0,
-   *             asio::error::get_system_category());
-   *         total_bytes_transferred_ += ec ? 0 : n;
-   *
-   *         // Retry operation immediately if interrupted by signal.
-   *         if (ec == asio::error::interrupted)
-   *           continue;
-   *
-   *         // Check if we need to run the operation again.
-   *         if (ec == asio::error::would_block
-   *             || ec == asio::error::try_again)
-   *         {
-   *           // We have to wait for the socket to become ready again.
-   *           sock_.async_write_some(asio::null_buffers(), *this);
-   *           return;
-   *         }
-   *
-   *         if (ec || n == 0)
-   *         {
-   *           // An error occurred, or we have reached the end of the file.
-   *           // Either way we must exit the loop so we can call the handler.
-   *           break;
-   *         }
-   *
-   *         // Loop around to try calling sendfile again.
-   *       }
-   *     }
-   *
-   *     // Pass result back to user's handler.
-   *     handler_(ec, total_bytes_transferred_);
-   *   }
-   * };
-   *
-   * template <typename Handler>
-   * void async_sendfile(tcp::socket& sock, int fd, Handler h)
-   * {
-   *   sendfile_op<Handler> op = { sock, fd, h, 0, 0 };
-   *   sock.async_write_some(asio::null_buffers(), op);
-   * } @endcode
-   */
-  bool native_non_blocking() const
-  {
-    return this->get_service().native_non_blocking(this->get_implementation());
-  }
-
-  /// Sets the non-blocking mode of the native socket implementation.
-  /**
-   * This function is used to modify the non-blocking mode of the underlying
-   * native socket. It has no effect on the behaviour of the socket object's
-   * synchronous operations.
-   *
-   * @param mode If @c true, the underlying socket is put into non-blocking
-   * mode and direct system calls may fail with asio::error::would_block
-   * (or the equivalent system error).
-   *
-   * @throws asio::system_error Thrown on failure. If the @c mode is
-   * @c false, but the current value of @c non_blocking() is @c true, this
-   * function fails with asio::error::invalid_argument, as the
-   * combination does not make sense.
-   *
-   * @par Example
-   * This function is intended to allow the encapsulation of arbitrary
-   * non-blocking system calls as asynchronous operations, in a way that is
-   * transparent to the user of the socket object. The following example
-   * illustrates how Linux's @c sendfile system call might be encapsulated:
-   * @code template <typename Handler>
-   * struct sendfile_op
-   * {
-   *   tcp::socket& sock_;
-   *   int fd_;
-   *   Handler handler_;
-   *   off_t offset_;
-   *   std::size_t total_bytes_transferred_;
-   *
-   *   // Function call operator meeting WriteHandler requirements.
-   *   // Used as the handler for the async_write_some operation.
-   *   void operator()(asio::error_code ec, std::size_t)
-   *   {
-   *     // Put the underlying socket into non-blocking mode.
-   *     if (!ec)
-   *       if (!sock_.native_non_blocking())
-   *         sock_.native_non_blocking(true, ec);
-   *
-   *     if (!ec)
-   *     {
-   *       for (;;)
-   *       {
-   *         // Try the system call.
-   *         errno = 0;
-   *         int n = ::sendfile(sock_.native_handle(), fd_, &offset_, 65536);
-   *         ec = asio::error_code(n < 0 ? errno : 0,
-   *             asio::error::get_system_category());
-   *         total_bytes_transferred_ += ec ? 0 : n;
-   *
-   *         // Retry operation immediately if interrupted by signal.
-   *         if (ec == asio::error::interrupted)
-   *           continue;
-   *
-   *         // Check if we need to run the operation again.
-   *         if (ec == asio::error::would_block
-   *             || ec == asio::error::try_again)
-   *         {
-   *           // We have to wait for the socket to become ready again.
-   *           sock_.async_write_some(asio::null_buffers(), *this);
-   *           return;
-   *         }
-   *
-   *         if (ec || n == 0)
-   *         {
-   *           // An error occurred, or we have reached the end of the file.
-   *           // Either way we must exit the loop so we can call the handler.
-   *           break;
-   *         }
-   *
-   *         // Loop around to try calling sendfile again.
-   *       }
-   *     }
-   *
-   *     // Pass result back to user's handler.
-   *     handler_(ec, total_bytes_transferred_);
-   *   }
-   * };
-   *
-   * template <typename Handler>
-   * void async_sendfile(tcp::socket& sock, int fd, Handler h)
-   * {
-   *   sendfile_op<Handler> op = { sock, fd, h, 0, 0 };
-   *   sock.async_write_some(asio::null_buffers(), op);
-   * } @endcode
-   */
-  void native_non_blocking(bool mode)
-  {
-    asio::error_code ec;
-    this->get_service().native_non_blocking(
-        this->get_implementation(), mode, ec);
-    asio::detail::throw_error(ec, "native_non_blocking");
-  }
-
-  /// Sets the non-blocking mode of the native socket implementation.
-  /**
-   * This function is used to modify the non-blocking mode of the underlying
-   * native socket. It has no effect on the behaviour of the socket object's
-   * synchronous operations.
-   *
-   * @param mode If @c true, the underlying socket is put into non-blocking
-   * mode and direct system calls may fail with asio::error::would_block
-   * (or the equivalent system error).
-   *
-   * @param ec Set to indicate what error occurred, if any. If the @c mode is
-   * @c false, but the current value of @c non_blocking() is @c true, this
-   * function fails with asio::error::invalid_argument, as the
-   * combination does not make sense.
-   *
-   * @par Example
-   * This function is intended to allow the encapsulation of arbitrary
-   * non-blocking system calls as asynchronous operations, in a way that is
-   * transparent to the user of the socket object. The following example
-   * illustrates how Linux's @c sendfile system call might be encapsulated:
-   * @code template <typename Handler>
-   * struct sendfile_op
-   * {
-   *   tcp::socket& sock_;
-   *   int fd_;
-   *   Handler handler_;
-   *   off_t offset_;
-   *   std::size_t total_bytes_transferred_;
-   *
-   *   // Function call operator meeting WriteHandler requirements.
-   *   // Used as the handler for the async_write_some operation.
-   *   void operator()(asio::error_code ec, std::size_t)
-   *   {
-   *     // Put the underlying socket into non-blocking mode.
-   *     if (!ec)
-   *       if (!sock_.native_non_blocking())
-   *         sock_.native_non_blocking(true, ec);
-   *
-   *     if (!ec)
-   *     {
-   *       for (;;)
-   *       {
-   *         // Try the system call.
-   *         errno = 0;
-   *         int n = ::sendfile(sock_.native_handle(), fd_, &offset_, 65536);
-   *         ec = asio::error_code(n < 0 ? errno : 0,
-   *             asio::error::get_system_category());
-   *         total_bytes_transferred_ += ec ? 0 : n;
-   *
-   *         // Retry operation immediately if interrupted by signal.
-   *         if (ec == asio::error::interrupted)
-   *           continue;
-   *
-   *         // Check if we need to run the operation again.
-   *         if (ec == asio::error::would_block
-   *             || ec == asio::error::try_again)
-   *         {
-   *           // We have to wait for the socket to become ready again.
-   *           sock_.async_write_some(asio::null_buffers(), *this);
-   *           return;
-   *         }
-   *
-   *         if (ec || n == 0)
-   *         {
-   *           // An error occurred, or we have reached the end of the file.
-   *           // Either way we must exit the loop so we can call the handler.
-   *           break;
-   *         }
-   *
-   *         // Loop around to try calling sendfile again.
-   *       }
-   *     }
-   *
-   *     // Pass result back to user's handler.
-   *     handler_(ec, total_bytes_transferred_);
-   *   }
-   * };
-   *
-   * template <typename Handler>
-   * void async_sendfile(tcp::socket& sock, int fd, Handler h)
-   * {
-   *   sendfile_op<Handler> op = { sock, fd, h, 0, 0 };
-   *   sock.async_write_some(asio::null_buffers(), op);
-   * } @endcode
-   */
-  asio::error_code native_non_blocking(
-      bool mode, asio::error_code& ec)
-  {
-    return this->get_service().native_non_blocking(
-        this->get_implementation(), mode, ec);
-  }
-
-  /// Get the local endpoint of the socket.
-  /**
-   * This function is used to obtain the locally bound endpoint of the socket.
-   *
-   * @returns An object that represents the local endpoint of the socket.
-   *
-   * @throws asio::system_error Thrown on failure.
-   *
-   * @par Example
-   * @code
-   * asio::ip::tcp::socket socket(io_service);
-   * ...
-   * asio::ip::tcp::endpoint endpoint = socket.local_endpoint();
-   * @endcode
-   */
-  endpoint_type local_endpoint() const
-  {
-    asio::error_code ec;
-    endpoint_type ep = this->get_service().local_endpoint(
-        this->get_implementation(), ec);
-    asio::detail::throw_error(ec, "local_endpoint");
-    return ep;
-  }
-
-  /// Get the local endpoint of the socket.
-  /**
-   * This function is used to obtain the locally bound endpoint of the socket.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   *
-   * @returns An object that represents the local endpoint of the socket.
-   * Returns a default-constructed endpoint object if an error occurred.
-   *
-   * @par Example
-   * @code
-   * asio::ip::tcp::socket socket(io_service);
-   * ...
-   * asio::error_code ec;
-   * asio::ip::tcp::endpoint endpoint = socket.local_endpoint(ec);
-   * if (ec)
-   * {
-   *   // An error occurred.
-   * }
-   * @endcode
-   */
-  endpoint_type local_endpoint(asio::error_code& ec) const
-  {
-    return this->get_service().local_endpoint(this->get_implementation(), ec);
-  }
-
-  /// Get the remote endpoint of the socket.
-  /**
-   * This function is used to obtain the remote endpoint of the socket.
-   *
-   * @returns An object that represents the remote endpoint of the socket.
-   *
-   * @throws asio::system_error Thrown on failure.
-   *
-   * @par Example
-   * @code
-   * asio::ip::tcp::socket socket(io_service);
-   * ...
-   * asio::ip::tcp::endpoint endpoint = socket.remote_endpoint();
-   * @endcode
-   */
-  endpoint_type remote_endpoint() const
-  {
-    asio::error_code ec;
-    endpoint_type ep = this->get_service().remote_endpoint(
-        this->get_implementation(), ec);
-    asio::detail::throw_error(ec, "remote_endpoint");
-    return ep;
-  }
-
-  /// Get the remote endpoint of the socket.
-  /**
-   * This function is used to obtain the remote endpoint of the socket.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   *
-   * @returns An object that represents the remote endpoint of the socket.
-   * Returns a default-constructed endpoint object if an error occurred.
-   *
-   * @par Example
-   * @code
-   * asio::ip::tcp::socket socket(io_service);
-   * ...
-   * asio::error_code ec;
-   * asio::ip::tcp::endpoint endpoint = socket.remote_endpoint(ec);
-   * if (ec)
-   * {
-   *   // An error occurred.
-   * }
-   * @endcode
-   */
-  endpoint_type remote_endpoint(asio::error_code& ec) const
-  {
-    return this->get_service().remote_endpoint(this->get_implementation(), ec);
-  }
-
-  /// Disable sends or receives on the socket.
-  /**
-   * This function is used to disable send operations, receive operations, or
-   * both.
-   *
-   * @param what Determines what types of operation will no longer be allowed.
-   *
-   * @throws asio::system_error Thrown on failure.
-   *
-   * @par Example
-   * Shutting down the send side of the socket:
-   * @code
-   * asio::ip::tcp::socket socket(io_service);
-   * ...
-   * socket.shutdown(asio::ip::tcp::socket::shutdown_send);
-   * @endcode
-   */
-  void shutdown(shutdown_type what)
-  {
-    asio::error_code ec;
-    this->get_service().shutdown(this->get_implementation(), what, ec);
-    asio::detail::throw_error(ec, "shutdown");
-  }
-
-  /// Disable sends or receives on the socket.
-  /**
-   * This function is used to disable send operations, receive operations, or
-   * both.
-   *
-   * @param what Determines what types of operation will no longer be allowed.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   *
-   * @par Example
-   * Shutting down the send side of the socket:
-   * @code
-   * asio::ip::tcp::socket socket(io_service);
-   * ...
-   * asio::error_code ec;
-   * socket.shutdown(asio::ip::tcp::socket::shutdown_send, ec);
-   * if (ec)
-   * {
-   *   // An error occurred.
-   * }
-   * @endcode
-   */
-  asio::error_code shutdown(shutdown_type what,
-      asio::error_code& ec)
-  {
-    return this->get_service().shutdown(this->get_implementation(), what, ec);
-  }
-
-protected:
-  /// Protected destructor to prevent deletion through this type.
-  ~basic_socket()
-  {
-  }
-};
-
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_BASIC_SOCKET_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/basic_socket_acceptor.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/basic_socket_acceptor.hpp
deleted file mode 100644
index f69f483250f2..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/basic_socket_acceptor.hpp
+++ /dev/null
@@ -1,1136 +0,0 @@
-//
-// basic_socket_acceptor.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_BASIC_SOCKET_ACCEPTOR_HPP
-#define ASIO_BASIC_SOCKET_ACCEPTOR_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include "asio/basic_io_object.hpp"
-#include "asio/basic_socket.hpp"
-#include "asio/detail/handler_type_requirements.hpp"
-#include "asio/detail/throw_error.hpp"
-#include "asio/detail/type_traits.hpp"
-#include "asio/error.hpp"
-#include "asio/socket_acceptor_service.hpp"
-#include "asio/socket_base.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-
-/// Provides the ability to accept new connections.
-/**
- * The basic_socket_acceptor class template is used for accepting new socket
- * connections.
- *
- * @par Thread Safety
- * @e Distinct @e objects: Safe.@n
- * @e Shared @e objects: Unsafe.
- *
- * @par Example
- * Opening a socket acceptor with the SO_REUSEADDR option enabled:
- * @code
- * asio::ip::tcp::acceptor acceptor(io_service);
- * asio::ip::tcp::endpoint endpoint(asio::ip::tcp::v4(), port);
- * acceptor.open(endpoint.protocol());
- * acceptor.set_option(asio::ip::tcp::acceptor::reuse_address(true));
- * acceptor.bind(endpoint);
- * acceptor.listen();
- * @endcode
- */
-template <typename Protocol,
-    typename SocketAcceptorService = socket_acceptor_service<Protocol> >
-class basic_socket_acceptor
-  : public basic_io_object<SocketAcceptorService>,
-    public socket_base
-{
-public:
-  /// (Deprecated: Use native_handle_type.) The native representation of an
-  /// acceptor.
-  typedef typename SocketAcceptorService::native_handle_type native_type;
-
-  /// The native representation of an acceptor.
-  typedef typename SocketAcceptorService::native_handle_type native_handle_type;
-
-  /// The protocol type.
-  typedef Protocol protocol_type;
-
-  /// The endpoint type.
-  typedef typename Protocol::endpoint endpoint_type;
-
-  /// Construct an acceptor without opening it.
-  /**
-   * This constructor creates an acceptor without opening it to listen for new
-   * connections. The open() function must be called before the acceptor can
-   * accept new socket connections.
-   *
-   * @param io_service The io_service object that the acceptor will use to
-   * dispatch handlers for any asynchronous operations performed on the
-   * acceptor.
-   */
-  explicit basic_socket_acceptor(asio::io_service& io_service)
-    : basic_io_object<SocketAcceptorService>(io_service)
-  {
-  }
-
-  /// Construct an open acceptor.
-  /**
-   * This constructor creates an acceptor and automatically opens it.
-   *
-   * @param io_service The io_service object that the acceptor will use to
-   * dispatch handlers for any asynchronous operations performed on the
-   * acceptor.
-   *
-   * @param protocol An object specifying protocol parameters to be used.
-   *
-   * @throws asio::system_error Thrown on failure.
-   */
-  basic_socket_acceptor(asio::io_service& io_service,
-      const protocol_type& protocol)
-    : basic_io_object<SocketAcceptorService>(io_service)
-  {
-    asio::error_code ec;
-    this->get_service().open(this->get_implementation(), protocol, ec);
-    asio::detail::throw_error(ec, "open");
-  }
-
-  /// Construct an acceptor opened on the given endpoint.
-  /**
-   * This constructor creates an acceptor and automatically opens it to listen
-   * for new connections on the specified endpoint.
-   *
-   * @param io_service The io_service object that the acceptor will use to
-   * dispatch handlers for any asynchronous operations performed on the
-   * acceptor.
-   *
-   * @param endpoint An endpoint on the local machine on which the acceptor
-   * will listen for new connections.
-   *
-   * @param reuse_addr Whether the constructor should set the socket option
-   * socket_base::reuse_address.
-   *
-   * @throws asio::system_error Thrown on failure.
-   *
-   * @note This constructor is equivalent to the following code:
-   * @code
-   * basic_socket_acceptor<Protocol> acceptor(io_service);
-   * acceptor.open(endpoint.protocol());
-   * if (reuse_addr)
-   *   acceptor.set_option(socket_base::reuse_address(true));
-   * acceptor.bind(endpoint);
-   * acceptor.listen(listen_backlog);
-   * @endcode
-   */
-  basic_socket_acceptor(asio::io_service& io_service,
-      const endpoint_type& endpoint, bool reuse_addr = true)
-    : basic_io_object<SocketAcceptorService>(io_service)
-  {
-    asio::error_code ec;
-    const protocol_type protocol = endpoint.protocol();
-    this->get_service().open(this->get_implementation(), protocol, ec);
-    asio::detail::throw_error(ec, "open");
-    if (reuse_addr)
-    {
-      this->get_service().set_option(this->get_implementation(),
-          socket_base::reuse_address(true), ec);
-      asio::detail::throw_error(ec, "set_option");
-    }
-    this->get_service().bind(this->get_implementation(), endpoint, ec);
-    asio::detail::throw_error(ec, "bind");
-    this->get_service().listen(this->get_implementation(),
-        socket_base::max_connections, ec);
-    asio::detail::throw_error(ec, "listen");
-  }
-
-  /// Construct a basic_socket_acceptor on an existing native acceptor.
-  /**
-   * This constructor creates an acceptor object to hold an existing native
-   * acceptor.
-   *
-   * @param io_service The io_service object that the acceptor will use to
-   * dispatch handlers for any asynchronous operations performed on the
-   * acceptor.
-   *
-   * @param protocol An object specifying protocol parameters to be used.
-   *
-   * @param native_acceptor A native acceptor.
-   *
-   * @throws asio::system_error Thrown on failure.
-   */
-  basic_socket_acceptor(asio::io_service& io_service,
-      const protocol_type& protocol, const native_handle_type& native_acceptor)
-    : basic_io_object<SocketAcceptorService>(io_service)
-  {
-    asio::error_code ec;
-    this->get_service().assign(this->get_implementation(),
-        protocol, native_acceptor, ec);
-    asio::detail::throw_error(ec, "assign");
-  }
-
-#if defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
-  /// Move-construct a basic_socket_acceptor from another.
-  /**
-   * This constructor moves an acceptor from one object to another.
-   *
-   * @param other The other basic_socket_acceptor object from which the move
-   * will occur.
-   *
-   * @note Following the move, the moved-from object is in the same state as if
-   * constructed using the @c basic_socket_acceptor(io_service&) constructor.
-   */
-  basic_socket_acceptor(basic_socket_acceptor&& other)
-    : basic_io_object<SocketAcceptorService>(
-        ASIO_MOVE_CAST(basic_socket_acceptor)(other))
-  {
-  }
-
-  /// Move-assign a basic_socket_acceptor from another.
-  /**
-   * This assignment operator moves an acceptor from one object to another.
-   *
-   * @param other The other basic_socket_acceptor object from which the move
-   * will occur.
-   *
-   * @note Following the move, the moved-from object is in the same state as if
-   * constructed using the @c basic_socket_acceptor(io_service&) constructor.
-   */
-  basic_socket_acceptor& operator=(basic_socket_acceptor&& other)
-  {
-    basic_io_object<SocketAcceptorService>::operator=(
-        ASIO_MOVE_CAST(basic_socket_acceptor)(other));
-    return *this;
-  }
-
-  // All socket acceptors have access to each other's implementations.
-  template <typename Protocol1, typename SocketAcceptorService1>
-  friend class basic_socket_acceptor;
-
-  /// Move-construct a basic_socket_acceptor from an acceptor of another
-  /// protocol type.
-  /**
-   * This constructor moves an acceptor from one object to another.
-   *
-   * @param other The other basic_socket_acceptor object from which the move
-   * will occur.
-   *
-   * @note Following the move, the moved-from object is in the same state as if
-   * constructed using the @c basic_socket(io_service&) constructor.
-   */
-  template <typename Protocol1, typename SocketAcceptorService1>
-  basic_socket_acceptor(
-      basic_socket_acceptor<Protocol1, SocketAcceptorService1>&& other,
-      typename enable_if<is_convertible<Protocol1, Protocol>::value>::type* = 0)
-    : basic_io_object<SocketAcceptorService>(other.get_io_service())
-  {
-    this->get_service().template converting_move_construct<Protocol1>(
-        this->get_implementation(), other.get_implementation());
-  }
-
-  /// Move-assign a basic_socket_acceptor from an acceptor of another protocol
-  /// type.
-  /**
-   * This assignment operator moves an acceptor from one object to another.
-   *
-   * @param other The other basic_socket_acceptor object from which the move
-   * will occur.
-   *
-   * @note Following the move, the moved-from object is in the same state as if
-   * constructed using the @c basic_socket(io_service&) constructor.
-   */
-  template <typename Protocol1, typename SocketAcceptorService1>
-  typename enable_if<is_convertible<Protocol1, Protocol>::value,
-      basic_socket_acceptor>::type& operator=(
-        basic_socket_acceptor<Protocol1, SocketAcceptorService1>&& other)
-  {
-    basic_socket_acceptor tmp(ASIO_MOVE_CAST2(basic_socket_acceptor<
-            Protocol1, SocketAcceptorService1>)(other));
-    basic_io_object<SocketAcceptorService>::operator=(
-        ASIO_MOVE_CAST(basic_socket_acceptor)(tmp));
-    return *this;
-  }
-#endif // defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
-
-  /// Open the acceptor using the specified protocol.
-  /**
-   * This function opens the socket acceptor so that it will use the specified
-   * protocol.
-   *
-   * @param protocol An object specifying which protocol is to be used.
-   *
-   * @throws asio::system_error Thrown on failure.
-   *
-   * @par Example
-   * @code
-   * asio::ip::tcp::acceptor acceptor(io_service);
-   * acceptor.open(asio::ip::tcp::v4());
-   * @endcode
-   */
-  void open(const protocol_type& protocol = protocol_type())
-  {
-    asio::error_code ec;
-    this->get_service().open(this->get_implementation(), protocol, ec);
-    asio::detail::throw_error(ec, "open");
-  }
-
-  /// Open the acceptor using the specified protocol.
-  /**
-   * This function opens the socket acceptor so that it will use the specified
-   * protocol.
-   *
-   * @param protocol An object specifying which protocol is to be used.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   *
-   * @par Example
-   * @code
-   * asio::ip::tcp::acceptor acceptor(io_service);
-   * asio::error_code ec;
-   * acceptor.open(asio::ip::tcp::v4(), ec);
-   * if (ec)
-   * {
-   *   // An error occurred.
-   * }
-   * @endcode
-   */
-  asio::error_code open(const protocol_type& protocol,
-      asio::error_code& ec)
-  {
-    return this->get_service().open(this->get_implementation(), protocol, ec);
-  }
-
-  /// Assigns an existing native acceptor to the acceptor.
-  /*
-   * This function opens the acceptor to hold an existing native acceptor.
-   *
-   * @param protocol An object specifying which protocol is to be used.
-   *
-   * @param native_acceptor A native acceptor.
-   *
-   * @throws asio::system_error Thrown on failure.
-   */
-  void assign(const protocol_type& protocol,
-      const native_handle_type& native_acceptor)
-  {
-    asio::error_code ec;
-    this->get_service().assign(this->get_implementation(),
-        protocol, native_acceptor, ec);
-    asio::detail::throw_error(ec, "assign");
-  }
-
-  /// Assigns an existing native acceptor to the acceptor.
-  /*
-   * This function opens the acceptor to hold an existing native acceptor.
-   *
-   * @param protocol An object specifying which protocol is to be used.
-   *
-   * @param native_acceptor A native acceptor.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   */
-  asio::error_code assign(const protocol_type& protocol,
-      const native_handle_type& native_acceptor, asio::error_code& ec)
-  {
-    return this->get_service().assign(this->get_implementation(),
-        protocol, native_acceptor, ec);
-  }
-
-  /// Determine whether the acceptor is open.
-  bool is_open() const
-  {
-    return this->get_service().is_open(this->get_implementation());
-  }
-
-  /// Bind the acceptor to the given local endpoint.
-  /**
-   * This function binds the socket acceptor to the specified endpoint on the
-   * local machine.
-   *
-   * @param endpoint An endpoint on the local machine to which the socket
-   * acceptor will be bound.
-   *
-   * @throws asio::system_error Thrown on failure.
-   *
-   * @par Example
-   * @code
-   * asio::ip::tcp::acceptor acceptor(io_service);
-   * asio::ip::tcp::endpoint endpoint(asio::ip::tcp::v4(), 12345);
-   * acceptor.open(endpoint.protocol());
-   * acceptor.bind(endpoint);
-   * @endcode
-   */
-  void bind(const endpoint_type& endpoint)
-  {
-    asio::error_code ec;
-    this->get_service().bind(this->get_implementation(), endpoint, ec);
-    asio::detail::throw_error(ec, "bind");
-  }
-
-  /// Bind the acceptor to the given local endpoint.
-  /**
-   * This function binds the socket acceptor to the specified endpoint on the
-   * local machine.
-   *
-   * @param endpoint An endpoint on the local machine to which the socket
-   * acceptor will be bound.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   *
-   * @par Example
-   * @code
-   * asio::ip::tcp::acceptor acceptor(io_service);
-   * asio::ip::tcp::endpoint endpoint(asio::ip::tcp::v4(), 12345);
-   * acceptor.open(endpoint.protocol());
-   * asio::error_code ec;
-   * acceptor.bind(endpoint, ec);
-   * if (ec)
-   * {
-   *   // An error occurred.
-   * }
-   * @endcode
-   */
-  asio::error_code bind(const endpoint_type& endpoint,
-      asio::error_code& ec)
-  {
-    return this->get_service().bind(this->get_implementation(), endpoint, ec);
-  }
-
-  /// Place the acceptor into the state where it will listen for new
-  /// connections.
-  /**
-   * This function puts the socket acceptor into the state where it may accept
-   * new connections.
-   *
-   * @param backlog The maximum length of the queue of pending connections.
-   *
-   * @throws asio::system_error Thrown on failure.
-   */
-  void listen(int backlog = socket_base::max_connections)
-  {
-    asio::error_code ec;
-    this->get_service().listen(this->get_implementation(), backlog, ec);
-    asio::detail::throw_error(ec, "listen");
-  }
-
-  /// Place the acceptor into the state where it will listen for new
-  /// connections.
-  /**
-   * This function puts the socket acceptor into the state where it may accept
-   * new connections.
-   *
-   * @param backlog The maximum length of the queue of pending connections.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   *
-   * @par Example
-   * @code
-   * asio::ip::tcp::acceptor acceptor(io_service);
-   * ...
-   * asio::error_code ec;
-   * acceptor.listen(asio::socket_base::max_connections, ec);
-   * if (ec)
-   * {
-   *   // An error occurred.
-   * }
-   * @endcode
-   */
-  asio::error_code listen(int backlog, asio::error_code& ec)
-  {
-    return this->get_service().listen(this->get_implementation(), backlog, ec);
-  }
-
-  /// Close the acceptor.
-  /**
-   * This function is used to close the acceptor. Any asynchronous accept
-   * operations will be cancelled immediately.
-   *
-   * A subsequent call to open() is required before the acceptor can again be
-   * used to again perform socket accept operations.
-   *
-   * @throws asio::system_error Thrown on failure.
-   */
-  void close()
-  {
-    asio::error_code ec;
-    this->get_service().close(this->get_implementation(), ec);
-    asio::detail::throw_error(ec, "close");
-  }
-
-  /// Close the acceptor.
-  /**
-   * This function is used to close the acceptor. Any asynchronous accept
-   * operations will be cancelled immediately.
-   *
-   * A subsequent call to open() is required before the acceptor can again be
-   * used to again perform socket accept operations.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   *
-   * @par Example
-   * @code
-   * asio::ip::tcp::acceptor acceptor(io_service);
-   * ...
-   * asio::error_code ec;
-   * acceptor.close(ec);
-   * if (ec)
-   * {
-   *   // An error occurred.
-   * }
-   * @endcode
-   */
-  asio::error_code close(asio::error_code& ec)
-  {
-    return this->get_service().close(this->get_implementation(), ec);
-  }
-
-  /// (Deprecated: Use native_handle().) Get the native acceptor representation.
-  /**
-   * This function may be used to obtain the underlying representation of the
-   * acceptor. This is intended to allow access to native acceptor functionality
-   * that is not otherwise provided.
-   */
-  native_type native()
-  {
-    return this->get_service().native_handle(this->get_implementation());
-  }
-
-  /// Get the native acceptor representation.
-  /**
-   * This function may be used to obtain the underlying representation of the
-   * acceptor. This is intended to allow access to native acceptor functionality
-   * that is not otherwise provided.
-   */
-  native_handle_type native_handle()
-  {
-    return this->get_service().native_handle(this->get_implementation());
-  }
-
-  /// Cancel all asynchronous operations associated with the acceptor.
-  /**
-   * This function causes all outstanding asynchronous connect, send and receive
-   * operations to finish immediately, and the handlers for cancelled operations
-   * will be passed the asio::error::operation_aborted error.
-   *
-   * @throws asio::system_error Thrown on failure.
-   */
-  void cancel()
-  {
-    asio::error_code ec;
-    this->get_service().cancel(this->get_implementation(), ec);
-    asio::detail::throw_error(ec, "cancel");
-  }
-
-  /// Cancel all asynchronous operations associated with the acceptor.
-  /**
-   * This function causes all outstanding asynchronous connect, send and receive
-   * operations to finish immediately, and the handlers for cancelled operations
-   * will be passed the asio::error::operation_aborted error.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   */
-  asio::error_code cancel(asio::error_code& ec)
-  {
-    return this->get_service().cancel(this->get_implementation(), ec);
-  }
-
-  /// Set an option on the acceptor.
-  /**
-   * This function is used to set an option on the acceptor.
-   *
-   * @param option The new option value to be set on the acceptor.
-   *
-   * @throws asio::system_error Thrown on failure.
-   *
-   * @sa SettableSocketOption @n
-   * asio::socket_base::reuse_address
-   * asio::socket_base::enable_connection_aborted
-   *
-   * @par Example
-   * Setting the SOL_SOCKET/SO_REUSEADDR option:
-   * @code
-   * asio::ip::tcp::acceptor acceptor(io_service);
-   * ...
-   * asio::ip::tcp::acceptor::reuse_address option(true);
-   * acceptor.set_option(option);
-   * @endcode
-   */
-  template <typename SettableSocketOption>
-  void set_option(const SettableSocketOption& option)
-  {
-    asio::error_code ec;
-    this->get_service().set_option(this->get_implementation(), option, ec);
-    asio::detail::throw_error(ec, "set_option");
-  }
-
-  /// Set an option on the acceptor.
-  /**
-   * This function is used to set an option on the acceptor.
-   *
-   * @param option The new option value to be set on the acceptor.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   *
-   * @sa SettableSocketOption @n
-   * asio::socket_base::reuse_address
-   * asio::socket_base::enable_connection_aborted
-   *
-   * @par Example
-   * Setting the SOL_SOCKET/SO_REUSEADDR option:
-   * @code
-   * asio::ip::tcp::acceptor acceptor(io_service);
-   * ...
-   * asio::ip::tcp::acceptor::reuse_address option(true);
-   * asio::error_code ec;
-   * acceptor.set_option(option, ec);
-   * if (ec)
-   * {
-   *   // An error occurred.
-   * }
-   * @endcode
-   */
-  template <typename SettableSocketOption>
-  asio::error_code set_option(const SettableSocketOption& option,
-      asio::error_code& ec)
-  {
-    return this->get_service().set_option(
-        this->get_implementation(), option, ec);
-  }
-
-  /// Get an option from the acceptor.
-  /**
-   * This function is used to get the current value of an option on the
-   * acceptor.
-   *
-   * @param option The option value to be obtained from the acceptor.
-   *
-   * @throws asio::system_error Thrown on failure.
-   *
-   * @sa GettableSocketOption @n
-   * asio::socket_base::reuse_address
-   *
-   * @par Example
-   * Getting the value of the SOL_SOCKET/SO_REUSEADDR option:
-   * @code
-   * asio::ip::tcp::acceptor acceptor(io_service);
-   * ...
-   * asio::ip::tcp::acceptor::reuse_address option;
-   * acceptor.get_option(option);
-   * bool is_set = option.get();
-   * @endcode
-   */
-  template <typename GettableSocketOption>
-  void get_option(GettableSocketOption& option)
-  {
-    asio::error_code ec;
-    this->get_service().get_option(this->get_implementation(), option, ec);
-    asio::detail::throw_error(ec, "get_option");
-  }
-
-  /// Get an option from the acceptor.
-  /**
-   * This function is used to get the current value of an option on the
-   * acceptor.
-   *
-   * @param option The option value to be obtained from the acceptor.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   *
-   * @sa GettableSocketOption @n
-   * asio::socket_base::reuse_address
-   *
-   * @par Example
-   * Getting the value of the SOL_SOCKET/SO_REUSEADDR option:
-   * @code
-   * asio::ip::tcp::acceptor acceptor(io_service);
-   * ...
-   * asio::ip::tcp::acceptor::reuse_address option;
-   * asio::error_code ec;
-   * acceptor.get_option(option, ec);
-   * if (ec)
-   * {
-   *   // An error occurred.
-   * }
-   * bool is_set = option.get();
-   * @endcode
-   */
-  template <typename GettableSocketOption>
-  asio::error_code get_option(GettableSocketOption& option,
-      asio::error_code& ec)
-  {
-    return this->get_service().get_option(
-        this->get_implementation(), option, ec);
-  }
-
-  /// Perform an IO control command on the acceptor.
-  /**
-   * This function is used to execute an IO control command on the acceptor.
-   *
-   * @param command The IO control command to be performed on the acceptor.
-   *
-   * @throws asio::system_error Thrown on failure.
-   *
-   * @sa IoControlCommand @n
-   * asio::socket_base::non_blocking_io
-   *
-   * @par Example
-   * Getting the number of bytes ready to read:
-   * @code
-   * asio::ip::tcp::acceptor acceptor(io_service);
-   * ...
-   * asio::ip::tcp::acceptor::non_blocking_io command(true);
-   * socket.io_control(command);
-   * @endcode
-   */
-  template <typename IoControlCommand>
-  void io_control(IoControlCommand& command)
-  {
-    asio::error_code ec;
-    this->get_service().io_control(this->get_implementation(), command, ec);
-    asio::detail::throw_error(ec, "io_control");
-  }
-
-  /// Perform an IO control command on the acceptor.
-  /**
-   * This function is used to execute an IO control command on the acceptor.
-   *
-   * @param command The IO control command to be performed on the acceptor.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   *
-   * @sa IoControlCommand @n
-   * asio::socket_base::non_blocking_io
-   *
-   * @par Example
-   * Getting the number of bytes ready to read:
-   * @code
-   * asio::ip::tcp::acceptor acceptor(io_service);
-   * ...
-   * asio::ip::tcp::acceptor::non_blocking_io command(true);
-   * asio::error_code ec;
-   * socket.io_control(command, ec);
-   * if (ec)
-   * {
-   *   // An error occurred.
-   * }
-   * @endcode
-   */
-  template <typename IoControlCommand>
-  asio::error_code io_control(IoControlCommand& command,
-      asio::error_code& ec)
-  {
-    return this->get_service().io_control(
-        this->get_implementation(), command, ec);
-  }
-
-  /// Gets the non-blocking mode of the acceptor.
-  /**
-   * @returns @c true if the acceptor's synchronous operations will fail with
-   * asio::error::would_block if they are unable to perform the requested
-   * operation immediately. If @c false, synchronous operations will block
-   * until complete.
-   *
-   * @note The non-blocking mode has no effect on the behaviour of asynchronous
-   * operations. Asynchronous operations will never fail with the error
-   * asio::error::would_block.
-   */
-  bool non_blocking() const
-  {
-    return this->get_service().non_blocking(this->get_implementation());
-  }
-
-  /// Sets the non-blocking mode of the acceptor.
-  /**
-   * @param mode If @c true, the acceptor's synchronous operations will fail
-   * with asio::error::would_block if they are unable to perform the
-   * requested operation immediately. If @c false, synchronous operations will
-   * block until complete.
-   *
-   * @throws asio::system_error Thrown on failure.
-   *
-   * @note The non-blocking mode has no effect on the behaviour of asynchronous
-   * operations. Asynchronous operations will never fail with the error
-   * asio::error::would_block.
-   */
-  void non_blocking(bool mode)
-  {
-    asio::error_code ec;
-    this->get_service().non_blocking(this->get_implementation(), mode, ec);
-    asio::detail::throw_error(ec, "non_blocking");
-  }
-
-  /// Sets the non-blocking mode of the acceptor.
-  /**
-   * @param mode If @c true, the acceptor's synchronous operations will fail
-   * with asio::error::would_block if they are unable to perform the
-   * requested operation immediately. If @c false, synchronous operations will
-   * block until complete.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   *
-   * @note The non-blocking mode has no effect on the behaviour of asynchronous
-   * operations. Asynchronous operations will never fail with the error
-   * asio::error::would_block.
-   */
-  asio::error_code non_blocking(
-      bool mode, asio::error_code& ec)
-  {
-    return this->get_service().non_blocking(
-        this->get_implementation(), mode, ec);
-  }
-
-  /// Gets the non-blocking mode of the native acceptor implementation.
-  /**
-   * This function is used to retrieve the non-blocking mode of the underlying
-   * native acceptor. This mode has no effect on the behaviour of the acceptor
-   * object's synchronous operations.
-   *
-   * @returns @c true if the underlying acceptor is in non-blocking mode and
-   * direct system calls may fail with asio::error::would_block (or the
-   * equivalent system error).
-   *
-   * @note The current non-blocking mode is cached by the acceptor object.
-   * Consequently, the return value may be incorrect if the non-blocking mode
-   * was set directly on the native acceptor.
-   */
-  bool native_non_blocking() const
-  {
-    return this->get_service().native_non_blocking(this->get_implementation());
-  }
-
-  /// Sets the non-blocking mode of the native acceptor implementation.
-  /**
-   * This function is used to modify the non-blocking mode of the underlying
-   * native acceptor. It has no effect on the behaviour of the acceptor object's
-   * synchronous operations.
-   *
-   * @param mode If @c true, the underlying acceptor is put into non-blocking
-   * mode and direct system calls may fail with asio::error::would_block
-   * (or the equivalent system error).
-   *
-   * @throws asio::system_error Thrown on failure. If the @c mode is
-   * @c false, but the current value of @c non_blocking() is @c true, this
-   * function fails with asio::error::invalid_argument, as the
-   * combination does not make sense.
-   */
-  void native_non_blocking(bool mode)
-  {
-    asio::error_code ec;
-    this->get_service().native_non_blocking(
-        this->get_implementation(), mode, ec);
-    asio::detail::throw_error(ec, "native_non_blocking");
-  }
-
-  /// Sets the non-blocking mode of the native acceptor implementation.
-  /**
-   * This function is used to modify the non-blocking mode of the underlying
-   * native acceptor. It has no effect on the behaviour of the acceptor object's
-   * synchronous operations.
-   *
-   * @param mode If @c true, the underlying acceptor is put into non-blocking
-   * mode and direct system calls may fail with asio::error::would_block
-   * (or the equivalent system error).
-   *
-   * @param ec Set to indicate what error occurred, if any. If the @c mode is
-   * @c false, but the current value of @c non_blocking() is @c true, this
-   * function fails with asio::error::invalid_argument, as the
-   * combination does not make sense.
-   */
-  asio::error_code native_non_blocking(
-      bool mode, asio::error_code& ec)
-  {
-    return this->get_service().native_non_blocking(
-        this->get_implementation(), mode, ec);
-  }
-
-  /// Get the local endpoint of the acceptor.
-  /**
-   * This function is used to obtain the locally bound endpoint of the acceptor.
-   *
-   * @returns An object that represents the local endpoint of the acceptor.
-   *
-   * @throws asio::system_error Thrown on failure.
-   *
-   * @par Example
-   * @code
-   * asio::ip::tcp::acceptor acceptor(io_service);
-   * ...
-   * asio::ip::tcp::endpoint endpoint = acceptor.local_endpoint();
-   * @endcode
-   */
-  endpoint_type local_endpoint() const
-  {
-    asio::error_code ec;
-    endpoint_type ep = this->get_service().local_endpoint(
-        this->get_implementation(), ec);
-    asio::detail::throw_error(ec, "local_endpoint");
-    return ep;
-  }
-
-  /// Get the local endpoint of the acceptor.
-  /**
-   * This function is used to obtain the locally bound endpoint of the acceptor.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   *
-   * @returns An object that represents the local endpoint of the acceptor.
-   * Returns a default-constructed endpoint object if an error occurred and the
-   * error handler did not throw an exception.
-   *
-   * @par Example
-   * @code
-   * asio::ip::tcp::acceptor acceptor(io_service);
-   * ...
-   * asio::error_code ec;
-   * asio::ip::tcp::endpoint endpoint = acceptor.local_endpoint(ec);
-   * if (ec)
-   * {
-   *   // An error occurred.
-   * }
-   * @endcode
-   */
-  endpoint_type local_endpoint(asio::error_code& ec) const
-  {
-    return this->get_service().local_endpoint(this->get_implementation(), ec);
-  }
-
-  /// Accept a new connection.
-  /**
-   * This function is used to accept a new connection from a peer into the
-   * given socket. The function call will block until a new connection has been
-   * accepted successfully or an error occurs.
-   *
-   * @param peer The socket into which the new connection will be accepted.
-   *
-   * @throws asio::system_error Thrown on failure.
-   *
-   * @par Example
-   * @code
-   * asio::ip::tcp::acceptor acceptor(io_service);
-   * ...
-   * asio::ip::tcp::socket socket(io_service);
-   * acceptor.accept(socket);
-   * @endcode
-   */
-  template <typename Protocol1, typename SocketService>
-  void accept(basic_socket<Protocol1, SocketService>& peer,
-      typename enable_if<is_convertible<Protocol, Protocol1>::value>::type* = 0)
-  {
-    asio::error_code ec;
-    this->get_service().accept(this->get_implementation(),
-        peer, static_cast<endpoint_type*>(0), ec);
-    asio::detail::throw_error(ec, "accept");
-  }
-
-  /// Accept a new connection.
-  /**
-   * This function is used to accept a new connection from a peer into the
-   * given socket. The function call will block until a new connection has been
-   * accepted successfully or an error occurs.
-   *
-   * @param peer The socket into which the new connection will be accepted.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   *
-   * @par Example
-   * @code
-   * asio::ip::tcp::acceptor acceptor(io_service);
-   * ...
-   * asio::ip::tcp::soocket socket(io_service);
-   * asio::error_code ec;
-   * acceptor.accept(socket, ec);
-   * if (ec)
-   * {
-   *   // An error occurred.
-   * }
-   * @endcode
-   */
-  template <typename Protocol1, typename SocketService>
-  asio::error_code accept(
-      basic_socket<Protocol1, SocketService>& peer,
-      asio::error_code& ec,
-      typename enable_if<is_convertible<Protocol, Protocol1>::value>::type* = 0)
-  {
-    return this->get_service().accept(this->get_implementation(),
-        peer, static_cast<endpoint_type*>(0), ec);
-  }
-
-  /// Start an asynchronous accept.
-  /**
-   * This function is used to asynchronously accept a new connection into a
-   * socket. The function call always returns immediately.
-   *
-   * @param peer The socket into which the new connection will be accepted.
-   * Ownership of the peer object is retained by the caller, which must
-   * guarantee that it is valid until the handler is called.
-   *
-   * @param handler The handler to be called when the accept operation
-   * completes. Copies will be made of the handler as required. The function
-   * signature of the handler must be:
-   * @code void handler(
-   *   const asio::error_code& error // Result of operation.
-   * ); @endcode
-   * Regardless of whether the asynchronous operation completes immediately or
-   * not, the handler will not be invoked from within this function. Invocation
-   * of the handler will be performed in a manner equivalent to using
-   * asio::io_service::post().
-   *
-   * @par Example
-   * @code
-   * void accept_handler(const asio::error_code& error)
-   * {
-   *   if (!error)
-   *   {
-   *     // Accept succeeded.
-   *   }
-   * }
-   *
-   * ...
-   *
-   * asio::ip::tcp::acceptor acceptor(io_service);
-   * ...
-   * asio::ip::tcp::socket socket(io_service);
-   * acceptor.async_accept(socket, accept_handler);
-   * @endcode
-   */
-  template <typename Protocol1, typename SocketService, typename AcceptHandler>
-  ASIO_INITFN_RESULT_TYPE(AcceptHandler,
-      void (asio::error_code))
-  async_accept(basic_socket<Protocol1, SocketService>& peer,
-      ASIO_MOVE_ARG(AcceptHandler) handler,
-      typename enable_if<is_convertible<Protocol, Protocol1>::value>::type* = 0)
-  {
-    // If you get an error on the following line it means that your handler does
-    // not meet the documented type requirements for a AcceptHandler.
-    ASIO_ACCEPT_HANDLER_CHECK(AcceptHandler, handler) type_check;
-
-    return this->get_service().async_accept(this->get_implementation(),
-        peer, static_cast<endpoint_type*>(0),
-        ASIO_MOVE_CAST(AcceptHandler)(handler));
-  }
-
-  /// Accept a new connection and obtain the endpoint of the peer
-  /**
-   * This function is used to accept a new connection from a peer into the
-   * given socket, and additionally provide the endpoint of the remote peer.
-   * The function call will block until a new connection has been accepted
-   * successfully or an error occurs.
-   *
-   * @param peer The socket into which the new connection will be accepted.
-   *
-   * @param peer_endpoint An endpoint object which will receive the endpoint of
-   * the remote peer.
-   *
-   * @throws asio::system_error Thrown on failure.
-   *
-   * @par Example
-   * @code
-   * asio::ip::tcp::acceptor acceptor(io_service);
-   * ...
-   * asio::ip::tcp::socket socket(io_service);
-   * asio::ip::tcp::endpoint endpoint;
-   * acceptor.accept(socket, endpoint);
-   * @endcode
-   */
-  template <typename SocketService>
-  void accept(basic_socket<protocol_type, SocketService>& peer,
-      endpoint_type& peer_endpoint)
-  {
-    asio::error_code ec;
-    this->get_service().accept(this->get_implementation(),
-        peer, &peer_endpoint, ec);
-    asio::detail::throw_error(ec, "accept");
-  }
-
-  /// Accept a new connection and obtain the endpoint of the peer
-  /**
-   * This function is used to accept a new connection from a peer into the
-   * given socket, and additionally provide the endpoint of the remote peer.
-   * The function call will block until a new connection has been accepted
-   * successfully or an error occurs.
-   *
-   * @param peer The socket into which the new connection will be accepted.
-   *
-   * @param peer_endpoint An endpoint object which will receive the endpoint of
-   * the remote peer.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   *
-   * @par Example
-   * @code
-   * asio::ip::tcp::acceptor acceptor(io_service);
-   * ...
-   * asio::ip::tcp::socket socket(io_service);
-   * asio::ip::tcp::endpoint endpoint;
-   * asio::error_code ec;
-   * acceptor.accept(socket, endpoint, ec);
-   * if (ec)
-   * {
-   *   // An error occurred.
-   * }
-   * @endcode
-   */
-  template <typename SocketService>
-  asio::error_code accept(
-      basic_socket<protocol_type, SocketService>& peer,
-      endpoint_type& peer_endpoint, asio::error_code& ec)
-  {
-    return this->get_service().accept(
-        this->get_implementation(), peer, &peer_endpoint, ec);
-  }
-
-  /// Start an asynchronous accept.
-  /**
-   * This function is used to asynchronously accept a new connection into a
-   * socket, and additionally obtain the endpoint of the remote peer. The
-   * function call always returns immediately.
-   *
-   * @param peer The socket into which the new connection will be accepted.
-   * Ownership of the peer object is retained by the caller, which must
-   * guarantee that it is valid until the handler is called.
-   *
-   * @param peer_endpoint An endpoint object into which the endpoint of the
-   * remote peer will be written. Ownership of the peer_endpoint object is
-   * retained by the caller, which must guarantee that it is valid until the
-   * handler is called.
-   *
-   * @param handler The handler to be called when the accept operation
-   * completes. Copies will be made of the handler as required. The function
-   * signature of the handler must be:
-   * @code void handler(
-   *   const asio::error_code& error // Result of operation.
-   * ); @endcode
-   * Regardless of whether the asynchronous operation completes immediately or
-   * not, the handler will not be invoked from within this function. Invocation
-   * of the handler will be performed in a manner equivalent to using
-   * asio::io_service::post().
-   */
-  template <typename SocketService, typename AcceptHandler>
-  ASIO_INITFN_RESULT_TYPE(AcceptHandler,
-      void (asio::error_code))
-  async_accept(basic_socket<protocol_type, SocketService>& peer,
-      endpoint_type& peer_endpoint, ASIO_MOVE_ARG(AcceptHandler) handler)
-  {
-    // If you get an error on the following line it means that your handler does
-    // not meet the documented type requirements for a AcceptHandler.
-    ASIO_ACCEPT_HANDLER_CHECK(AcceptHandler, handler) type_check;
-
-    return this->get_service().async_accept(this->get_implementation(), peer,
-        &peer_endpoint, ASIO_MOVE_CAST(AcceptHandler)(handler));
-  }
-};
-
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_BASIC_SOCKET_ACCEPTOR_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/basic_socket_iostream.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/basic_socket_iostream.hpp
deleted file mode 100644
index 81754022131f..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/basic_socket_iostream.hpp
+++ /dev/null
@@ -1,286 +0,0 @@
-//
-// basic_socket_iostream.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_BASIC_SOCKET_IOSTREAM_HPP
-#define ASIO_BASIC_SOCKET_IOSTREAM_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if !defined(ASIO_NO_IOSTREAM)
-
-#include <istream>
-#include <ostream>
-#include "asio/basic_socket_streambuf.hpp"
-#include "asio/stream_socket_service.hpp"
-
-#if !defined(ASIO_HAS_VARIADIC_TEMPLATES)
-
-# include "asio/detail/variadic_templates.hpp"
-
-// A macro that should expand to:
-//   template <typename T1, ..., typename Tn>
-//   explicit basic_socket_iostream(T1 x1, ..., Tn xn)
-//     : std::basic_iostream<char>(
-//         &this->detail::socket_iostream_base<
-//           Protocol, StreamSocketService, Time,
-//           TimeTraits, TimerService>::streambuf_)
-//   {
-//     if (rdbuf()->connect(x1, ..., xn) == 0)
-//       this->setstate(std::ios_base::failbit);
-//   }
-// This macro should only persist within this file.
-
-# define ASIO_PRIVATE_CTR_DEF(n) \
-  template <ASIO_VARIADIC_TPARAMS(n)> \
-  explicit basic_socket_iostream(ASIO_VARIADIC_PARAMS(n)) \
-    : std::basic_iostream<char>( \
-        &this->detail::socket_iostream_base< \
-          Protocol, StreamSocketService, Time, \
-          TimeTraits, TimerService>::streambuf_) \
-  { \
-    this->setf(std::ios_base::unitbuf); \
-    if (rdbuf()->connect(ASIO_VARIADIC_ARGS(n)) == 0) \
-      this->setstate(std::ios_base::failbit); \
-  } \
-  /**/
-
-// A macro that should expand to:
-//   template <typename T1, ..., typename Tn>
-//   void connect(T1 x1, ..., Tn xn)
-//   {
-//     if (rdbuf()->connect(x1, ..., xn) == 0)
-//       this->setstate(std::ios_base::failbit);
-//   }
-// This macro should only persist within this file.
-
-# define ASIO_PRIVATE_CONNECT_DEF(n) \
-  template <ASIO_VARIADIC_TPARAMS(n)> \
-  void connect(ASIO_VARIADIC_PARAMS(n)) \
-  { \
-    if (rdbuf()->connect(ASIO_VARIADIC_ARGS(n)) == 0) \
-      this->setstate(std::ios_base::failbit); \
-  } \
-  /**/
-
-#endif // !defined(ASIO_HAS_VARIADIC_TEMPLATES)
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-// A separate base class is used to ensure that the streambuf is initialised
-// prior to the basic_socket_iostream's basic_iostream base class.
-template <typename Protocol, typename StreamSocketService,
-    typename Time, typename TimeTraits, typename TimerService>
-class socket_iostream_base
-{
-protected:
-  basic_socket_streambuf<Protocol, StreamSocketService,
-    Time, TimeTraits, TimerService> streambuf_;
-};
-
-}
-
-/// Iostream interface for a socket.
-template <typename Protocol,
-    typename StreamSocketService = stream_socket_service<Protocol>,
-#if defined(ASIO_HAS_BOOST_DATE_TIME) \
-  || defined(GENERATING_DOCUMENTATION)
-    typename Time = boost::posix_time::ptime,
-    typename TimeTraits = asio::time_traits<Time>,
-    typename TimerService = deadline_timer_service<Time, TimeTraits> >
-#else
-    typename Time = steady_timer::clock_type,
-    typename TimeTraits = steady_timer::traits_type,
-    typename TimerService = steady_timer::service_type>
-#endif
-class basic_socket_iostream
-  : private detail::socket_iostream_base<Protocol,
-        StreamSocketService, Time, TimeTraits, TimerService>,
-    public std::basic_iostream<char>
-{
-private:
-  // These typedefs are intended keep this class's implementation independent
-  // of whether it's using Boost.DateTime, Boost.Chrono or std::chrono.
-#if defined(ASIO_HAS_BOOST_DATE_TIME)
-  typedef TimeTraits traits_helper;
-#else
-  typedef detail::chrono_time_traits<Time, TimeTraits> traits_helper;
-#endif
-
-public:
-  /// The endpoint type.
-  typedef typename Protocol::endpoint endpoint_type;
-
-#if defined(GENERATING_DOCUMENTATION)
-  /// The time type.
-  typedef typename TimeTraits::time_type time_type;
-
-  /// The duration type.
-  typedef typename TimeTraits::duration_type duration_type;
-#else
-  typedef typename traits_helper::time_type time_type;
-  typedef typename traits_helper::duration_type duration_type;
-#endif
-
-  /// Construct a basic_socket_iostream without establishing a connection.
-  basic_socket_iostream()
-    : std::basic_iostream<char>(
-        &this->detail::socket_iostream_base<
-          Protocol, StreamSocketService, Time,
-          TimeTraits, TimerService>::streambuf_)
-  {
-    this->setf(std::ios_base::unitbuf);
-  }
-
-#if defined(GENERATING_DOCUMENTATION)
-  /// Establish a connection to an endpoint corresponding to a resolver query.
-  /**
-   * This constructor automatically establishes a connection based on the
-   * supplied resolver query parameters. The arguments are used to construct
-   * a resolver query object.
-   */
-  template <typename T1, ..., typename TN>
-  explicit basic_socket_iostream(T1 t1, ..., TN tn);
-#elif defined(ASIO_HAS_VARIADIC_TEMPLATES)
-  template <typename... T>
-  explicit basic_socket_iostream(T... x)
-    : std::basic_iostream<char>(
-        &this->detail::socket_iostream_base<
-          Protocol, StreamSocketService, Time,
-          TimeTraits, TimerService>::streambuf_)
-  {
-    this->setf(std::ios_base::unitbuf);
-    if (rdbuf()->connect(x...) == 0)
-      this->setstate(std::ios_base::failbit);
-  }
-#else
-  ASIO_VARIADIC_GENERATE(ASIO_PRIVATE_CTR_DEF)
-#endif
-
-#if defined(GENERATING_DOCUMENTATION)
-  /// Establish a connection to an endpoint corresponding to a resolver query.
-  /**
-   * This function automatically establishes a connection based on the supplied
-   * resolver query parameters. The arguments are used to construct a resolver
-   * query object.
-   */
-  template <typename T1, ..., typename TN>
-  void connect(T1 t1, ..., TN tn);
-#elif defined(ASIO_HAS_VARIADIC_TEMPLATES)
-  template <typename... T>
-  void connect(T... x)
-  {
-    if (rdbuf()->connect(x...) == 0)
-      this->setstate(std::ios_base::failbit);
-  }
-#else
-  ASIO_VARIADIC_GENERATE(ASIO_PRIVATE_CONNECT_DEF)
-#endif
-
-  /// Close the connection.
-  void close()
-  {
-    if (rdbuf()->close() == 0)
-      this->setstate(std::ios_base::failbit);
-  }
-
-  /// Return a pointer to the underlying streambuf.
-  basic_socket_streambuf<Protocol, StreamSocketService,
-    Time, TimeTraits, TimerService>* rdbuf() const
-  {
-    return const_cast<basic_socket_streambuf<Protocol, StreamSocketService,
-      Time, TimeTraits, TimerService>*>(
-        &this->detail::socket_iostream_base<
-          Protocol, StreamSocketService, Time,
-          TimeTraits, TimerService>::streambuf_);
-  }
-
-  /// Get the last error associated with the stream.
-  /**
-   * @return An \c error_code corresponding to the last error from the stream.
-   *
-   * @par Example
-   * To print the error associated with a failure to establish a connection:
-   * @code tcp::iostream s("www.boost.org", "http");
-   * if (!s)
-   * {
-   *   std::cout << "Error: " << s.error().message() << std::endl;
-   * } @endcode
-   */
-  const asio::error_code& error() const
-  {
-    return rdbuf()->puberror();
-  }
-
-  /// Get the stream's expiry time as an absolute time.
-  /**
-   * @return An absolute time value representing the stream's expiry time.
-   */
-  time_type expires_at() const
-  {
-    return rdbuf()->expires_at();
-  }
-
-  /// Set the stream's expiry time as an absolute time.
-  /**
-   * This function sets the expiry time associated with the stream. Stream
-   * operations performed after this time (where the operations cannot be
-   * completed using the internal buffers) will fail with the error
-   * asio::error::operation_aborted.
-   *
-   * @param expiry_time The expiry time to be used for the stream.
-   */
-  void expires_at(const time_type& expiry_time)
-  {
-    rdbuf()->expires_at(expiry_time);
-  }
-
-  /// Get the timer's expiry time relative to now.
-  /**
-   * @return A relative time value representing the stream's expiry time.
-   */
-  duration_type expires_from_now() const
-  {
-    return rdbuf()->expires_from_now();
-  }
-
-  /// Set the stream's expiry time relative to now.
-  /**
-   * This function sets the expiry time associated with the stream. Stream
-   * operations performed after this time (where the operations cannot be
-   * completed using the internal buffers) will fail with the error
-   * asio::error::operation_aborted.
-   *
-   * @param expiry_time The expiry time to be used for the timer.
-   */
-  void expires_from_now(const duration_type& expiry_time)
-  {
-    rdbuf()->expires_from_now(expiry_time);
-  }
-};
-
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#if !defined(ASIO_HAS_VARIADIC_TEMPLATES)
-# undef ASIO_PRIVATE_CTR_DEF
-# undef ASIO_PRIVATE_CONNECT_DEF
-#endif // !defined(ASIO_HAS_VARIADIC_TEMPLATES)
-
-#endif // !defined(ASIO_NO_IOSTREAM)
-
-#endif // ASIO_BASIC_SOCKET_IOSTREAM_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/basic_socket_streambuf.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/basic_socket_streambuf.hpp
deleted file mode 100644
index c2f368a406c2..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/basic_socket_streambuf.hpp
+++ /dev/null
@@ -1,567 +0,0 @@
-//
-// basic_socket_streambuf.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_BASIC_SOCKET_STREAMBUF_HPP
-#define ASIO_BASIC_SOCKET_STREAMBUF_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if !defined(ASIO_NO_IOSTREAM)
-
-#include <streambuf>
-#include "asio/basic_socket.hpp"
-#include "asio/deadline_timer_service.hpp"
-#include "asio/detail/array.hpp"
-#include "asio/detail/throw_error.hpp"
-#include "asio/io_service.hpp"
-#include "asio/stream_socket_service.hpp"
-
-#if defined(ASIO_HAS_BOOST_DATE_TIME)
-# include "asio/deadline_timer.hpp"
-#else
-# include "asio/steady_timer.hpp"
-#endif
-
-#if !defined(ASIO_HAS_VARIADIC_TEMPLATES)
-
-# include "asio/detail/variadic_templates.hpp"
-
-// A macro that should expand to:
-//   template <typename T1, ..., typename Tn>
-//   basic_socket_streambuf<Protocol, StreamSocketService,
-//     Time, TimeTraits, TimerService>* connect(
-//       T1 x1, ..., Tn xn)
-//   {
-//     init_buffers();
-//     this->basic_socket<Protocol, StreamSocketService>::close(ec_);
-//     typedef typename Protocol::resolver resolver_type;
-//     typedef typename resolver_type::query resolver_query;
-//     resolver_query query(x1, ..., xn);
-//     resolve_and_connect(query);
-//     return !ec_ ? this : 0;
-//   }
-// This macro should only persist within this file.
-
-# define ASIO_PRIVATE_CONNECT_DEF(n) \
-  template <ASIO_VARIADIC_TPARAMS(n)> \
-  basic_socket_streambuf<Protocol, StreamSocketService, \
-    Time, TimeTraits, TimerService>* connect(ASIO_VARIADIC_PARAMS(n)) \
-  { \
-    init_buffers(); \
-    this->basic_socket<Protocol, StreamSocketService>::close(ec_); \
-    typedef typename Protocol::resolver resolver_type; \
-    typedef typename resolver_type::query resolver_query; \
-    resolver_query query(ASIO_VARIADIC_ARGS(n)); \
-    resolve_and_connect(query); \
-    return !ec_ ? this : 0; \
-  } \
-  /**/
-
-#endif // !defined(ASIO_HAS_VARIADIC_TEMPLATES)
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-// A separate base class is used to ensure that the io_service is initialised
-// prior to the basic_socket_streambuf's basic_socket base class.
-class socket_streambuf_base
-{
-protected:
-  io_service io_service_;
-};
-
-} // namespace detail
-
-/// Iostream streambuf for a socket.
-template <typename Protocol,
-    typename StreamSocketService = stream_socket_service<Protocol>,
-#if defined(ASIO_HAS_BOOST_DATE_TIME) \
-  || defined(GENERATING_DOCUMENTATION)
-    typename Time = boost::posix_time::ptime,
-    typename TimeTraits = asio::time_traits<Time>,
-    typename TimerService = deadline_timer_service<Time, TimeTraits> >
-#else
-    typename Time = steady_timer::clock_type,
-    typename TimeTraits = steady_timer::traits_type,
-    typename TimerService = steady_timer::service_type>
-#endif
-class basic_socket_streambuf
-  : public std::streambuf,
-    private detail::socket_streambuf_base,
-    public basic_socket<Protocol, StreamSocketService>
-{
-private:
-  // These typedefs are intended keep this class's implementation independent
-  // of whether it's using Boost.DateTime, Boost.Chrono or std::chrono.
-#if defined(ASIO_HAS_BOOST_DATE_TIME)
-  typedef TimeTraits traits_helper;
-#else
-  typedef detail::chrono_time_traits<Time, TimeTraits> traits_helper;
-#endif
-
-public:
-  /// The endpoint type.
-  typedef typename Protocol::endpoint endpoint_type;
-
-#if defined(GENERATING_DOCUMENTATION)
-  /// The time type.
-  typedef typename TimeTraits::time_type time_type;
-
-  /// The duration type.
-  typedef typename TimeTraits::duration_type duration_type;
-#else
-  typedef typename traits_helper::time_type time_type;
-  typedef typename traits_helper::duration_type duration_type;
-#endif
-
-  /// Construct a basic_socket_streambuf without establishing a connection.
-  basic_socket_streambuf()
-    : basic_socket<Protocol, StreamSocketService>(
-        this->detail::socket_streambuf_base::io_service_),
-      unbuffered_(false),
-      timer_service_(0),
-      timer_state_(no_timer)
-  {
-    init_buffers();
-  }
-
-  /// Destructor flushes buffered data.
-  virtual ~basic_socket_streambuf()
-  {
-    if (pptr() != pbase())
-      overflow(traits_type::eof());
-
-    destroy_timer();
-  }
-
-  /// Establish a connection.
-  /**
-   * This function establishes a connection to the specified endpoint.
-   *
-   * @return \c this if a connection was successfully established, a null
-   * pointer otherwise.
-   */
-  basic_socket_streambuf<Protocol, StreamSocketService,
-    Time, TimeTraits, TimerService>* connect(
-      const endpoint_type& endpoint)
-  {
-    init_buffers();
-
-    this->basic_socket<Protocol, StreamSocketService>::close(ec_);
-
-    if (timer_state_ == timer_has_expired)
-    {
-      ec_ = asio::error::operation_aborted;
-      return 0;
-    }
-
-    io_handler handler = { this };
-    this->basic_socket<Protocol, StreamSocketService>::async_connect(
-        endpoint, handler);
-
-    ec_ = asio::error::would_block;
-    this->get_service().get_io_service().reset();
-    do this->get_service().get_io_service().run_one();
-    while (ec_ == asio::error::would_block);
-
-    return !ec_ ? this : 0;
-  }
-
-#if defined(GENERATING_DOCUMENTATION)
-  /// Establish a connection.
-  /**
-   * This function automatically establishes a connection based on the supplied
-   * resolver query parameters. The arguments are used to construct a resolver
-   * query object.
-   *
-   * @return \c this if a connection was successfully established, a null
-   * pointer otherwise.
-   */
-  template <typename T1, ..., typename TN>
-  basic_socket_streambuf<Protocol, StreamSocketService>* connect(
-      T1 t1, ..., TN tn);
-#elif defined(ASIO_HAS_VARIADIC_TEMPLATES)
-  template <typename... T>
-  basic_socket_streambuf<Protocol, StreamSocketService,
-    Time, TimeTraits, TimerService>* connect(T... x)
-  {
-    init_buffers();
-    this->basic_socket<Protocol, StreamSocketService>::close(ec_);
-    typedef typename Protocol::resolver resolver_type;
-    typedef typename resolver_type::query resolver_query;
-    resolver_query query(x...);
-    resolve_and_connect(query);
-    return !ec_ ? this : 0;
-  }
-#else
-  ASIO_VARIADIC_GENERATE(ASIO_PRIVATE_CONNECT_DEF)
-#endif
-
-  /// Close the connection.
-  /**
-   * @return \c this if a connection was successfully established, a null
-   * pointer otherwise.
-   */
-  basic_socket_streambuf<Protocol, StreamSocketService,
-    Time, TimeTraits, TimerService>* close()
-  {
-    sync();
-    this->basic_socket<Protocol, StreamSocketService>::close(ec_);
-    if (!ec_)
-      init_buffers();
-    return !ec_ ? this : 0;
-  }
-
-  /// Get the last error associated with the stream buffer.
-  /**
-   * @return An \c error_code corresponding to the last error from the stream
-   * buffer.
-   */
-  const asio::error_code& puberror() const
-  {
-    return error();
-  }
-
-  /// Get the stream buffer's expiry time as an absolute time.
-  /**
-   * @return An absolute time value representing the stream buffer's expiry
-   * time.
-   */
-  time_type expires_at() const
-  {
-    return timer_service_
-      ? timer_service_->expires_at(timer_implementation_)
-      : time_type();
-  }
-
-  /// Set the stream buffer's expiry time as an absolute time.
-  /**
-   * This function sets the expiry time associated with the stream. Stream
-   * operations performed after this time (where the operations cannot be
-   * completed using the internal buffers) will fail with the error
-   * asio::error::operation_aborted.
-   *
-   * @param expiry_time The expiry time to be used for the stream.
-   */
-  void expires_at(const time_type& expiry_time)
-  {
-    construct_timer();
-
-    asio::error_code ec;
-    timer_service_->expires_at(timer_implementation_, expiry_time, ec);
-    asio::detail::throw_error(ec, "expires_at");
-
-    start_timer();
-  }
-
-  /// Get the stream buffer's expiry time relative to now.
-  /**
-   * @return A relative time value representing the stream buffer's expiry time.
-   */
-  duration_type expires_from_now() const
-  {
-    return traits_helper::subtract(expires_at(), traits_helper::now());
-  }
-
-  /// Set the stream buffer's expiry time relative to now.
-  /**
-   * This function sets the expiry time associated with the stream. Stream
-   * operations performed after this time (where the operations cannot be
-   * completed using the internal buffers) will fail with the error
-   * asio::error::operation_aborted.
-   *
-   * @param expiry_time The expiry time to be used for the timer.
-   */
-  void expires_from_now(const duration_type& expiry_time)
-  {
-    construct_timer();
-
-    asio::error_code ec;
-    timer_service_->expires_from_now(timer_implementation_, expiry_time, ec);
-    asio::detail::throw_error(ec, "expires_from_now");
-
-    start_timer();
-  }
-
-protected:
-  int_type underflow()
-  {
-    if (gptr() == egptr())
-    {
-      if (timer_state_ == timer_has_expired)
-      {
-        ec_ = asio::error::operation_aborted;
-        return traits_type::eof();
-      }
-
-      io_handler handler = { this };
-      this->get_service().async_receive(this->get_implementation(),
-          asio::buffer(asio::buffer(get_buffer_) + putback_max),
-          0, handler);
-
-      ec_ = asio::error::would_block;
-      this->get_service().get_io_service().reset();
-      do this->get_service().get_io_service().run_one();
-      while (ec_ == asio::error::would_block);
-      if (ec_)
-        return traits_type::eof();
-
-      setg(&get_buffer_[0], &get_buffer_[0] + putback_max,
-          &get_buffer_[0] + putback_max + bytes_transferred_);
-      return traits_type::to_int_type(*gptr());
-    }
-    else
-    {
-      return traits_type::eof();
-    }
-  }
-
-  int_type overflow(int_type c)
-  {
-    if (unbuffered_)
-    {
-      if (traits_type::eq_int_type(c, traits_type::eof()))
-      {
-        // Nothing to do.
-        return traits_type::not_eof(c);
-      }
-      else
-      {
-        if (timer_state_ == timer_has_expired)
-        {
-          ec_ = asio::error::operation_aborted;
-          return traits_type::eof();
-        }
-
-        // Send the single character immediately.
-        char_type ch = traits_type::to_char_type(c);
-        io_handler handler = { this };
-        this->get_service().async_send(this->get_implementation(),
-            asio::buffer(&ch, sizeof(char_type)), 0, handler);
-
-        ec_ = asio::error::would_block;
-        this->get_service().get_io_service().reset();
-        do this->get_service().get_io_service().run_one();
-        while (ec_ == asio::error::would_block);
-        if (ec_)
-          return traits_type::eof();
-
-        return c;
-      }
-    }
-    else
-    {
-      // Send all data in the output buffer.
-      asio::const_buffer buffer =
-        asio::buffer(pbase(), pptr() - pbase());
-      while (asio::buffer_size(buffer) > 0)
-      {
-        if (timer_state_ == timer_has_expired)
-        {
-          ec_ = asio::error::operation_aborted;
-          return traits_type::eof();
-        }
-
-        io_handler handler = { this };
-        this->get_service().async_send(this->get_implementation(),
-            asio::buffer(buffer), 0, handler);
-
-        ec_ = asio::error::would_block;
-        this->get_service().get_io_service().reset();
-        do this->get_service().get_io_service().run_one();
-        while (ec_ == asio::error::would_block);
-        if (ec_)
-          return traits_type::eof();
-
-        buffer = buffer + bytes_transferred_;
-      }
-      setp(&put_buffer_[0], &put_buffer_[0] + put_buffer_.size());
-
-      // If the new character is eof then our work here is done.
-      if (traits_type::eq_int_type(c, traits_type::eof()))
-        return traits_type::not_eof(c);
-
-      // Add the new character to the output buffer.
-      *pptr() = traits_type::to_char_type(c);
-      pbump(1);
-      return c;
-    }
-  }
-
-  int sync()
-  {
-    return overflow(traits_type::eof());
-  }
-
-  std::streambuf* setbuf(char_type* s, std::streamsize n)
-  {
-    if (pptr() == pbase() && s == 0 && n == 0)
-    {
-      unbuffered_ = true;
-      setp(0, 0);
-      return this;
-    }
-
-    return 0;
-  }
-
-  /// Get the last error associated with the stream buffer.
-  /**
-   * @return An \c error_code corresponding to the last error from the stream
-   * buffer.
-   */
-  virtual const asio::error_code& error() const
-  {
-    return ec_;
-  }
-
-private:
-  void init_buffers()
-  {
-    setg(&get_buffer_[0],
-        &get_buffer_[0] + putback_max,
-        &get_buffer_[0] + putback_max);
-    if (unbuffered_)
-      setp(0, 0);
-    else
-      setp(&put_buffer_[0], &put_buffer_[0] + put_buffer_.size());
-  }
-
-  template <typename ResolverQuery>
-  void resolve_and_connect(const ResolverQuery& query)
-  {
-    typedef typename Protocol::resolver resolver_type;
-    typedef typename resolver_type::iterator iterator_type;
-    resolver_type resolver(detail::socket_streambuf_base::io_service_);
-    iterator_type i = resolver.resolve(query, ec_);
-    if (!ec_)
-    {
-      iterator_type end;
-      ec_ = asio::error::host_not_found;
-      while (ec_ && i != end)
-      {
-        this->basic_socket<Protocol, StreamSocketService>::close(ec_);
-
-        if (timer_state_ == timer_has_expired)
-        {
-          ec_ = asio::error::operation_aborted;
-          return;
-        }
-
-        io_handler handler = { this };
-        this->basic_socket<Protocol, StreamSocketService>::async_connect(
-            *i, handler);
-
-        ec_ = asio::error::would_block;
-        this->get_service().get_io_service().reset();
-        do this->get_service().get_io_service().run_one();
-        while (ec_ == asio::error::would_block);
-
-        ++i;
-      }
-    }
-  }
-
-  struct io_handler;
-  friend struct io_handler;
-  struct io_handler
-  {
-    basic_socket_streambuf* this_;
-
-    void operator()(const asio::error_code& ec,
-        std::size_t bytes_transferred = 0)
-    {
-      this_->ec_ = ec;
-      this_->bytes_transferred_ = bytes_transferred;
-    }
-  };
-
-  struct timer_handler;
-  friend struct timer_handler;
-  struct timer_handler
-  {
-    basic_socket_streambuf* this_;
-
-    void operator()(const asio::error_code&)
-    {
-      time_type now = traits_helper::now();
-
-      time_type expiry_time = this_->timer_service_->expires_at(
-            this_->timer_implementation_);
-
-      if (traits_helper::less_than(now, expiry_time))
-      {
-        this_->timer_state_ = timer_is_pending;
-        this_->timer_service_->async_wait(this_->timer_implementation_, *this);
-      }
-      else
-      {
-        this_->timer_state_ = timer_has_expired;
-        asio::error_code ec;
-        this_->basic_socket<Protocol, StreamSocketService>::close(ec);
-      }
-    }
-  };
-
-  void construct_timer()
-  {
-    if (timer_service_ == 0)
-    {
-      TimerService& timer_service = use_service<TimerService>(
-          detail::socket_streambuf_base::io_service_);
-      timer_service.construct(timer_implementation_);
-      timer_service_ = &timer_service;
-    }
-  }
-
-  void destroy_timer()
-  {
-    if (timer_service_)
-      timer_service_->destroy(timer_implementation_);
-  }
-
-  void start_timer()
-  {
-    if (timer_state_ != timer_is_pending)
-    {
-      timer_handler handler = { this };
-      handler(asio::error_code());
-    }
-  }
-
-  enum { putback_max = 8 };
-  enum { buffer_size = 512 };
-  asio::detail::array<char, buffer_size> get_buffer_;
-  asio::detail::array<char, buffer_size> put_buffer_;
-  bool unbuffered_;
-  asio::error_code ec_;
-  std::size_t bytes_transferred_;
-  TimerService* timer_service_;
-  typename TimerService::implementation_type timer_implementation_;
-  enum state { no_timer, timer_is_pending, timer_has_expired } timer_state_;
-};
-
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#if !defined(ASIO_HAS_VARIADIC_TEMPLATES)
-# undef ASIO_PRIVATE_CONNECT_DEF
-#endif // !defined(ASIO_HAS_VARIADIC_TEMPLATES)
-
-#endif // !defined(ASIO_NO_IOSTREAM)
-
-#endif // ASIO_BASIC_SOCKET_STREAMBUF_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/basic_stream_socket.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/basic_stream_socket.hpp
deleted file mode 100644
index f2d1ccf344dc..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/basic_stream_socket.hpp
+++ /dev/null
@@ -1,852 +0,0 @@
-//
-// basic_stream_socket.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_BASIC_STREAM_SOCKET_HPP
-#define ASIO_BASIC_STREAM_SOCKET_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include <cstddef>
-#include "asio/async_result.hpp"
-#include "asio/basic_socket.hpp"
-#include "asio/detail/handler_type_requirements.hpp"
-#include "asio/detail/throw_error.hpp"
-#include "asio/error.hpp"
-#include "asio/stream_socket_service.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-
-/// Provides stream-oriented socket functionality.
-/**
- * The basic_stream_socket class template provides asynchronous and blocking
- * stream-oriented socket functionality.
- *
- * @par Thread Safety
- * @e Distinct @e objects: Safe.@n
- * @e Shared @e objects: Unsafe.
- *
- * @par Concepts:
- * AsyncReadStream, AsyncWriteStream, Stream, SyncReadStream, SyncWriteStream.
- */
-template <typename Protocol,
-    typename StreamSocketService = stream_socket_service<Protocol> >
-class basic_stream_socket
-  : public basic_socket<Protocol, StreamSocketService>
-{
-public:
-  /// (Deprecated: Use native_handle_type.) The native representation of a
-  /// socket.
-  typedef typename StreamSocketService::native_handle_type native_type;
-
-  /// The native representation of a socket.
-  typedef typename StreamSocketService::native_handle_type native_handle_type;
-
-  /// The protocol type.
-  typedef Protocol protocol_type;
-
-  /// The endpoint type.
-  typedef typename Protocol::endpoint endpoint_type;
-
-  /// Construct a basic_stream_socket without opening it.
-  /**
-   * This constructor creates a stream socket without opening it. The socket
-   * needs to be opened and then connected or accepted before data can be sent
-   * or received on it.
-   *
-   * @param io_service The io_service object that the stream socket will use to
-   * dispatch handlers for any asynchronous operations performed on the socket.
-   */
-  explicit basic_stream_socket(asio::io_service& io_service)
-    : basic_socket<Protocol, StreamSocketService>(io_service)
-  {
-  }
-
-  /// Construct and open a basic_stream_socket.
-  /**
-   * This constructor creates and opens a stream socket. The socket needs to be
-   * connected or accepted before data can be sent or received on it.
-   *
-   * @param io_service The io_service object that the stream socket will use to
-   * dispatch handlers for any asynchronous operations performed on the socket.
-   *
-   * @param protocol An object specifying protocol parameters to be used.
-   *
-   * @throws asio::system_error Thrown on failure.
-   */
-  basic_stream_socket(asio::io_service& io_service,
-      const protocol_type& protocol)
-    : basic_socket<Protocol, StreamSocketService>(io_service, protocol)
-  {
-  }
-
-  /// Construct a basic_stream_socket, opening it and binding it to the given
-  /// local endpoint.
-  /**
-   * This constructor creates a stream socket and automatically opens it bound
-   * to the specified endpoint on the local machine. The protocol used is the
-   * protocol associated with the given endpoint.
-   *
-   * @param io_service The io_service object that the stream socket will use to
-   * dispatch handlers for any asynchronous operations performed on the socket.
-   *
-   * @param endpoint An endpoint on the local machine to which the stream
-   * socket will be bound.
-   *
-   * @throws asio::system_error Thrown on failure.
-   */
-  basic_stream_socket(asio::io_service& io_service,
-      const endpoint_type& endpoint)
-    : basic_socket<Protocol, StreamSocketService>(io_service, endpoint)
-  {
-  }
-
-  /// Construct a basic_stream_socket on an existing native socket.
-  /**
-   * This constructor creates a stream socket object to hold an existing native
-   * socket.
-   *
-   * @param io_service The io_service object that the stream socket will use to
-   * dispatch handlers for any asynchronous operations performed on the socket.
-   *
-   * @param protocol An object specifying protocol parameters to be used.
-   *
-   * @param native_socket The new underlying socket implementation.
-   *
-   * @throws asio::system_error Thrown on failure.
-   */
-  basic_stream_socket(asio::io_service& io_service,
-      const protocol_type& protocol, const native_handle_type& native_socket)
-    : basic_socket<Protocol, StreamSocketService>(
-        io_service, protocol, native_socket)
-  {
-  }
-
-#if defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
-  /// Move-construct a basic_stream_socket from another.
-  /**
-   * This constructor moves a stream socket from one object to another.
-   *
-   * @param other The other basic_stream_socket object from which the move
-   * will occur.
-   *
-   * @note Following the move, the moved-from object is in the same state as if
-   * constructed using the @c basic_stream_socket(io_service&) constructor.
-   */
-  basic_stream_socket(basic_stream_socket&& other)
-    : basic_socket<Protocol, StreamSocketService>(
-        ASIO_MOVE_CAST(basic_stream_socket)(other))
-  {
-  }
-
-  /// Move-assign a basic_stream_socket from another.
-  /**
-   * This assignment operator moves a stream socket from one object to another.
-   *
-   * @param other The other basic_stream_socket object from which the move
-   * will occur.
-   *
-   * @note Following the move, the moved-from object is in the same state as if
-   * constructed using the @c basic_stream_socket(io_service&) constructor.
-   */
-  basic_stream_socket& operator=(basic_stream_socket&& other)
-  {
-    basic_socket<Protocol, StreamSocketService>::operator=(
-        ASIO_MOVE_CAST(basic_stream_socket)(other));
-    return *this;
-  }
-
-  /// Move-construct a basic_stream_socket from a socket of another protocol
-  /// type.
-  /**
-   * This constructor moves a stream socket from one object to another.
-   *
-   * @param other The other basic_stream_socket object from which the move
-   * will occur.
-   *
-   * @note Following the move, the moved-from object is in the same state as if
-   * constructed using the @c basic_stream_socket(io_service&) constructor.
-   */
-  template <typename Protocol1, typename StreamSocketService1>
-  basic_stream_socket(
-      basic_stream_socket<Protocol1, StreamSocketService1>&& other,
-      typename enable_if<is_convertible<Protocol1, Protocol>::value>::type* = 0)
-    : basic_socket<Protocol, StreamSocketService>(
-        ASIO_MOVE_CAST2(basic_stream_socket<
-          Protocol1, StreamSocketService1>)(other))
-  {
-  }
-
-  /// Move-assign a basic_stream_socket from a socket of another protocol type.
-  /**
-   * This assignment operator moves a stream socket from one object to another.
-   *
-   * @param other The other basic_stream_socket object from which the move
-   * will occur.
-   *
-   * @note Following the move, the moved-from object is in the same state as if
-   * constructed using the @c basic_stream_socket(io_service&) constructor.
-   */
-  template <typename Protocol1, typename StreamSocketService1>
-  typename enable_if<is_convertible<Protocol1, Protocol>::value,
-      basic_stream_socket>::type& operator=(
-        basic_stream_socket<Protocol1, StreamSocketService1>&& other)
-  {
-    basic_socket<Protocol, StreamSocketService>::operator=(
-        ASIO_MOVE_CAST2(basic_stream_socket<
-          Protocol1, StreamSocketService1>)(other));
-    return *this;
-  }
-#endif // defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
-
-  /// Send some data on the socket.
-  /**
-   * This function is used to send data on the stream socket. The function
-   * call will block until one or more bytes of the data has been sent
-   * successfully, or an until error occurs.
-   *
-   * @param buffers One or more data buffers to be sent on the socket.
-   *
-   * @returns The number of bytes sent.
-   *
-   * @throws asio::system_error Thrown on failure.
-   *
-   * @note The send operation may not transmit all of the data to the peer.
-   * Consider using the @ref write function if you need to ensure that all data
-   * is written before the blocking operation completes.
-   *
-   * @par Example
-   * To send a single data buffer use the @ref buffer function as follows:
-   * @code
-   * socket.send(asio::buffer(data, size));
-   * @endcode
-   * See the @ref buffer documentation for information on sending multiple
-   * buffers in one go, and how to use it with arrays, boost::array or
-   * std::vector.
-   */
-  template <typename ConstBufferSequence>
-  std::size_t send(const ConstBufferSequence& buffers)
-  {
-    asio::error_code ec;
-    std::size_t s = this->get_service().send(
-        this->get_implementation(), buffers, 0, ec);
-    asio::detail::throw_error(ec, "send");
-    return s;
-  }
-
-  /// Send some data on the socket.
-  /**
-   * This function is used to send data on the stream socket. The function
-   * call will block until one or more bytes of the data has been sent
-   * successfully, or an until error occurs.
-   *
-   * @param buffers One or more data buffers to be sent on the socket.
-   *
-   * @param flags Flags specifying how the send call is to be made.
-   *
-   * @returns The number of bytes sent.
-   *
-   * @throws asio::system_error Thrown on failure.
-   *
-   * @note The send operation may not transmit all of the data to the peer.
-   * Consider using the @ref write function if you need to ensure that all data
-   * is written before the blocking operation completes.
-   *
-   * @par Example
-   * To send a single data buffer use the @ref buffer function as follows:
-   * @code
-   * socket.send(asio::buffer(data, size), 0);
-   * @endcode
-   * See the @ref buffer documentation for information on sending multiple
-   * buffers in one go, and how to use it with arrays, boost::array or
-   * std::vector.
-   */
-  template <typename ConstBufferSequence>
-  std::size_t send(const ConstBufferSequence& buffers,
-      socket_base::message_flags flags)
-  {
-    asio::error_code ec;
-    std::size_t s = this->get_service().send(
-        this->get_implementation(), buffers, flags, ec);
-    asio::detail::throw_error(ec, "send");
-    return s;
-  }
-
-  /// Send some data on the socket.
-  /**
-   * This function is used to send data on the stream socket. The function
-   * call will block until one or more bytes of the data has been sent
-   * successfully, or an until error occurs.
-   *
-   * @param buffers One or more data buffers to be sent on the socket.
-   *
-   * @param flags Flags specifying how the send call is to be made.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   *
-   * @returns The number of bytes sent. Returns 0 if an error occurred.
-   *
-   * @note The send operation may not transmit all of the data to the peer.
-   * Consider using the @ref write function if you need to ensure that all data
-   * is written before the blocking operation completes.
-   */
-  template <typename ConstBufferSequence>
-  std::size_t send(const ConstBufferSequence& buffers,
-      socket_base::message_flags flags, asio::error_code& ec)
-  {
-    return this->get_service().send(
-        this->get_implementation(), buffers, flags, ec);
-  }
-
-  /// Start an asynchronous send.
-  /**
-   * This function is used to asynchronously send data on the stream socket.
-   * The function call always returns immediately.
-   *
-   * @param buffers One or more data buffers to be sent on the socket. Although
-   * the buffers object may be copied as necessary, ownership of the underlying
-   * memory blocks is retained by the caller, which must guarantee that they
-   * remain valid until the handler is called.
-   *
-   * @param handler The handler to be called when the send operation completes.
-   * Copies will be made of the handler as required. The function signature of
-   * the handler must be:
-   * @code void handler(
-   *   const asio::error_code& error, // Result of operation.
-   *   std::size_t bytes_transferred           // Number of bytes sent.
-   * ); @endcode
-   * Regardless of whether the asynchronous operation completes immediately or
-   * not, the handler will not be invoked from within this function. Invocation
-   * of the handler will be performed in a manner equivalent to using
-   * asio::io_service::post().
-   *
-   * @note The send operation may not transmit all of the data to the peer.
-   * Consider using the @ref async_write function if you need to ensure that all
-   * data is written before the asynchronous operation completes.
-   *
-   * @par Example
-   * To send a single data buffer use the @ref buffer function as follows:
-   * @code
-   * socket.async_send(asio::buffer(data, size), handler);
-   * @endcode
-   * See the @ref buffer documentation for information on sending multiple
-   * buffers in one go, and how to use it with arrays, boost::array or
-   * std::vector.
-   */
-  template <typename ConstBufferSequence, typename WriteHandler>
-  ASIO_INITFN_RESULT_TYPE(WriteHandler,
-      void (asio::error_code, std::size_t))
-  async_send(const ConstBufferSequence& buffers,
-      ASIO_MOVE_ARG(WriteHandler) handler)
-  {
-    // If you get an error on the following line it means that your handler does
-    // not meet the documented type requirements for a WriteHandler.
-    ASIO_WRITE_HANDLER_CHECK(WriteHandler, handler) type_check;
-
-    return this->get_service().async_send(
-        this->get_implementation(), buffers, 0,
-        ASIO_MOVE_CAST(WriteHandler)(handler));
-  }
-
-  /// Start an asynchronous send.
-  /**
-   * This function is used to asynchronously send data on the stream socket.
-   * The function call always returns immediately.
-   *
-   * @param buffers One or more data buffers to be sent on the socket. Although
-   * the buffers object may be copied as necessary, ownership of the underlying
-   * memory blocks is retained by the caller, which must guarantee that they
-   * remain valid until the handler is called.
-   *
-   * @param flags Flags specifying how the send call is to be made.
-   *
-   * @param handler The handler to be called when the send operation completes.
-   * Copies will be made of the handler as required. The function signature of
-   * the handler must be:
-   * @code void handler(
-   *   const asio::error_code& error, // Result of operation.
-   *   std::size_t bytes_transferred           // Number of bytes sent.
-   * ); @endcode
-   * Regardless of whether the asynchronous operation completes immediately or
-   * not, the handler will not be invoked from within this function. Invocation
-   * of the handler will be performed in a manner equivalent to using
-   * asio::io_service::post().
-   *
-   * @note The send operation may not transmit all of the data to the peer.
-   * Consider using the @ref async_write function if you need to ensure that all
-   * data is written before the asynchronous operation completes.
-   *
-   * @par Example
-   * To send a single data buffer use the @ref buffer function as follows:
-   * @code
-   * socket.async_send(asio::buffer(data, size), 0, handler);
-   * @endcode
-   * See the @ref buffer documentation for information on sending multiple
-   * buffers in one go, and how to use it with arrays, boost::array or
-   * std::vector.
-   */
-  template <typename ConstBufferSequence, typename WriteHandler>
-  ASIO_INITFN_RESULT_TYPE(WriteHandler,
-      void (asio::error_code, std::size_t))
-  async_send(const ConstBufferSequence& buffers,
-      socket_base::message_flags flags,
-      ASIO_MOVE_ARG(WriteHandler) handler)
-  {
-    // If you get an error on the following line it means that your handler does
-    // not meet the documented type requirements for a WriteHandler.
-    ASIO_WRITE_HANDLER_CHECK(WriteHandler, handler) type_check;
-
-    return this->get_service().async_send(
-        this->get_implementation(), buffers, flags,
-        ASIO_MOVE_CAST(WriteHandler)(handler));
-  }
-
-  /// Receive some data on the socket.
-  /**
-   * This function is used to receive data on the stream socket. The function
-   * call will block until one or more bytes of data has been received
-   * successfully, or until an error occurs.
-   *
-   * @param buffers One or more buffers into which the data will be received.
-   *
-   * @returns The number of bytes received.
-   *
-   * @throws asio::system_error Thrown on failure. An error code of
-   * asio::error::eof indicates that the connection was closed by the
-   * peer.
-   *
-   * @note The receive operation may not receive all of the requested number of
-   * bytes. Consider using the @ref read function if you need to ensure that the
-   * requested amount of data is read before the blocking operation completes.
-   *
-   * @par Example
-   * To receive into a single data buffer use the @ref buffer function as
-   * follows:
-   * @code
-   * socket.receive(asio::buffer(data, size));
-   * @endcode
-   * See the @ref buffer documentation for information on receiving into
-   * multiple buffers in one go, and how to use it with arrays, boost::array or
-   * std::vector.
-   */
-  template <typename MutableBufferSequence>
-  std::size_t receive(const MutableBufferSequence& buffers)
-  {
-    asio::error_code ec;
-    std::size_t s = this->get_service().receive(
-        this->get_implementation(), buffers, 0, ec);
-    asio::detail::throw_error(ec, "receive");
-    return s;
-  }
-
-  /// Receive some data on the socket.
-  /**
-   * This function is used to receive data on the stream socket. The function
-   * call will block until one or more bytes of data has been received
-   * successfully, or until an error occurs.
-   *
-   * @param buffers One or more buffers into which the data will be received.
-   *
-   * @param flags Flags specifying how the receive call is to be made.
-   *
-   * @returns The number of bytes received.
-   *
-   * @throws asio::system_error Thrown on failure. An error code of
-   * asio::error::eof indicates that the connection was closed by the
-   * peer.
-   *
-   * @note The receive operation may not receive all of the requested number of
-   * bytes. Consider using the @ref read function if you need to ensure that the
-   * requested amount of data is read before the blocking operation completes.
-   *
-   * @par Example
-   * To receive into a single data buffer use the @ref buffer function as
-   * follows:
-   * @code
-   * socket.receive(asio::buffer(data, size), 0);
-   * @endcode
-   * See the @ref buffer documentation for information on receiving into
-   * multiple buffers in one go, and how to use it with arrays, boost::array or
-   * std::vector.
-   */
-  template <typename MutableBufferSequence>
-  std::size_t receive(const MutableBufferSequence& buffers,
-      socket_base::message_flags flags)
-  {
-    asio::error_code ec;
-    std::size_t s = this->get_service().receive(
-        this->get_implementation(), buffers, flags, ec);
-    asio::detail::throw_error(ec, "receive");
-    return s;
-  }
-
-  /// Receive some data on a connected socket.
-  /**
-   * This function is used to receive data on the stream socket. The function
-   * call will block until one or more bytes of data has been received
-   * successfully, or until an error occurs.
-   *
-   * @param buffers One or more buffers into which the data will be received.
-   *
-   * @param flags Flags specifying how the receive call is to be made.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   *
-   * @returns The number of bytes received. Returns 0 if an error occurred.
-   *
-   * @note The receive operation may not receive all of the requested number of
-   * bytes. Consider using the @ref read function if you need to ensure that the
-   * requested amount of data is read before the blocking operation completes.
-   */
-  template <typename MutableBufferSequence>
-  std::size_t receive(const MutableBufferSequence& buffers,
-      socket_base::message_flags flags, asio::error_code& ec)
-  {
-    return this->get_service().receive(
-        this->get_implementation(), buffers, flags, ec);
-  }
-
-  /// Start an asynchronous receive.
-  /**
-   * This function is used to asynchronously receive data from the stream
-   * socket. The function call always returns immediately.
-   *
-   * @param buffers One or more buffers into which the data will be received.
-   * Although the buffers object may be copied as necessary, ownership of the
-   * underlying memory blocks is retained by the caller, which must guarantee
-   * that they remain valid until the handler is called.
-   *
-   * @param handler The handler to be called when the receive operation
-   * completes. Copies will be made of the handler as required. The function
-   * signature of the handler must be:
-   * @code void handler(
-   *   const asio::error_code& error, // Result of operation.
-   *   std::size_t bytes_transferred           // Number of bytes received.
-   * ); @endcode
-   * Regardless of whether the asynchronous operation completes immediately or
-   * not, the handler will not be invoked from within this function. Invocation
-   * of the handler will be performed in a manner equivalent to using
-   * asio::io_service::post().
-   *
-   * @note The receive operation may not receive all of the requested number of
-   * bytes. Consider using the @ref async_read function if you need to ensure
-   * that the requested amount of data is received before the asynchronous
-   * operation completes.
-   *
-   * @par Example
-   * To receive into a single data buffer use the @ref buffer function as
-   * follows:
-   * @code
-   * socket.async_receive(asio::buffer(data, size), handler);
-   * @endcode
-   * See the @ref buffer documentation for information on receiving into
-   * multiple buffers in one go, and how to use it with arrays, boost::array or
-   * std::vector.
-   */
-  template <typename MutableBufferSequence, typename ReadHandler>
-  ASIO_INITFN_RESULT_TYPE(ReadHandler,
-      void (asio::error_code, std::size_t))
-  async_receive(const MutableBufferSequence& buffers,
-      ASIO_MOVE_ARG(ReadHandler) handler)
-  {
-    // If you get an error on the following line it means that your handler does
-    // not meet the documented type requirements for a ReadHandler.
-    ASIO_READ_HANDLER_CHECK(ReadHandler, handler) type_check;
-
-    return this->get_service().async_receive(this->get_implementation(),
-        buffers, 0, ASIO_MOVE_CAST(ReadHandler)(handler));
-  }
-
-  /// Start an asynchronous receive.
-  /**
-   * This function is used to asynchronously receive data from the stream
-   * socket. The function call always returns immediately.
-   *
-   * @param buffers One or more buffers into which the data will be received.
-   * Although the buffers object may be copied as necessary, ownership of the
-   * underlying memory blocks is retained by the caller, which must guarantee
-   * that they remain valid until the handler is called.
-   *
-   * @param flags Flags specifying how the receive call is to be made.
-   *
-   * @param handler The handler to be called when the receive operation
-   * completes. Copies will be made of the handler as required. The function
-   * signature of the handler must be:
-   * @code void handler(
-   *   const asio::error_code& error, // Result of operation.
-   *   std::size_t bytes_transferred           // Number of bytes received.
-   * ); @endcode
-   * Regardless of whether the asynchronous operation completes immediately or
-   * not, the handler will not be invoked from within this function. Invocation
-   * of the handler will be performed in a manner equivalent to using
-   * asio::io_service::post().
-   *
-   * @note The receive operation may not receive all of the requested number of
-   * bytes. Consider using the @ref async_read function if you need to ensure
-   * that the requested amount of data is received before the asynchronous
-   * operation completes.
-   *
-   * @par Example
-   * To receive into a single data buffer use the @ref buffer function as
-   * follows:
-   * @code
-   * socket.async_receive(asio::buffer(data, size), 0, handler);
-   * @endcode
-   * See the @ref buffer documentation for information on receiving into
-   * multiple buffers in one go, and how to use it with arrays, boost::array or
-   * std::vector.
-   */
-  template <typename MutableBufferSequence, typename ReadHandler>
-  ASIO_INITFN_RESULT_TYPE(ReadHandler,
-      void (asio::error_code, std::size_t))
-  async_receive(const MutableBufferSequence& buffers,
-      socket_base::message_flags flags,
-      ASIO_MOVE_ARG(ReadHandler) handler)
-  {
-    // If you get an error on the following line it means that your handler does
-    // not meet the documented type requirements for a ReadHandler.
-    ASIO_READ_HANDLER_CHECK(ReadHandler, handler) type_check;
-
-    return this->get_service().async_receive(this->get_implementation(),
-        buffers, flags, ASIO_MOVE_CAST(ReadHandler)(handler));
-  }
-
-  /// Write some data to the socket.
-  /**
-   * This function is used to write data to the stream socket. The function call
-   * will block until one or more bytes of the data has been written
-   * successfully, or until an error occurs.
-   *
-   * @param buffers One or more data buffers to be written to the socket.
-   *
-   * @returns The number of bytes written.
-   *
-   * @throws asio::system_error Thrown on failure. An error code of
-   * asio::error::eof indicates that the connection was closed by the
-   * peer.
-   *
-   * @note The write_some operation may not transmit all of the data to the
-   * peer. Consider using the @ref write function if you need to ensure that
-   * all data is written before the blocking operation completes.
-   *
-   * @par Example
-   * To write a single data buffer use the @ref buffer function as follows:
-   * @code
-   * socket.write_some(asio::buffer(data, size));
-   * @endcode
-   * See the @ref buffer documentation for information on writing multiple
-   * buffers in one go, and how to use it with arrays, boost::array or
-   * std::vector.
-   */
-  template <typename ConstBufferSequence>
-  std::size_t write_some(const ConstBufferSequence& buffers)
-  {
-    asio::error_code ec;
-    std::size_t s = this->get_service().send(
-        this->get_implementation(), buffers, 0, ec);
-    asio::detail::throw_error(ec, "write_some");
-    return s;
-  }
-
-  /// Write some data to the socket.
-  /**
-   * This function is used to write data to the stream socket. The function call
-   * will block until one or more bytes of the data has been written
-   * successfully, or until an error occurs.
-   *
-   * @param buffers One or more data buffers to be written to the socket.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   *
-   * @returns The number of bytes written. Returns 0 if an error occurred.
-   *
-   * @note The write_some operation may not transmit all of the data to the
-   * peer. Consider using the @ref write function if you need to ensure that
-   * all data is written before the blocking operation completes.
-   */
-  template <typename ConstBufferSequence>
-  std::size_t write_some(const ConstBufferSequence& buffers,
-      asio::error_code& ec)
-  {
-    return this->get_service().send(this->get_implementation(), buffers, 0, ec);
-  }
-
-  /// Start an asynchronous write.
-  /**
-   * This function is used to asynchronously write data to the stream socket.
-   * The function call always returns immediately.
-   *
-   * @param buffers One or more data buffers to be written to the socket.
-   * Although the buffers object may be copied as necessary, ownership of the
-   * underlying memory blocks is retained by the caller, which must guarantee
-   * that they remain valid until the handler is called.
-   *
-   * @param handler The handler to be called when the write operation completes.
-   * Copies will be made of the handler as required. The function signature of
-   * the handler must be:
-   * @code void handler(
-   *   const asio::error_code& error, // Result of operation.
-   *   std::size_t bytes_transferred           // Number of bytes written.
-   * ); @endcode
-   * Regardless of whether the asynchronous operation completes immediately or
-   * not, the handler will not be invoked from within this function. Invocation
-   * of the handler will be performed in a manner equivalent to using
-   * asio::io_service::post().
-   *
-   * @note The write operation may not transmit all of the data to the peer.
-   * Consider using the @ref async_write function if you need to ensure that all
-   * data is written before the asynchronous operation completes.
-   *
-   * @par Example
-   * To write a single data buffer use the @ref buffer function as follows:
-   * @code
-   * socket.async_write_some(asio::buffer(data, size), handler);
-   * @endcode
-   * See the @ref buffer documentation for information on writing multiple
-   * buffers in one go, and how to use it with arrays, boost::array or
-   * std::vector.
-   */
-  template <typename ConstBufferSequence, typename WriteHandler>
-  ASIO_INITFN_RESULT_TYPE(WriteHandler,
-      void (asio::error_code, std::size_t))
-  async_write_some(const ConstBufferSequence& buffers,
-      ASIO_MOVE_ARG(WriteHandler) handler)
-  {
-    // If you get an error on the following line it means that your handler does
-    // not meet the documented type requirements for a WriteHandler.
-    ASIO_WRITE_HANDLER_CHECK(WriteHandler, handler) type_check;
-
-    return this->get_service().async_send(this->get_implementation(),
-        buffers, 0, ASIO_MOVE_CAST(WriteHandler)(handler));
-  }
-
-  /// Read some data from the socket.
-  /**
-   * This function is used to read data from the stream socket. The function
-   * call will block until one or more bytes of data has been read successfully,
-   * or until an error occurs.
-   *
-   * @param buffers One or more buffers into which the data will be read.
-   *
-   * @returns The number of bytes read.
-   *
-   * @throws asio::system_error Thrown on failure. An error code of
-   * asio::error::eof indicates that the connection was closed by the
-   * peer.
-   *
-   * @note The read_some operation may not read all of the requested number of
-   * bytes. Consider using the @ref read function if you need to ensure that
-   * the requested amount of data is read before the blocking operation
-   * completes.
-   *
-   * @par Example
-   * To read into a single data buffer use the @ref buffer function as follows:
-   * @code
-   * socket.read_some(asio::buffer(data, size));
-   * @endcode
-   * See the @ref buffer documentation for information on reading into multiple
-   * buffers in one go, and how to use it with arrays, boost::array or
-   * std::vector.
-   */
-  template <typename MutableBufferSequence>
-  std::size_t read_some(const MutableBufferSequence& buffers)
-  {
-    asio::error_code ec;
-    std::size_t s = this->get_service().receive(
-        this->get_implementation(), buffers, 0, ec);
-    asio::detail::throw_error(ec, "read_some");
-    return s;
-  }
-
-  /// Read some data from the socket.
-  /**
-   * This function is used to read data from the stream socket. The function
-   * call will block until one or more bytes of data has been read successfully,
-   * or until an error occurs.
-   *
-   * @param buffers One or more buffers into which the data will be read.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   *
-   * @returns The number of bytes read. Returns 0 if an error occurred.
-   *
-   * @note The read_some operation may not read all of the requested number of
-   * bytes. Consider using the @ref read function if you need to ensure that
-   * the requested amount of data is read before the blocking operation
-   * completes.
-   */
-  template <typename MutableBufferSequence>
-  std::size_t read_some(const MutableBufferSequence& buffers,
-      asio::error_code& ec)
-  {
-    return this->get_service().receive(
-        this->get_implementation(), buffers, 0, ec);
-  }
-
-  /// Start an asynchronous read.
-  /**
-   * This function is used to asynchronously read data from the stream socket.
-   * The function call always returns immediately.
-   *
-   * @param buffers One or more buffers into which the data will be read.
-   * Although the buffers object may be copied as necessary, ownership of the
-   * underlying memory blocks is retained by the caller, which must guarantee
-   * that they remain valid until the handler is called.
-   *
-   * @param handler The handler to be called when the read operation completes.
-   * Copies will be made of the handler as required. The function signature of
-   * the handler must be:
-   * @code void handler(
-   *   const asio::error_code& error, // Result of operation.
-   *   std::size_t bytes_transferred           // Number of bytes read.
-   * ); @endcode
-   * Regardless of whether the asynchronous operation completes immediately or
-   * not, the handler will not be invoked from within this function. Invocation
-   * of the handler will be performed in a manner equivalent to using
-   * asio::io_service::post().
-   *
-   * @note The read operation may not read all of the requested number of bytes.
-   * Consider using the @ref async_read function if you need to ensure that the
-   * requested amount of data is read before the asynchronous operation
-   * completes.
-   *
-   * @par Example
-   * To read into a single data buffer use the @ref buffer function as follows:
-   * @code
-   * socket.async_read_some(asio::buffer(data, size), handler);
-   * @endcode
-   * See the @ref buffer documentation for information on reading into multiple
-   * buffers in one go, and how to use it with arrays, boost::array or
-   * std::vector.
-   */
-  template <typename MutableBufferSequence, typename ReadHandler>
-  ASIO_INITFN_RESULT_TYPE(ReadHandler,
-      void (asio::error_code, std::size_t))
-  async_read_some(const MutableBufferSequence& buffers,
-      ASIO_MOVE_ARG(ReadHandler) handler)
-  {
-    // If you get an error on the following line it means that your handler does
-    // not meet the documented type requirements for a ReadHandler.
-    ASIO_READ_HANDLER_CHECK(ReadHandler, handler) type_check;
-
-    return this->get_service().async_receive(this->get_implementation(),
-        buffers, 0, ASIO_MOVE_CAST(ReadHandler)(handler));
-  }
-};
-
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_BASIC_STREAM_SOCKET_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/basic_streambuf.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/basic_streambuf.hpp
deleted file mode 100644
index bacc4852c3c6..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/basic_streambuf.hpp
+++ /dev/null
@@ -1,369 +0,0 @@
-//
-// basic_streambuf.hpp
-// ~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_BASIC_STREAMBUF_HPP
-#define ASIO_BASIC_STREAMBUF_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if !defined(ASIO_NO_IOSTREAM)
-
-#include <algorithm>
-#include <cstring>
-#include <stdexcept>
-#include <streambuf>
-#include <vector>
-#include "asio/basic_streambuf_fwd.hpp"
-#include "asio/buffer.hpp"
-#include "asio/detail/limits.hpp"
-#include "asio/detail/noncopyable.hpp"
-#include "asio/detail/throw_exception.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-
-/// Automatically resizable buffer class based on std::streambuf.
-/**
- * The @c basic_streambuf class is derived from @c std::streambuf to associate
- * the streambuf's input and output sequences with one or more character
- * arrays. These character arrays are internal to the @c basic_streambuf
- * object, but direct access to the array elements is provided to permit them
- * to be used efficiently with I/O operations. Characters written to the output
- * sequence of a @c basic_streambuf object are appended to the input sequence
- * of the same object.
- *
- * The @c basic_streambuf class's public interface is intended to permit the
- * following implementation strategies:
- *
- * @li A single contiguous character array, which is reallocated as necessary
- * to accommodate changes in the size of the character sequence. This is the
- * implementation approach currently used in Asio.
- *
- * @li A sequence of one or more character arrays, where each array is of the
- * same size. Additional character array objects are appended to the sequence
- * to accommodate changes in the size of the character sequence.
- *
- * @li A sequence of one or more character arrays of varying sizes. Additional
- * character array objects are appended to the sequence to accommodate changes
- * in the size of the character sequence.
- *
- * The constructor for basic_streambuf accepts a @c size_t argument specifying
- * the maximum of the sum of the sizes of the input sequence and output
- * sequence. During the lifetime of the @c basic_streambuf object, the following
- * invariant holds:
- * @code size() <= max_size()@endcode
- * Any member function that would, if successful, cause the invariant to be
- * violated shall throw an exception of class @c std::length_error.
- *
- * The constructor for @c basic_streambuf takes an Allocator argument. A copy
- * of this argument is used for any memory allocation performed, by the
- * constructor and by all member functions, during the lifetime of each @c
- * basic_streambuf object.
- *
- * @par Examples
- * Writing directly from an streambuf to a socket:
- * @code
- * asio::streambuf b;
- * std::ostream os(&b);
- * os << "Hello, World!\n";
- *
- * // try sending some data in input sequence
- * size_t n = sock.send(b.data());
- *
- * b.consume(n); // sent data is removed from input sequence
- * @endcode
- *
- * Reading from a socket directly into a streambuf:
- * @code
- * asio::streambuf b;
- *
- * // reserve 512 bytes in output sequence
- * asio::streambuf::mutable_buffers_type bufs = b.prepare(512);
- *
- * size_t n = sock.receive(bufs);
- *
- * // received data is "committed" from output sequence to input sequence
- * b.commit(n);
- *
- * std::istream is(&b);
- * std::string s;
- * is >> s;
- * @endcode
- */
-#if defined(GENERATING_DOCUMENTATION)
-template <typename Allocator = std::allocator<char> >
-#else
-template <typename Allocator>
-#endif
-class basic_streambuf
-  : public std::streambuf,
-    private noncopyable
-{
-public:
-#if defined(GENERATING_DOCUMENTATION)
-  /// The type used to represent the input sequence as a list of buffers.
-  typedef implementation_defined const_buffers_type;
-
-  /// The type used to represent the output sequence as a list of buffers.
-  typedef implementation_defined mutable_buffers_type;
-#else
-  typedef asio::const_buffers_1 const_buffers_type;
-  typedef asio::mutable_buffers_1 mutable_buffers_type;
-#endif
-
-  /// Construct a basic_streambuf object.
-  /**
-   * Constructs a streambuf with the specified maximum size. The initial size
-   * of the streambuf's input sequence is 0.
-   */
-  explicit basic_streambuf(
-      std::size_t maximum_size = (std::numeric_limits<std::size_t>::max)(),
-      const Allocator& allocator = Allocator())
-    : max_size_(maximum_size),
-      buffer_(allocator)
-  {
-    std::size_t pend = (std::min<std::size_t>)(max_size_, buffer_delta);
-    buffer_.resize((std::max<std::size_t>)(pend, 1));
-    setg(&buffer_[0], &buffer_[0], &buffer_[0]);
-    setp(&buffer_[0], &buffer_[0] + pend);
-  }
-
-  /// Get the size of the input sequence.
-  /**
-   * @returns The size of the input sequence. The value is equal to that
-   * calculated for @c s in the following code:
-   * @code
-   * size_t s = 0;
-   * const_buffers_type bufs = data();
-   * const_buffers_type::const_iterator i = bufs.begin();
-   * while (i != bufs.end())
-   * {
-   *   const_buffer buf(*i++);
-   *   s += buffer_size(buf);
-   * }
-   * @endcode
-   */
-  std::size_t size() const
-  {
-    return pptr() - gptr();
-  }
-
-  /// Get the maximum size of the basic_streambuf.
-  /**
-   * @returns The allowed maximum of the sum of the sizes of the input sequence
-   * and output sequence.
-   */
-  std::size_t max_size() const
-  {
-    return max_size_;
-  }
-
-  /// Get a list of buffers that represents the input sequence.
-  /**
-   * @returns An object of type @c const_buffers_type that satisfies
-   * ConstBufferSequence requirements, representing all character arrays in the
-   * input sequence.
-   *
-   * @note The returned object is invalidated by any @c basic_streambuf member
-   * function that modifies the input sequence or output sequence.
-   */
-  const_buffers_type data() const
-  {
-    return asio::buffer(asio::const_buffer(gptr(),
-          (pptr() - gptr()) * sizeof(char_type)));
-  }
-
-  /// Get a list of buffers that represents the output sequence, with the given
-  /// size.
-  /**
-   * Ensures that the output sequence can accommodate @c n characters,
-   * reallocating character array objects as necessary.
-   *
-   * @returns An object of type @c mutable_buffers_type that satisfies
-   * MutableBufferSequence requirements, representing character array objects
-   * at the start of the output sequence such that the sum of the buffer sizes
-   * is @c n.
-   *
-   * @throws std::length_error If <tt>size() + n > max_size()</tt>.
-   *
-   * @note The returned object is invalidated by any @c basic_streambuf member
-   * function that modifies the input sequence or output sequence.
-   */
-  mutable_buffers_type prepare(std::size_t n)
-  {
-    reserve(n);
-    return asio::buffer(asio::mutable_buffer(
-          pptr(), n * sizeof(char_type)));
-  }
-
-  /// Move characters from the output sequence to the input sequence.
-  /**
-   * Appends @c n characters from the start of the output sequence to the input
-   * sequence. The beginning of the output sequence is advanced by @c n
-   * characters.
-   *
-   * Requires a preceding call <tt>prepare(x)</tt> where <tt>x >= n</tt>, and
-   * no intervening operations that modify the input or output sequence.
-   *
-   * @note If @c n is greater than the size of the output sequence, the entire
-   * output sequence is moved to the input sequence and no error is issued.
-   */
-  void commit(std::size_t n)
-  {
-    if (pptr() + n > epptr())
-      n = epptr() - pptr();
-    pbump(static_cast<int>(n));
-    setg(eback(), gptr(), pptr());
-  }
-
-  /// Remove characters from the input sequence.
-  /**
-   * Removes @c n characters from the beginning of the input sequence.
-   *
-   * @note If @c n is greater than the size of the input sequence, the entire
-   * input sequence is consumed and no error is issued.
-   */
-  void consume(std::size_t n)
-  {
-    if (egptr() < pptr())
-      setg(&buffer_[0], gptr(), pptr());
-    if (gptr() + n > pptr())
-      n = pptr() - gptr();
-    gbump(static_cast<int>(n));
-  }
-
-protected:
-  enum { buffer_delta = 128 };
-
-  /// Override std::streambuf behaviour.
-  /**
-   * Behaves according to the specification of @c std::streambuf::underflow().
-   */
-  int_type underflow()
-  {
-    if (gptr() < pptr())
-    {
-      setg(&buffer_[0], gptr(), pptr());
-      return traits_type::to_int_type(*gptr());
-    }
-    else
-    {
-      return traits_type::eof();
-    }
-  }
-
-  /// Override std::streambuf behaviour.
-  /**
-   * Behaves according to the specification of @c std::streambuf::overflow(),
-   * with the specialisation that @c std::length_error is thrown if appending
-   * the character to the input sequence would require the condition
-   * <tt>size() > max_size()</tt> to be true.
-   */
-  int_type overflow(int_type c)
-  {
-    if (!traits_type::eq_int_type(c, traits_type::eof()))
-    {
-      if (pptr() == epptr())
-      {
-        std::size_t buffer_size = pptr() - gptr();
-        if (buffer_size < max_size_ && max_size_ - buffer_size < buffer_delta)
-        {
-          reserve(max_size_ - buffer_size);
-        }
-        else
-        {
-          reserve(buffer_delta);
-        }
-      }
-
-      *pptr() = traits_type::to_char_type(c);
-      pbump(1);
-      return c;
-    }
-
-    return traits_type::not_eof(c);
-  }
-
-  void reserve(std::size_t n)
-  {
-    // Get current stream positions as offsets.
-    std::size_t gnext = gptr() - &buffer_[0];
-    std::size_t pnext = pptr() - &buffer_[0];
-    std::size_t pend = epptr() - &buffer_[0];
-
-    // Check if there is already enough space in the put area.
-    if (n <= pend - pnext)
-    {
-      return;
-    }
-
-    // Shift existing contents of get area to start of buffer.
-    if (gnext > 0)
-    {
-      pnext -= gnext;
-      std::memmove(&buffer_[0], &buffer_[0] + gnext, pnext);
-    }
-
-    // Ensure buffer is large enough to hold at least the specified size.
-    if (n > pend - pnext)
-    {
-      if (n <= max_size_ && pnext <= max_size_ - n)
-      {
-        pend = pnext + n;
-        buffer_.resize((std::max<std::size_t>)(pend, 1));
-      }
-      else
-      {
-        std::length_error ex("asio::streambuf too long");
-        asio::detail::throw_exception(ex);
-      }
-    }
-
-    // Update stream positions.
-    setg(&buffer_[0], &buffer_[0], &buffer_[0] + pnext);
-    setp(&buffer_[0] + pnext, &buffer_[0] + pend);
-  }
-
-private:
-  std::size_t max_size_;
-  std::vector<char_type, Allocator> buffer_;
-
-  // Helper function to get the preferred size for reading data.
-  friend std::size_t read_size_helper(
-      basic_streambuf& sb, std::size_t max_size)
-  {
-    return std::min<std::size_t>(
-        std::max<std::size_t>(512, sb.buffer_.capacity() - sb.size()),
-        std::min<std::size_t>(max_size, sb.max_size() - sb.size()));
-  }
-};
-
-// Helper function to get the preferred size for reading data. Used for any
-// user-provided specialisations of basic_streambuf.
-template <typename Allocator>
-inline std::size_t read_size_helper(
-    basic_streambuf<Allocator>& sb, std::size_t max_size)
-{
-  return std::min<std::size_t>(512,
-      std::min<std::size_t>(max_size, sb.max_size() - sb.size()));
-}
-
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // !defined(ASIO_NO_IOSTREAM)
-
-#endif // ASIO_BASIC_STREAMBUF_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/basic_streambuf_fwd.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/basic_streambuf_fwd.hpp
deleted file mode 100644
index 8fd0ae8880b1..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/basic_streambuf_fwd.hpp
+++ /dev/null
@@ -1,33 +0,0 @@
-//
-// basic_streambuf_fwd.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_BASIC_STREAMBUF_FWD_HPP
-#define ASIO_BASIC_STREAMBUF_FWD_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if !defined(ASIO_NO_IOSTREAM)
-
-#include <memory>
-
-namespace asio {
-
-template <typename Allocator = std::allocator<char> >
-class basic_streambuf;
-
-} // namespace asio
-
-#endif // !defined(ASIO_NO_IOSTREAM)
-
-#endif // ASIO_BASIC_STREAMBUF_FWD_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/basic_waitable_timer.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/basic_waitable_timer.hpp
deleted file mode 100644
index c204ae264eab..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/basic_waitable_timer.hpp
+++ /dev/null
@@ -1,519 +0,0 @@
-//
-// basic_waitable_timer.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_BASIC_WAITABLE_TIMER_HPP
-#define ASIO_BASIC_WAITABLE_TIMER_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include <cstddef>
-#include "asio/basic_io_object.hpp"
-#include "asio/detail/handler_type_requirements.hpp"
-#include "asio/detail/throw_error.hpp"
-#include "asio/error.hpp"
-#include "asio/wait_traits.hpp"
-#include "asio/waitable_timer_service.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-
-/// Provides waitable timer functionality.
-/**
- * The basic_waitable_timer class template provides the ability to perform a
- * blocking or asynchronous wait for a timer to expire.
- *
- * A waitable timer is always in one of two states: "expired" or "not expired".
- * If the wait() or async_wait() function is called on an expired timer, the
- * wait operation will complete immediately.
- *
- * Most applications will use one of the asio::steady_timer,
- * asio::system_timer or asio::high_resolution_timer typedefs.
- *
- * @note This waitable timer functionality is for use with the C++11 standard
- * library's @c &lt;chrono&gt; facility, or with the Boost.Chrono library.
- *
- * @par Thread Safety
- * @e Distinct @e objects: Safe.@n
- * @e Shared @e objects: Unsafe.
- *
- * @par Examples
- * Performing a blocking wait (C++11):
- * @code
- * // Construct a timer without setting an expiry time.
- * asio::steady_timer timer(io_service);
- *
- * // Set an expiry time relative to now.
- * timer.expires_from_now(std::chrono::seconds(5));
- *
- * // Wait for the timer to expire.
- * timer.wait();
- * @endcode
- *
- * @par 
- * Performing an asynchronous wait (C++11):
- * @code
- * void handler(const asio::error_code& error)
- * {
- *   if (!error)
- *   {
- *     // Timer expired.
- *   }
- * }
- *
- * ...
- *
- * // Construct a timer with an absolute expiry time.
- * asio::steady_timer timer(io_service,
- *     std::chrono::steady_clock::now() + std::chrono::seconds(60));
- *
- * // Start an asynchronous wait.
- * timer.async_wait(handler);
- * @endcode
- *
- * @par Changing an active waitable timer's expiry time
- *
- * Changing the expiry time of a timer while there are pending asynchronous
- * waits causes those wait operations to be cancelled. To ensure that the action
- * associated with the timer is performed only once, use something like this:
- * used:
- *
- * @code
- * void on_some_event()
- * {
- *   if (my_timer.expires_from_now(seconds(5)) > 0)
- *   {
- *     // We managed to cancel the timer. Start new asynchronous wait.
- *     my_timer.async_wait(on_timeout);
- *   }
- *   else
- *   {
- *     // Too late, timer has already expired!
- *   }
- * }
- *
- * void on_timeout(const asio::error_code& e)
- * {
- *   if (e != asio::error::operation_aborted)
- *   {
- *     // Timer was not cancelled, take necessary action.
- *   }
- * }
- * @endcode
- *
- * @li The asio::basic_waitable_timer::expires_from_now() function
- * cancels any pending asynchronous waits, and returns the number of
- * asynchronous waits that were cancelled. If it returns 0 then you were too
- * late and the wait handler has already been executed, or will soon be
- * executed. If it returns 1 then the wait handler was successfully cancelled.
- *
- * @li If a wait handler is cancelled, the asio::error_code passed to
- * it contains the value asio::error::operation_aborted.
- */
-template <typename Clock,
-    typename WaitTraits = asio::wait_traits<Clock>,
-    typename WaitableTimerService = waitable_timer_service<Clock, WaitTraits> >
-class basic_waitable_timer
-  : public basic_io_object<WaitableTimerService>
-{
-public:
-  /// The clock type.
-  typedef Clock clock_type;
-
-  /// The duration type of the clock.
-  typedef typename clock_type::duration duration;
-
-  /// The time point type of the clock.
-  typedef typename clock_type::time_point time_point;
-
-  /// The wait traits type.
-  typedef WaitTraits traits_type;
-
-  /// Constructor.
-  /**
-   * This constructor creates a timer without setting an expiry time. The
-   * expires_at() or expires_from_now() functions must be called to set an
-   * expiry time before the timer can be waited on.
-   *
-   * @param io_service The io_service object that the timer will use to dispatch
-   * handlers for any asynchronous operations performed on the timer.
-   */
-  explicit basic_waitable_timer(asio::io_service& io_service)
-    : basic_io_object<WaitableTimerService>(io_service)
-  {
-  }
-
-  /// Constructor to set a particular expiry time as an absolute time.
-  /**
-   * This constructor creates a timer and sets the expiry time.
-   *
-   * @param io_service The io_service object that the timer will use to dispatch
-   * handlers for any asynchronous operations performed on the timer.
-   *
-   * @param expiry_time The expiry time to be used for the timer, expressed
-   * as an absolute time.
-   */
-  basic_waitable_timer(asio::io_service& io_service,
-      const time_point& expiry_time)
-    : basic_io_object<WaitableTimerService>(io_service)
-  {
-    asio::error_code ec;
-    this->service.expires_at(this->implementation, expiry_time, ec);
-    asio::detail::throw_error(ec, "expires_at");
-  }
-
-  /// Constructor to set a particular expiry time relative to now.
-  /**
-   * This constructor creates a timer and sets the expiry time.
-   *
-   * @param io_service The io_service object that the timer will use to dispatch
-   * handlers for any asynchronous operations performed on the timer.
-   *
-   * @param expiry_time The expiry time to be used for the timer, relative to
-   * now.
-   */
-  basic_waitable_timer(asio::io_service& io_service,
-      const duration& expiry_time)
-    : basic_io_object<WaitableTimerService>(io_service)
-  {
-    asio::error_code ec;
-    this->service.expires_from_now(this->implementation, expiry_time, ec);
-    asio::detail::throw_error(ec, "expires_from_now");
-  }
-
-  /// Cancel any asynchronous operations that are waiting on the timer.
-  /**
-   * This function forces the completion of any pending asynchronous wait
-   * operations against the timer. The handler for each cancelled operation will
-   * be invoked with the asio::error::operation_aborted error code.
-   *
-   * Cancelling the timer does not change the expiry time.
-   *
-   * @return The number of asynchronous operations that were cancelled.
-   *
-   * @throws asio::system_error Thrown on failure.
-   *
-   * @note If the timer has already expired when cancel() is called, then the
-   * handlers for asynchronous wait operations will:
-   *
-   * @li have already been invoked; or
-   *
-   * @li have been queued for invocation in the near future.
-   *
-   * These handlers can no longer be cancelled, and therefore are passed an
-   * error code that indicates the successful completion of the wait operation.
-   */
-  std::size_t cancel()
-  {
-    asio::error_code ec;
-    std::size_t s = this->service.cancel(this->implementation, ec);
-    asio::detail::throw_error(ec, "cancel");
-    return s;
-  }
-
-  /// Cancel any asynchronous operations that are waiting on the timer.
-  /**
-   * This function forces the completion of any pending asynchronous wait
-   * operations against the timer. The handler for each cancelled operation will
-   * be invoked with the asio::error::operation_aborted error code.
-   *
-   * Cancelling the timer does not change the expiry time.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   *
-   * @return The number of asynchronous operations that were cancelled.
-   *
-   * @note If the timer has already expired when cancel() is called, then the
-   * handlers for asynchronous wait operations will:
-   *
-   * @li have already been invoked; or
-   *
-   * @li have been queued for invocation in the near future.
-   *
-   * These handlers can no longer be cancelled, and therefore are passed an
-   * error code that indicates the successful completion of the wait operation.
-   */
-  std::size_t cancel(asio::error_code& ec)
-  {
-    return this->service.cancel(this->implementation, ec);
-  }
-
-  /// Cancels one asynchronous operation that is waiting on the timer.
-  /**
-   * This function forces the completion of one pending asynchronous wait
-   * operation against the timer. Handlers are cancelled in FIFO order. The
-   * handler for the cancelled operation will be invoked with the
-   * asio::error::operation_aborted error code.
-   *
-   * Cancelling the timer does not change the expiry time.
-   *
-   * @return The number of asynchronous operations that were cancelled. That is,
-   * either 0 or 1.
-   *
-   * @throws asio::system_error Thrown on failure.
-   *
-   * @note If the timer has already expired when cancel_one() is called, then
-   * the handlers for asynchronous wait operations will:
-   *
-   * @li have already been invoked; or
-   *
-   * @li have been queued for invocation in the near future.
-   *
-   * These handlers can no longer be cancelled, and therefore are passed an
-   * error code that indicates the successful completion of the wait operation.
-   */
-  std::size_t cancel_one()
-  {
-    asio::error_code ec;
-    std::size_t s = this->service.cancel_one(this->implementation, ec);
-    asio::detail::throw_error(ec, "cancel_one");
-    return s;
-  }
-
-  /// Cancels one asynchronous operation that is waiting on the timer.
-  /**
-   * This function forces the completion of one pending asynchronous wait
-   * operation against the timer. Handlers are cancelled in FIFO order. The
-   * handler for the cancelled operation will be invoked with the
-   * asio::error::operation_aborted error code.
-   *
-   * Cancelling the timer does not change the expiry time.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   *
-   * @return The number of asynchronous operations that were cancelled. That is,
-   * either 0 or 1.
-   *
-   * @note If the timer has already expired when cancel_one() is called, then
-   * the handlers for asynchronous wait operations will:
-   *
-   * @li have already been invoked; or
-   *
-   * @li have been queued for invocation in the near future.
-   *
-   * These handlers can no longer be cancelled, and therefore are passed an
-   * error code that indicates the successful completion of the wait operation.
-   */
-  std::size_t cancel_one(asio::error_code& ec)
-  {
-    return this->service.cancel_one(this->implementation, ec);
-  }
-
-  /// Get the timer's expiry time as an absolute time.
-  /**
-   * This function may be used to obtain the timer's current expiry time.
-   * Whether the timer has expired or not does not affect this value.
-   */
-  time_point expires_at() const
-  {
-    return this->service.expires_at(this->implementation);
-  }
-
-  /// Set the timer's expiry time as an absolute time.
-  /**
-   * This function sets the expiry time. Any pending asynchronous wait
-   * operations will be cancelled. The handler for each cancelled operation will
-   * be invoked with the asio::error::operation_aborted error code.
-   *
-   * @param expiry_time The expiry time to be used for the timer.
-   *
-   * @return The number of asynchronous operations that were cancelled.
-   *
-   * @throws asio::system_error Thrown on failure.
-   *
-   * @note If the timer has already expired when expires_at() is called, then
-   * the handlers for asynchronous wait operations will:
-   *
-   * @li have already been invoked; or
-   *
-   * @li have been queued for invocation in the near future.
-   *
-   * These handlers can no longer be cancelled, and therefore are passed an
-   * error code that indicates the successful completion of the wait operation.
-   */
-  std::size_t expires_at(const time_point& expiry_time)
-  {
-    asio::error_code ec;
-    std::size_t s = this->service.expires_at(
-        this->implementation, expiry_time, ec);
-    asio::detail::throw_error(ec, "expires_at");
-    return s;
-  }
-
-  /// Set the timer's expiry time as an absolute time.
-  /**
-   * This function sets the expiry time. Any pending asynchronous wait
-   * operations will be cancelled. The handler for each cancelled operation will
-   * be invoked with the asio::error::operation_aborted error code.
-   *
-   * @param expiry_time The expiry time to be used for the timer.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   *
-   * @return The number of asynchronous operations that were cancelled.
-   *
-   * @note If the timer has already expired when expires_at() is called, then
-   * the handlers for asynchronous wait operations will:
-   *
-   * @li have already been invoked; or
-   *
-   * @li have been queued for invocation in the near future.
-   *
-   * These handlers can no longer be cancelled, and therefore are passed an
-   * error code that indicates the successful completion of the wait operation.
-   */
-  std::size_t expires_at(const time_point& expiry_time,
-      asio::error_code& ec)
-  {
-    return this->service.expires_at(this->implementation, expiry_time, ec);
-  }
-
-  /// Get the timer's expiry time relative to now.
-  /**
-   * This function may be used to obtain the timer's current expiry time.
-   * Whether the timer has expired or not does not affect this value.
-   */
-  duration expires_from_now() const
-  {
-    return this->service.expires_from_now(this->implementation);
-  }
-
-  /// Set the timer's expiry time relative to now.
-  /**
-   * This function sets the expiry time. Any pending asynchronous wait
-   * operations will be cancelled. The handler for each cancelled operation will
-   * be invoked with the asio::error::operation_aborted error code.
-   *
-   * @param expiry_time The expiry time to be used for the timer.
-   *
-   * @return The number of asynchronous operations that were cancelled.
-   *
-   * @throws asio::system_error Thrown on failure.
-   *
-   * @note If the timer has already expired when expires_from_now() is called,
-   * then the handlers for asynchronous wait operations will:
-   *
-   * @li have already been invoked; or
-   *
-   * @li have been queued for invocation in the near future.
-   *
-   * These handlers can no longer be cancelled, and therefore are passed an
-   * error code that indicates the successful completion of the wait operation.
-   */
-  std::size_t expires_from_now(const duration& expiry_time)
-  {
-    asio::error_code ec;
-    std::size_t s = this->service.expires_from_now(
-        this->implementation, expiry_time, ec);
-    asio::detail::throw_error(ec, "expires_from_now");
-    return s;
-  }
-
-  /// Set the timer's expiry time relative to now.
-  /**
-   * This function sets the expiry time. Any pending asynchronous wait
-   * operations will be cancelled. The handler for each cancelled operation will
-   * be invoked with the asio::error::operation_aborted error code.
-   *
-   * @param expiry_time The expiry time to be used for the timer.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   *
-   * @return The number of asynchronous operations that were cancelled.
-   *
-   * @note If the timer has already expired when expires_from_now() is called,
-   * then the handlers for asynchronous wait operations will:
-   *
-   * @li have already been invoked; or
-   *
-   * @li have been queued for invocation in the near future.
-   *
-   * These handlers can no longer be cancelled, and therefore are passed an
-   * error code that indicates the successful completion of the wait operation.
-   */
-  std::size_t expires_from_now(const duration& expiry_time,
-      asio::error_code& ec)
-  {
-    return this->service.expires_from_now(
-        this->implementation, expiry_time, ec);
-  }
-
-  /// Perform a blocking wait on the timer.
-  /**
-   * This function is used to wait for the timer to expire. This function
-   * blocks and does not return until the timer has expired.
-   *
-   * @throws asio::system_error Thrown on failure.
-   */
-  void wait()
-  {
-    asio::error_code ec;
-    this->service.wait(this->implementation, ec);
-    asio::detail::throw_error(ec, "wait");
-  }
-
-  /// Perform a blocking wait on the timer.
-  /**
-   * This function is used to wait for the timer to expire. This function
-   * blocks and does not return until the timer has expired.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   */
-  void wait(asio::error_code& ec)
-  {
-    this->service.wait(this->implementation, ec);
-  }
-
-  /// Start an asynchronous wait on the timer.
-  /**
-   * This function may be used to initiate an asynchronous wait against the
-   * timer. It always returns immediately.
-   *
-   * For each call to async_wait(), the supplied handler will be called exactly
-   * once. The handler will be called when:
-   *
-   * @li The timer has expired.
-   *
-   * @li The timer was cancelled, in which case the handler is passed the error
-   * code asio::error::operation_aborted.
-   *
-   * @param handler The handler to be called when the timer expires. Copies
-   * will be made of the handler as required. The function signature of the
-   * handler must be:
-   * @code void handler(
-   *   const asio::error_code& error // Result of operation.
-   * ); @endcode
-   * Regardless of whether the asynchronous operation completes immediately or
-   * not, the handler will not be invoked from within this function. Invocation
-   * of the handler will be performed in a manner equivalent to using
-   * asio::io_service::post().
-   */
-  template <typename WaitHandler>
-  ASIO_INITFN_RESULT_TYPE(WaitHandler,
-      void (asio::error_code))
-  async_wait(ASIO_MOVE_ARG(WaitHandler) handler)
-  {
-    // If you get an error on the following line it means that your handler does
-    // not meet the documented type requirements for a WaitHandler.
-    ASIO_WAIT_HANDLER_CHECK(WaitHandler, handler) type_check;
-
-    return this->service.async_wait(this->implementation,
-        ASIO_MOVE_CAST(WaitHandler)(handler));
-  }
-};
-
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_BASIC_WAITABLE_TIMER_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/buffer.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/buffer.hpp
deleted file mode 100644
index afd5d04576a2..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/buffer.hpp
+++ /dev/null
@@ -1,2239 +0,0 @@
-//
-// buffer.hpp
-// ~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_BUFFER_HPP
-#define ASIO_BUFFER_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include <cstddef>
-#include <cstring>
-#include <string>
-#include <vector>
-#include "asio/detail/array_fwd.hpp"
-
-#if defined(ASIO_MSVC)
-# if defined(_HAS_ITERATOR_DEBUGGING) && (_HAS_ITERATOR_DEBUGGING != 0)
-#  if !defined(ASIO_DISABLE_BUFFER_DEBUGGING)
-#   define ASIO_ENABLE_BUFFER_DEBUGGING
-#  endif // !defined(ASIO_DISABLE_BUFFER_DEBUGGING)
-# endif // defined(_HAS_ITERATOR_DEBUGGING)
-#endif // defined(ASIO_MSVC)
-
-#if defined(__GNUC__)
-# if defined(_GLIBCXX_DEBUG)
-#  if !defined(ASIO_DISABLE_BUFFER_DEBUGGING)
-#   define ASIO_ENABLE_BUFFER_DEBUGGING
-#  endif // !defined(ASIO_DISABLE_BUFFER_DEBUGGING)
-# endif // defined(_GLIBCXX_DEBUG)
-#endif // defined(__GNUC__)
-
-#if defined(ASIO_ENABLE_BUFFER_DEBUGGING)
-# include "asio/detail/function.hpp"
-#endif // ASIO_ENABLE_BUFFER_DEBUGGING
-
-#if defined(ASIO_HAS_BOOST_WORKAROUND)
-# include <boost/detail/workaround.hpp>
-# if BOOST_WORKAROUND(__BORLANDC__, BOOST_TESTED_AT(0x582)) \
-    || BOOST_WORKAROUND(__SUNPRO_CC, BOOST_TESTED_AT(0x590))
-#  define ASIO_ENABLE_ARRAY_BUFFER_WORKAROUND
-# endif // BOOST_WORKAROUND(__BORLANDC__, BOOST_TESTED_AT(0x582))
-        // || BOOST_WORKAROUND(__SUNPRO_CC, BOOST_TESTED_AT(0x590))
-#endif // defined(ASIO_HAS_BOOST_WORKAROUND)
-
-#if defined(ASIO_ENABLE_ARRAY_BUFFER_WORKAROUND)
-# include "asio/detail/type_traits.hpp"
-#endif // defined(ASIO_ENABLE_ARRAY_BUFFER_WORKAROUND)
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-
-class mutable_buffer;
-class const_buffer;
-
-namespace detail {
-void* buffer_cast_helper(const mutable_buffer&);
-const void* buffer_cast_helper(const const_buffer&);
-std::size_t buffer_size_helper(const mutable_buffer&);
-std::size_t buffer_size_helper(const const_buffer&);
-} // namespace detail
-
-/// Holds a buffer that can be modified.
-/**
- * The mutable_buffer class provides a safe representation of a buffer that can
- * be modified. It does not own the underlying data, and so is cheap to copy or
- * assign.
- *
- * @par Accessing Buffer Contents
- *
- * The contents of a buffer may be accessed using the @ref buffer_size
- * and @ref buffer_cast functions:
- *
- * @code asio::mutable_buffer b1 = ...;
- * std::size_t s1 = asio::buffer_size(b1);
- * unsigned char* p1 = asio::buffer_cast<unsigned char*>(b1);
- * @endcode
- *
- * The asio::buffer_cast function permits violations of type safety, so
- * uses of it in application code should be carefully considered.
- */
-class mutable_buffer
-{
-public:
-  /// Construct an empty buffer.
-  mutable_buffer()
-    : data_(0),
-      size_(0)
-  {
-  }
-
-  /// Construct a buffer to represent a given memory range.
-  mutable_buffer(void* data, std::size_t size)
-    : data_(data),
-      size_(size)
-  {
-  }
-
-#if defined(ASIO_ENABLE_BUFFER_DEBUGGING)
-  mutable_buffer(void* data, std::size_t size,
-      asio::detail::function<void()> debug_check)
-    : data_(data),
-      size_(size),
-      debug_check_(debug_check)
-  {
-  }
-
-  const asio::detail::function<void()>& get_debug_check() const
-  {
-    return debug_check_;
-  }
-#endif // ASIO_ENABLE_BUFFER_DEBUGGING
-
-private:
-  friend void* asio::detail::buffer_cast_helper(
-      const mutable_buffer& b);
-  friend std::size_t asio::detail::buffer_size_helper(
-      const mutable_buffer& b);
-
-  void* data_;
-  std::size_t size_;
-
-#if defined(ASIO_ENABLE_BUFFER_DEBUGGING)
-  asio::detail::function<void()> debug_check_;
-#endif // ASIO_ENABLE_BUFFER_DEBUGGING
-};
-
-namespace detail {
-
-inline void* buffer_cast_helper(const mutable_buffer& b)
-{
-#if defined(ASIO_ENABLE_BUFFER_DEBUGGING)
-  if (b.size_ && b.debug_check_)
-    b.debug_check_();
-#endif // ASIO_ENABLE_BUFFER_DEBUGGING
-  return b.data_;
-}
-
-inline std::size_t buffer_size_helper(const mutable_buffer& b)
-{
-  return b.size_;
-}
-
-} // namespace detail
-
-/// Adapts a single modifiable buffer so that it meets the requirements of the
-/// MutableBufferSequence concept.
-class mutable_buffers_1
-  : public mutable_buffer
-{
-public:
-  /// The type for each element in the list of buffers.
-  typedef mutable_buffer value_type;
-
-  /// A random-access iterator type that may be used to read elements.
-  typedef const mutable_buffer* const_iterator;
-
-  /// Construct to represent a given memory range.
-  mutable_buffers_1(void* data, std::size_t size)
-    : mutable_buffer(data, size)
-  {
-  }
-
-  /// Construct to represent a single modifiable buffer.
-  explicit mutable_buffers_1(const mutable_buffer& b)
-    : mutable_buffer(b)
-  {
-  }
-
-  /// Get a random-access iterator to the first element.
-  const_iterator begin() const
-  {
-    return this;
-  }
-
-  /// Get a random-access iterator for one past the last element.
-  const_iterator end() const
-  {
-    return begin() + 1;
-  }
-};
-
-/// Holds a buffer that cannot be modified.
-/**
- * The const_buffer class provides a safe representation of a buffer that cannot
- * be modified. It does not own the underlying data, and so is cheap to copy or
- * assign.
- *
- * @par Accessing Buffer Contents
- *
- * The contents of a buffer may be accessed using the @ref buffer_size
- * and @ref buffer_cast functions:
- *
- * @code asio::const_buffer b1 = ...;
- * std::size_t s1 = asio::buffer_size(b1);
- * const unsigned char* p1 = asio::buffer_cast<const unsigned char*>(b1);
- * @endcode
- *
- * The asio::buffer_cast function permits violations of type safety, so
- * uses of it in application code should be carefully considered.
- */
-class const_buffer
-{
-public:
-  /// Construct an empty buffer.
-  const_buffer()
-    : data_(0),
-      size_(0)
-  {
-  }
-
-  /// Construct a buffer to represent a given memory range.
-  const_buffer(const void* data, std::size_t size)
-    : data_(data),
-      size_(size)
-  {
-  }
-
-  /// Construct a non-modifiable buffer from a modifiable one.
-  const_buffer(const mutable_buffer& b)
-    : data_(asio::detail::buffer_cast_helper(b)),
-      size_(asio::detail::buffer_size_helper(b))
-#if defined(ASIO_ENABLE_BUFFER_DEBUGGING)
-      , debug_check_(b.get_debug_check())
-#endif // ASIO_ENABLE_BUFFER_DEBUGGING
-  {
-  }
-
-#if defined(ASIO_ENABLE_BUFFER_DEBUGGING)
-  const_buffer(const void* data, std::size_t size,
-      asio::detail::function<void()> debug_check)
-    : data_(data),
-      size_(size),
-      debug_check_(debug_check)
-  {
-  }
-
-  const asio::detail::function<void()>& get_debug_check() const
-  {
-    return debug_check_;
-  }
-#endif // ASIO_ENABLE_BUFFER_DEBUGGING
-
-private:
-  friend const void* asio::detail::buffer_cast_helper(
-      const const_buffer& b);
-  friend std::size_t asio::detail::buffer_size_helper(
-      const const_buffer& b);
-
-  const void* data_;
-  std::size_t size_;
-
-#if defined(ASIO_ENABLE_BUFFER_DEBUGGING)
-  asio::detail::function<void()> debug_check_;
-#endif // ASIO_ENABLE_BUFFER_DEBUGGING
-};
-
-namespace detail {
-
-inline const void* buffer_cast_helper(const const_buffer& b)
-{
-#if defined(ASIO_ENABLE_BUFFER_DEBUGGING)
-  if (b.size_ && b.debug_check_)
-    b.debug_check_();
-#endif // ASIO_ENABLE_BUFFER_DEBUGGING
-  return b.data_;
-}
-
-inline std::size_t buffer_size_helper(const const_buffer& b)
-{
-  return b.size_;
-}
-
-} // namespace detail
-
-/// Adapts a single non-modifiable buffer so that it meets the requirements of
-/// the ConstBufferSequence concept.
-class const_buffers_1
-  : public const_buffer
-{
-public:
-  /// The type for each element in the list of buffers.
-  typedef const_buffer value_type;
-
-  /// A random-access iterator type that may be used to read elements.
-  typedef const const_buffer* const_iterator;
-
-  /// Construct to represent a given memory range.
-  const_buffers_1(const void* data, std::size_t size)
-    : const_buffer(data, size)
-  {
-  }
-
-  /// Construct to represent a single non-modifiable buffer.
-  explicit const_buffers_1(const const_buffer& b)
-    : const_buffer(b)
-  {
-  }
-
-  /// Get a random-access iterator to the first element.
-  const_iterator begin() const
-  {
-    return this;
-  }
-
-  /// Get a random-access iterator for one past the last element.
-  const_iterator end() const
-  {
-    return begin() + 1;
-  }
-};
-
-/// An implementation of both the ConstBufferSequence and MutableBufferSequence
-/// concepts to represent a null buffer sequence.
-class null_buffers
-{
-public:
-  /// The type for each element in the list of buffers.
-  typedef mutable_buffer value_type;
-
-  /// A random-access iterator type that may be used to read elements.
-  typedef const mutable_buffer* const_iterator;
-
-  /// Get a random-access iterator to the first element.
-  const_iterator begin() const
-  {
-    return &buf_;
-  }
-
-  /// Get a random-access iterator for one past the last element.
-  const_iterator end() const
-  {
-    return &buf_;
-  }
-
-private:
-  mutable_buffer buf_;
-};
-
-/** @defgroup buffer_size asio::buffer_size
- *
- * @brief The asio::buffer_size function determines the total number of
- * bytes in a buffer or buffer sequence.
- */
-/*@{*/
-
-/// Get the number of bytes in a modifiable buffer.
-inline std::size_t buffer_size(const mutable_buffer& b)
-{
-  return detail::buffer_size_helper(b);
-}
-
-/// Get the number of bytes in a modifiable buffer.
-inline std::size_t buffer_size(const mutable_buffers_1& b)
-{
-  return detail::buffer_size_helper(b);
-}
-
-/// Get the number of bytes in a non-modifiable buffer.
-inline std::size_t buffer_size(const const_buffer& b)
-{
-  return detail::buffer_size_helper(b);
-}
-
-/// Get the number of bytes in a non-modifiable buffer.
-inline std::size_t buffer_size(const const_buffers_1& b)
-{
-  return detail::buffer_size_helper(b);
-}
-
-/// Get the total number of bytes in a buffer sequence.
-/** 
- * The @c BufferSequence template parameter may meet either of the @c
- * ConstBufferSequence or @c MutableBufferSequence type requirements.
- */
-template <typename BufferSequence>
-inline std::size_t buffer_size(const BufferSequence& b)
-{
-  std::size_t total_buffer_size = 0;
-
-  typename BufferSequence::const_iterator iter = b.begin();
-  typename BufferSequence::const_iterator end = b.end();
-  for (; iter != end; ++iter)
-    total_buffer_size += detail::buffer_size_helper(*iter);
-
-  return total_buffer_size;
-}
-
-/*@}*/
-
-/** @defgroup buffer_cast asio::buffer_cast
- *
- * @brief The asio::buffer_cast function is used to obtain a pointer to
- * the underlying memory region associated with a buffer.
- *
- * @par Examples:
- *
- * To access the memory of a non-modifiable buffer, use:
- * @code asio::const_buffer b1 = ...;
- * const unsigned char* p1 = asio::buffer_cast<const unsigned char*>(b1);
- * @endcode
- *
- * To access the memory of a modifiable buffer, use:
- * @code asio::mutable_buffer b2 = ...;
- * unsigned char* p2 = asio::buffer_cast<unsigned char*>(b2);
- * @endcode
- *
- * The asio::buffer_cast function permits violations of type safety, so
- * uses of it in application code should be carefully considered.
- */
-/*@{*/
-
-/// Cast a non-modifiable buffer to a specified pointer to POD type.
-template <typename PointerToPodType>
-inline PointerToPodType buffer_cast(const mutable_buffer& b)
-{
-  return static_cast<PointerToPodType>(detail::buffer_cast_helper(b));
-}
-
-/// Cast a non-modifiable buffer to a specified pointer to POD type.
-template <typename PointerToPodType>
-inline PointerToPodType buffer_cast(const const_buffer& b)
-{
-  return static_cast<PointerToPodType>(detail::buffer_cast_helper(b));
-}
-
-/*@}*/
-
-/// Create a new modifiable buffer that is offset from the start of another.
-/**
- * @relates mutable_buffer
- */
-inline mutable_buffer operator+(const mutable_buffer& b, std::size_t start)
-{
-  if (start > buffer_size(b))
-    return mutable_buffer();
-  char* new_data = buffer_cast<char*>(b) + start;
-  std::size_t new_size = buffer_size(b) - start;
-  return mutable_buffer(new_data, new_size
-#if defined(ASIO_ENABLE_BUFFER_DEBUGGING)
-      , b.get_debug_check()
-#endif // ASIO_ENABLE_BUFFER_DEBUGGING
-      );
-}
-
-/// Create a new modifiable buffer that is offset from the start of another.
-/**
- * @relates mutable_buffer
- */
-inline mutable_buffer operator+(std::size_t start, const mutable_buffer& b)
-{
-  if (start > buffer_size(b))
-    return mutable_buffer();
-  char* new_data = buffer_cast<char*>(b) + start;
-  std::size_t new_size = buffer_size(b) - start;
-  return mutable_buffer(new_data, new_size
-#if defined(ASIO_ENABLE_BUFFER_DEBUGGING)
-      , b.get_debug_check()
-#endif // ASIO_ENABLE_BUFFER_DEBUGGING
-      );
-}
-
-/// Create a new non-modifiable buffer that is offset from the start of another.
-/**
- * @relates const_buffer
- */
-inline const_buffer operator+(const const_buffer& b, std::size_t start)
-{
-  if (start > buffer_size(b))
-    return const_buffer();
-  const char* new_data = buffer_cast<const char*>(b) + start;
-  std::size_t new_size = buffer_size(b) - start;
-  return const_buffer(new_data, new_size
-#if defined(ASIO_ENABLE_BUFFER_DEBUGGING)
-      , b.get_debug_check()
-#endif // ASIO_ENABLE_BUFFER_DEBUGGING
-      );
-}
-
-/// Create a new non-modifiable buffer that is offset from the start of another.
-/**
- * @relates const_buffer
- */
-inline const_buffer operator+(std::size_t start, const const_buffer& b)
-{
-  if (start > buffer_size(b))
-    return const_buffer();
-  const char* new_data = buffer_cast<const char*>(b) + start;
-  std::size_t new_size = buffer_size(b) - start;
-  return const_buffer(new_data, new_size
-#if defined(ASIO_ENABLE_BUFFER_DEBUGGING)
-      , b.get_debug_check()
-#endif // ASIO_ENABLE_BUFFER_DEBUGGING
-      );
-}
-
-#if defined(ASIO_ENABLE_BUFFER_DEBUGGING)
-namespace detail {
-
-template <typename Iterator>
-class buffer_debug_check
-{
-public:
-  buffer_debug_check(Iterator iter)
-    : iter_(iter)
-  {
-  }
-
-  ~buffer_debug_check()
-  {
-#if defined(ASIO_MSVC) && (ASIO_MSVC == 1400)
-    // MSVC 8's string iterator checking may crash in a std::string::iterator
-    // object's destructor when the iterator points to an already-destroyed
-    // std::string object, unless the iterator is cleared first.
-    iter_ = Iterator();
-#endif // defined(ASIO_MSVC) && (ASIO_MSVC == 1400)
-  }
-
-  void operator()()
-  {
-    *iter_;
-  }
-
-private:
-  Iterator iter_;
-};
-
-} // namespace detail
-#endif // ASIO_ENABLE_BUFFER_DEBUGGING
-
-/** @defgroup buffer asio::buffer
- *
- * @brief The asio::buffer function is used to create a buffer object to
- * represent raw memory, an array of POD elements, a vector of POD elements,
- * or a std::string.
- *
- * A buffer object represents a contiguous region of memory as a 2-tuple
- * consisting of a pointer and size in bytes. A tuple of the form <tt>{void*,
- * size_t}</tt> specifies a mutable (modifiable) region of memory. Similarly, a
- * tuple of the form <tt>{const void*, size_t}</tt> specifies a const
- * (non-modifiable) region of memory. These two forms correspond to the classes
- * mutable_buffer and const_buffer, respectively. To mirror C++'s conversion
- * rules, a mutable_buffer is implicitly convertible to a const_buffer, and the
- * opposite conversion is not permitted.
- *
- * The simplest use case involves reading or writing a single buffer of a
- * specified size:
- *
- * @code sock.send(asio::buffer(data, size)); @endcode
- *
- * In the above example, the return value of asio::buffer meets the
- * requirements of the ConstBufferSequence concept so that it may be directly
- * passed to the socket's write function. A buffer created for modifiable
- * memory also meets the requirements of the MutableBufferSequence concept.
- *
- * An individual buffer may be created from a builtin array, std::vector,
- * std::array or boost::array of POD elements. This helps prevent buffer
- * overruns by automatically determining the size of the buffer:
- *
- * @code char d1[128];
- * size_t bytes_transferred = sock.receive(asio::buffer(d1));
- *
- * std::vector<char> d2(128);
- * bytes_transferred = sock.receive(asio::buffer(d2));
- *
- * std::array<char, 128> d3;
- * bytes_transferred = sock.receive(asio::buffer(d3));
- *
- * boost::array<char, 128> d4;
- * bytes_transferred = sock.receive(asio::buffer(d4)); @endcode
- *
- * In all three cases above, the buffers created are exactly 128 bytes long.
- * Note that a vector is @e never automatically resized when creating or using
- * a buffer. The buffer size is determined using the vector's <tt>size()</tt>
- * member function, and not its capacity.
- *
- * @par Accessing Buffer Contents
- *
- * The contents of a buffer may be accessed using the @ref buffer_size and
- * @ref buffer_cast functions:
- *
- * @code asio::mutable_buffer b1 = ...;
- * std::size_t s1 = asio::buffer_size(b1);
- * unsigned char* p1 = asio::buffer_cast<unsigned char*>(b1);
- *
- * asio::const_buffer b2 = ...;
- * std::size_t s2 = asio::buffer_size(b2);
- * const void* p2 = asio::buffer_cast<const void*>(b2); @endcode
- *
- * The asio::buffer_cast function permits violations of type safety, so
- * uses of it in application code should be carefully considered.
- *
- * For convenience, the @ref buffer_size function also works on buffer
- * sequences (that is, types meeting the ConstBufferSequence or
- * MutableBufferSequence type requirements). In this case, the function returns
- * the total size of all buffers in the sequence.
- *
- * @par Buffer Copying
- *
- * The @ref buffer_copy function may be used to copy raw bytes between
- * individual buffers and buffer sequences.
- *
- * In particular, when used with the @ref buffer_size, the @ref buffer_copy
- * function can be used to linearise a sequence of buffers. For example:
- *
- * @code vector<const_buffer> buffers = ...;
- *
- * vector<unsigned char> data(asio::buffer_size(buffers));
- * asio::buffer_copy(asio::buffer(data), buffers); @endcode
- *
- * Note that @ref buffer_copy is implemented in terms of @c memcpy, and
- * consequently it cannot be used to copy between overlapping memory regions.
- *
- * @par Buffer Invalidation
- *
- * A buffer object does not have any ownership of the memory it refers to. It
- * is the responsibility of the application to ensure the memory region remains
- * valid until it is no longer required for an I/O operation. When the memory
- * is no longer available, the buffer is said to have been invalidated.
- *
- * For the asio::buffer overloads that accept an argument of type
- * std::vector, the buffer objects returned are invalidated by any vector
- * operation that also invalidates all references, pointers and iterators
- * referring to the elements in the sequence (C++ Std, 23.2.4)
- *
- * For the asio::buffer overloads that accept an argument of type
- * std::basic_string, the buffer objects returned are invalidated according to
- * the rules defined for invalidation of references, pointers and iterators
- * referring to elements of the sequence (C++ Std, 21.3).
- *
- * @par Buffer Arithmetic
- *
- * Buffer objects may be manipulated using simple arithmetic in a safe way
- * which helps prevent buffer overruns. Consider an array initialised as
- * follows:
- *
- * @code boost::array<char, 6> a = { 'a', 'b', 'c', 'd', 'e' }; @endcode
- *
- * A buffer object @c b1 created using:
- *
- * @code b1 = asio::buffer(a); @endcode
- *
- * represents the entire array, <tt>{ 'a', 'b', 'c', 'd', 'e' }</tt>. An
- * optional second argument to the asio::buffer function may be used to
- * limit the size, in bytes, of the buffer:
- *
- * @code b2 = asio::buffer(a, 3); @endcode
- *
- * such that @c b2 represents the data <tt>{ 'a', 'b', 'c' }</tt>. Even if the
- * size argument exceeds the actual size of the array, the size of the buffer
- * object created will be limited to the array size.
- *
- * An offset may be applied to an existing buffer to create a new one:
- *
- * @code b3 = b1 + 2; @endcode
- *
- * where @c b3 will set to represent <tt>{ 'c', 'd', 'e' }</tt>. If the offset
- * exceeds the size of the existing buffer, the newly created buffer will be
- * empty.
- *
- * Both an offset and size may be specified to create a buffer that corresponds
- * to a specific range of bytes within an existing buffer:
- *
- * @code b4 = asio::buffer(b1 + 1, 3); @endcode
- *
- * so that @c b4 will refer to the bytes <tt>{ 'b', 'c', 'd' }</tt>.
- *
- * @par Buffers and Scatter-Gather I/O
- *
- * To read or write using multiple buffers (i.e. scatter-gather I/O), multiple
- * buffer objects may be assigned into a container that supports the
- * MutableBufferSequence (for read) or ConstBufferSequence (for write) concepts:
- *
- * @code
- * char d1[128];
- * std::vector<char> d2(128);
- * boost::array<char, 128> d3;
- *
- * boost::array<mutable_buffer, 3> bufs1 = {
- *   asio::buffer(d1),
- *   asio::buffer(d2),
- *   asio::buffer(d3) };
- * bytes_transferred = sock.receive(bufs1);
- *
- * std::vector<const_buffer> bufs2;
- * bufs2.push_back(asio::buffer(d1));
- * bufs2.push_back(asio::buffer(d2));
- * bufs2.push_back(asio::buffer(d3));
- * bytes_transferred = sock.send(bufs2); @endcode
- */
-/*@{*/
-
-/// Create a new modifiable buffer from an existing buffer.
-/**
- * @returns <tt>mutable_buffers_1(b)</tt>.
- */
-inline mutable_buffers_1 buffer(const mutable_buffer& b)
-{
-  return mutable_buffers_1(b);
-}
-
-/// Create a new modifiable buffer from an existing buffer.
-/**
- * @returns A mutable_buffers_1 value equivalent to:
- * @code mutable_buffers_1(
- *     buffer_cast<void*>(b),
- *     min(buffer_size(b), max_size_in_bytes)); @endcode
- */
-inline mutable_buffers_1 buffer(const mutable_buffer& b,
-    std::size_t max_size_in_bytes)
-{
-  return mutable_buffers_1(
-      mutable_buffer(buffer_cast<void*>(b),
-        buffer_size(b) < max_size_in_bytes
-        ? buffer_size(b) : max_size_in_bytes
-#if defined(ASIO_ENABLE_BUFFER_DEBUGGING)
-        , b.get_debug_check()
-#endif // ASIO_ENABLE_BUFFER_DEBUGGING
-        ));
-}
-
-/// Create a new non-modifiable buffer from an existing buffer.
-/**
- * @returns <tt>const_buffers_1(b)</tt>.
- */
-inline const_buffers_1 buffer(const const_buffer& b)
-{
-  return const_buffers_1(b);
-}
-
-/// Create a new non-modifiable buffer from an existing buffer.
-/**
- * @returns A const_buffers_1 value equivalent to:
- * @code const_buffers_1(
- *     buffer_cast<const void*>(b),
- *     min(buffer_size(b), max_size_in_bytes)); @endcode
- */
-inline const_buffers_1 buffer(const const_buffer& b,
-    std::size_t max_size_in_bytes)
-{
-  return const_buffers_1(
-      const_buffer(buffer_cast<const void*>(b),
-        buffer_size(b) < max_size_in_bytes
-        ? buffer_size(b) : max_size_in_bytes
-#if defined(ASIO_ENABLE_BUFFER_DEBUGGING)
-        , b.get_debug_check()
-#endif // ASIO_ENABLE_BUFFER_DEBUGGING
-        ));
-}
-
-/// Create a new modifiable buffer that represents the given memory range.
-/**
- * @returns <tt>mutable_buffers_1(data, size_in_bytes)</tt>.
- */
-inline mutable_buffers_1 buffer(void* data, std::size_t size_in_bytes)
-{
-  return mutable_buffers_1(mutable_buffer(data, size_in_bytes));
-}
-
-/// Create a new non-modifiable buffer that represents the given memory range.
-/**
- * @returns <tt>const_buffers_1(data, size_in_bytes)</tt>.
- */
-inline const_buffers_1 buffer(const void* data,
-    std::size_t size_in_bytes)
-{
-  return const_buffers_1(const_buffer(data, size_in_bytes));
-}
-
-/// Create a new modifiable buffer that represents the given POD array.
-/**
- * @returns A mutable_buffers_1 value equivalent to:
- * @code mutable_buffers_1(
- *     static_cast<void*>(data),
- *     N * sizeof(PodType)); @endcode
- */
-template <typename PodType, std::size_t N>
-inline mutable_buffers_1 buffer(PodType (&data)[N])
-{
-  return mutable_buffers_1(mutable_buffer(data, N * sizeof(PodType)));
-}
- 
-/// Create a new modifiable buffer that represents the given POD array.
-/**
- * @returns A mutable_buffers_1 value equivalent to:
- * @code mutable_buffers_1(
- *     static_cast<void*>(data),
- *     min(N * sizeof(PodType), max_size_in_bytes)); @endcode
- */
-template <typename PodType, std::size_t N>
-inline mutable_buffers_1 buffer(PodType (&data)[N],
-    std::size_t max_size_in_bytes)
-{
-  return mutable_buffers_1(
-      mutable_buffer(data,
-        N * sizeof(PodType) < max_size_in_bytes
-        ? N * sizeof(PodType) : max_size_in_bytes));
-}
- 
-/// Create a new non-modifiable buffer that represents the given POD array.
-/**
- * @returns A const_buffers_1 value equivalent to:
- * @code const_buffers_1(
- *     static_cast<const void*>(data),
- *     N * sizeof(PodType)); @endcode
- */
-template <typename PodType, std::size_t N>
-inline const_buffers_1 buffer(const PodType (&data)[N])
-{
-  return const_buffers_1(const_buffer(data, N * sizeof(PodType)));
-}
-
-/// Create a new non-modifiable buffer that represents the given POD array.
-/**
- * @returns A const_buffers_1 value equivalent to:
- * @code const_buffers_1(
- *     static_cast<const void*>(data),
- *     min(N * sizeof(PodType), max_size_in_bytes)); @endcode
- */
-template <typename PodType, std::size_t N>
-inline const_buffers_1 buffer(const PodType (&data)[N],
-    std::size_t max_size_in_bytes)
-{
-  return const_buffers_1(
-      const_buffer(data,
-        N * sizeof(PodType) < max_size_in_bytes
-        ? N * sizeof(PodType) : max_size_in_bytes));
-}
-
-#if defined(ASIO_ENABLE_ARRAY_BUFFER_WORKAROUND)
-
-// Borland C++ and Sun Studio think the overloads:
-//
-//   unspecified buffer(boost::array<PodType, N>& array ...);
-//
-// and
-//
-//   unspecified buffer(boost::array<const PodType, N>& array ...);
-//
-// are ambiguous. This will be worked around by using a buffer_types traits
-// class that contains typedefs for the appropriate buffer and container
-// classes, based on whether PodType is const or non-const.
-
-namespace detail {
-
-template <bool IsConst>
-struct buffer_types_base;
-
-template <>
-struct buffer_types_base<false>
-{
-  typedef mutable_buffer buffer_type;
-  typedef mutable_buffers_1 container_type;
-};
-
-template <>
-struct buffer_types_base<true>
-{
-  typedef const_buffer buffer_type;
-  typedef const_buffers_1 container_type;
-};
-
-template <typename PodType>
-struct buffer_types
-  : public buffer_types_base<is_const<PodType>::value>
-{
-};
-
-} // namespace detail
-
-template <typename PodType, std::size_t N>
-inline typename detail::buffer_types<PodType>::container_type
-buffer(boost::array<PodType, N>& data)
-{
-  typedef typename asio::detail::buffer_types<PodType>::buffer_type
-    buffer_type;
-  typedef typename asio::detail::buffer_types<PodType>::container_type
-    container_type;
-  return container_type(
-      buffer_type(data.c_array(), data.size() * sizeof(PodType)));
-}
-
-template <typename PodType, std::size_t N>
-inline typename detail::buffer_types<PodType>::container_type
-buffer(boost::array<PodType, N>& data, std::size_t max_size_in_bytes)
-{
-  typedef typename asio::detail::buffer_types<PodType>::buffer_type
-    buffer_type;
-  typedef typename asio::detail::buffer_types<PodType>::container_type
-    container_type;
-  return container_type(
-      buffer_type(data.c_array(),
-        data.size() * sizeof(PodType) < max_size_in_bytes
-        ? data.size() * sizeof(PodType) : max_size_in_bytes));
-}
-
-#else // defined(ASIO_ENABLE_ARRAY_BUFFER_WORKAROUND)
-
-/// Create a new modifiable buffer that represents the given POD array.
-/**
- * @returns A mutable_buffers_1 value equivalent to:
- * @code mutable_buffers_1(
- *     data.data(),
- *     data.size() * sizeof(PodType)); @endcode
- */
-template <typename PodType, std::size_t N>
-inline mutable_buffers_1 buffer(boost::array<PodType, N>& data)
-{
-  return mutable_buffers_1(
-      mutable_buffer(data.c_array(), data.size() * sizeof(PodType)));
-}
-
-/// Create a new modifiable buffer that represents the given POD array.
-/**
- * @returns A mutable_buffers_1 value equivalent to:
- * @code mutable_buffers_1(
- *     data.data(),
- *     min(data.size() * sizeof(PodType), max_size_in_bytes)); @endcode
- */
-template <typename PodType, std::size_t N>
-inline mutable_buffers_1 buffer(boost::array<PodType, N>& data,
-    std::size_t max_size_in_bytes)
-{
-  return mutable_buffers_1(
-      mutable_buffer(data.c_array(),
-        data.size() * sizeof(PodType) < max_size_in_bytes
-        ? data.size() * sizeof(PodType) : max_size_in_bytes));
-}
-
-/// Create a new non-modifiable buffer that represents the given POD array.
-/**
- * @returns A const_buffers_1 value equivalent to:
- * @code const_buffers_1(
- *     data.data(),
- *     data.size() * sizeof(PodType)); @endcode
- */
-template <typename PodType, std::size_t N>
-inline const_buffers_1 buffer(boost::array<const PodType, N>& data)
-{
-  return const_buffers_1(
-      const_buffer(data.data(), data.size() * sizeof(PodType)));
-}
-
-/// Create a new non-modifiable buffer that represents the given POD array.
-/**
- * @returns A const_buffers_1 value equivalent to:
- * @code const_buffers_1(
- *     data.data(),
- *     min(data.size() * sizeof(PodType), max_size_in_bytes)); @endcode
- */
-template <typename PodType, std::size_t N>
-inline const_buffers_1 buffer(boost::array<const PodType, N>& data,
-    std::size_t max_size_in_bytes)
-{
-  return const_buffers_1(
-      const_buffer(data.data(),
-        data.size() * sizeof(PodType) < max_size_in_bytes
-        ? data.size() * sizeof(PodType) : max_size_in_bytes));
-}
-
-#endif // defined(ASIO_ENABLE_ARRAY_BUFFER_WORKAROUND)
-
-/// Create a new non-modifiable buffer that represents the given POD array.
-/**
- * @returns A const_buffers_1 value equivalent to:
- * @code const_buffers_1(
- *     data.data(),
- *     data.size() * sizeof(PodType)); @endcode
- */
-template <typename PodType, std::size_t N>
-inline const_buffers_1 buffer(const boost::array<PodType, N>& data)
-{
-  return const_buffers_1(
-      const_buffer(data.data(), data.size() * sizeof(PodType)));
-}
-
-/// Create a new non-modifiable buffer that represents the given POD array.
-/**
- * @returns A const_buffers_1 value equivalent to:
- * @code const_buffers_1(
- *     data.data(),
- *     min(data.size() * sizeof(PodType), max_size_in_bytes)); @endcode
- */
-template <typename PodType, std::size_t N>
-inline const_buffers_1 buffer(const boost::array<PodType, N>& data,
-    std::size_t max_size_in_bytes)
-{
-  return const_buffers_1(
-      const_buffer(data.data(),
-        data.size() * sizeof(PodType) < max_size_in_bytes
-        ? data.size() * sizeof(PodType) : max_size_in_bytes));
-}
-
-#if defined(ASIO_HAS_STD_ARRAY) || defined(GENERATING_DOCUMENTATION)
-
-/// Create a new modifiable buffer that represents the given POD array.
-/**
- * @returns A mutable_buffers_1 value equivalent to:
- * @code mutable_buffers_1(
- *     data.data(),
- *     data.size() * sizeof(PodType)); @endcode
- */
-template <typename PodType, std::size_t N>
-inline mutable_buffers_1 buffer(std::array<PodType, N>& data)
-{
-  return mutable_buffers_1(
-      mutable_buffer(data.data(), data.size() * sizeof(PodType)));
-}
-
-/// Create a new modifiable buffer that represents the given POD array.
-/**
- * @returns A mutable_buffers_1 value equivalent to:
- * @code mutable_buffers_1(
- *     data.data(),
- *     min(data.size() * sizeof(PodType), max_size_in_bytes)); @endcode
- */
-template <typename PodType, std::size_t N>
-inline mutable_buffers_1 buffer(std::array<PodType, N>& data,
-    std::size_t max_size_in_bytes)
-{
-  return mutable_buffers_1(
-      mutable_buffer(data.data(),
-        data.size() * sizeof(PodType) < max_size_in_bytes
-        ? data.size() * sizeof(PodType) : max_size_in_bytes));
-}
-
-/// Create a new non-modifiable buffer that represents the given POD array.
-/**
- * @returns A const_buffers_1 value equivalent to:
- * @code const_buffers_1(
- *     data.data(),
- *     data.size() * sizeof(PodType)); @endcode
- */
-template <typename PodType, std::size_t N>
-inline const_buffers_1 buffer(std::array<const PodType, N>& data)
-{
-  return const_buffers_1(
-      const_buffer(data.data(), data.size() * sizeof(PodType)));
-}
-
-/// Create a new non-modifiable buffer that represents the given POD array.
-/**
- * @returns A const_buffers_1 value equivalent to:
- * @code const_buffers_1(
- *     data.data(),
- *     min(data.size() * sizeof(PodType), max_size_in_bytes)); @endcode
- */
-template <typename PodType, std::size_t N>
-inline const_buffers_1 buffer(std::array<const PodType, N>& data,
-    std::size_t max_size_in_bytes)
-{
-  return const_buffers_1(
-      const_buffer(data.data(),
-        data.size() * sizeof(PodType) < max_size_in_bytes
-        ? data.size() * sizeof(PodType) : max_size_in_bytes));
-}
-
-/// Create a new non-modifiable buffer that represents the given POD array.
-/**
- * @returns A const_buffers_1 value equivalent to:
- * @code const_buffers_1(
- *     data.data(),
- *     data.size() * sizeof(PodType)); @endcode
- */
-template <typename PodType, std::size_t N>
-inline const_buffers_1 buffer(const std::array<PodType, N>& data)
-{
-  return const_buffers_1(
-      const_buffer(data.data(), data.size() * sizeof(PodType)));
-}
-
-/// Create a new non-modifiable buffer that represents the given POD array.
-/**
- * @returns A const_buffers_1 value equivalent to:
- * @code const_buffers_1(
- *     data.data(),
- *     min(data.size() * sizeof(PodType), max_size_in_bytes)); @endcode
- */
-template <typename PodType, std::size_t N>
-inline const_buffers_1 buffer(const std::array<PodType, N>& data,
-    std::size_t max_size_in_bytes)
-{
-  return const_buffers_1(
-      const_buffer(data.data(),
-        data.size() * sizeof(PodType) < max_size_in_bytes
-        ? data.size() * sizeof(PodType) : max_size_in_bytes));
-}
-
-#endif // defined(ASIO_HAS_STD_ARRAY) || defined(GENERATING_DOCUMENTATION)
-
-/// Create a new modifiable buffer that represents the given POD vector.
-/**
- * @returns A mutable_buffers_1 value equivalent to:
- * @code mutable_buffers_1(
- *     data.size() ? &data[0] : 0,
- *     data.size() * sizeof(PodType)); @endcode
- *
- * @note The buffer is invalidated by any vector operation that would also
- * invalidate iterators.
- */
-template <typename PodType, typename Allocator>
-inline mutable_buffers_1 buffer(std::vector<PodType, Allocator>& data)
-{
-  return mutable_buffers_1(
-      mutable_buffer(data.size() ? &data[0] : 0, data.size() * sizeof(PodType)
-#if defined(ASIO_ENABLE_BUFFER_DEBUGGING)
-        , detail::buffer_debug_check<
-            typename std::vector<PodType, Allocator>::iterator
-          >(data.begin())
-#endif // ASIO_ENABLE_BUFFER_DEBUGGING
-        ));
-}
-
-/// Create a new modifiable buffer that represents the given POD vector.
-/**
- * @returns A mutable_buffers_1 value equivalent to:
- * @code mutable_buffers_1(
- *     data.size() ? &data[0] : 0,
- *     min(data.size() * sizeof(PodType), max_size_in_bytes)); @endcode
- *
- * @note The buffer is invalidated by any vector operation that would also
- * invalidate iterators.
- */
-template <typename PodType, typename Allocator>
-inline mutable_buffers_1 buffer(std::vector<PodType, Allocator>& data,
-    std::size_t max_size_in_bytes)
-{
-  return mutable_buffers_1(
-      mutable_buffer(data.size() ? &data[0] : 0,
-        data.size() * sizeof(PodType) < max_size_in_bytes
-        ? data.size() * sizeof(PodType) : max_size_in_bytes
-#if defined(ASIO_ENABLE_BUFFER_DEBUGGING)
-        , detail::buffer_debug_check<
-            typename std::vector<PodType, Allocator>::iterator
-          >(data.begin())
-#endif // ASIO_ENABLE_BUFFER_DEBUGGING
-        ));
-}
-
-/// Create a new non-modifiable buffer that represents the given POD vector.
-/**
- * @returns A const_buffers_1 value equivalent to:
- * @code const_buffers_1(
- *     data.size() ? &data[0] : 0,
- *     data.size() * sizeof(PodType)); @endcode
- *
- * @note The buffer is invalidated by any vector operation that would also
- * invalidate iterators.
- */
-template <typename PodType, typename Allocator>
-inline const_buffers_1 buffer(
-    const std::vector<PodType, Allocator>& data)
-{
-  return const_buffers_1(
-      const_buffer(data.size() ? &data[0] : 0, data.size() * sizeof(PodType)
-#if defined(ASIO_ENABLE_BUFFER_DEBUGGING)
-        , detail::buffer_debug_check<
-            typename std::vector<PodType, Allocator>::const_iterator
-          >(data.begin())
-#endif // ASIO_ENABLE_BUFFER_DEBUGGING
-        ));
-}
-
-/// Create a new non-modifiable buffer that represents the given POD vector.
-/**
- * @returns A const_buffers_1 value equivalent to:
- * @code const_buffers_1(
- *     data.size() ? &data[0] : 0,
- *     min(data.size() * sizeof(PodType), max_size_in_bytes)); @endcode
- *
- * @note The buffer is invalidated by any vector operation that would also
- * invalidate iterators.
- */
-template <typename PodType, typename Allocator>
-inline const_buffers_1 buffer(
-    const std::vector<PodType, Allocator>& data, std::size_t max_size_in_bytes)
-{
-  return const_buffers_1(
-      const_buffer(data.size() ? &data[0] : 0,
-        data.size() * sizeof(PodType) < max_size_in_bytes
-        ? data.size() * sizeof(PodType) : max_size_in_bytes
-#if defined(ASIO_ENABLE_BUFFER_DEBUGGING)
-        , detail::buffer_debug_check<
-            typename std::vector<PodType, Allocator>::const_iterator
-          >(data.begin())
-#endif // ASIO_ENABLE_BUFFER_DEBUGGING
-        ));
-}
-
-/// Create a new non-modifiable buffer that represents the given string.
-/**
- * @returns <tt>const_buffers_1(data.data(), data.size() * sizeof(Elem))</tt>.
- *
- * @note The buffer is invalidated by any non-const operation called on the
- * given string object.
- */
-template <typename Elem, typename Traits, typename Allocator>
-inline const_buffers_1 buffer(
-    const std::basic_string<Elem, Traits, Allocator>& data)
-{
-  return const_buffers_1(const_buffer(data.data(), data.size() * sizeof(Elem)
-#if defined(ASIO_ENABLE_BUFFER_DEBUGGING)
-        , detail::buffer_debug_check<
-            typename std::basic_string<Elem, Traits, Allocator>::const_iterator
-          >(data.begin())
-#endif // ASIO_ENABLE_BUFFER_DEBUGGING
-        ));
-}
-
-/// Create a new non-modifiable buffer that represents the given string.
-/**
- * @returns A const_buffers_1 value equivalent to:
- * @code const_buffers_1(
- *     data.data(),
- *     min(data.size() * sizeof(Elem), max_size_in_bytes)); @endcode
- *
- * @note The buffer is invalidated by any non-const operation called on the
- * given string object.
- */
-template <typename Elem, typename Traits, typename Allocator>
-inline const_buffers_1 buffer(
-    const std::basic_string<Elem, Traits, Allocator>& data,
-    std::size_t max_size_in_bytes)
-{
-  return const_buffers_1(
-      const_buffer(data.data(),
-        data.size() * sizeof(Elem) < max_size_in_bytes
-        ? data.size() * sizeof(Elem) : max_size_in_bytes
-#if defined(ASIO_ENABLE_BUFFER_DEBUGGING)
-        , detail::buffer_debug_check<
-            typename std::basic_string<Elem, Traits, Allocator>::const_iterator
-          >(data.begin())
-#endif // ASIO_ENABLE_BUFFER_DEBUGGING
-        ));
-}
-
-/*@}*/
-
-/** @defgroup buffer_copy asio::buffer_copy
- *
- * @brief The asio::buffer_copy function is used to copy bytes from a
- * source buffer (or buffer sequence) to a target buffer (or buffer sequence).
- *
- * The @c buffer_copy function is available in two forms:
- *
- * @li A 2-argument form: @c buffer_copy(target, source)
- *
- * @li A 3-argument form: @c buffer_copy(target, source, max_bytes_to_copy)
-
- * Both forms return the number of bytes actually copied. The number of bytes
- * copied is the lesser of:
- *
- * @li @c buffer_size(target)
- *
- * @li @c buffer_size(source)
- *
- * @li @c If specified, @c max_bytes_to_copy.
- *
- * This prevents buffer overflow, regardless of the buffer sizes used in the
- * copy operation.
- *
- * Note that @ref buffer_copy is implemented in terms of @c memcpy, and
- * consequently it cannot be used to copy between overlapping memory regions.
- */
-/*@{*/
-
-/// Copies bytes from a source buffer to a target buffer.
-/**
- * @param target A modifiable buffer representing the memory region to which
- * the bytes will be copied.
- *
- * @param source A non-modifiable buffer representing the memory region from
- * which the bytes will be copied.
- *
- * @returns The number of bytes copied.
- *
- * @note The number of bytes copied is the lesser of:
- *
- * @li @c buffer_size(target)
- *
- * @li @c buffer_size(source)
- *
- * This function is implemented in terms of @c memcpy, and consequently it
- * cannot be used to copy between overlapping memory regions.
- */
-inline std::size_t buffer_copy(const mutable_buffer& target,
-    const const_buffer& source)
-{
-  using namespace std; // For memcpy.
-  std::size_t target_size = buffer_size(target);
-  std::size_t source_size = buffer_size(source);
-  std::size_t n = target_size < source_size ? target_size : source_size;
-  memcpy(buffer_cast<void*>(target), buffer_cast<const void*>(source), n);
-  return n;
-}
-
-/// Copies bytes from a source buffer to a target buffer.
-/**
- * @param target A modifiable buffer representing the memory region to which
- * the bytes will be copied.
- *
- * @param source A non-modifiable buffer representing the memory region from
- * which the bytes will be copied.
- *
- * @returns The number of bytes copied.
- *
- * @note The number of bytes copied is the lesser of:
- *
- * @li @c buffer_size(target)
- *
- * @li @c buffer_size(source)
- *
- * This function is implemented in terms of @c memcpy, and consequently it
- * cannot be used to copy between overlapping memory regions.
- */
-inline std::size_t buffer_copy(const mutable_buffer& target,
-    const const_buffers_1& source)
-{
-  return buffer_copy(target, static_cast<const const_buffer&>(source));
-}
-
-/// Copies bytes from a source buffer to a target buffer.
-/**
- * @param target A modifiable buffer representing the memory region to which
- * the bytes will be copied.
- *
- * @param source A modifiable buffer representing the memory region from which
- * the bytes will be copied. The contents of the source buffer will not be
- * modified.
- *
- * @returns The number of bytes copied.
- *
- * @note The number of bytes copied is the lesser of:
- *
- * @li @c buffer_size(target)
- *
- * @li @c buffer_size(source)
- *
- * This function is implemented in terms of @c memcpy, and consequently it
- * cannot be used to copy between overlapping memory regions.
- */
-inline std::size_t buffer_copy(const mutable_buffer& target,
-    const mutable_buffer& source)
-{
-  return buffer_copy(target, const_buffer(source));
-}
-
-/// Copies bytes from a source buffer to a target buffer.
-/**
- * @param target A modifiable buffer representing the memory region to which
- * the bytes will be copied.
- *
- * @param source A modifiable buffer representing the memory region from which
- * the bytes will be copied. The contents of the source buffer will not be
- * modified.
- *
- * @returns The number of bytes copied.
- *
- * @note The number of bytes copied is the lesser of:
- *
- * @li @c buffer_size(target)
- *
- * @li @c buffer_size(source)
- *
- * This function is implemented in terms of @c memcpy, and consequently it
- * cannot be used to copy between overlapping memory regions.
- */
-inline std::size_t buffer_copy(const mutable_buffer& target,
-    const mutable_buffers_1& source)
-{
-  return buffer_copy(target, const_buffer(source));
-}
-
-/// Copies bytes from a source buffer sequence to a target buffer.
-/**
- * @param target A modifiable buffer representing the memory region to which
- * the bytes will be copied.
- *
- * @param source A non-modifiable buffer sequence representing the memory
- * regions from which the bytes will be copied.
- *
- * @returns The number of bytes copied.
- *
- * @note The number of bytes copied is the lesser of:
- *
- * @li @c buffer_size(target)
- *
- * @li @c buffer_size(source)
- *
- * This function is implemented in terms of @c memcpy, and consequently it
- * cannot be used to copy between overlapping memory regions.
- */
-template <typename ConstBufferSequence>
-std::size_t buffer_copy(const mutable_buffer& target,
-    const ConstBufferSequence& source)
-{
-  std::size_t total_bytes_copied = 0;
-
-  typename ConstBufferSequence::const_iterator source_iter = source.begin();
-  typename ConstBufferSequence::const_iterator source_end = source.end();
-
-  for (mutable_buffer target_buffer(target);
-      buffer_size(target_buffer) && source_iter != source_end; ++source_iter)
-  {
-    const_buffer source_buffer(*source_iter);
-    std::size_t bytes_copied = buffer_copy(target_buffer, source_buffer);
-    total_bytes_copied += bytes_copied;
-    target_buffer = target_buffer + bytes_copied;
-  }
-
-  return total_bytes_copied;
-}
-
-/// Copies bytes from a source buffer to a target buffer.
-/**
- * @param target A modifiable buffer representing the memory region to which
- * the bytes will be copied.
- *
- * @param source A non-modifiable buffer representing the memory region from
- * which the bytes will be copied.
- *
- * @returns The number of bytes copied.
- *
- * @note The number of bytes copied is the lesser of:
- *
- * @li @c buffer_size(target)
- *
- * @li @c buffer_size(source)
- *
- * This function is implemented in terms of @c memcpy, and consequently it
- * cannot be used to copy between overlapping memory regions.
- */
-inline std::size_t buffer_copy(const mutable_buffers_1& target,
-    const const_buffer& source)
-{
-  return buffer_copy(static_cast<const mutable_buffer&>(target), source);
-}
-
-/// Copies bytes from a source buffer to a target buffer.
-/**
- * @param target A modifiable buffer representing the memory region to which
- * the bytes will be copied.
- *
- * @param source A non-modifiable buffer representing the memory region from
- * which the bytes will be copied.
- *
- * @returns The number of bytes copied.
- *
- * @note The number of bytes copied is the lesser of:
- *
- * @li @c buffer_size(target)
- *
- * @li @c buffer_size(source)
- *
- * This function is implemented in terms of @c memcpy, and consequently it
- * cannot be used to copy between overlapping memory regions.
- */
-inline std::size_t buffer_copy(const mutable_buffers_1& target,
-    const const_buffers_1& source)
-{
-  return buffer_copy(static_cast<const mutable_buffer&>(target),
-      static_cast<const const_buffer&>(source));
-}
-
-/// Copies bytes from a source buffer to a target buffer.
-/**
- * @param target A modifiable buffer representing the memory region to which
- * the bytes will be copied.
- *
- * @param source A modifiable buffer representing the memory region from which
- * the bytes will be copied. The contents of the source buffer will not be
- * modified.
- *
- * @returns The number of bytes copied.
- *
- * @note The number of bytes copied is the lesser of:
- *
- * @li @c buffer_size(target)
- *
- * @li @c buffer_size(source)
- *
- * This function is implemented in terms of @c memcpy, and consequently it
- * cannot be used to copy between overlapping memory regions.
- */
-inline std::size_t buffer_copy(const mutable_buffers_1& target,
-    const mutable_buffer& source)
-{
-  return buffer_copy(static_cast<const mutable_buffer&>(target),
-      const_buffer(source));
-}
-
-/// Copies bytes from a source buffer to a target buffer.
-/**
- * @param target A modifiable buffer representing the memory region to which
- * the bytes will be copied.
- *
- * @param source A modifiable buffer representing the memory region from which
- * the bytes will be copied. The contents of the source buffer will not be
- * modified.
- *
- * @returns The number of bytes copied.
- *
- * @note The number of bytes copied is the lesser of:
- *
- * @li @c buffer_size(target)
- *
- * @li @c buffer_size(source)
- *
- * This function is implemented in terms of @c memcpy, and consequently it
- * cannot be used to copy between overlapping memory regions.
- */
-inline std::size_t buffer_copy(const mutable_buffers_1& target,
-    const mutable_buffers_1& source)
-{
-  return buffer_copy(static_cast<const mutable_buffer&>(target),
-      const_buffer(source));
-}
-
-/// Copies bytes from a source buffer sequence to a target buffer.
-/**
- * @param target A modifiable buffer representing the memory region to which
- * the bytes will be copied.
- *
- * @param source A non-modifiable buffer sequence representing the memory
- * regions from which the bytes will be copied.
- *
- * @returns The number of bytes copied.
- *
- * @note The number of bytes copied is the lesser of:
- *
- * @li @c buffer_size(target)
- *
- * @li @c buffer_size(source)
- *
- * This function is implemented in terms of @c memcpy, and consequently it
- * cannot be used to copy between overlapping memory regions.
- */
-template <typename ConstBufferSequence>
-inline std::size_t buffer_copy(const mutable_buffers_1& target,
-    const ConstBufferSequence& source)
-{
-  return buffer_copy(static_cast<const mutable_buffer&>(target), source);
-}
-
-/// Copies bytes from a source buffer to a target buffer sequence.
-/**
- * @param target A modifiable buffer sequence representing the memory regions to
- * which the bytes will be copied.
- *
- * @param source A non-modifiable buffer representing the memory region from
- * which the bytes will be copied.
- *
- * @returns The number of bytes copied.
- *
- * @note The number of bytes copied is the lesser of:
- *
- * @li @c buffer_size(target)
- *
- * @li @c buffer_size(source)
- *
- * This function is implemented in terms of @c memcpy, and consequently it
- * cannot be used to copy between overlapping memory regions.
- */
-template <typename MutableBufferSequence>
-std::size_t buffer_copy(const MutableBufferSequence& target,
-    const const_buffer& source)
-{
-  std::size_t total_bytes_copied = 0;
-
-  typename MutableBufferSequence::const_iterator target_iter = target.begin();
-  typename MutableBufferSequence::const_iterator target_end = target.end();
-
-  for (const_buffer source_buffer(source);
-      buffer_size(source_buffer) && target_iter != target_end; ++target_iter)
-  {
-    mutable_buffer target_buffer(*target_iter);
-    std::size_t bytes_copied = buffer_copy(target_buffer, source_buffer);
-    total_bytes_copied += bytes_copied;
-    source_buffer = source_buffer + bytes_copied;
-  }
-
-  return total_bytes_copied;
-}
-
-/// Copies bytes from a source buffer to a target buffer sequence.
-/**
- * @param target A modifiable buffer sequence representing the memory regions to
- * which the bytes will be copied.
- *
- * @param source A non-modifiable buffer representing the memory region from
- * which the bytes will be copied.
- *
- * @returns The number of bytes copied.
- *
- * @note The number of bytes copied is the lesser of:
- *
- * @li @c buffer_size(target)
- *
- * @li @c buffer_size(source)
- *
- * This function is implemented in terms of @c memcpy, and consequently it
- * cannot be used to copy between overlapping memory regions.
- */
-template <typename MutableBufferSequence>
-inline std::size_t buffer_copy(const MutableBufferSequence& target,
-    const const_buffers_1& source)
-{
-  return buffer_copy(target, static_cast<const const_buffer&>(source));
-}
-
-/// Copies bytes from a source buffer to a target buffer sequence.
-/**
- * @param target A modifiable buffer sequence representing the memory regions to
- * which the bytes will be copied.
- *
- * @param source A modifiable buffer representing the memory region from which
- * the bytes will be copied. The contents of the source buffer will not be
- * modified.
- *
- * @returns The number of bytes copied.
- *
- * @note The number of bytes copied is the lesser of:
- *
- * @li @c buffer_size(target)
- *
- * @li @c buffer_size(source)
- *
- * This function is implemented in terms of @c memcpy, and consequently it
- * cannot be used to copy between overlapping memory regions.
- */
-template <typename MutableBufferSequence>
-inline std::size_t buffer_copy(const MutableBufferSequence& target,
-    const mutable_buffer& source)
-{
-  return buffer_copy(target, const_buffer(source));
-}
-
-/// Copies bytes from a source buffer to a target buffer sequence.
-/**
- * @param target A modifiable buffer sequence representing the memory regions to
- * which the bytes will be copied.
- *
- * @param source A modifiable buffer representing the memory region from which
- * the bytes will be copied. The contents of the source buffer will not be
- * modified.
- *
- * @returns The number of bytes copied.
- *
- * @note The number of bytes copied is the lesser of:
- *
- * @li @c buffer_size(target)
- *
- * @li @c buffer_size(source)
- *
- * This function is implemented in terms of @c memcpy, and consequently it
- * cannot be used to copy between overlapping memory regions.
- */
-template <typename MutableBufferSequence>
-inline std::size_t buffer_copy(const MutableBufferSequence& target,
-    const mutable_buffers_1& source)
-{
-  return buffer_copy(target, const_buffer(source));
-}
-
-/// Copies bytes from a source buffer sequence to a target buffer sequence.
-/**
- * @param target A modifiable buffer sequence representing the memory regions to
- * which the bytes will be copied.
- *
- * @param source A non-modifiable buffer sequence representing the memory
- * regions from which the bytes will be copied.
- *
- * @returns The number of bytes copied.
- *
- * @note The number of bytes copied is the lesser of:
- *
- * @li @c buffer_size(target)
- *
- * @li @c buffer_size(source)
- *
- * This function is implemented in terms of @c memcpy, and consequently it
- * cannot be used to copy between overlapping memory regions.
- */
-template <typename MutableBufferSequence, typename ConstBufferSequence>
-std::size_t buffer_copy(const MutableBufferSequence& target,
-    const ConstBufferSequence& source)
-{
-  std::size_t total_bytes_copied = 0;
-
-  typename MutableBufferSequence::const_iterator target_iter = target.begin();
-  typename MutableBufferSequence::const_iterator target_end = target.end();
-  std::size_t target_buffer_offset = 0;
-
-  typename ConstBufferSequence::const_iterator source_iter = source.begin();
-  typename ConstBufferSequence::const_iterator source_end = source.end();
-  std::size_t source_buffer_offset = 0;
-
-  while (target_iter != target_end && source_iter != source_end)
-  {
-    mutable_buffer target_buffer =
-      mutable_buffer(*target_iter) + target_buffer_offset;
-
-    const_buffer source_buffer =
-      const_buffer(*source_iter) + source_buffer_offset;
-
-    std::size_t bytes_copied = buffer_copy(target_buffer, source_buffer);
-    total_bytes_copied += bytes_copied;
-
-    if (bytes_copied == buffer_size(target_buffer))
-    {
-      ++target_iter;
-      target_buffer_offset = 0;
-    }
-    else
-      target_buffer_offset += bytes_copied;
-
-    if (bytes_copied == buffer_size(source_buffer))
-    {
-      ++source_iter;
-      source_buffer_offset = 0;
-    }
-    else
-      source_buffer_offset += bytes_copied;
-  }
-
-  return total_bytes_copied;
-}
-
-/// Copies a limited number of bytes from a source buffer to a target buffer.
-/**
- * @param target A modifiable buffer representing the memory region to which
- * the bytes will be copied.
- *
- * @param source A non-modifiable buffer representing the memory region from
- * which the bytes will be copied.
- *
- * @param max_bytes_to_copy The maximum number of bytes to be copied.
- *
- * @returns The number of bytes copied.
- *
- * @note The number of bytes copied is the lesser of:
- *
- * @li @c buffer_size(target)
- *
- * @li @c buffer_size(source)
- *
- * @li @c max_bytes_to_copy
- *
- * This function is implemented in terms of @c memcpy, and consequently it
- * cannot be used to copy between overlapping memory regions.
- */
-inline std::size_t buffer_copy(const mutable_buffer& target,
-    const const_buffer& source, std::size_t max_bytes_to_copy)
-{
-  return buffer_copy(buffer(target, max_bytes_to_copy), source);
-}
-
-/// Copies a limited number of bytes from a source buffer to a target buffer.
-/**
- * @param target A modifiable buffer representing the memory region to which
- * the bytes will be copied.
- *
- * @param source A non-modifiable buffer representing the memory region from
- * which the bytes will be copied.
- *
- * @param max_bytes_to_copy The maximum number of bytes to be copied.
- *
- * @returns The number of bytes copied.
- *
- * @note The number of bytes copied is the lesser of:
- *
- * @li @c buffer_size(target)
- *
- * @li @c buffer_size(source)
- *
- * @li @c max_bytes_to_copy
- *
- * This function is implemented in terms of @c memcpy, and consequently it
- * cannot be used to copy between overlapping memory regions.
- */
-inline std::size_t buffer_copy(const mutable_buffer& target,
-    const const_buffers_1& source, std::size_t max_bytes_to_copy)
-{
-  return buffer_copy(buffer(target, max_bytes_to_copy), source);
-}
-
-/// Copies a limited number of bytes from a source buffer to a target buffer.
-/**
- * @param target A modifiable buffer representing the memory region to which
- * the bytes will be copied.
- *
- * @param source A modifiable buffer representing the memory region from which
- * the bytes will be copied. The contents of the source buffer will not be
- * modified.
- *
- * @param max_bytes_to_copy The maximum number of bytes to be copied.
- *
- * @returns The number of bytes copied.
- *
- * @note The number of bytes copied is the lesser of:
- *
- * @li @c buffer_size(target)
- *
- * @li @c buffer_size(source)
- *
- * @li @c max_bytes_to_copy
- *
- * This function is implemented in terms of @c memcpy, and consequently it
- * cannot be used to copy between overlapping memory regions.
- */
-inline std::size_t buffer_copy(const mutable_buffer& target,
-    const mutable_buffer& source, std::size_t max_bytes_to_copy)
-{
-  return buffer_copy(buffer(target, max_bytes_to_copy), source);
-}
-
-/// Copies a limited number of bytes from a source buffer to a target buffer.
-/**
- * @param target A modifiable buffer representing the memory region to which
- * the bytes will be copied.
- *
- * @param source A modifiable buffer representing the memory region from which
- * the bytes will be copied. The contents of the source buffer will not be
- * modified.
- *
- * @param max_bytes_to_copy The maximum number of bytes to be copied.
- *
- * @returns The number of bytes copied.
- *
- * @note The number of bytes copied is the lesser of:
- *
- * @li @c buffer_size(target)
- *
- * @li @c buffer_size(source)
- *
- * @li @c max_bytes_to_copy
- *
- * This function is implemented in terms of @c memcpy, and consequently it
- * cannot be used to copy between overlapping memory regions.
- */
-inline std::size_t buffer_copy(const mutable_buffer& target,
-    const mutable_buffers_1& source, std::size_t max_bytes_to_copy)
-{
-  return buffer_copy(buffer(target, max_bytes_to_copy), source);
-}
-
-/// Copies a limited number of bytes from a source buffer sequence to a target
-/// buffer.
-/**
- * @param target A modifiable buffer representing the memory region to which
- * the bytes will be copied.
- *
- * @param source A non-modifiable buffer sequence representing the memory
- * regions from which the bytes will be copied.
- *
- * @param max_bytes_to_copy The maximum number of bytes to be copied.
- *
- * @returns The number of bytes copied.
- *
- * @note The number of bytes copied is the lesser of:
- *
- * @li @c buffer_size(target)
- *
- * @li @c buffer_size(source)
- *
- * @li @c max_bytes_to_copy
- *
- * This function is implemented in terms of @c memcpy, and consequently it
- * cannot be used to copy between overlapping memory regions.
- */
-template <typename ConstBufferSequence>
-inline std::size_t buffer_copy(const mutable_buffer& target,
-    const ConstBufferSequence& source, std::size_t max_bytes_to_copy)
-{
-  return buffer_copy(buffer(target, max_bytes_to_copy), source);
-}
-
-/// Copies a limited number of bytes from a source buffer to a target buffer.
-/**
- * @param target A modifiable buffer representing the memory region to which
- * the bytes will be copied.
- *
- * @param source A non-modifiable buffer representing the memory region from
- * which the bytes will be copied.
- *
- * @param max_bytes_to_copy The maximum number of bytes to be copied.
- *
- * @returns The number of bytes copied.
- *
- * @note The number of bytes copied is the lesser of:
- *
- * @li @c buffer_size(target)
- *
- * @li @c buffer_size(source)
- *
- * @li @c max_bytes_to_copy
- *
- * This function is implemented in terms of @c memcpy, and consequently it
- * cannot be used to copy between overlapping memory regions.
- */
-inline std::size_t buffer_copy(const mutable_buffers_1& target,
-    const const_buffer& source, std::size_t max_bytes_to_copy)
-{
-  return buffer_copy(buffer(target, max_bytes_to_copy), source);
-}
-
-/// Copies a limited number of bytes from a source buffer to a target buffer.
-/**
- * @param target A modifiable buffer representing the memory region to which
- * the bytes will be copied.
- *
- * @param source A non-modifiable buffer representing the memory region from
- * which the bytes will be copied.
- *
- * @param max_bytes_to_copy The maximum number of bytes to be copied.
- *
- * @returns The number of bytes copied.
- *
- * @note The number of bytes copied is the lesser of:
- *
- * @li @c buffer_size(target)
- *
- * @li @c buffer_size(source)
- *
- * @li @c max_bytes_to_copy
- *
- * This function is implemented in terms of @c memcpy, and consequently it
- * cannot be used to copy between overlapping memory regions.
- */
-inline std::size_t buffer_copy(const mutable_buffers_1& target,
-    const const_buffers_1& source, std::size_t max_bytes_to_copy)
-{
-  return buffer_copy(buffer(target, max_bytes_to_copy), source);
-}
-
-/// Copies a limited number of bytes from a source buffer to a target buffer.
-/**
- * @param target A modifiable buffer representing the memory region to which
- * the bytes will be copied.
- *
- * @param source A modifiable buffer representing the memory region from which
- * the bytes will be copied. The contents of the source buffer will not be
- * modified.
- *
- * @param max_bytes_to_copy The maximum number of bytes to be copied.
- *
- * @returns The number of bytes copied.
- *
- * @note The number of bytes copied is the lesser of:
- *
- * @li @c buffer_size(target)
- *
- * @li @c buffer_size(source)
- *
- * @li @c max_bytes_to_copy
- *
- * This function is implemented in terms of @c memcpy, and consequently it
- * cannot be used to copy between overlapping memory regions.
- */
-inline std::size_t buffer_copy(const mutable_buffers_1& target,
-    const mutable_buffer& source, std::size_t max_bytes_to_copy)
-{
-  return buffer_copy(buffer(target, max_bytes_to_copy), source);
-}
-
-/// Copies a limited number of bytes from a source buffer to a target buffer.
-/**
- * @param target A modifiable buffer representing the memory region to which
- * the bytes will be copied.
- *
- * @param source A modifiable buffer representing the memory region from which
- * the bytes will be copied. The contents of the source buffer will not be
- * modified.
- *
- * @param max_bytes_to_copy The maximum number of bytes to be copied.
- *
- * @returns The number of bytes copied.
- *
- * @note The number of bytes copied is the lesser of:
- *
- * @li @c buffer_size(target)
- *
- * @li @c buffer_size(source)
- *
- * @li @c max_bytes_to_copy
- *
- * This function is implemented in terms of @c memcpy, and consequently it
- * cannot be used to copy between overlapping memory regions.
- */
-inline std::size_t buffer_copy(const mutable_buffers_1& target,
-    const mutable_buffers_1& source, std::size_t max_bytes_to_copy)
-{
-  return buffer_copy(buffer(target, max_bytes_to_copy), source);
-}
-
-/// Copies a limited number of bytes from a source buffer sequence to a target
-/// buffer.
-/**
- * @param target A modifiable buffer representing the memory region to which
- * the bytes will be copied.
- *
- * @param source A non-modifiable buffer sequence representing the memory
- * regions from which the bytes will be copied.
- *
- * @param max_bytes_to_copy The maximum number of bytes to be copied.
- *
- * @returns The number of bytes copied.
- *
- * @note The number of bytes copied is the lesser of:
- *
- * @li @c buffer_size(target)
- *
- * @li @c buffer_size(source)
- *
- * @li @c max_bytes_to_copy
- *
- * This function is implemented in terms of @c memcpy, and consequently it
- * cannot be used to copy between overlapping memory regions.
- */
-template <typename ConstBufferSequence>
-inline std::size_t buffer_copy(const mutable_buffers_1& target,
-    const ConstBufferSequence& source, std::size_t max_bytes_to_copy)
-{
-  return buffer_copy(buffer(target, max_bytes_to_copy), source);
-}
-
-/// Copies a limited number of bytes from a source buffer to a target buffer
-/// sequence.
-/**
- * @param target A modifiable buffer sequence representing the memory regions to
- * which the bytes will be copied.
- *
- * @param source A non-modifiable buffer representing the memory region from
- * which the bytes will be copied.
- *
- * @param max_bytes_to_copy The maximum number of bytes to be copied.
- *
- * @returns The number of bytes copied.
- *
- * @note The number of bytes copied is the lesser of:
- *
- * @li @c buffer_size(target)
- *
- * @li @c buffer_size(source)
- *
- * @li @c max_bytes_to_copy
- *
- * This function is implemented in terms of @c memcpy, and consequently it
- * cannot be used to copy between overlapping memory regions.
- */
-template <typename MutableBufferSequence>
-inline std::size_t buffer_copy(const MutableBufferSequence& target,
-    const const_buffer& source, std::size_t max_bytes_to_copy)
-{
-  return buffer_copy(target, buffer(source, max_bytes_to_copy));
-}
-
-/// Copies a limited number of bytes from a source buffer to a target buffer
-/// sequence.
-/**
- * @param target A modifiable buffer sequence representing the memory regions to
- * which the bytes will be copied.
- *
- * @param source A non-modifiable buffer representing the memory region from
- * which the bytes will be copied.
- *
- * @param max_bytes_to_copy The maximum number of bytes to be copied.
- *
- * @returns The number of bytes copied.
- *
- * @note The number of bytes copied is the lesser of:
- *
- * @li @c buffer_size(target)
- *
- * @li @c buffer_size(source)
- *
- * @li @c max_bytes_to_copy
- *
- * This function is implemented in terms of @c memcpy, and consequently it
- * cannot be used to copy between overlapping memory regions.
- */
-template <typename MutableBufferSequence>
-inline std::size_t buffer_copy(const MutableBufferSequence& target,
-    const const_buffers_1& source, std::size_t max_bytes_to_copy)
-{
-  return buffer_copy(target, buffer(source, max_bytes_to_copy));
-}
-
-/// Copies a limited number of bytes from a source buffer to a target buffer
-/// sequence.
-/**
- * @param target A modifiable buffer sequence representing the memory regions to
- * which the bytes will be copied.
- *
- * @param source A modifiable buffer representing the memory region from which
- * the bytes will be copied. The contents of the source buffer will not be
- * modified.
- *
- * @param max_bytes_to_copy The maximum number of bytes to be copied.
- *
- * @returns The number of bytes copied.
- *
- * @note The number of bytes copied is the lesser of:
- *
- * @li @c buffer_size(target)
- *
- * @li @c buffer_size(source)
- *
- * @li @c max_bytes_to_copy
- *
- * This function is implemented in terms of @c memcpy, and consequently it
- * cannot be used to copy between overlapping memory regions.
- */
-template <typename MutableBufferSequence>
-inline std::size_t buffer_copy(const MutableBufferSequence& target,
-    const mutable_buffer& source, std::size_t max_bytes_to_copy)
-{
-  return buffer_copy(target, buffer(source, max_bytes_to_copy));
-}
-
-/// Copies a limited number of bytes from a source buffer to a target buffer
-/// sequence.
-/**
- * @param target A modifiable buffer sequence representing the memory regions to
- * which the bytes will be copied.
- *
- * @param source A modifiable buffer representing the memory region from which
- * the bytes will be copied. The contents of the source buffer will not be
- * modified.
- *
- * @param max_bytes_to_copy The maximum number of bytes to be copied.
- *
- * @returns The number of bytes copied.
- *
- * @note The number of bytes copied is the lesser of:
- *
- * @li @c buffer_size(target)
- *
- * @li @c buffer_size(source)
- *
- * @li @c max_bytes_to_copy
- *
- * This function is implemented in terms of @c memcpy, and consequently it
- * cannot be used to copy between overlapping memory regions.
- */
-template <typename MutableBufferSequence>
-inline std::size_t buffer_copy(const MutableBufferSequence& target,
-    const mutable_buffers_1& source, std::size_t max_bytes_to_copy)
-{
-  return buffer_copy(target, buffer(source, max_bytes_to_copy));
-}
-
-/// Copies a limited number of bytes from a source buffer sequence to a target
-/// buffer sequence.
-/**
- * @param target A modifiable buffer sequence representing the memory regions to
- * which the bytes will be copied.
- *
- * @param source A non-modifiable buffer sequence representing the memory
- * regions from which the bytes will be copied.
- *
- * @param max_bytes_to_copy The maximum number of bytes to be copied.
- *
- * @returns The number of bytes copied.
- *
- * @note The number of bytes copied is the lesser of:
- *
- * @li @c buffer_size(target)
- *
- * @li @c buffer_size(source)
- *
- * @li @c max_bytes_to_copy
- *
- * This function is implemented in terms of @c memcpy, and consequently it
- * cannot be used to copy between overlapping memory regions.
- */
-template <typename MutableBufferSequence, typename ConstBufferSequence>
-std::size_t buffer_copy(const MutableBufferSequence& target,
-    const ConstBufferSequence& source, std::size_t max_bytes_to_copy)
-{
-  std::size_t total_bytes_copied = 0;
-
-  typename MutableBufferSequence::const_iterator target_iter = target.begin();
-  typename MutableBufferSequence::const_iterator target_end = target.end();
-  std::size_t target_buffer_offset = 0;
-
-  typename ConstBufferSequence::const_iterator source_iter = source.begin();
-  typename ConstBufferSequence::const_iterator source_end = source.end();
-  std::size_t source_buffer_offset = 0;
-
-  while (total_bytes_copied != max_bytes_to_copy
-      && target_iter != target_end && source_iter != source_end)
-  {
-    mutable_buffer target_buffer =
-      mutable_buffer(*target_iter) + target_buffer_offset;
-
-    const_buffer source_buffer =
-      const_buffer(*source_iter) + source_buffer_offset;
-
-    std::size_t bytes_copied = buffer_copy(target_buffer,
-        source_buffer, max_bytes_to_copy - total_bytes_copied);
-    total_bytes_copied += bytes_copied;
-
-    if (bytes_copied == buffer_size(target_buffer))
-    {
-      ++target_iter;
-      target_buffer_offset = 0;
-    }
-    else
-      target_buffer_offset += bytes_copied;
-
-    if (bytes_copied == buffer_size(source_buffer))
-    {
-      ++source_iter;
-      source_buffer_offset = 0;
-    }
-    else
-      source_buffer_offset += bytes_copied;
-  }
-
-  return total_bytes_copied;
-}
-
-/*@}*/
-
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_BUFFER_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/buffered_read_stream.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/buffered_read_stream.hpp
deleted file mode 100644
index 15e6cffe9dd1..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/buffered_read_stream.hpp
+++ /dev/null
@@ -1,244 +0,0 @@
-//
-// buffered_read_stream.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_BUFFERED_READ_STREAM_HPP
-#define ASIO_BUFFERED_READ_STREAM_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include <cstddef>
-#include "asio/async_result.hpp"
-#include "asio/buffered_read_stream_fwd.hpp"
-#include "asio/buffer.hpp"
-#include "asio/detail/bind_handler.hpp"
-#include "asio/detail/buffer_resize_guard.hpp"
-#include "asio/detail/buffered_stream_storage.hpp"
-#include "asio/detail/noncopyable.hpp"
-#include "asio/detail/type_traits.hpp"
-#include "asio/error.hpp"
-#include "asio/io_service.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-
-/// Adds buffering to the read-related operations of a stream.
-/**
- * The buffered_read_stream class template can be used to add buffering to the
- * synchronous and asynchronous read operations of a stream.
- *
- * @par Thread Safety
- * @e Distinct @e objects: Safe.@n
- * @e Shared @e objects: Unsafe.
- *
- * @par Concepts:
- * AsyncReadStream, AsyncWriteStream, Stream, SyncReadStream, SyncWriteStream.
- */
-template <typename Stream>
-class buffered_read_stream
-  : private noncopyable
-{
-public:
-  /// The type of the next layer.
-  typedef typename remove_reference<Stream>::type next_layer_type;
-
-  /// The type of the lowest layer.
-  typedef typename next_layer_type::lowest_layer_type lowest_layer_type;
-
-#if defined(GENERATING_DOCUMENTATION)
-  /// The default buffer size.
-  static const std::size_t default_buffer_size = implementation_defined;
-#else
-  ASIO_STATIC_CONSTANT(std::size_t, default_buffer_size = 1024);
-#endif
-
-  /// Construct, passing the specified argument to initialise the next layer.
-  template <typename Arg>
-  explicit buffered_read_stream(Arg& a)
-    : next_layer_(a),
-      storage_(default_buffer_size)
-  {
-  }
-
-  /// Construct, passing the specified argument to initialise the next layer.
-  template <typename Arg>
-  buffered_read_stream(Arg& a, std::size_t buffer_size)
-    : next_layer_(a),
-      storage_(buffer_size)
-  {
-  }
-
-  /// Get a reference to the next layer.
-  next_layer_type& next_layer()
-  {
-    return next_layer_;
-  }
-
-  /// Get a reference to the lowest layer.
-  lowest_layer_type& lowest_layer()
-  {
-    return next_layer_.lowest_layer();
-  }
-
-  /// Get a const reference to the lowest layer.
-  const lowest_layer_type& lowest_layer() const
-  {
-    return next_layer_.lowest_layer();
-  }
-
-  /// Get the io_service associated with the object.
-  asio::io_service& get_io_service()
-  {
-    return next_layer_.get_io_service();
-  }
-
-  /// Close the stream.
-  void close()
-  {
-    next_layer_.close();
-  }
-
-  /// Close the stream.
-  asio::error_code close(asio::error_code& ec)
-  {
-    return next_layer_.close(ec);
-  }
-
-  /// Write the given data to the stream. Returns the number of bytes written.
-  /// Throws an exception on failure.
-  template <typename ConstBufferSequence>
-  std::size_t write_some(const ConstBufferSequence& buffers)
-  {
-    return next_layer_.write_some(buffers);
-  }
-
-  /// Write the given data to the stream. Returns the number of bytes written,
-  /// or 0 if an error occurred.
-  template <typename ConstBufferSequence>
-  std::size_t write_some(const ConstBufferSequence& buffers,
-      asio::error_code& ec)
-  {
-    return next_layer_.write_some(buffers, ec);
-  }
-
-  /// Start an asynchronous write. The data being written must be valid for the
-  /// lifetime of the asynchronous operation.
-  template <typename ConstBufferSequence, typename WriteHandler>
-  ASIO_INITFN_RESULT_TYPE(WriteHandler,
-      void (asio::error_code, std::size_t))
-  async_write_some(const ConstBufferSequence& buffers,
-      ASIO_MOVE_ARG(WriteHandler) handler)
-  {
-    detail::async_result_init<
-      WriteHandler, void (asio::error_code, std::size_t)> init(
-        ASIO_MOVE_CAST(WriteHandler)(handler));
-
-    next_layer_.async_write_some(buffers,
-        ASIO_MOVE_CAST(ASIO_HANDLER_TYPE(WriteHandler,
-            void (asio::error_code, std::size_t)))(init.handler));
-
-    return init.result.get();
-  }
-
-  /// Fill the buffer with some data. Returns the number of bytes placed in the
-  /// buffer as a result of the operation. Throws an exception on failure.
-  std::size_t fill();
-
-  /// Fill the buffer with some data. Returns the number of bytes placed in the
-  /// buffer as a result of the operation, or 0 if an error occurred.
-  std::size_t fill(asio::error_code& ec);
-
-  /// Start an asynchronous fill.
-  template <typename ReadHandler>
-  ASIO_INITFN_RESULT_TYPE(ReadHandler,
-      void (asio::error_code, std::size_t))
-  async_fill(ASIO_MOVE_ARG(ReadHandler) handler);
-
-  /// Read some data from the stream. Returns the number of bytes read. Throws
-  /// an exception on failure.
-  template <typename MutableBufferSequence>
-  std::size_t read_some(const MutableBufferSequence& buffers);
-
-  /// Read some data from the stream. Returns the number of bytes read or 0 if
-  /// an error occurred.
-  template <typename MutableBufferSequence>
-  std::size_t read_some(const MutableBufferSequence& buffers,
-      asio::error_code& ec);
-
-  /// Start an asynchronous read. The buffer into which the data will be read
-  /// must be valid for the lifetime of the asynchronous operation.
-  template <typename MutableBufferSequence, typename ReadHandler>
-  ASIO_INITFN_RESULT_TYPE(ReadHandler,
-      void (asio::error_code, std::size_t))
-  async_read_some(const MutableBufferSequence& buffers,
-      ASIO_MOVE_ARG(ReadHandler) handler);
-
-  /// Peek at the incoming data on the stream. Returns the number of bytes read.
-  /// Throws an exception on failure.
-  template <typename MutableBufferSequence>
-  std::size_t peek(const MutableBufferSequence& buffers);
-
-  /// Peek at the incoming data on the stream. Returns the number of bytes read,
-  /// or 0 if an error occurred.
-  template <typename MutableBufferSequence>
-  std::size_t peek(const MutableBufferSequence& buffers,
-      asio::error_code& ec);
-
-  /// Determine the amount of data that may be read without blocking.
-  std::size_t in_avail()
-  {
-    return storage_.size();
-  }
-
-  /// Determine the amount of data that may be read without blocking.
-  std::size_t in_avail(asio::error_code& ec)
-  {
-    ec = asio::error_code();
-    return storage_.size();
-  }
-
-private:
-  /// Copy data out of the internal buffer to the specified target buffer.
-  /// Returns the number of bytes copied.
-  template <typename MutableBufferSequence>
-  std::size_t copy(const MutableBufferSequence& buffers)
-  {
-    std::size_t bytes_copied = asio::buffer_copy(
-        buffers, storage_.data(), storage_.size());
-    storage_.consume(bytes_copied);
-    return bytes_copied;
-  }
-
-  /// Copy data from the internal buffer to the specified target buffer, without
-  /// removing the data from the internal buffer. Returns the number of bytes
-  /// copied.
-  template <typename MutableBufferSequence>
-  std::size_t peek_copy(const MutableBufferSequence& buffers)
-  {
-    return asio::buffer_copy(buffers, storage_.data(), storage_.size());
-  }
-
-  /// The next layer.
-  Stream next_layer_;
-
-  // The data in the buffer.
-  detail::buffered_stream_storage storage_;
-};
-
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#include "asio/impl/buffered_read_stream.hpp"
-
-#endif // ASIO_BUFFERED_READ_STREAM_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/buffered_read_stream_fwd.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/buffered_read_stream_fwd.hpp
deleted file mode 100644
index 9bac6345a232..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/buffered_read_stream_fwd.hpp
+++ /dev/null
@@ -1,25 +0,0 @@
-//
-// buffered_read_stream_fwd.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_BUFFERED_READ_STREAM_FWD_HPP
-#define ASIO_BUFFERED_READ_STREAM_FWD_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-namespace asio {
-
-template <typename Stream>
-class buffered_read_stream;
-
-} // namespace asio
-
-#endif // ASIO_BUFFERED_READ_STREAM_FWD_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/buffered_stream.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/buffered_stream.hpp
deleted file mode 100644
index 0516090e56d2..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/buffered_stream.hpp
+++ /dev/null
@@ -1,258 +0,0 @@
-//
-// buffered_stream.hpp
-// ~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_BUFFERED_STREAM_HPP
-#define ASIO_BUFFERED_STREAM_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include <cstddef>
-#include "asio/async_result.hpp"
-#include "asio/buffered_read_stream.hpp"
-#include "asio/buffered_write_stream.hpp"
-#include "asio/buffered_stream_fwd.hpp"
-#include "asio/detail/noncopyable.hpp"
-#include "asio/error.hpp"
-#include "asio/io_service.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-
-/// Adds buffering to the read- and write-related operations of a stream.
-/**
- * The buffered_stream class template can be used to add buffering to the
- * synchronous and asynchronous read and write operations of a stream.
- *
- * @par Thread Safety
- * @e Distinct @e objects: Safe.@n
- * @e Shared @e objects: Unsafe.
- *
- * @par Concepts:
- * AsyncReadStream, AsyncWriteStream, Stream, SyncReadStream, SyncWriteStream.
- */
-template <typename Stream>
-class buffered_stream
-  : private noncopyable
-{
-public:
-  /// The type of the next layer.
-  typedef typename remove_reference<Stream>::type next_layer_type;
-
-  /// The type of the lowest layer.
-  typedef typename next_layer_type::lowest_layer_type lowest_layer_type;
-
-  /// Construct, passing the specified argument to initialise the next layer.
-  template <typename Arg>
-  explicit buffered_stream(Arg& a)
-    : inner_stream_impl_(a),
-      stream_impl_(inner_stream_impl_)
-  {
-  }
-
-  /// Construct, passing the specified argument to initialise the next layer.
-  template <typename Arg>
-  explicit buffered_stream(Arg& a, std::size_t read_buffer_size,
-      std::size_t write_buffer_size)
-    : inner_stream_impl_(a, write_buffer_size),
-      stream_impl_(inner_stream_impl_, read_buffer_size)
-  {
-  }
-
-  /// Get a reference to the next layer.
-  next_layer_type& next_layer()
-  {
-    return stream_impl_.next_layer().next_layer();
-  }
-
-  /// Get a reference to the lowest layer.
-  lowest_layer_type& lowest_layer()
-  {
-    return stream_impl_.lowest_layer();
-  }
-
-  /// Get a const reference to the lowest layer.
-  const lowest_layer_type& lowest_layer() const
-  {
-    return stream_impl_.lowest_layer();
-  }
-
-  /// Get the io_service associated with the object.
-  asio::io_service& get_io_service()
-  {
-    return stream_impl_.get_io_service();
-  }
-
-  /// Close the stream.
-  void close()
-  {
-    stream_impl_.close();
-  }
-
-  /// Close the stream.
-  asio::error_code close(asio::error_code& ec)
-  {
-    return stream_impl_.close(ec);
-  }
-
-  /// Flush all data from the buffer to the next layer. Returns the number of
-  /// bytes written to the next layer on the last write operation. Throws an
-  /// exception on failure.
-  std::size_t flush()
-  {
-    return stream_impl_.next_layer().flush();
-  }
-
-  /// Flush all data from the buffer to the next layer. Returns the number of
-  /// bytes written to the next layer on the last write operation, or 0 if an
-  /// error occurred.
-  std::size_t flush(asio::error_code& ec)
-  {
-    return stream_impl_.next_layer().flush(ec);
-  }
-
-  /// Start an asynchronous flush.
-  template <typename WriteHandler>
-  ASIO_INITFN_RESULT_TYPE(WriteHandler,
-      void (asio::error_code, std::size_t))
-  async_flush(ASIO_MOVE_ARG(WriteHandler) handler)
-  {
-    return stream_impl_.next_layer().async_flush(
-        ASIO_MOVE_CAST(WriteHandler)(handler));
-  }
-
-  /// Write the given data to the stream. Returns the number of bytes written.
-  /// Throws an exception on failure.
-  template <typename ConstBufferSequence>
-  std::size_t write_some(const ConstBufferSequence& buffers)
-  {
-    return stream_impl_.write_some(buffers);
-  }
-
-  /// Write the given data to the stream. Returns the number of bytes written,
-  /// or 0 if an error occurred.
-  template <typename ConstBufferSequence>
-  std::size_t write_some(const ConstBufferSequence& buffers,
-      asio::error_code& ec)
-  {
-    return stream_impl_.write_some(buffers, ec);
-  }
-
-  /// Start an asynchronous write. The data being written must be valid for the
-  /// lifetime of the asynchronous operation.
-  template <typename ConstBufferSequence, typename WriteHandler>
-  ASIO_INITFN_RESULT_TYPE(WriteHandler,
-      void (asio::error_code, std::size_t))
-  async_write_some(const ConstBufferSequence& buffers,
-      ASIO_MOVE_ARG(WriteHandler) handler)
-  {
-    return stream_impl_.async_write_some(buffers,
-        ASIO_MOVE_CAST(WriteHandler)(handler));
-  }
-
-  /// Fill the buffer with some data. Returns the number of bytes placed in the
-  /// buffer as a result of the operation. Throws an exception on failure.
-  std::size_t fill()
-  {
-    return stream_impl_.fill();
-  }
-
-  /// Fill the buffer with some data. Returns the number of bytes placed in the
-  /// buffer as a result of the operation, or 0 if an error occurred.
-  std::size_t fill(asio::error_code& ec)
-  {
-    return stream_impl_.fill(ec);
-  }
-
-  /// Start an asynchronous fill.
-  template <typename ReadHandler>
-  ASIO_INITFN_RESULT_TYPE(ReadHandler,
-      void (asio::error_code, std::size_t))
-  async_fill(ASIO_MOVE_ARG(ReadHandler) handler)
-  {
-    return stream_impl_.async_fill(ASIO_MOVE_CAST(ReadHandler)(handler));
-  }
-
-  /// Read some data from the stream. Returns the number of bytes read. Throws
-  /// an exception on failure.
-  template <typename MutableBufferSequence>
-  std::size_t read_some(const MutableBufferSequence& buffers)
-  {
-    return stream_impl_.read_some(buffers);
-  }
-
-  /// Read some data from the stream. Returns the number of bytes read or 0 if
-  /// an error occurred.
-  template <typename MutableBufferSequence>
-  std::size_t read_some(const MutableBufferSequence& buffers,
-      asio::error_code& ec)
-  {
-    return stream_impl_.read_some(buffers, ec);
-  }
-
-  /// Start an asynchronous read. The buffer into which the data will be read
-  /// must be valid for the lifetime of the asynchronous operation.
-  template <typename MutableBufferSequence, typename ReadHandler>
-  ASIO_INITFN_RESULT_TYPE(ReadHandler,
-      void (asio::error_code, std::size_t))
-  async_read_some(const MutableBufferSequence& buffers,
-      ASIO_MOVE_ARG(ReadHandler) handler)
-  {
-    return stream_impl_.async_read_some(buffers,
-        ASIO_MOVE_CAST(ReadHandler)(handler));
-  }
-
-  /// Peek at the incoming data on the stream. Returns the number of bytes read.
-  /// Throws an exception on failure.
-  template <typename MutableBufferSequence>
-  std::size_t peek(const MutableBufferSequence& buffers)
-  {
-    return stream_impl_.peek(buffers);
-  }
-
-  /// Peek at the incoming data on the stream. Returns the number of bytes read,
-  /// or 0 if an error occurred.
-  template <typename MutableBufferSequence>
-  std::size_t peek(const MutableBufferSequence& buffers,
-      asio::error_code& ec)
-  {
-    return stream_impl_.peek(buffers, ec);
-  }
-
-  /// Determine the amount of data that may be read without blocking.
-  std::size_t in_avail()
-  {
-    return stream_impl_.in_avail();
-  }
-
-  /// Determine the amount of data that may be read without blocking.
-  std::size_t in_avail(asio::error_code& ec)
-  {
-    return stream_impl_.in_avail(ec);
-  }
-
-private:
-  // The buffered write stream.
-  typedef buffered_write_stream<Stream> write_stream_type;
-  write_stream_type inner_stream_impl_;
-
-  // The buffered read stream.
-  typedef buffered_read_stream<write_stream_type&> read_stream_type;
-  read_stream_type stream_impl_;
-};
-
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_BUFFERED_STREAM_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/buffered_stream_fwd.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/buffered_stream_fwd.hpp
deleted file mode 100644
index a5730bf06b75..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/buffered_stream_fwd.hpp
+++ /dev/null
@@ -1,25 +0,0 @@
-//
-// buffered_stream_fwd.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_BUFFERED_STREAM_FWD_HPP
-#define ASIO_BUFFERED_STREAM_FWD_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-namespace asio {
-
-template <typename Stream>
-class buffered_stream;
-
-} // namespace asio
-
-#endif // ASIO_BUFFERED_STREAM_FWD_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/buffered_write_stream.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/buffered_write_stream.hpp
deleted file mode 100644
index 5198d90c478a..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/buffered_write_stream.hpp
+++ /dev/null
@@ -1,236 +0,0 @@
-//
-// buffered_write_stream.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_BUFFERED_WRITE_STREAM_HPP
-#define ASIO_BUFFERED_WRITE_STREAM_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include <cstddef>
-#include "asio/buffered_write_stream_fwd.hpp"
-#include "asio/buffer.hpp"
-#include "asio/completion_condition.hpp"
-#include "asio/detail/bind_handler.hpp"
-#include "asio/detail/buffered_stream_storage.hpp"
-#include "asio/detail/noncopyable.hpp"
-#include "asio/detail/type_traits.hpp"
-#include "asio/error.hpp"
-#include "asio/io_service.hpp"
-#include "asio/write.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-
-/// Adds buffering to the write-related operations of a stream.
-/**
- * The buffered_write_stream class template can be used to add buffering to the
- * synchronous and asynchronous write operations of a stream.
- *
- * @par Thread Safety
- * @e Distinct @e objects: Safe.@n
- * @e Shared @e objects: Unsafe.
- *
- * @par Concepts:
- * AsyncReadStream, AsyncWriteStream, Stream, SyncReadStream, SyncWriteStream.
- */
-template <typename Stream>
-class buffered_write_stream
-  : private noncopyable
-{
-public:
-  /// The type of the next layer.
-  typedef typename remove_reference<Stream>::type next_layer_type;
-
-  /// The type of the lowest layer.
-  typedef typename next_layer_type::lowest_layer_type lowest_layer_type;
-
-#if defined(GENERATING_DOCUMENTATION)
-  /// The default buffer size.
-  static const std::size_t default_buffer_size = implementation_defined;
-#else
-  ASIO_STATIC_CONSTANT(std::size_t, default_buffer_size = 1024);
-#endif
-
-  /// Construct, passing the specified argument to initialise the next layer.
-  template <typename Arg>
-  explicit buffered_write_stream(Arg& a)
-    : next_layer_(a),
-      storage_(default_buffer_size)
-  {
-  }
-
-  /// Construct, passing the specified argument to initialise the next layer.
-  template <typename Arg>
-  buffered_write_stream(Arg& a, std::size_t buffer_size)
-    : next_layer_(a),
-      storage_(buffer_size)
-  {
-  }
-
-  /// Get a reference to the next layer.
-  next_layer_type& next_layer()
-  {
-    return next_layer_;
-  }
-
-  /// Get a reference to the lowest layer.
-  lowest_layer_type& lowest_layer()
-  {
-    return next_layer_.lowest_layer();
-  }
-
-  /// Get a const reference to the lowest layer.
-  const lowest_layer_type& lowest_layer() const
-  {
-    return next_layer_.lowest_layer();
-  }
-
-  /// Get the io_service associated with the object.
-  asio::io_service& get_io_service()
-  {
-    return next_layer_.get_io_service();
-  }
-
-  /// Close the stream.
-  void close()
-  {
-    next_layer_.close();
-  }
-
-  /// Close the stream.
-  asio::error_code close(asio::error_code& ec)
-  {
-    return next_layer_.close(ec);
-  }
-
-  /// Flush all data from the buffer to the next layer. Returns the number of
-  /// bytes written to the next layer on the last write operation. Throws an
-  /// exception on failure.
-  std::size_t flush();
-
-  /// Flush all data from the buffer to the next layer. Returns the number of
-  /// bytes written to the next layer on the last write operation, or 0 if an
-  /// error occurred.
-  std::size_t flush(asio::error_code& ec);
-
-  /// Start an asynchronous flush.
-  template <typename WriteHandler>
-  ASIO_INITFN_RESULT_TYPE(WriteHandler,
-      void (asio::error_code, std::size_t))
-  async_flush(ASIO_MOVE_ARG(WriteHandler) handler);
-
-  /// Write the given data to the stream. Returns the number of bytes written.
-  /// Throws an exception on failure.
-  template <typename ConstBufferSequence>
-  std::size_t write_some(const ConstBufferSequence& buffers);
-
-  /// Write the given data to the stream. Returns the number of bytes written,
-  /// or 0 if an error occurred and the error handler did not throw.
-  template <typename ConstBufferSequence>
-  std::size_t write_some(const ConstBufferSequence& buffers,
-      asio::error_code& ec);
-
-  /// Start an asynchronous write. The data being written must be valid for the
-  /// lifetime of the asynchronous operation.
-  template <typename ConstBufferSequence, typename WriteHandler>
-  ASIO_INITFN_RESULT_TYPE(WriteHandler,
-      void (asio::error_code, std::size_t))
-  async_write_some(const ConstBufferSequence& buffers,
-      ASIO_MOVE_ARG(WriteHandler) handler);
-
-  /// Read some data from the stream. Returns the number of bytes read. Throws
-  /// an exception on failure.
-  template <typename MutableBufferSequence>
-  std::size_t read_some(const MutableBufferSequence& buffers)
-  {
-    return next_layer_.read_some(buffers);
-  }
-
-  /// Read some data from the stream. Returns the number of bytes read or 0 if
-  /// an error occurred.
-  template <typename MutableBufferSequence>
-  std::size_t read_some(const MutableBufferSequence& buffers,
-      asio::error_code& ec)
-  {
-    return next_layer_.read_some(buffers, ec);
-  }
-
-  /// Start an asynchronous read. The buffer into which the data will be read
-  /// must be valid for the lifetime of the asynchronous operation.
-  template <typename MutableBufferSequence, typename ReadHandler>
-  ASIO_INITFN_RESULT_TYPE(ReadHandler,
-      void (asio::error_code, std::size_t))
-  async_read_some(const MutableBufferSequence& buffers,
-      ASIO_MOVE_ARG(ReadHandler) handler)
-  {
-    detail::async_result_init<
-      ReadHandler, void (asio::error_code, std::size_t)> init(
-        ASIO_MOVE_CAST(ReadHandler)(handler));
-
-    next_layer_.async_read_some(buffers,
-        ASIO_MOVE_CAST(ASIO_HANDLER_TYPE(ReadHandler,
-            void (asio::error_code, std::size_t)))(init.handler));
-
-    return init.result.get();
-  }
-
-  /// Peek at the incoming data on the stream. Returns the number of bytes read.
-  /// Throws an exception on failure.
-  template <typename MutableBufferSequence>
-  std::size_t peek(const MutableBufferSequence& buffers)
-  {
-    return next_layer_.peek(buffers);
-  }
-
-  /// Peek at the incoming data on the stream. Returns the number of bytes read,
-  /// or 0 if an error occurred.
-  template <typename MutableBufferSequence>
-  std::size_t peek(const MutableBufferSequence& buffers,
-      asio::error_code& ec)
-  {
-    return next_layer_.peek(buffers, ec);
-  }
-
-  /// Determine the amount of data that may be read without blocking.
-  std::size_t in_avail()
-  {
-    return next_layer_.in_avail();
-  }
-
-  /// Determine the amount of data that may be read without blocking.
-  std::size_t in_avail(asio::error_code& ec)
-  {
-    return next_layer_.in_avail(ec);
-  }
-
-private:
-  /// Copy data into the internal buffer from the specified source buffer.
-  /// Returns the number of bytes copied.
-  template <typename ConstBufferSequence>
-  std::size_t copy(const ConstBufferSequence& buffers);
-
-  /// The next layer.
-  Stream next_layer_;
-
-  // The data in the buffer.
-  detail::buffered_stream_storage storage_;
-};
-
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#include "asio/impl/buffered_write_stream.hpp"
-
-#endif // ASIO_BUFFERED_WRITE_STREAM_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/buffered_write_stream_fwd.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/buffered_write_stream_fwd.hpp
deleted file mode 100644
index 53ef7b83a6e7..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/buffered_write_stream_fwd.hpp
+++ /dev/null
@@ -1,25 +0,0 @@
-//
-// buffered_write_stream_fwd.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_BUFFERED_WRITE_STREAM_FWD_HPP
-#define ASIO_BUFFERED_WRITE_STREAM_FWD_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-namespace asio {
-
-template <typename Stream>
-class buffered_write_stream;
-
-} // namespace asio
-
-#endif // ASIO_BUFFERED_WRITE_STREAM_FWD_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/buffers_iterator.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/buffers_iterator.hpp
deleted file mode 100644
index a64a89ffeece..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/buffers_iterator.hpp
+++ /dev/null
@@ -1,481 +0,0 @@
-//
-// buffers_iterator.hpp
-// ~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_BUFFERS_ITERATOR_HPP
-#define ASIO_BUFFERS_ITERATOR_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include <cstddef>
-#include <iterator>
-#include "asio/buffer.hpp"
-#include "asio/detail/assert.hpp"
-#include "asio/detail/type_traits.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-
-namespace detail
-{
-  template <bool IsMutable>
-  struct buffers_iterator_types_helper;
-
-  template <>
-  struct buffers_iterator_types_helper<false>
-  {
-    typedef const_buffer buffer_type;
-    template <typename ByteType>
-    struct byte_type
-    {
-      typedef typename add_const<ByteType>::type type;
-    };
-  };
-
-  template <>
-  struct buffers_iterator_types_helper<true>
-  {
-    typedef mutable_buffer buffer_type;
-    template <typename ByteType>
-    struct byte_type
-    {
-      typedef ByteType type;
-    };
-  };
-
-  template <typename BufferSequence, typename ByteType>
-  struct buffers_iterator_types
-  {
-    enum
-    {
-      is_mutable = is_convertible<
-          typename BufferSequence::value_type,
-          mutable_buffer>::value
-    };
-    typedef buffers_iterator_types_helper<is_mutable> helper;
-    typedef typename helper::buffer_type buffer_type;
-    typedef typename helper::template byte_type<ByteType>::type byte_type;
-  };
-}
-
-/// A random access iterator over the bytes in a buffer sequence.
-template <typename BufferSequence, typename ByteType = char>
-class buffers_iterator
-{
-private:
-  typedef typename detail::buffers_iterator_types<
-      BufferSequence, ByteType>::buffer_type buffer_type;
-
-public:
-  /// The type used for the distance between two iterators.
-  typedef std::ptrdiff_t difference_type;
-
-  /// The type of the value pointed to by the iterator.
-  typedef ByteType value_type;
-
-#if defined(GENERATING_DOCUMENTATION)
-  /// The type of the result of applying operator->() to the iterator.
-  /**
-   * If the buffer sequence stores buffer objects that are convertible to
-   * mutable_buffer, this is a pointer to a non-const ByteType. Otherwise, a
-   * pointer to a const ByteType.
-   */
-  typedef const_or_non_const_ByteType* pointer;
-#else // defined(GENERATING_DOCUMENTATION)
-  typedef typename detail::buffers_iterator_types<
-      BufferSequence, ByteType>::byte_type* pointer;
-#endif // defined(GENERATING_DOCUMENTATION)
-
-#if defined(GENERATING_DOCUMENTATION)
-  /// The type of the result of applying operator*() to the iterator.
-  /**
-   * If the buffer sequence stores buffer objects that are convertible to
-   * mutable_buffer, this is a reference to a non-const ByteType. Otherwise, a
-   * reference to a const ByteType.
-   */
-  typedef const_or_non_const_ByteType& reference;
-#else // defined(GENERATING_DOCUMENTATION)
-  typedef typename detail::buffers_iterator_types<
-      BufferSequence, ByteType>::byte_type& reference;
-#endif // defined(GENERATING_DOCUMENTATION)
-
-  /// The iterator category.
-  typedef std::random_access_iterator_tag iterator_category;
-
-  /// Default constructor. Creates an iterator in an undefined state.
-  buffers_iterator()
-    : current_buffer_(),
-      current_buffer_position_(0),
-      begin_(),
-      current_(),
-      end_(),
-      position_(0)
-  {
-  }
-
-  /// Construct an iterator representing the beginning of the buffers' data.
-  static buffers_iterator begin(const BufferSequence& buffers)
-#if defined(__GNUC__) && (__GNUC__ == 4) && (__GNUC_MINOR__ == 3)
-    __attribute__ ((__noinline__))
-#endif // defined(__GNUC__) && (__GNUC__ == 4) && (__GNUC_MINOR__ == 3)
-  {
-    buffers_iterator new_iter;
-    new_iter.begin_ = buffers.begin();
-    new_iter.current_ = buffers.begin();
-    new_iter.end_ = buffers.end();
-    while (new_iter.current_ != new_iter.end_)
-    {
-      new_iter.current_buffer_ = *new_iter.current_;
-      if (asio::buffer_size(new_iter.current_buffer_) > 0)
-        break;
-      ++new_iter.current_;
-    }
-    return new_iter;
-  }
-
-  /// Construct an iterator representing the end of the buffers' data.
-  static buffers_iterator end(const BufferSequence& buffers)
-#if defined(__GNUC__) && (__GNUC__ == 4) && (__GNUC_MINOR__ == 3)
-    __attribute__ ((__noinline__))
-#endif // defined(__GNUC__) && (__GNUC__ == 4) && (__GNUC_MINOR__ == 3)
-  {
-    buffers_iterator new_iter;
-    new_iter.begin_ = buffers.begin();
-    new_iter.current_ = buffers.begin();
-    new_iter.end_ = buffers.end();
-    while (new_iter.current_ != new_iter.end_)
-    {
-      buffer_type buffer = *new_iter.current_;
-      new_iter.position_ += asio::buffer_size(buffer);
-      ++new_iter.current_;
-    }
-    return new_iter;
-  }
-
-  /// Dereference an iterator.
-  reference operator*() const
-  {
-    return dereference();
-  }
-
-  /// Dereference an iterator.
-  pointer operator->() const
-  {
-    return &dereference();
-  }
-
-  /// Access an individual element.
-  reference operator[](std::ptrdiff_t difference) const
-  {
-    buffers_iterator tmp(*this);
-    tmp.advance(difference);
-    return *tmp;
-  }
-
-  /// Increment operator (prefix).
-  buffers_iterator& operator++()
-  {
-    increment();
-    return *this;
-  }
-
-  /// Increment operator (postfix).
-  buffers_iterator operator++(int)
-  {
-    buffers_iterator tmp(*this);
-    ++*this;
-    return tmp;
-  }
-
-  /// Decrement operator (prefix).
-  buffers_iterator& operator--()
-  {
-    decrement();
-    return *this;
-  }
-
-  /// Decrement operator (postfix).
-  buffers_iterator operator--(int)
-  {
-    buffers_iterator tmp(*this);
-    --*this;
-    return tmp;
-  }
-
-  /// Addition operator.
-  buffers_iterator& operator+=(std::ptrdiff_t difference)
-  {
-    advance(difference);
-    return *this;
-  }
-
-  /// Subtraction operator.
-  buffers_iterator& operator-=(std::ptrdiff_t difference)
-  {
-    advance(-difference);
-    return *this;
-  }
-
-  /// Addition operator.
-  friend buffers_iterator operator+(const buffers_iterator& iter,
-      std::ptrdiff_t difference)
-  {
-    buffers_iterator tmp(iter);
-    tmp.advance(difference);
-    return tmp;
-  }
-
-  /// Addition operator.
-  friend buffers_iterator operator+(std::ptrdiff_t difference,
-      const buffers_iterator& iter)
-  {
-    buffers_iterator tmp(iter);
-    tmp.advance(difference);
-    return tmp;
-  }
-
-  /// Subtraction operator.
-  friend buffers_iterator operator-(const buffers_iterator& iter,
-      std::ptrdiff_t difference)
-  {
-    buffers_iterator tmp(iter);
-    tmp.advance(-difference);
-    return tmp;
-  }
-
-  /// Subtraction operator.
-  friend std::ptrdiff_t operator-(const buffers_iterator& a,
-      const buffers_iterator& b)
-  {
-    return b.distance_to(a);
-  }
-
-  /// Test two iterators for equality.
-  friend bool operator==(const buffers_iterator& a, const buffers_iterator& b)
-  {
-    return a.equal(b);
-  }
-
-  /// Test two iterators for inequality.
-  friend bool operator!=(const buffers_iterator& a, const buffers_iterator& b)
-  {
-    return !a.equal(b);
-  }
-
-  /// Compare two iterators.
-  friend bool operator<(const buffers_iterator& a, const buffers_iterator& b)
-  {
-    return a.distance_to(b) > 0;
-  }
-
-  /// Compare two iterators.
-  friend bool operator<=(const buffers_iterator& a, const buffers_iterator& b)
-  {
-    return !(b < a);
-  }
-
-  /// Compare two iterators.
-  friend bool operator>(const buffers_iterator& a, const buffers_iterator& b)
-  {
-    return b < a;
-  }
-
-  /// Compare two iterators.
-  friend bool operator>=(const buffers_iterator& a, const buffers_iterator& b)
-  {
-    return !(a < b);
-  }
-
-private:
-  // Dereference the iterator.
-  reference dereference() const
-  {
-    return buffer_cast<pointer>(current_buffer_)[current_buffer_position_];
-  }
-
-  // Compare two iterators for equality.
-  bool equal(const buffers_iterator& other) const
-  {
-    return position_ == other.position_;
-  }
-
-  // Increment the iterator.
-  void increment()
-  {
-    ASIO_ASSERT(current_ != end_ && "iterator out of bounds");
-    ++position_;
-
-    // Check if the increment can be satisfied by the current buffer.
-    ++current_buffer_position_;
-    if (current_buffer_position_ != asio::buffer_size(current_buffer_))
-      return;
-
-    // Find the next non-empty buffer.
-    ++current_;
-    current_buffer_position_ = 0;
-    while (current_ != end_)
-    {
-      current_buffer_ = *current_;
-      if (asio::buffer_size(current_buffer_) > 0)
-        return;
-      ++current_;
-    }
-  }
-
-  // Decrement the iterator.
-  void decrement()
-  {
-    ASIO_ASSERT(position_ > 0 && "iterator out of bounds");
-    --position_;
-
-    // Check if the decrement can be satisfied by the current buffer.
-    if (current_buffer_position_ != 0)
-    {
-      --current_buffer_position_;
-      return;
-    }
-
-    // Find the previous non-empty buffer.
-    typename BufferSequence::const_iterator iter = current_;
-    while (iter != begin_)
-    {
-      --iter;
-      buffer_type buffer = *iter;
-      std::size_t buffer_size = asio::buffer_size(buffer);
-      if (buffer_size > 0)
-      {
-        current_ = iter;
-        current_buffer_ = buffer;
-        current_buffer_position_ = buffer_size - 1;
-        return;
-      }
-    }
-  }
-
-  // Advance the iterator by the specified distance.
-  void advance(std::ptrdiff_t n)
-  {
-    if (n > 0)
-    {
-      ASIO_ASSERT(current_ != end_ && "iterator out of bounds");
-      for (;;)
-      {
-        std::ptrdiff_t current_buffer_balance
-          = asio::buffer_size(current_buffer_)
-          - current_buffer_position_;
-
-        // Check if the advance can be satisfied by the current buffer.
-        if (current_buffer_balance > n)
-        {
-          position_ += n;
-          current_buffer_position_ += n;
-          return;
-        }
-
-        // Update position.
-        n -= current_buffer_balance;
-        position_ += current_buffer_balance;
-
-        // Move to next buffer. If it is empty then it will be skipped on the
-        // next iteration of this loop.
-        if (++current_ == end_)
-        {
-          ASIO_ASSERT(n == 0 && "iterator out of bounds");
-          current_buffer_ = buffer_type();
-          current_buffer_position_ = 0;
-          return;
-        }
-        current_buffer_ = *current_;
-        current_buffer_position_ = 0;
-      }
-    }
-    else if (n < 0)
-    {
-      std::size_t abs_n = -n;
-      ASIO_ASSERT(position_ >= abs_n && "iterator out of bounds");
-      for (;;)
-      {
-        // Check if the advance can be satisfied by the current buffer.
-        if (current_buffer_position_ >= abs_n)
-        {
-          position_ -= abs_n;
-          current_buffer_position_ -= abs_n;
-          return;
-        }
-
-        // Update position.
-        abs_n -= current_buffer_position_;
-        position_ -= current_buffer_position_;
-
-        // Check if we've reached the beginning of the buffers.
-        if (current_ == begin_)
-        {
-          ASIO_ASSERT(abs_n == 0 && "iterator out of bounds");
-          current_buffer_position_ = 0;
-          return;
-        }
-
-        // Find the previous non-empty buffer.
-        typename BufferSequence::const_iterator iter = current_;
-        while (iter != begin_)
-        {
-          --iter;
-          buffer_type buffer = *iter;
-          std::size_t buffer_size = asio::buffer_size(buffer);
-          if (buffer_size > 0)
-          {
-            current_ = iter;
-            current_buffer_ = buffer;
-            current_buffer_position_ = buffer_size;
-            break;
-          }
-        }
-      }
-    }
-  }
-
-  // Determine the distance between two iterators.
-  std::ptrdiff_t distance_to(const buffers_iterator& other) const
-  {
-    return other.position_ - position_;
-  }
-
-  buffer_type current_buffer_;
-  std::size_t current_buffer_position_;
-  typename BufferSequence::const_iterator begin_;
-  typename BufferSequence::const_iterator current_;
-  typename BufferSequence::const_iterator end_;
-  std::size_t position_;
-};
-
-/// Construct an iterator representing the beginning of the buffers' data.
-template <typename BufferSequence>
-inline buffers_iterator<BufferSequence> buffers_begin(
-    const BufferSequence& buffers)
-{
-  return buffers_iterator<BufferSequence>::begin(buffers);
-}
-
-/// Construct an iterator representing the end of the buffers' data.
-template <typename BufferSequence>
-inline buffers_iterator<BufferSequence> buffers_end(
-    const BufferSequence& buffers)
-{
-  return buffers_iterator<BufferSequence>::end(buffers);
-}
-
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_BUFFERS_ITERATOR_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/completion_condition.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/completion_condition.hpp
deleted file mode 100644
index aab7617ea0fd..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/completion_condition.hpp
+++ /dev/null
@@ -1,218 +0,0 @@
-//
-// completion_condition.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_COMPLETION_CONDITION_HPP
-#define ASIO_COMPLETION_CONDITION_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include <cstddef>
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-
-namespace detail {
-
-// The default maximum number of bytes to transfer in a single operation.
-enum { default_max_transfer_size = 65536 };
-
-// Adapt result of old-style completion conditions (which had a bool result
-// where true indicated that the operation was complete).
-inline std::size_t adapt_completion_condition_result(bool result)
-{
-  return result ? 0 : default_max_transfer_size;
-}
-
-// Adapt result of current completion conditions (which have a size_t result
-// where 0 means the operation is complete, and otherwise the result is the
-// maximum number of bytes to transfer on the next underlying operation).
-inline std::size_t adapt_completion_condition_result(std::size_t result)
-{
-  return result;
-}
-
-class transfer_all_t
-{
-public:
-  typedef std::size_t result_type;
-
-  template <typename Error>
-  std::size_t operator()(const Error& err, std::size_t)
-  {
-    return !!err ? 0 : default_max_transfer_size;
-  }
-};
-
-class transfer_at_least_t
-{
-public:
-  typedef std::size_t result_type;
-
-  explicit transfer_at_least_t(std::size_t minimum)
-    : minimum_(minimum)
-  {
-  }
-
-  template <typename Error>
-  std::size_t operator()(const Error& err, std::size_t bytes_transferred)
-  {
-    return (!!err || bytes_transferred >= minimum_)
-      ? 0 : default_max_transfer_size;
-  }
-
-private:
-  std::size_t minimum_;
-};
-
-class transfer_exactly_t
-{
-public:
-  typedef std::size_t result_type;
-
-  explicit transfer_exactly_t(std::size_t size)
-    : size_(size)
-  {
-  }
-
-  template <typename Error>
-  std::size_t operator()(const Error& err, std::size_t bytes_transferred)
-  {
-    return (!!err || bytes_transferred >= size_) ? 0 :
-      (size_ - bytes_transferred < default_max_transfer_size
-        ? size_ - bytes_transferred : std::size_t(default_max_transfer_size));
-  }
-
-private:
-  std::size_t size_;
-};
-
-} // namespace detail
-
-/**
- * @defgroup completion_condition Completion Condition Function Objects
- *
- * Function objects used for determining when a read or write operation should
- * complete.
- */
-/*@{*/
-
-/// Return a completion condition function object that indicates that a read or
-/// write operation should continue until all of the data has been transferred,
-/// or until an error occurs.
-/**
- * This function is used to create an object, of unspecified type, that meets
- * CompletionCondition requirements.
- *
- * @par Example
- * Reading until a buffer is full:
- * @code
- * boost::array<char, 128> buf;
- * asio::error_code ec;
- * std::size_t n = asio::read(
- *     sock, asio::buffer(buf),
- *     asio::transfer_all(), ec);
- * if (ec)
- * {
- *   // An error occurred.
- * }
- * else
- * {
- *   // n == 128
- * }
- * @endcode
- */
-#if defined(GENERATING_DOCUMENTATION)
-unspecified transfer_all();
-#else
-inline detail::transfer_all_t transfer_all()
-{
-  return detail::transfer_all_t();
-}
-#endif
-
-/// Return a completion condition function object that indicates that a read or
-/// write operation should continue until a minimum number of bytes has been
-/// transferred, or until an error occurs.
-/**
- * This function is used to create an object, of unspecified type, that meets
- * CompletionCondition requirements.
- *
- * @par Example
- * Reading until a buffer is full or contains at least 64 bytes:
- * @code
- * boost::array<char, 128> buf;
- * asio::error_code ec;
- * std::size_t n = asio::read(
- *     sock, asio::buffer(buf),
- *     asio::transfer_at_least(64), ec);
- * if (ec)
- * {
- *   // An error occurred.
- * }
- * else
- * {
- *   // n >= 64 && n <= 128
- * }
- * @endcode
- */
-#if defined(GENERATING_DOCUMENTATION)
-unspecified transfer_at_least(std::size_t minimum);
-#else
-inline detail::transfer_at_least_t transfer_at_least(std::size_t minimum)
-{
-  return detail::transfer_at_least_t(minimum);
-}
-#endif
-
-/// Return a completion condition function object that indicates that a read or
-/// write operation should continue until an exact number of bytes has been
-/// transferred, or until an error occurs.
-/**
- * This function is used to create an object, of unspecified type, that meets
- * CompletionCondition requirements.
- *
- * @par Example
- * Reading until a buffer is full or contains exactly 64 bytes:
- * @code
- * boost::array<char, 128> buf;
- * asio::error_code ec;
- * std::size_t n = asio::read(
- *     sock, asio::buffer(buf),
- *     asio::transfer_exactly(64), ec);
- * if (ec)
- * {
- *   // An error occurred.
- * }
- * else
- * {
- *   // n == 64
- * }
- * @endcode
- */
-#if defined(GENERATING_DOCUMENTATION)
-unspecified transfer_exactly(std::size_t size);
-#else
-inline detail::transfer_exactly_t transfer_exactly(std::size_t size)
-{
-  return detail::transfer_exactly_t(size);
-}
-#endif
-
-/*@}*/
-
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_COMPLETION_CONDITION_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/connect.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/connect.hpp
deleted file mode 100644
index 9912238b3567..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/connect.hpp
+++ /dev/null
@@ -1,823 +0,0 @@
-//
-// connect.hpp
-// ~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_CONNECT_HPP
-#define ASIO_CONNECT_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include "asio/async_result.hpp"
-#include "asio/basic_socket.hpp"
-#include "asio/error.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-
-/**
- * @defgroup connect asio::connect
- *
- * @brief Establishes a socket connection by trying each endpoint in a sequence.
- */
-/*@{*/
-
-/// Establishes a socket connection by trying each endpoint in a sequence.
-/**
- * This function attempts to connect a socket to one of a sequence of
- * endpoints. It does this by repeated calls to the socket's @c connect member
- * function, once for each endpoint in the sequence, until a connection is
- * successfully established.
- *
- * @param s The socket to be connected. If the socket is already open, it will
- * be closed.
- *
- * @param begin An iterator pointing to the start of a sequence of endpoints.
- *
- * @returns On success, an iterator denoting the successfully connected
- * endpoint. Otherwise, the end iterator.
- *
- * @throws asio::system_error Thrown on failure. If the sequence is
- * empty, the associated @c error_code is asio::error::not_found.
- * Otherwise, contains the error from the last connection attempt.
- *
- * @note This overload assumes that a default constructed object of type @c
- * Iterator represents the end of the sequence. This is a valid assumption for
- * iterator types such as @c asio::ip::tcp::resolver::iterator.
- *
- * @par Example
- * @code tcp::resolver r(io_service);
- * tcp::resolver::query q("host", "service");
- * tcp::socket s(io_service);
- * asio::connect(s, r.resolve(q)); @endcode
- */
-template <typename Protocol, typename SocketService, typename Iterator>
-Iterator connect(basic_socket<Protocol, SocketService>& s, Iterator begin);
-
-/// Establishes a socket connection by trying each endpoint in a sequence.
-/**
- * This function attempts to connect a socket to one of a sequence of
- * endpoints. It does this by repeated calls to the socket's @c connect member
- * function, once for each endpoint in the sequence, until a connection is
- * successfully established.
- *
- * @param s The socket to be connected. If the socket is already open, it will
- * be closed.
- *
- * @param begin An iterator pointing to the start of a sequence of endpoints.
- *
- * @param ec Set to indicate what error occurred, if any. If the sequence is
- * empty, set to asio::error::not_found. Otherwise, contains the error
- * from the last connection attempt.
- *
- * @returns On success, an iterator denoting the successfully connected
- * endpoint. Otherwise, the end iterator.
- *
- * @note This overload assumes that a default constructed object of type @c
- * Iterator represents the end of the sequence. This is a valid assumption for
- * iterator types such as @c asio::ip::tcp::resolver::iterator.
- *
- * @par Example
- * @code tcp::resolver r(io_service);
- * tcp::resolver::query q("host", "service");
- * tcp::socket s(io_service);
- * asio::error_code ec;
- * asio::connect(s, r.resolve(q), ec);
- * if (ec)
- * {
- *   // An error occurred.
- * } @endcode
- */
-template <typename Protocol, typename SocketService, typename Iterator>
-Iterator connect(basic_socket<Protocol, SocketService>& s,
-    Iterator begin, asio::error_code& ec);
-
-/// Establishes a socket connection by trying each endpoint in a sequence.
-/**
- * This function attempts to connect a socket to one of a sequence of
- * endpoints. It does this by repeated calls to the socket's @c connect member
- * function, once for each endpoint in the sequence, until a connection is
- * successfully established.
- *
- * @param s The socket to be connected. If the socket is already open, it will
- * be closed.
- *
- * @param begin An iterator pointing to the start of a sequence of endpoints.
- *
- * @param end An iterator pointing to the end of a sequence of endpoints.
- *
- * @returns On success, an iterator denoting the successfully connected
- * endpoint. Otherwise, the end iterator.
- *
- * @throws asio::system_error Thrown on failure. If the sequence is
- * empty, the associated @c error_code is asio::error::not_found.
- * Otherwise, contains the error from the last connection attempt.
- *
- * @par Example
- * @code tcp::resolver r(io_service);
- * tcp::resolver::query q("host", "service");
- * tcp::resolver::iterator i = r.resolve(q), end;
- * tcp::socket s(io_service);
- * asio::connect(s, i, end); @endcode
- */
-template <typename Protocol, typename SocketService, typename Iterator>
-Iterator connect(basic_socket<Protocol, SocketService>& s,
-    Iterator begin, Iterator end);
-
-/// Establishes a socket connection by trying each endpoint in a sequence.
-/**
- * This function attempts to connect a socket to one of a sequence of
- * endpoints. It does this by repeated calls to the socket's @c connect member
- * function, once for each endpoint in the sequence, until a connection is
- * successfully established.
- *
- * @param s The socket to be connected. If the socket is already open, it will
- * be closed.
- *
- * @param begin An iterator pointing to the start of a sequence of endpoints.
- *
- * @param end An iterator pointing to the end of a sequence of endpoints.
- *
- * @param ec Set to indicate what error occurred, if any. If the sequence is
- * empty, set to asio::error::not_found. Otherwise, contains the error
- * from the last connection attempt.
- *
- * @returns On success, an iterator denoting the successfully connected
- * endpoint. Otherwise, the end iterator.
- *
- * @par Example
- * @code tcp::resolver r(io_service);
- * tcp::resolver::query q("host", "service");
- * tcp::resolver::iterator i = r.resolve(q), end;
- * tcp::socket s(io_service);
- * asio::error_code ec;
- * asio::connect(s, i, end, ec);
- * if (ec)
- * {
- *   // An error occurred.
- * } @endcode
- */
-template <typename Protocol, typename SocketService, typename Iterator>
-Iterator connect(basic_socket<Protocol, SocketService>& s,
-    Iterator begin, Iterator end, asio::error_code& ec);
-
-/// Establishes a socket connection by trying each endpoint in a sequence.
-/**
- * This function attempts to connect a socket to one of a sequence of
- * endpoints. It does this by repeated calls to the socket's @c connect member
- * function, once for each endpoint in the sequence, until a connection is
- * successfully established.
- *
- * @param s The socket to be connected. If the socket is already open, it will
- * be closed.
- *
- * @param begin An iterator pointing to the start of a sequence of endpoints.
- *
- * @param connect_condition A function object that is called prior to each
- * connection attempt. The signature of the function object must be:
- * @code Iterator connect_condition(
- *     const asio::error_code& ec,
- *     Iterator next); @endcode
- * The @c ec parameter contains the result from the most recent connect
- * operation. Before the first connection attempt, @c ec is always set to
- * indicate success. The @c next parameter is an iterator pointing to the next
- * endpoint to be tried. The function object should return the next iterator,
- * but is permitted to return a different iterator so that endpoints may be
- * skipped. The implementation guarantees that the function object will never
- * be called with the end iterator.
- *
- * @returns On success, an iterator denoting the successfully connected
- * endpoint. Otherwise, the end iterator.
- *
- * @throws asio::system_error Thrown on failure. If the sequence is
- * empty, the associated @c error_code is asio::error::not_found.
- * Otherwise, contains the error from the last connection attempt.
- *
- * @note This overload assumes that a default constructed object of type @c
- * Iterator represents the end of the sequence. This is a valid assumption for
- * iterator types such as @c asio::ip::tcp::resolver::iterator.
- *
- * @par Example
- * The following connect condition function object can be used to output
- * information about the individual connection attempts:
- * @code struct my_connect_condition
- * {
- *   template <typename Iterator>
- *   Iterator operator()(
- *       const asio::error_code& ec,
- *       Iterator next)
- *   {
- *     if (ec) std::cout << "Error: " << ec.message() << std::endl;
- *     std::cout << "Trying: " << next->endpoint() << std::endl;
- *     return next;
- *   }
- * }; @endcode
- * It would be used with the asio::connect function as follows:
- * @code tcp::resolver r(io_service);
- * tcp::resolver::query q("host", "service");
- * tcp::socket s(io_service);
- * tcp::resolver::iterator i = asio::connect(
- *     s, r.resolve(q), my_connect_condition());
- * std::cout << "Connected to: " << i->endpoint() << std::endl; @endcode
- */
-template <typename Protocol, typename SocketService,
-    typename Iterator, typename ConnectCondition>
-Iterator connect(basic_socket<Protocol, SocketService>& s,
-    Iterator begin, ConnectCondition connect_condition);
-
-/// Establishes a socket connection by trying each endpoint in a sequence.
-/**
- * This function attempts to connect a socket to one of a sequence of
- * endpoints. It does this by repeated calls to the socket's @c connect member
- * function, once for each endpoint in the sequence, until a connection is
- * successfully established.
- *
- * @param s The socket to be connected. If the socket is already open, it will
- * be closed.
- *
- * @param begin An iterator pointing to the start of a sequence of endpoints.
- *
- * @param connect_condition A function object that is called prior to each
- * connection attempt. The signature of the function object must be:
- * @code Iterator connect_condition(
- *     const asio::error_code& ec,
- *     Iterator next); @endcode
- * The @c ec parameter contains the result from the most recent connect
- * operation. Before the first connection attempt, @c ec is always set to
- * indicate success. The @c next parameter is an iterator pointing to the next
- * endpoint to be tried. The function object should return the next iterator,
- * but is permitted to return a different iterator so that endpoints may be
- * skipped. The implementation guarantees that the function object will never
- * be called with the end iterator.
- *
- * @param ec Set to indicate what error occurred, if any. If the sequence is
- * empty, set to asio::error::not_found. Otherwise, contains the error
- * from the last connection attempt.
- *
- * @returns On success, an iterator denoting the successfully connected
- * endpoint. Otherwise, the end iterator.
- *
- * @note This overload assumes that a default constructed object of type @c
- * Iterator represents the end of the sequence. This is a valid assumption for
- * iterator types such as @c asio::ip::tcp::resolver::iterator.
- *
- * @par Example
- * The following connect condition function object can be used to output
- * information about the individual connection attempts:
- * @code struct my_connect_condition
- * {
- *   template <typename Iterator>
- *   Iterator operator()(
- *       const asio::error_code& ec,
- *       Iterator next)
- *   {
- *     if (ec) std::cout << "Error: " << ec.message() << std::endl;
- *     std::cout << "Trying: " << next->endpoint() << std::endl;
- *     return next;
- *   }
- * }; @endcode
- * It would be used with the asio::connect function as follows:
- * @code tcp::resolver r(io_service);
- * tcp::resolver::query q("host", "service");
- * tcp::socket s(io_service);
- * asio::error_code ec;
- * tcp::resolver::iterator i = asio::connect(
- *     s, r.resolve(q), my_connect_condition(), ec);
- * if (ec)
- * {
- *   // An error occurred.
- * }
- * else
- * {
- *   std::cout << "Connected to: " << i->endpoint() << std::endl;
- * } @endcode
- */
-template <typename Protocol, typename SocketService,
-    typename Iterator, typename ConnectCondition>
-Iterator connect(basic_socket<Protocol, SocketService>& s, Iterator begin,
-    ConnectCondition connect_condition, asio::error_code& ec);
-
-/// Establishes a socket connection by trying each endpoint in a sequence.
-/**
- * This function attempts to connect a socket to one of a sequence of
- * endpoints. It does this by repeated calls to the socket's @c connect member
- * function, once for each endpoint in the sequence, until a connection is
- * successfully established.
- *
- * @param s The socket to be connected. If the socket is already open, it will
- * be closed.
- *
- * @param begin An iterator pointing to the start of a sequence of endpoints.
- *
- * @param end An iterator pointing to the end of a sequence of endpoints.
- *
- * @param connect_condition A function object that is called prior to each
- * connection attempt. The signature of the function object must be:
- * @code Iterator connect_condition(
- *     const asio::error_code& ec,
- *     Iterator next); @endcode
- * The @c ec parameter contains the result from the most recent connect
- * operation. Before the first connection attempt, @c ec is always set to
- * indicate success. The @c next parameter is an iterator pointing to the next
- * endpoint to be tried. The function object should return the next iterator,
- * but is permitted to return a different iterator so that endpoints may be
- * skipped. The implementation guarantees that the function object will never
- * be called with the end iterator.
- *
- * @returns On success, an iterator denoting the successfully connected
- * endpoint. Otherwise, the end iterator.
- *
- * @throws asio::system_error Thrown on failure. If the sequence is
- * empty, the associated @c error_code is asio::error::not_found.
- * Otherwise, contains the error from the last connection attempt.
- *
- * @par Example
- * The following connect condition function object can be used to output
- * information about the individual connection attempts:
- * @code struct my_connect_condition
- * {
- *   template <typename Iterator>
- *   Iterator operator()(
- *       const asio::error_code& ec,
- *       Iterator next)
- *   {
- *     if (ec) std::cout << "Error: " << ec.message() << std::endl;
- *     std::cout << "Trying: " << next->endpoint() << std::endl;
- *     return next;
- *   }
- * }; @endcode
- * It would be used with the asio::connect function as follows:
- * @code tcp::resolver r(io_service);
- * tcp::resolver::query q("host", "service");
- * tcp::resolver::iterator i = r.resolve(q), end;
- * tcp::socket s(io_service);
- * i = asio::connect(s, i, end, my_connect_condition());
- * std::cout << "Connected to: " << i->endpoint() << std::endl; @endcode
- */
-template <typename Protocol, typename SocketService,
-    typename Iterator, typename ConnectCondition>
-Iterator connect(basic_socket<Protocol, SocketService>& s, Iterator begin,
-    Iterator end, ConnectCondition connect_condition);
-
-/// Establishes a socket connection by trying each endpoint in a sequence.
-/**
- * This function attempts to connect a socket to one of a sequence of
- * endpoints. It does this by repeated calls to the socket's @c connect member
- * function, once for each endpoint in the sequence, until a connection is
- * successfully established.
- *
- * @param s The socket to be connected. If the socket is already open, it will
- * be closed.
- *
- * @param begin An iterator pointing to the start of a sequence of endpoints.
- *
- * @param end An iterator pointing to the end of a sequence of endpoints.
- *
- * @param connect_condition A function object that is called prior to each
- * connection attempt. The signature of the function object must be:
- * @code Iterator connect_condition(
- *     const asio::error_code& ec,
- *     Iterator next); @endcode
- * The @c ec parameter contains the result from the most recent connect
- * operation. Before the first connection attempt, @c ec is always set to
- * indicate success. The @c next parameter is an iterator pointing to the next
- * endpoint to be tried. The function object should return the next iterator,
- * but is permitted to return a different iterator so that endpoints may be
- * skipped. The implementation guarantees that the function object will never
- * be called with the end iterator.
- *
- * @param ec Set to indicate what error occurred, if any. If the sequence is
- * empty, set to asio::error::not_found. Otherwise, contains the error
- * from the last connection attempt.
- *
- * @returns On success, an iterator denoting the successfully connected
- * endpoint. Otherwise, the end iterator.
- *
- * @par Example
- * The following connect condition function object can be used to output
- * information about the individual connection attempts:
- * @code struct my_connect_condition
- * {
- *   template <typename Iterator>
- *   Iterator operator()(
- *       const asio::error_code& ec,
- *       Iterator next)
- *   {
- *     if (ec) std::cout << "Error: " << ec.message() << std::endl;
- *     std::cout << "Trying: " << next->endpoint() << std::endl;
- *     return next;
- *   }
- * }; @endcode
- * It would be used with the asio::connect function as follows:
- * @code tcp::resolver r(io_service);
- * tcp::resolver::query q("host", "service");
- * tcp::resolver::iterator i = r.resolve(q), end;
- * tcp::socket s(io_service);
- * asio::error_code ec;
- * i = asio::connect(s, i, end, my_connect_condition(), ec);
- * if (ec)
- * {
- *   // An error occurred.
- * }
- * else
- * {
- *   std::cout << "Connected to: " << i->endpoint() << std::endl;
- * } @endcode
- */
-template <typename Protocol, typename SocketService,
-    typename Iterator, typename ConnectCondition>
-Iterator connect(basic_socket<Protocol, SocketService>& s,
-    Iterator begin, Iterator end, ConnectCondition connect_condition,
-    asio::error_code& ec);
-
-/*@}*/
-
-/**
- * @defgroup async_connect asio::async_connect
- *
- * @brief Asynchronously establishes a socket connection by trying each
- * endpoint in a sequence.
- */
-/*@{*/
-
-/// Asynchronously establishes a socket connection by trying each endpoint in a
-/// sequence.
-/**
- * This function attempts to connect a socket to one of a sequence of
- * endpoints. It does this by repeated calls to the socket's @c async_connect
- * member function, once for each endpoint in the sequence, until a connection
- * is successfully established.
- *
- * @param s The socket to be connected. If the socket is already open, it will
- * be closed.
- *
- * @param begin An iterator pointing to the start of a sequence of endpoints.
- *
- * @param handler The handler to be called when the connect operation
- * completes. Copies will be made of the handler as required. The function
- * signature of the handler must be:
- * @code void handler(
- *   // Result of operation. if the sequence is empty, set to
- *   // asio::error::not_found. Otherwise, contains the
- *   // error from the last connection attempt.
- *   const asio::error_code& error,
- *
- *   // On success, an iterator denoting the successfully
- *   // connected endpoint. Otherwise, the end iterator.
- *   Iterator iterator
- * ); @endcode
- * Regardless of whether the asynchronous operation completes immediately or
- * not, the handler will not be invoked from within this function. Invocation
- * of the handler will be performed in a manner equivalent to using
- * asio::io_service::post().
- *
- * @note This overload assumes that a default constructed object of type @c
- * Iterator represents the end of the sequence. This is a valid assumption for
- * iterator types such as @c asio::ip::tcp::resolver::iterator.
- *
- * @par Example
- * @code tcp::resolver r(io_service);
- * tcp::resolver::query q("host", "service");
- * tcp::socket s(io_service);
- *
- * // ...
- *
- * r.async_resolve(q, resolve_handler);
- *
- * // ...
- *
- * void resolve_handler(
- *     const asio::error_code& ec,
- *     tcp::resolver::iterator i)
- * {
- *   if (!ec)
- *   {
- *     asio::async_connect(s, i, connect_handler);
- *   }
- * }
- *
- * // ...
- *
- * void connect_handler(
- *     const asio::error_code& ec,
- *     tcp::resolver::iterator i)
- * {
- *   // ...
- * } @endcode
- */
-template <typename Protocol, typename SocketService,
-    typename Iterator, typename ComposedConnectHandler>
-ASIO_INITFN_RESULT_TYPE(ComposedConnectHandler,
-    void (asio::error_code, Iterator))
-async_connect(basic_socket<Protocol, SocketService>& s,
-    Iterator begin, ASIO_MOVE_ARG(ComposedConnectHandler) handler);
-
-/// Asynchronously establishes a socket connection by trying each endpoint in a
-/// sequence.
-/**
- * This function attempts to connect a socket to one of a sequence of
- * endpoints. It does this by repeated calls to the socket's @c async_connect
- * member function, once for each endpoint in the sequence, until a connection
- * is successfully established.
- *
- * @param s The socket to be connected. If the socket is already open, it will
- * be closed.
- *
- * @param begin An iterator pointing to the start of a sequence of endpoints.
- *
- * @param end An iterator pointing to the end of a sequence of endpoints.
- *
- * @param handler The handler to be called when the connect operation
- * completes. Copies will be made of the handler as required. The function
- * signature of the handler must be:
- * @code void handler(
- *   // Result of operation. if the sequence is empty, set to
- *   // asio::error::not_found. Otherwise, contains the
- *   // error from the last connection attempt.
- *   const asio::error_code& error,
- *
- *   // On success, an iterator denoting the successfully
- *   // connected endpoint. Otherwise, the end iterator.
- *   Iterator iterator
- * ); @endcode
- * Regardless of whether the asynchronous operation completes immediately or
- * not, the handler will not be invoked from within this function. Invocation
- * of the handler will be performed in a manner equivalent to using
- * asio::io_service::post().
- *
- * @par Example
- * @code tcp::resolver r(io_service);
- * tcp::resolver::query q("host", "service");
- * tcp::socket s(io_service);
- *
- * // ...
- *
- * r.async_resolve(q, resolve_handler);
- *
- * // ...
- *
- * void resolve_handler(
- *     const asio::error_code& ec,
- *     tcp::resolver::iterator i)
- * {
- *   if (!ec)
- *   {
- *     tcp::resolver::iterator end;
- *     asio::async_connect(s, i, end, connect_handler);
- *   }
- * }
- *
- * // ...
- *
- * void connect_handler(
- *     const asio::error_code& ec,
- *     tcp::resolver::iterator i)
- * {
- *   // ...
- * } @endcode
- */
-template <typename Protocol, typename SocketService,
-    typename Iterator, typename ComposedConnectHandler>
-ASIO_INITFN_RESULT_TYPE(ComposedConnectHandler,
-    void (asio::error_code, Iterator))
-async_connect(basic_socket<Protocol, SocketService>& s,
-    Iterator begin, Iterator end,
-    ASIO_MOVE_ARG(ComposedConnectHandler) handler);
-
-/// Asynchronously establishes a socket connection by trying each endpoint in a
-/// sequence.
-/**
- * This function attempts to connect a socket to one of a sequence of
- * endpoints. It does this by repeated calls to the socket's @c async_connect
- * member function, once for each endpoint in the sequence, until a connection
- * is successfully established.
- *
- * @param s The socket to be connected. If the socket is already open, it will
- * be closed.
- *
- * @param begin An iterator pointing to the start of a sequence of endpoints.
- *
- * @param connect_condition A function object that is called prior to each
- * connection attempt. The signature of the function object must be:
- * @code Iterator connect_condition(
- *     const asio::error_code& ec,
- *     Iterator next); @endcode
- * The @c ec parameter contains the result from the most recent connect
- * operation. Before the first connection attempt, @c ec is always set to
- * indicate success. The @c next parameter is an iterator pointing to the next
- * endpoint to be tried. The function object should return the next iterator,
- * but is permitted to return a different iterator so that endpoints may be
- * skipped. The implementation guarantees that the function object will never
- * be called with the end iterator.
- *
- * @param handler The handler to be called when the connect operation
- * completes. Copies will be made of the handler as required. The function
- * signature of the handler must be:
- * @code void handler(
- *   // Result of operation. if the sequence is empty, set to
- *   // asio::error::not_found. Otherwise, contains the
- *   // error from the last connection attempt.
- *   const asio::error_code& error,
- *
- *   // On success, an iterator denoting the successfully
- *   // connected endpoint. Otherwise, the end iterator.
- *   Iterator iterator
- * ); @endcode
- * Regardless of whether the asynchronous operation completes immediately or
- * not, the handler will not be invoked from within this function. Invocation
- * of the handler will be performed in a manner equivalent to using
- * asio::io_service::post().
- *
- * @note This overload assumes that a default constructed object of type @c
- * Iterator represents the end of the sequence. This is a valid assumption for
- * iterator types such as @c asio::ip::tcp::resolver::iterator.
- *
- * @par Example
- * The following connect condition function object can be used to output
- * information about the individual connection attempts:
- * @code struct my_connect_condition
- * {
- *   template <typename Iterator>
- *   Iterator operator()(
- *       const asio::error_code& ec,
- *       Iterator next)
- *   {
- *     if (ec) std::cout << "Error: " << ec.message() << std::endl;
- *     std::cout << "Trying: " << next->endpoint() << std::endl;
- *     return next;
- *   }
- * }; @endcode
- * It would be used with the asio::connect function as follows:
- * @code tcp::resolver r(io_service);
- * tcp::resolver::query q("host", "service");
- * tcp::socket s(io_service);
- *
- * // ...
- *
- * r.async_resolve(q, resolve_handler);
- *
- * // ...
- *
- * void resolve_handler(
- *     const asio::error_code& ec,
- *     tcp::resolver::iterator i)
- * {
- *   if (!ec)
- *   {
- *     asio::async_connect(s, i,
- *         my_connect_condition(),
- *         connect_handler);
- *   }
- * }
- *
- * // ...
- *
- * void connect_handler(
- *     const asio::error_code& ec,
- *     tcp::resolver::iterator i)
- * {
- *   if (ec)
- *   {
- *     // An error occurred.
- *   }
- *   else
- *   {
- *     std::cout << "Connected to: " << i->endpoint() << std::endl;
- *   }
- * } @endcode
- */
-template <typename Protocol, typename SocketService, typename Iterator,
-    typename ConnectCondition, typename ComposedConnectHandler>
-ASIO_INITFN_RESULT_TYPE(ComposedConnectHandler,
-    void (asio::error_code, Iterator))
-async_connect(basic_socket<Protocol, SocketService>& s, Iterator begin,
-    ConnectCondition connect_condition,
-    ASIO_MOVE_ARG(ComposedConnectHandler) handler);
-
-/// Asynchronously establishes a socket connection by trying each endpoint in a
-/// sequence.
-/**
- * This function attempts to connect a socket to one of a sequence of
- * endpoints. It does this by repeated calls to the socket's @c async_connect
- * member function, once for each endpoint in the sequence, until a connection
- * is successfully established.
- *
- * @param s The socket to be connected. If the socket is already open, it will
- * be closed.
- *
- * @param begin An iterator pointing to the start of a sequence of endpoints.
- *
- * @param end An iterator pointing to the end of a sequence of endpoints.
- *
- * @param connect_condition A function object that is called prior to each
- * connection attempt. The signature of the function object must be:
- * @code Iterator connect_condition(
- *     const asio::error_code& ec,
- *     Iterator next); @endcode
- * The @c ec parameter contains the result from the most recent connect
- * operation. Before the first connection attempt, @c ec is always set to
- * indicate success. The @c next parameter is an iterator pointing to the next
- * endpoint to be tried. The function object should return the next iterator,
- * but is permitted to return a different iterator so that endpoints may be
- * skipped. The implementation guarantees that the function object will never
- * be called with the end iterator.
- *
- * @param handler The handler to be called when the connect operation
- * completes. Copies will be made of the handler as required. The function
- * signature of the handler must be:
- * @code void handler(
- *   // Result of operation. if the sequence is empty, set to
- *   // asio::error::not_found. Otherwise, contains the
- *   // error from the last connection attempt.
- *   const asio::error_code& error,
- *
- *   // On success, an iterator denoting the successfully
- *   // connected endpoint. Otherwise, the end iterator.
- *   Iterator iterator
- * ); @endcode
- * Regardless of whether the asynchronous operation completes immediately or
- * not, the handler will not be invoked from within this function. Invocation
- * of the handler will be performed in a manner equivalent to using
- * asio::io_service::post().
- *
- * @par Example
- * The following connect condition function object can be used to output
- * information about the individual connection attempts:
- * @code struct my_connect_condition
- * {
- *   template <typename Iterator>
- *   Iterator operator()(
- *       const asio::error_code& ec,
- *       Iterator next)
- *   {
- *     if (ec) std::cout << "Error: " << ec.message() << std::endl;
- *     std::cout << "Trying: " << next->endpoint() << std::endl;
- *     return next;
- *   }
- * }; @endcode
- * It would be used with the asio::connect function as follows:
- * @code tcp::resolver r(io_service);
- * tcp::resolver::query q("host", "service");
- * tcp::socket s(io_service);
- *
- * // ...
- *
- * r.async_resolve(q, resolve_handler);
- *
- * // ...
- *
- * void resolve_handler(
- *     const asio::error_code& ec,
- *     tcp::resolver::iterator i)
- * {
- *   if (!ec)
- *   {
- *     tcp::resolver::iterator end;
- *     asio::async_connect(s, i, end,
- *         my_connect_condition(),
- *         connect_handler);
- *   }
- * }
- *
- * // ...
- *
- * void connect_handler(
- *     const asio::error_code& ec,
- *     tcp::resolver::iterator i)
- * {
- *   if (ec)
- *   {
- *     // An error occurred.
- *   }
- *   else
- *   {
- *     std::cout << "Connected to: " << i->endpoint() << std::endl;
- *   }
- * } @endcode
- */
-template <typename Protocol, typename SocketService, typename Iterator,
-    typename ConnectCondition, typename ComposedConnectHandler>
-ASIO_INITFN_RESULT_TYPE(ComposedConnectHandler,
-    void (asio::error_code, Iterator))
-async_connect(basic_socket<Protocol, SocketService>& s,
-    Iterator begin, Iterator end, ConnectCondition connect_condition,
-    ASIO_MOVE_ARG(ComposedConnectHandler) handler);
-
-/*@}*/
-
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#include "asio/impl/connect.hpp"
-
-#endif
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/coroutine.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/coroutine.hpp
deleted file mode 100644
index 67c3cf50ec9e..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/coroutine.hpp
+++ /dev/null
@@ -1,328 +0,0 @@
-//
-// coroutine.hpp
-// ~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_COROUTINE_HPP
-#define ASIO_COROUTINE_HPP
-
-namespace asio {
-namespace detail {
-
-class coroutine_ref;
-
-} // namespace detail
-
-/// Provides support for implementing stackless coroutines.
-/**
- * The @c coroutine class may be used to implement stackless coroutines. The
- * class itself is used to store the current state of the coroutine.
- *
- * Coroutines are copy-constructible and assignable, and the space overhead is
- * a single int. They can be used as a base class:
- *
- * @code class session : coroutine
- * {
- *   ...
- * }; @endcode
- *
- * or as a data member:
- *
- * @code class session
- * {
- *   ...
- *   coroutine coro_;
- * }; @endcode
- *
- * or even bound in as a function argument using lambdas or @c bind(). The
- * important thing is that as the application maintains a copy of the object
- * for as long as the coroutine must be kept alive.
- *
- * @par Pseudo-keywords
- *
- * A coroutine is used in conjunction with certain "pseudo-keywords", which
- * are implemented as macros. These macros are defined by a header file:
- *
- * @code #include <asio/yield.hpp>@endcode
- *
- * and may conversely be undefined as follows:
- *
- * @code #include <asio/unyield.hpp>@endcode
- *
- * <b>reenter</b>
- *
- * The @c reenter macro is used to define the body of a coroutine. It takes a
- * single argument: a pointer or reference to a coroutine object. For example,
- * if the base class is a coroutine object you may write:
- *
- * @code reenter (this)
- * {
- *   ... coroutine body ...
- * } @endcode
- *
- * and if a data member or other variable you can write:
- *
- * @code reenter (coro_)
- * {
- *   ... coroutine body ...
- * } @endcode
- *
- * When @c reenter is executed at runtime, control jumps to the location of the
- * last @c yield or @c fork.
- *
- * The coroutine body may also be a single statement, such as:
- *
- * @code reenter (this) for (;;)
- * {
- *   ...
- * } @endcode
- *
- * @b Limitation: The @c reenter macro is implemented using a switch. This
- * means that you must take care when using local variables within the
- * coroutine body. The local variable is not allowed in a position where
- * reentering the coroutine could bypass the variable definition.
- *
- * <b>yield <em>statement</em></b>
- *
- * This form of the @c yield keyword is often used with asynchronous operations:
- *
- * @code yield socket_->async_read_some(buffer(*buffer_), *this); @endcode
- *
- * This divides into four logical steps:
- *
- * @li @c yield saves the current state of the coroutine.
- * @li The statement initiates the asynchronous operation.
- * @li The resume point is defined immediately following the statement.
- * @li Control is transferred to the end of the coroutine body.
- *
- * When the asynchronous operation completes, the function object is invoked
- * and @c reenter causes control to transfer to the resume point. It is
- * important to remember to carry the coroutine state forward with the
- * asynchronous operation. In the above snippet, the current class is a
- * function object object with a coroutine object as base class or data member.
- *
- * The statement may also be a compound statement, and this permits us to
- * define local variables with limited scope:
- *
- * @code yield
- * {
- *   mutable_buffers_1 b = buffer(*buffer_);
- *   socket_->async_read_some(b, *this);
- * } @endcode
- *
- * <b>yield return <em>expression</em> ;</b>
- *
- * This form of @c yield is often used in generators or coroutine-based parsers.
- * For example, the function object:
- *
- * @code struct interleave : coroutine
- * {
- *   istream& is1;
- *   istream& is2;
- *   char operator()(char c)
- *   {
- *     reenter (this) for (;;)
- *     {
- *       yield return is1.get();
- *       yield return is2.get();
- *     }
- *   }
- * }; @endcode
- *
- * defines a trivial coroutine that interleaves the characters from two input
- * streams.
- *
- * This type of @c yield divides into three logical steps:
- *
- * @li @c yield saves the current state of the coroutine.
- * @li The resume point is defined immediately following the semicolon.
- * @li The value of the expression is returned from the function.
- *
- * <b>yield ;</b>
- *
- * This form of @c yield is equivalent to the following steps:
- *
- * @li @c yield saves the current state of the coroutine.
- * @li The resume point is defined immediately following the semicolon.
- * @li Control is transferred to the end of the coroutine body.
- *
- * This form might be applied when coroutines are used for cooperative
- * threading and scheduling is explicitly managed. For example:
- *
- * @code struct task : coroutine
- * {
- *   ...
- *   void operator()()
- *   {
- *     reenter (this)
- *     {
- *       while (... not finished ...)
- *       {
- *         ... do something ...
- *         yield;
- *         ... do some more ...
- *         yield;
- *       }
- *     }
- *   }
- *   ...
- * };
- * ...
- * task t1, t2;
- * for (;;)
- * {
- *   t1();
- *   t2();
- * } @endcode
- *
- * <b>yield break ;</b>
- *
- * The final form of @c yield is used to explicitly terminate the coroutine.
- * This form is comprised of two steps:
- *
- * @li @c yield sets the coroutine state to indicate termination.
- * @li Control is transferred to the end of the coroutine body.
- *
- * Once terminated, calls to is_complete() return true and the coroutine cannot
- * be reentered.
- *
- * Note that a coroutine may also be implicitly terminated if the coroutine
- * body is exited without a yield, e.g. by return, throw or by running to the
- * end of the body.
- *
- * <b>fork <em>statement</em></b>
- *
- * The @c fork pseudo-keyword is used when "forking" a coroutine, i.e. splitting
- * it into two (or more) copies. One use of @c fork is in a server, where a new
- * coroutine is created to handle each client connection:
- * 
- * @code reenter (this)
- * {
- *   do
- *   {
- *     socket_.reset(new tcp::socket(io_service_));
- *     yield acceptor->async_accept(*socket_, *this);
- *     fork server(*this)();
- *   } while (is_parent());
- *   ... client-specific handling follows ...
- * } @endcode
- * 
- * The logical steps involved in a @c fork are:
- * 
- * @li @c fork saves the current state of the coroutine.
- * @li The statement creates a copy of the coroutine and either executes it
- *     immediately or schedules it for later execution.
- * @li The resume point is defined immediately following the semicolon.
- * @li For the "parent", control immediately continues from the next line.
- *
- * The functions is_parent() and is_child() can be used to differentiate
- * between parent and child. You would use these functions to alter subsequent
- * control flow.
- *
- * Note that @c fork doesn't do the actual forking by itself. It is the
- * application's responsibility to create a clone of the coroutine and call it.
- * The clone can be called immediately, as above, or scheduled for delayed
- * execution using something like io_service::post().
- *
- * @par Alternate macro names
- *
- * If preferred, an application can use macro names that follow a more typical
- * naming convention, rather than the pseudo-keywords. These are:
- *
- * @li @c ASIO_CORO_REENTER instead of @c reenter
- * @li @c ASIO_CORO_YIELD instead of @c yield
- * @li @c ASIO_CORO_FORK instead of @c fork
- */
-class coroutine
-{
-public:
-  /// Constructs a coroutine in its initial state.
-  coroutine() : value_(0) {}
-
-  /// Returns true if the coroutine is the child of a fork.
-  bool is_child() const { return value_ < 0; }
-
-  /// Returns true if the coroutine is the parent of a fork.
-  bool is_parent() const { return !is_child(); }
-
-  /// Returns true if the coroutine has reached its terminal state.
-  bool is_complete() const { return value_ == -1; }
-
-private:
-  friend class detail::coroutine_ref;
-  int value_;
-};
-
-
-namespace detail {
-
-class coroutine_ref
-{
-public:
-  coroutine_ref(coroutine& c) : value_(c.value_), modified_(false) {}
-  coroutine_ref(coroutine* c) : value_(c->value_), modified_(false) {}
-  ~coroutine_ref() { if (!modified_) value_ = -1; }
-  operator int() const { return value_; }
-  int& operator=(int v) { modified_ = true; return value_ = v; }
-private:
-  void operator=(const coroutine_ref&);
-  int& value_;
-  bool modified_;
-};
-
-} // namespace detail
-} // namespace asio
-
-#define ASIO_CORO_REENTER(c) \
-  switch (::asio::detail::coroutine_ref _coro_value = c) \
-    case -1: if (_coro_value) \
-    { \
-      goto terminate_coroutine; \
-      terminate_coroutine: \
-      _coro_value = -1; \
-      goto bail_out_of_coroutine; \
-      bail_out_of_coroutine: \
-      break; \
-    } \
-    else case 0:
-
-#define ASIO_CORO_YIELD_IMPL(n) \
-  for (_coro_value = (n);;) \
-    if (_coro_value == 0) \
-    { \
-      case (n): ; \
-      break; \
-    } \
-    else \
-      switch (_coro_value ? 0 : 1) \
-        for (;;) \
-          case -1: if (_coro_value) \
-            goto terminate_coroutine; \
-          else for (;;) \
-            case 1: if (_coro_value) \
-              goto bail_out_of_coroutine; \
-            else case 0:
-
-#define ASIO_CORO_FORK_IMPL(n) \
-  for (_coro_value = -(n);; _coro_value = (n)) \
-    if (_coro_value == (n)) \
-    { \
-      case -(n): ; \
-      break; \
-    } \
-    else
-
-#if defined(_MSC_VER)
-# define ASIO_CORO_YIELD ASIO_CORO_YIELD_IMPL(__COUNTER__ + 1)
-# define ASIO_CORO_FORK ASIO_CORO_FORK_IMPL(__COUNTER__ + 1)
-#else // defined(_MSC_VER)
-# define ASIO_CORO_YIELD ASIO_CORO_YIELD_IMPL(__LINE__)
-# define ASIO_CORO_FORK ASIO_CORO_FORK_IMPL(__LINE__)
-#endif // defined(_MSC_VER)
-
-#endif // ASIO_COROUTINE_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/datagram_socket_service.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/datagram_socket_service.hpp
deleted file mode 100644
index a9b96102e953..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/datagram_socket_service.hpp
+++ /dev/null
@@ -1,432 +0,0 @@
-//
-// datagram_socket_service.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DATAGRAM_SOCKET_SERVICE_HPP
-#define ASIO_DATAGRAM_SOCKET_SERVICE_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include <cstddef>
-#include "asio/async_result.hpp"
-#include "asio/detail/type_traits.hpp"
-#include "asio/error.hpp"
-#include "asio/io_service.hpp"
-
-#if defined(ASIO_WINDOWS_RUNTIME)
-# include "asio/detail/null_socket_service.hpp"
-#elif defined(ASIO_HAS_IOCP)
-# include "asio/detail/win_iocp_socket_service.hpp"
-#else
-# include "asio/detail/reactive_socket_service.hpp"
-#endif
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-
-/// Default service implementation for a datagram socket.
-template <typename Protocol>
-class datagram_socket_service
-#if defined(GENERATING_DOCUMENTATION)
-  : public asio::io_service::service
-#else
-  : public asio::detail::service_base<datagram_socket_service<Protocol> >
-#endif
-{
-public:
-#if defined(GENERATING_DOCUMENTATION)
-  /// The unique service identifier.
-  static asio::io_service::id id;
-#endif
-
-  /// The protocol type.
-  typedef Protocol protocol_type;
-
-  /// The endpoint type.
-  typedef typename Protocol::endpoint endpoint_type;
-
-private:
-  // The type of the platform-specific implementation.
-#if defined(ASIO_WINDOWS_RUNTIME)
-  typedef detail::null_socket_service<Protocol> service_impl_type;
-#elif defined(ASIO_HAS_IOCP)
-  typedef detail::win_iocp_socket_service<Protocol> service_impl_type;
-#else
-  typedef detail::reactive_socket_service<Protocol> service_impl_type;
-#endif
-
-public:
-  /// The type of a datagram socket.
-#if defined(GENERATING_DOCUMENTATION)
-  typedef implementation_defined implementation_type;
-#else
-  typedef typename service_impl_type::implementation_type implementation_type;
-#endif
-
-  /// (Deprecated: Use native_handle_type.) The native socket type.
-#if defined(GENERATING_DOCUMENTATION)
-  typedef implementation_defined native_type;
-#else
-  typedef typename service_impl_type::native_handle_type native_type;
-#endif
-
-  /// The native socket type.
-#if defined(GENERATING_DOCUMENTATION)
-  typedef implementation_defined native_handle_type;
-#else
-  typedef typename service_impl_type::native_handle_type native_handle_type;
-#endif
-
-  /// Construct a new datagram socket service for the specified io_service.
-  explicit datagram_socket_service(asio::io_service& io_service)
-    : asio::detail::service_base<
-        datagram_socket_service<Protocol> >(io_service),
-      service_impl_(io_service)
-  {
-  }
-
-  /// Construct a new datagram socket implementation.
-  void construct(implementation_type& impl)
-  {
-    service_impl_.construct(impl);
-  }
-
-#if defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
-  /// Move-construct a new datagram socket implementation.
-  void move_construct(implementation_type& impl,
-      implementation_type& other_impl)
-  {
-    service_impl_.move_construct(impl, other_impl);
-  }
-
-  /// Move-assign from another datagram socket implementation.
-  void move_assign(implementation_type& impl,
-      datagram_socket_service& other_service,
-      implementation_type& other_impl)
-  {
-    service_impl_.move_assign(impl, other_service.service_impl_, other_impl);
-  }
-
-  /// Move-construct a new datagram socket implementation from another protocol
-  /// type.
-  template <typename Protocol1>
-  void converting_move_construct(implementation_type& impl,
-      typename datagram_socket_service<
-        Protocol1>::implementation_type& other_impl,
-      typename enable_if<is_convertible<
-        Protocol1, Protocol>::value>::type* = 0)
-  {
-    service_impl_.template converting_move_construct<Protocol1>(
-        impl, other_impl);
-  }
-#endif // defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
-
-  /// Destroy a datagram socket implementation.
-  void destroy(implementation_type& impl)
-  {
-    service_impl_.destroy(impl);
-  }
-
-  // Open a new datagram socket implementation.
-  asio::error_code open(implementation_type& impl,
-      const protocol_type& protocol, asio::error_code& ec)
-  {
-    if (protocol.type() == ASIO_OS_DEF(SOCK_DGRAM))
-      service_impl_.open(impl, protocol, ec);
-    else
-      ec = asio::error::invalid_argument;
-    return ec;
-  }
-
-  /// Assign an existing native socket to a datagram socket.
-  asio::error_code assign(implementation_type& impl,
-      const protocol_type& protocol, const native_handle_type& native_socket,
-      asio::error_code& ec)
-  {
-    return service_impl_.assign(impl, protocol, native_socket, ec);
-  }
-
-  /// Determine whether the socket is open.
-  bool is_open(const implementation_type& impl) const
-  {
-    return service_impl_.is_open(impl);
-  }
-
-  /// Close a datagram socket implementation.
-  asio::error_code close(implementation_type& impl,
-      asio::error_code& ec)
-  {
-    return service_impl_.close(impl, ec);
-  }
-
-  /// (Deprecated: Use native_handle().) Get the native socket implementation.
-  native_type native(implementation_type& impl)
-  {
-    return service_impl_.native_handle(impl);
-  }
-
-  /// Get the native socket implementation.
-  native_handle_type native_handle(implementation_type& impl)
-  {
-    return service_impl_.native_handle(impl);
-  }
-
-  /// Cancel all asynchronous operations associated with the socket.
-  asio::error_code cancel(implementation_type& impl,
-      asio::error_code& ec)
-  {
-    return service_impl_.cancel(impl, ec);
-  }
-
-  /// Determine whether the socket is at the out-of-band data mark.
-  bool at_mark(const implementation_type& impl,
-      asio::error_code& ec) const
-  {
-    return service_impl_.at_mark(impl, ec);
-  }
-
-  /// Determine the number of bytes available for reading.
-  std::size_t available(const implementation_type& impl,
-      asio::error_code& ec) const
-  {
-    return service_impl_.available(impl, ec);
-  }
-
-  // Bind the datagram socket to the specified local endpoint.
-  asio::error_code bind(implementation_type& impl,
-      const endpoint_type& endpoint, asio::error_code& ec)
-  {
-    return service_impl_.bind(impl, endpoint, ec);
-  }
-
-  /// Connect the datagram socket to the specified endpoint.
-  asio::error_code connect(implementation_type& impl,
-      const endpoint_type& peer_endpoint, asio::error_code& ec)
-  {
-    return service_impl_.connect(impl, peer_endpoint, ec);
-  }
-
-  /// Start an asynchronous connect.
-  template <typename ConnectHandler>
-  ASIO_INITFN_RESULT_TYPE(ConnectHandler,
-      void (asio::error_code))
-  async_connect(implementation_type& impl,
-      const endpoint_type& peer_endpoint,
-      ASIO_MOVE_ARG(ConnectHandler) handler)
-  {
-    detail::async_result_init<
-      ConnectHandler, void (asio::error_code)> init(
-        ASIO_MOVE_CAST(ConnectHandler)(handler));
-
-    service_impl_.async_connect(impl, peer_endpoint, init.handler);
-
-    return init.result.get();
-  }
-
-  /// Set a socket option.
-  template <typename SettableSocketOption>
-  asio::error_code set_option(implementation_type& impl,
-      const SettableSocketOption& option, asio::error_code& ec)
-  {
-    return service_impl_.set_option(impl, option, ec);
-  }
-
-  /// Get a socket option.
-  template <typename GettableSocketOption>
-  asio::error_code get_option(const implementation_type& impl,
-      GettableSocketOption& option, asio::error_code& ec) const
-  {
-    return service_impl_.get_option(impl, option, ec);
-  }
-
-  /// Perform an IO control command on the socket.
-  template <typename IoControlCommand>
-  asio::error_code io_control(implementation_type& impl,
-      IoControlCommand& command, asio::error_code& ec)
-  {
-    return service_impl_.io_control(impl, command, ec);
-  }
-
-  /// Gets the non-blocking mode of the socket.
-  bool non_blocking(const implementation_type& impl) const
-  {
-    return service_impl_.non_blocking(impl);
-  }
-
-  /// Sets the non-blocking mode of the socket.
-  asio::error_code non_blocking(implementation_type& impl,
-      bool mode, asio::error_code& ec)
-  {
-    return service_impl_.non_blocking(impl, mode, ec);
-  }
-
-  /// Gets the non-blocking mode of the native socket implementation.
-  bool native_non_blocking(const implementation_type& impl) const
-  {
-    return service_impl_.native_non_blocking(impl);
-  }
-
-  /// Sets the non-blocking mode of the native socket implementation.
-  asio::error_code native_non_blocking(implementation_type& impl,
-      bool mode, asio::error_code& ec)
-  {
-    return service_impl_.native_non_blocking(impl, mode, ec);
-  }
-
-  /// Get the local endpoint.
-  endpoint_type local_endpoint(const implementation_type& impl,
-      asio::error_code& ec) const
-  {
-    return service_impl_.local_endpoint(impl, ec);
-  }
-
-  /// Get the remote endpoint.
-  endpoint_type remote_endpoint(const implementation_type& impl,
-      asio::error_code& ec) const
-  {
-    return service_impl_.remote_endpoint(impl, ec);
-  }
-
-  /// Disable sends or receives on the socket.
-  asio::error_code shutdown(implementation_type& impl,
-      socket_base::shutdown_type what, asio::error_code& ec)
-  {
-    return service_impl_.shutdown(impl, what, ec);
-  }
-
-  /// Send the given data to the peer.
-  template <typename ConstBufferSequence>
-  std::size_t send(implementation_type& impl,
-      const ConstBufferSequence& buffers,
-      socket_base::message_flags flags, asio::error_code& ec)
-  {
-    return service_impl_.send(impl, buffers, flags, ec);
-  }
-
-  /// Start an asynchronous send.
-  template <typename ConstBufferSequence, typename WriteHandler>
-  ASIO_INITFN_RESULT_TYPE(WriteHandler,
-      void (asio::error_code, std::size_t))
-  async_send(implementation_type& impl, const ConstBufferSequence& buffers,
-      socket_base::message_flags flags,
-      ASIO_MOVE_ARG(WriteHandler) handler)
-  {
-    detail::async_result_init<
-      WriteHandler, void (asio::error_code, std::size_t)> init(
-        ASIO_MOVE_CAST(WriteHandler)(handler));
-
-    service_impl_.async_send(impl, buffers, flags, init.handler);
-
-    return init.result.get();
-  }
-
-  /// Send a datagram to the specified endpoint.
-  template <typename ConstBufferSequence>
-  std::size_t send_to(implementation_type& impl,
-      const ConstBufferSequence& buffers, const endpoint_type& destination,
-      socket_base::message_flags flags, asio::error_code& ec)
-  {
-    return service_impl_.send_to(impl, buffers, destination, flags, ec);
-  }
-
-  /// Start an asynchronous send.
-  template <typename ConstBufferSequence, typename WriteHandler>
-  ASIO_INITFN_RESULT_TYPE(WriteHandler,
-      void (asio::error_code, std::size_t))
-  async_send_to(implementation_type& impl,
-      const ConstBufferSequence& buffers, const endpoint_type& destination,
-      socket_base::message_flags flags,
-      ASIO_MOVE_ARG(WriteHandler) handler)
-  {
-    detail::async_result_init<
-      WriteHandler, void (asio::error_code, std::size_t)> init(
-        ASIO_MOVE_CAST(WriteHandler)(handler));
-
-    service_impl_.async_send_to(impl, buffers,
-        destination, flags, init.handler);
-
-    return init.result.get();
-  }
-
-  /// Receive some data from the peer.
-  template <typename MutableBufferSequence>
-  std::size_t receive(implementation_type& impl,
-      const MutableBufferSequence& buffers,
-      socket_base::message_flags flags, asio::error_code& ec)
-  {
-    return service_impl_.receive(impl, buffers, flags, ec);
-  }
-
-  /// Start an asynchronous receive.
-  template <typename MutableBufferSequence, typename ReadHandler>
-  ASIO_INITFN_RESULT_TYPE(ReadHandler,
-      void (asio::error_code, std::size_t))
-  async_receive(implementation_type& impl,
-      const MutableBufferSequence& buffers,
-      socket_base::message_flags flags,
-      ASIO_MOVE_ARG(ReadHandler) handler)
-  {
-    detail::async_result_init<
-      ReadHandler, void (asio::error_code, std::size_t)> init(
-        ASIO_MOVE_CAST(ReadHandler)(handler));
-
-    service_impl_.async_receive(impl, buffers, flags, init.handler);
-
-    return init.result.get();
-  }
-
-  /// Receive a datagram with the endpoint of the sender.
-  template <typename MutableBufferSequence>
-  std::size_t receive_from(implementation_type& impl,
-      const MutableBufferSequence& buffers, endpoint_type& sender_endpoint,
-      socket_base::message_flags flags, asio::error_code& ec)
-  {
-    return service_impl_.receive_from(impl, buffers, sender_endpoint, flags,
-        ec);
-  }
-
-  /// Start an asynchronous receive that will get the endpoint of the sender.
-  template <typename MutableBufferSequence, typename ReadHandler>
-  ASIO_INITFN_RESULT_TYPE(ReadHandler,
-      void (asio::error_code, std::size_t))
-  async_receive_from(implementation_type& impl,
-      const MutableBufferSequence& buffers, endpoint_type& sender_endpoint,
-      socket_base::message_flags flags,
-      ASIO_MOVE_ARG(ReadHandler) handler)
-  {
-    detail::async_result_init<
-      ReadHandler, void (asio::error_code, std::size_t)> init(
-        ASIO_MOVE_CAST(ReadHandler)(handler));
-
-    service_impl_.async_receive_from(impl, buffers,
-        sender_endpoint, flags, init.handler);
-
-    return init.result.get();
-  }
-
-private:
-  // Destroy all user-defined handler objects owned by the service.
-  void shutdown_service()
-  {
-    service_impl_.shutdown_service();
-  }
-
-  // The platform-specific implementation.
-  service_impl_type service_impl_;
-};
-
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_DATAGRAM_SOCKET_SERVICE_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/deadline_timer.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/deadline_timer.hpp
deleted file mode 100644
index c0b7fe844814..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/deadline_timer.hpp
+++ /dev/null
@@ -1,63 +0,0 @@
-//
-// deadline_timer.hpp
-// ~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DEADLINE_TIMER_HPP
-#define ASIO_DEADLINE_TIMER_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_HAS_BOOST_DATE_TIME) \
-  || defined(ASIO_CPP11_DATE_TIME) \
-  || defined(GENERATING_DOCUMENTATION)
-
-#include "asio/detail/socket_types.hpp" // Must come before posix_time.
-#include "asio/basic_deadline_timer.hpp"
-
-#if defined(ASIO_HAS_BOOST_DATE_TIME)
-
-#include "asio/detail/push_options.hpp"
-#include <boost/date_time/posix_time/posix_time_types.hpp>
-#include "asio/detail/pop_options.hpp"
-
-#elif defined(ASIO_CPP11_DATE_TIME)
-
-#include "asio/detail/chrono_time_traits.hpp"
-#include "asio/wait_traits.hpp"
-#include <chrono>
-
-#endif
-
-namespace asio {
-
-#if defined(ASIO_HAS_BOOST_DATE_TIME)
-/// Typedef for the typical usage of timer. Uses a UTC clock.
-typedef basic_deadline_timer<boost::posix_time::ptime> deadline_timer;
-
-#elif defined(ASIO_CPP11_DATE_TIME)
-
-typedef basic_deadline_timer<
-    std::chrono::system_clock,
-    detail::chrono_time_traits<std::chrono::system_clock,
-                               wait_traits<std::chrono::system_clock>>>
-    deadline_timer;
-
-#endif
-
-} // namespace asio
-
-#endif // defined(ASIO_HAS_BOOST_DATE_TIME)
-       // || defined(ASIO_CPP11_DATE_TIME)
-       // || defined(GENERATING_DOCUMENTATION)
-
-#endif // ASIO_DEADLINE_TIMER_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/deadline_timer_service.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/deadline_timer_service.hpp
deleted file mode 100644
index 990c2e755f6c..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/deadline_timer_service.hpp
+++ /dev/null
@@ -1,173 +0,0 @@
-//
-// deadline_timer_service.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DEADLINE_TIMER_SERVICE_HPP
-#define ASIO_DEADLINE_TIMER_SERVICE_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_HAS_BOOST_DATE_TIME) \
-  || defined(ASIO_CPP11_DATE_TIME) \
-  || defined(GENERATING_DOCUMENTATION)
-
-#include <cstddef>
-#include "asio/async_result.hpp"
-#include "asio/detail/deadline_timer_service.hpp"
-#include "asio/io_service.hpp"
-#include "asio/time_traits.hpp"
-#include "asio/detail/timer_queue_ptime.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-
-/// Default service implementation for a timer.
-template <typename TimeType,
-    typename TimeTraits = asio::time_traits<TimeType> >
-class deadline_timer_service
-#if defined(GENERATING_DOCUMENTATION)
-  : public asio::io_service::service
-#else
-  : public asio::detail::service_base<
-      deadline_timer_service<TimeType, TimeTraits> >
-#endif
-{
-public:
-#if defined(GENERATING_DOCUMENTATION)
-  /// The unique service identifier.
-  static asio::io_service::id id;
-#endif
-
-  /// The time traits type.
-  typedef TimeTraits traits_type;
-
-  /// The time type.
-  typedef typename traits_type::time_type time_type;
-
-  /// The duration type.
-  typedef typename traits_type::duration_type duration_type;
-
-private:
-  // The type of the platform-specific implementation.
-  typedef detail::deadline_timer_service<traits_type> service_impl_type;
-
-public:
-  /// The implementation type of the deadline timer.
-#if defined(GENERATING_DOCUMENTATION)
-  typedef implementation_defined implementation_type;
-#else
-  typedef typename service_impl_type::implementation_type implementation_type;
-#endif
-
-  /// Construct a new timer service for the specified io_service.
-  explicit deadline_timer_service(asio::io_service& io_service)
-    : asio::detail::service_base<
-        deadline_timer_service<TimeType, TimeTraits> >(io_service),
-      service_impl_(io_service)
-  {
-  }
-
-  /// Construct a new timer implementation.
-  void construct(implementation_type& impl)
-  {
-    service_impl_.construct(impl);
-  }
-
-  /// Destroy a timer implementation.
-  void destroy(implementation_type& impl)
-  {
-    service_impl_.destroy(impl);
-  }
-
-  /// Cancel any asynchronous wait operations associated with the timer.
-  std::size_t cancel(implementation_type& impl, asio::error_code& ec)
-  {
-    return service_impl_.cancel(impl, ec);
-  }
-
-  /// Cancels one asynchronous wait operation associated with the timer.
-  std::size_t cancel_one(implementation_type& impl,
-      asio::error_code& ec)
-  {
-    return service_impl_.cancel_one(impl, ec);
-  }
-
-  /// Get the expiry time for the timer as an absolute time.
-  time_type expires_at(const implementation_type& impl) const
-  {
-    return service_impl_.expires_at(impl);
-  }
-
-  /// Set the expiry time for the timer as an absolute time.
-  std::size_t expires_at(implementation_type& impl,
-      const time_type& expiry_time, asio::error_code& ec)
-  {
-    return service_impl_.expires_at(impl, expiry_time, ec);
-  }
-
-  /// Get the expiry time for the timer relative to now.
-  duration_type expires_from_now(const implementation_type& impl) const
-  {
-    return service_impl_.expires_from_now(impl);
-  }
-
-  /// Set the expiry time for the timer relative to now.
-  std::size_t expires_from_now(implementation_type& impl,
-      const duration_type& expiry_time, asio::error_code& ec)
-  {
-    return service_impl_.expires_from_now(impl, expiry_time, ec);
-  }
-
-  // Perform a blocking wait on the timer.
-  void wait(implementation_type& impl, asio::error_code& ec)
-  {
-    service_impl_.wait(impl, ec);
-  }
-
-  // Start an asynchronous wait on the timer.
-  template <typename WaitHandler>
-  ASIO_INITFN_RESULT_TYPE(WaitHandler,
-      void (asio::error_code))
-  async_wait(implementation_type& impl,
-      ASIO_MOVE_ARG(WaitHandler) handler)
-  {
-    detail::async_result_init<
-      WaitHandler, void (asio::error_code)> init(
-        ASIO_MOVE_CAST(WaitHandler)(handler));
-
-    service_impl_.async_wait(impl, init.handler);
-
-    return init.result.get();
-  }
-
-private:
-  // Destroy all user-defined handler objects owned by the service.
-  void shutdown_service()
-  {
-    service_impl_.shutdown_service();
-  }
-
-  // The platform-specific implementation.
-  service_impl_type service_impl_;
-};
-
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // defined(ASIO_HAS_BOOST_DATE_TIME)
-       // || defined(ASIO_CPP11_DATE_TIME)
-       // || defined(GENERATING_DOCUMENTATION)
-
-#endif // ASIO_DEADLINE_TIMER_SERVICE_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/addressof.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/addressof.hpp
deleted file mode 100644
index d09c70cc9510..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/addressof.hpp
+++ /dev/null
@@ -1,38 +0,0 @@
-//
-// detail/addressof.hpp
-// ~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_ADDRESSOF_HPP
-#define ASIO_DETAIL_ADDRESSOF_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_HAS_STD_ADDRESSOF)
-# include <memory>
-#else // defined(ASIO_HAS_STD_ADDRESSOF)
-# include <boost/utility/addressof.hpp>
-#endif // defined(ASIO_HAS_STD_ADDRESSOF)
-
-namespace asio {
-namespace detail {
-
-#if defined(ASIO_HAS_STD_ADDRESSOF)
-using std::addressof;
-#else // defined(ASIO_HAS_STD_ADDRESSOF)
-using boost::addressof;
-#endif // defined(ASIO_HAS_STD_ADDRESSOF)
-
-} // namespace detail
-} // namespace asio
-
-#endif // ASIO_DETAIL_ADDRESSOF_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/array.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/array.hpp
deleted file mode 100644
index 240a1ca864c9..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/array.hpp
+++ /dev/null
@@ -1,38 +0,0 @@
-//
-// detail/array.hpp
-// ~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_ARRAY_HPP
-#define ASIO_DETAIL_ARRAY_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_HAS_STD_ARRAY)
-# include <array>
-#else // defined(ASIO_HAS_STD_ARRAY)
-# include <boost/array.hpp>
-#endif // defined(ASIO_HAS_STD_ARRAY)
-
-namespace asio {
-namespace detail {
-
-#if defined(ASIO_HAS_STD_ARRAY)
-using std::array;
-#else // defined(ASIO_HAS_STD_ARRAY)
-using boost::array;
-#endif // defined(ASIO_HAS_STD_ARRAY)
-
-} // namespace detail
-} // namespace asio
-
-#endif // ASIO_DETAIL_ARRAY_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/array_fwd.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/array_fwd.hpp
deleted file mode 100644
index 84ee3b1ee4b6..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/array_fwd.hpp
+++ /dev/null
@@ -1,34 +0,0 @@
-//
-// detail/array_fwd.hpp
-// ~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_ARRAY_FWD_HPP
-#define ASIO_DETAIL_ARRAY_FWD_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-namespace boost {
-
-template<class T, std::size_t N>
-class array;
-
-} // namespace boost
-
-// Standard library components can't be forward declared, so we'll have to
-// include the array header. Fortunately, it's fairly lightweight and doesn't
-// add significantly to the compile time.
-#if defined(ASIO_HAS_STD_ARRAY)
-# include <array>
-#endif // defined(ASIO_HAS_STD_ARRAY)
-
-#endif // ASIO_DETAIL_ARRAY_FWD_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/assert.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/assert.hpp
deleted file mode 100644
index 32ec0dd81c5e..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/assert.hpp
+++ /dev/null
@@ -1,32 +0,0 @@
-//
-// detail/assert.hpp
-// ~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_ASSERT_HPP
-#define ASIO_DETAIL_ASSERT_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_HAS_BOOST_ASSERT)
-# include <boost/assert.hpp>
-#else // defined(ASIO_HAS_BOOST_ASSERT)
-# include <cassert>
-#endif // defined(ASIO_HAS_BOOST_ASSERT)
-
-#if defined(ASIO_HAS_BOOST_ASSERT)
-# define ASIO_ASSERT(expr) BOOST_ASSERT(expr)
-#else // defined(ASIO_HAS_BOOST_ASSERT)
-# define ASIO_ASSERT(expr) assert(expr)
-#endif // defined(ASIO_HAS_BOOST_ASSERT)
-
-#endif // ASIO_DETAIL_ASSERT_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/atomic_count.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/atomic_count.hpp
deleted file mode 100644
index a83f7038a13d..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/atomic_count.hpp
+++ /dev/null
@@ -1,45 +0,0 @@
-//
-// detail/atomic_count.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_ATOMIC_COUNT_HPP
-#define ASIO_DETAIL_ATOMIC_COUNT_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if !defined(ASIO_HAS_THREADS)
-// Nothing to include.
-#elif defined(ASIO_HAS_STD_ATOMIC)
-# include <atomic>
-#else // defined(ASIO_HAS_STD_ATOMIC)
-# include <boost/detail/atomic_count.hpp>
-#endif // defined(ASIO_HAS_STD_ATOMIC)
-
-namespace asio {
-namespace detail {
-
-#if !defined(ASIO_HAS_THREADS)
-typedef long atomic_count;
-inline void increment(atomic_count& a, long b) { a += b; }
-#elif defined(ASIO_HAS_STD_ATOMIC)
-typedef std::atomic<long> atomic_count;
-inline void increment(atomic_count& a, long b) { a += b; }
-#else // defined(ASIO_HAS_STD_ATOMIC)
-typedef boost::detail::atomic_count atomic_count;
-inline void increment(atomic_count& a, long b) { while (b > 0) ++a, --b; }
-#endif // defined(ASIO_HAS_STD_ATOMIC)
-
-} // namespace detail
-} // namespace asio
-
-#endif // ASIO_DETAIL_ATOMIC_COUNT_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/base_from_completion_cond.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/base_from_completion_cond.hpp
deleted file mode 100644
index e78a13f9b55b..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/base_from_completion_cond.hpp
+++ /dev/null
@@ -1,68 +0,0 @@
-//
-// detail/base_from_completion_cond.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_BASE_FROM_COMPLETION_COND_HPP
-#define ASIO_DETAIL_BASE_FROM_COMPLETION_COND_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include "asio/completion_condition.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-template <typename CompletionCondition>
-class base_from_completion_cond
-{
-protected:
-  explicit base_from_completion_cond(CompletionCondition completion_condition)
-    : completion_condition_(completion_condition)
-  {
-  }
-
-  std::size_t check_for_completion(
-      const asio::error_code& ec,
-      std::size_t total_transferred)
-  {
-    return detail::adapt_completion_condition_result(
-        completion_condition_(ec, total_transferred));
-  }
-
-private:
-  CompletionCondition completion_condition_;
-};
-
-template <>
-class base_from_completion_cond<transfer_all_t>
-{
-protected:
-  explicit base_from_completion_cond(transfer_all_t)
-  {
-  }
-
-  static std::size_t check_for_completion(
-      const asio::error_code& ec,
-      std::size_t total_transferred)
-  {
-    return transfer_all_t()(ec, total_transferred);
-  }
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_DETAIL_BASE_FROM_COMPLETION_COND_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/bind_handler.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/bind_handler.hpp
deleted file mode 100644
index 9ecea5234d58..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/bind_handler.hpp
+++ /dev/null
@@ -1,489 +0,0 @@
-//
-// detail/bind_handler.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_BIND_HANDLER_HPP
-#define ASIO_DETAIL_BIND_HANDLER_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include "asio/detail/handler_alloc_helpers.hpp"
-#include "asio/detail/handler_cont_helpers.hpp"
-#include "asio/detail/handler_invoke_helpers.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-template <typename Handler, typename Arg1>
-class binder1
-{
-public:
-  binder1(const Handler& handler, const Arg1& arg1)
-    : handler_(handler),
-      arg1_(arg1)
-  {
-  }
-
-  binder1(Handler& handler, const Arg1& arg1)
-    : handler_(ASIO_MOVE_CAST(Handler)(handler)),
-      arg1_(arg1)
-  {
-  }
-
-  void operator()()
-  {
-    handler_(static_cast<const Arg1&>(arg1_));
-  }
-
-  void operator()() const
-  {
-    handler_(arg1_);
-  }
-
-//private:
-  Handler handler_;
-  Arg1 arg1_;
-};
-
-template <typename Handler, typename Arg1>
-inline void* asio_handler_allocate(std::size_t size,
-    binder1<Handler, Arg1>* this_handler)
-{
-  return asio_handler_alloc_helpers::allocate(
-      size, this_handler->handler_);
-}
-
-template <typename Handler, typename Arg1>
-inline void asio_handler_deallocate(void* pointer, std::size_t size,
-    binder1<Handler, Arg1>* this_handler)
-{
-  asio_handler_alloc_helpers::deallocate(
-      pointer, size, this_handler->handler_);
-}
-
-template <typename Handler, typename Arg1>
-inline bool asio_handler_is_continuation(
-    binder1<Handler, Arg1>* this_handler)
-{
-  return asio_handler_cont_helpers::is_continuation(
-      this_handler->handler_);
-}
-
-template <typename Function, typename Handler, typename Arg1>
-inline void asio_handler_invoke(Function& function,
-    binder1<Handler, Arg1>* this_handler)
-{
-  asio_handler_invoke_helpers::invoke(
-      function, this_handler->handler_);
-}
-
-template <typename Function, typename Handler, typename Arg1>
-inline void asio_handler_invoke(const Function& function,
-    binder1<Handler, Arg1>* this_handler)
-{
-  asio_handler_invoke_helpers::invoke(
-      function, this_handler->handler_);
-}
-
-template <typename Handler, typename Arg1>
-inline binder1<Handler, Arg1> bind_handler(Handler handler,
-    const Arg1& arg1)
-{
-  return binder1<Handler, Arg1>(handler, arg1);
-}
-
-template <typename Handler, typename Arg1, typename Arg2>
-class binder2
-{
-public:
-  binder2(const Handler& handler, const Arg1& arg1, const Arg2& arg2)
-    : handler_(handler),
-      arg1_(arg1),
-      arg2_(arg2)
-  {
-  }
-
-  binder2(Handler& handler, const Arg1& arg1, const Arg2& arg2)
-    : handler_(ASIO_MOVE_CAST(Handler)(handler)),
-      arg1_(arg1),
-      arg2_(arg2)
-  {
-  }
-
-  void operator()()
-  {
-    handler_(static_cast<const Arg1&>(arg1_),
-        static_cast<const Arg2&>(arg2_));
-  }
-
-  void operator()() const
-  {
-    handler_(arg1_, arg2_);
-  }
-
-//private:
-  Handler handler_;
-  Arg1 arg1_;
-  Arg2 arg2_;
-};
-
-template <typename Handler, typename Arg1, typename Arg2>
-inline void* asio_handler_allocate(std::size_t size,
-    binder2<Handler, Arg1, Arg2>* this_handler)
-{
-  return asio_handler_alloc_helpers::allocate(
-      size, this_handler->handler_);
-}
-
-template <typename Handler, typename Arg1, typename Arg2>
-inline void asio_handler_deallocate(void* pointer, std::size_t size,
-    binder2<Handler, Arg1, Arg2>* this_handler)
-{
-  asio_handler_alloc_helpers::deallocate(
-      pointer, size, this_handler->handler_);
-}
-
-template <typename Handler, typename Arg1, typename Arg2>
-inline bool asio_handler_is_continuation(
-    binder2<Handler, Arg1, Arg2>* this_handler)
-{
-  return asio_handler_cont_helpers::is_continuation(
-      this_handler->handler_);
-}
-
-template <typename Function, typename Handler, typename Arg1, typename Arg2>
-inline void asio_handler_invoke(Function& function,
-    binder2<Handler, Arg1, Arg2>* this_handler)
-{
-  asio_handler_invoke_helpers::invoke(
-      function, this_handler->handler_);
-}
-
-template <typename Function, typename Handler, typename Arg1, typename Arg2>
-inline void asio_handler_invoke(const Function& function,
-    binder2<Handler, Arg1, Arg2>* this_handler)
-{
-  asio_handler_invoke_helpers::invoke(
-      function, this_handler->handler_);
-}
-
-template <typename Handler, typename Arg1, typename Arg2>
-inline binder2<Handler, Arg1, Arg2> bind_handler(Handler handler,
-    const Arg1& arg1, const Arg2& arg2)
-{
-  return binder2<Handler, Arg1, Arg2>(handler, arg1, arg2);
-}
-
-template <typename Handler, typename Arg1, typename Arg2, typename Arg3>
-class binder3
-{
-public:
-  binder3(const Handler& handler, const Arg1& arg1, const Arg2& arg2,
-      const Arg3& arg3)
-    : handler_(handler),
-      arg1_(arg1),
-      arg2_(arg2),
-      arg3_(arg3)
-  {
-  }
-
-  binder3(Handler& handler, const Arg1& arg1, const Arg2& arg2,
-      const Arg3& arg3)
-    : handler_(ASIO_MOVE_CAST(Handler)(handler)),
-      arg1_(arg1),
-      arg2_(arg2),
-      arg3_(arg3)
-  {
-  }
-
-  void operator()()
-  {
-    handler_(static_cast<const Arg1&>(arg1_),
-        static_cast<const Arg2&>(arg2_),
-        static_cast<const Arg3&>(arg3_));
-  }
-
-  void operator()() const
-  {
-    handler_(arg1_, arg2_, arg3_);
-  }
-
-//private:
-  Handler handler_;
-  Arg1 arg1_;
-  Arg2 arg2_;
-  Arg3 arg3_;
-};
-
-template <typename Handler, typename Arg1, typename Arg2, typename Arg3>
-inline void* asio_handler_allocate(std::size_t size,
-    binder3<Handler, Arg1, Arg2, Arg3>* this_handler)
-{
-  return asio_handler_alloc_helpers::allocate(
-      size, this_handler->handler_);
-}
-
-template <typename Handler, typename Arg1, typename Arg2, typename Arg3>
-inline void asio_handler_deallocate(void* pointer, std::size_t size,
-    binder3<Handler, Arg1, Arg2, Arg3>* this_handler)
-{
-  asio_handler_alloc_helpers::deallocate(
-      pointer, size, this_handler->handler_);
-}
-
-template <typename Handler, typename Arg1, typename Arg2, typename Arg3>
-inline bool asio_handler_is_continuation(
-    binder3<Handler, Arg1, Arg2, Arg3>* this_handler)
-{
-  return asio_handler_cont_helpers::is_continuation(
-      this_handler->handler_);
-}
-
-template <typename Function, typename Handler, typename Arg1, typename Arg2,
-    typename Arg3>
-inline void asio_handler_invoke(Function& function,
-    binder3<Handler, Arg1, Arg2, Arg3>* this_handler)
-{
-  asio_handler_invoke_helpers::invoke(
-      function, this_handler->handler_);
-}
-
-template <typename Function, typename Handler, typename Arg1, typename Arg2,
-    typename Arg3>
-inline void asio_handler_invoke(const Function& function,
-    binder3<Handler, Arg1, Arg2, Arg3>* this_handler)
-{
-  asio_handler_invoke_helpers::invoke(
-      function, this_handler->handler_);
-}
-
-template <typename Handler, typename Arg1, typename Arg2, typename Arg3>
-inline binder3<Handler, Arg1, Arg2, Arg3> bind_handler(Handler handler,
-    const Arg1& arg1, const Arg2& arg2, const Arg3& arg3)
-{
-  return binder3<Handler, Arg1, Arg2, Arg3>(handler, arg1, arg2, arg3);
-}
-
-template <typename Handler, typename Arg1, typename Arg2, typename Arg3,
-    typename Arg4>
-class binder4
-{
-public:
-  binder4(const Handler& handler, const Arg1& arg1, const Arg2& arg2,
-      const Arg3& arg3, const Arg4& arg4)
-    : handler_(handler),
-      arg1_(arg1),
-      arg2_(arg2),
-      arg3_(arg3),
-      arg4_(arg4)
-  {
-  }
-
-  binder4(Handler& handler, const Arg1& arg1, const Arg2& arg2,
-      const Arg3& arg3, const Arg4& arg4)
-    : handler_(ASIO_MOVE_CAST(Handler)(handler)),
-      arg1_(arg1),
-      arg2_(arg2),
-      arg3_(arg3),
-      arg4_(arg4)
-  {
-  }
-
-  void operator()()
-  {
-    handler_(static_cast<const Arg1&>(arg1_),
-        static_cast<const Arg2&>(arg2_),
-        static_cast<const Arg3&>(arg3_),
-        static_cast<const Arg4&>(arg4_));
-  }
-
-  void operator()() const
-  {
-    handler_(arg1_, arg2_, arg3_, arg4_);
-  }
-
-//private:
-  Handler handler_;
-  Arg1 arg1_;
-  Arg2 arg2_;
-  Arg3 arg3_;
-  Arg4 arg4_;
-};
-
-template <typename Handler, typename Arg1, typename Arg2, typename Arg3,
-    typename Arg4>
-inline void* asio_handler_allocate(std::size_t size,
-    binder4<Handler, Arg1, Arg2, Arg3, Arg4>* this_handler)
-{
-  return asio_handler_alloc_helpers::allocate(
-      size, this_handler->handler_);
-}
-
-template <typename Handler, typename Arg1, typename Arg2, typename Arg3,
-    typename Arg4>
-inline void asio_handler_deallocate(void* pointer, std::size_t size,
-    binder4<Handler, Arg1, Arg2, Arg3, Arg4>* this_handler)
-{
-  asio_handler_alloc_helpers::deallocate(
-      pointer, size, this_handler->handler_);
-}
-
-template <typename Handler, typename Arg1, typename Arg2, typename Arg3,
-    typename Arg4>
-inline bool asio_handler_is_continuation(
-    binder4<Handler, Arg1, Arg2, Arg3, Arg4>* this_handler)
-{
-  return asio_handler_cont_helpers::is_continuation(
-      this_handler->handler_);
-}
-
-template <typename Function, typename Handler, typename Arg1, typename Arg2,
-    typename Arg3, typename Arg4>
-inline void asio_handler_invoke(Function& function,
-    binder4<Handler, Arg1, Arg2, Arg3, Arg4>* this_handler)
-{
-  asio_handler_invoke_helpers::invoke(
-      function, this_handler->handler_);
-}
-
-template <typename Function, typename Handler, typename Arg1, typename Arg2,
-    typename Arg3, typename Arg4>
-inline void asio_handler_invoke(const Function& function,
-    binder4<Handler, Arg1, Arg2, Arg3, Arg4>* this_handler)
-{
-  asio_handler_invoke_helpers::invoke(
-      function, this_handler->handler_);
-}
-
-template <typename Handler, typename Arg1, typename Arg2, typename Arg3,
-    typename Arg4>
-inline binder4<Handler, Arg1, Arg2, Arg3, Arg4> bind_handler(
-    Handler handler, const Arg1& arg1, const Arg2& arg2,
-    const Arg3& arg3, const Arg4& arg4)
-{
-  return binder4<Handler, Arg1, Arg2, Arg3, Arg4>(handler, arg1, arg2, arg3,
-      arg4);
-}
-
-template <typename Handler, typename Arg1, typename Arg2, typename Arg3,
-    typename Arg4, typename Arg5>
-class binder5
-{
-public:
-  binder5(const Handler& handler, const Arg1& arg1, const Arg2& arg2,
-      const Arg3& arg3, const Arg4& arg4, const Arg5& arg5)
-    : handler_(handler),
-      arg1_(arg1),
-      arg2_(arg2),
-      arg3_(arg3),
-      arg4_(arg4),
-      arg5_(arg5)
-  {
-  }
-
-  binder5(Handler& handler, const Arg1& arg1, const Arg2& arg2,
-      const Arg3& arg3, const Arg4& arg4, const Arg5& arg5)
-    : handler_(ASIO_MOVE_CAST(Handler)(handler)),
-      arg1_(arg1),
-      arg2_(arg2),
-      arg3_(arg3),
-      arg4_(arg4),
-      arg5_(arg5)
-  {
-  }
-
-  void operator()()
-  {
-    handler_(static_cast<const Arg1&>(arg1_),
-        static_cast<const Arg2&>(arg2_),
-        static_cast<const Arg3&>(arg3_),
-        static_cast<const Arg4&>(arg4_),
-        static_cast<const Arg5&>(arg5_));
-  }
-
-  void operator()() const
-  {
-    handler_(arg1_, arg2_, arg3_, arg4_, arg5_);
-  }
-
-//private:
-  Handler handler_;
-  Arg1 arg1_;
-  Arg2 arg2_;
-  Arg3 arg3_;
-  Arg4 arg4_;
-  Arg5 arg5_;
-};
-
-template <typename Handler, typename Arg1, typename Arg2, typename Arg3,
-    typename Arg4, typename Arg5>
-inline void* asio_handler_allocate(std::size_t size,
-    binder5<Handler, Arg1, Arg2, Arg3, Arg4, Arg5>* this_handler)
-{
-  return asio_handler_alloc_helpers::allocate(
-      size, this_handler->handler_);
-}
-
-template <typename Handler, typename Arg1, typename Arg2, typename Arg3,
-    typename Arg4, typename Arg5>
-inline void asio_handler_deallocate(void* pointer, std::size_t size,
-    binder5<Handler, Arg1, Arg2, Arg3, Arg4, Arg5>* this_handler)
-{
-  asio_handler_alloc_helpers::deallocate(
-      pointer, size, this_handler->handler_);
-}
-
-template <typename Handler, typename Arg1, typename Arg2, typename Arg3,
-    typename Arg4, typename Arg5>
-inline bool asio_handler_is_continuation(
-    binder5<Handler, Arg1, Arg2, Arg3, Arg4, Arg5>* this_handler)
-{
-  return asio_handler_cont_helpers::is_continuation(
-      this_handler->handler_);
-}
-
-template <typename Function, typename Handler, typename Arg1, typename Arg2,
-    typename Arg3, typename Arg4, typename Arg5>
-inline void asio_handler_invoke(Function& function,
-    binder5<Handler, Arg1, Arg2, Arg3, Arg4, Arg5>* this_handler)
-{
-  asio_handler_invoke_helpers::invoke(
-      function, this_handler->handler_);
-}
-
-template <typename Function, typename Handler, typename Arg1, typename Arg2,
-    typename Arg3, typename Arg4, typename Arg5>
-inline void asio_handler_invoke(const Function& function,
-    binder5<Handler, Arg1, Arg2, Arg3, Arg4, Arg5>* this_handler)
-{
-  asio_handler_invoke_helpers::invoke(
-      function, this_handler->handler_);
-}
-
-template <typename Handler, typename Arg1, typename Arg2, typename Arg3,
-    typename Arg4, typename Arg5>
-inline binder5<Handler, Arg1, Arg2, Arg3, Arg4, Arg5> bind_handler(
-    Handler handler, const Arg1& arg1, const Arg2& arg2,
-    const Arg3& arg3, const Arg4& arg4, const Arg5& arg5)
-{
-  return binder5<Handler, Arg1, Arg2, Arg3, Arg4, Arg5>(handler, arg1, arg2,
-      arg3, arg4, arg5);
-}
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_DETAIL_BIND_HANDLER_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/buffer_resize_guard.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/buffer_resize_guard.hpp
deleted file mode 100644
index 0d01c506ba4a..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/buffer_resize_guard.hpp
+++ /dev/null
@@ -1,66 +0,0 @@
-//
-// detail/buffer_resize_guard.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_BUFFER_RESIZE_GUARD_HPP
-#define ASIO_DETAIL_BUFFER_RESIZE_GUARD_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include "asio/detail/limits.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-// Helper class to manage buffer resizing in an exception safe way.
-template <typename Buffer>
-class buffer_resize_guard
-{
-public:
-  // Constructor.
-  buffer_resize_guard(Buffer& buffer)
-    : buffer_(buffer),
-      old_size_(buffer.size())
-  {
-  }
-
-  // Destructor rolls back the buffer resize unless commit was called.
-  ~buffer_resize_guard()
-  {
-    if (old_size_ != (std::numeric_limits<size_t>::max)())
-    {
-      buffer_.resize(old_size_);
-    }
-  }
-
-  // Commit the resize transaction.
-  void commit()
-  {
-    old_size_ = (std::numeric_limits<size_t>::max)();
-  }
-
-private:
-  // The buffer being managed.
-  Buffer& buffer_;
-
-  // The size of the buffer at the time the guard was constructed.
-  size_t old_size_;
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_DETAIL_BUFFER_RESIZE_GUARD_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/buffer_sequence_adapter.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/buffer_sequence_adapter.hpp
deleted file mode 100644
index f0ba0ea9bc21..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/buffer_sequence_adapter.hpp
+++ /dev/null
@@ -1,383 +0,0 @@
-//
-// detail/buffer_sequence_adapter.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_BUFFER_SEQUENCE_ADAPTER_HPP
-#define ASIO_DETAIL_BUFFER_SEQUENCE_ADAPTER_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include "asio/buffer.hpp"
-#include "asio/detail/array_fwd.hpp"
-#include "asio/detail/socket_types.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-class buffer_sequence_adapter_base
-{
-protected:
-#if defined(ASIO_WINDOWS_RUNTIME)
-  // The maximum number of buffers to support in a single operation.
-  enum { max_buffers = 1 };
-
-  typedef Windows::Storage::Streams::IBuffer^ native_buffer_type;
-
-  ASIO_DECL static void init_native_buffer(
-      native_buffer_type& buf,
-      const asio::mutable_buffer& buffer);
-
-  ASIO_DECL static void init_native_buffer(
-      native_buffer_type& buf,
-      const asio::const_buffer& buffer);
-#elif defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-  // The maximum number of buffers to support in a single operation.
-  enum { max_buffers = 64 < max_iov_len ? 64 : max_iov_len };
-
-  typedef WSABUF native_buffer_type;
-
-  static void init_native_buffer(WSABUF& buf,
-      const asio::mutable_buffer& buffer)
-  {
-    buf.buf = asio::buffer_cast<char*>(buffer);
-    buf.len = static_cast<ULONG>(asio::buffer_size(buffer));
-  }
-
-  static void init_native_buffer(WSABUF& buf,
-      const asio::const_buffer& buffer)
-  {
-    buf.buf = const_cast<char*>(asio::buffer_cast<const char*>(buffer));
-    buf.len = static_cast<ULONG>(asio::buffer_size(buffer));
-  }
-#else // defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-  // The maximum number of buffers to support in a single operation.
-  enum { max_buffers = 64 < max_iov_len ? 64 : max_iov_len };
-
-  typedef iovec native_buffer_type;
-
-  static void init_iov_base(void*& base, void* addr)
-  {
-    base = addr;
-  }
-
-  template <typename T>
-  static void init_iov_base(T& base, void* addr)
-  {
-    base = static_cast<T>(addr);
-  }
-
-  static void init_native_buffer(iovec& iov,
-      const asio::mutable_buffer& buffer)
-  {
-    init_iov_base(iov.iov_base, asio::buffer_cast<void*>(buffer));
-    iov.iov_len = asio::buffer_size(buffer);
-  }
-
-  static void init_native_buffer(iovec& iov,
-      const asio::const_buffer& buffer)
-  {
-    init_iov_base(iov.iov_base, const_cast<void*>(
-          asio::buffer_cast<const void*>(buffer)));
-    iov.iov_len = asio::buffer_size(buffer);
-  }
-#endif // defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-};
-
-// Helper class to translate buffers into the native buffer representation.
-template <typename Buffer, typename Buffers>
-class buffer_sequence_adapter
-  : buffer_sequence_adapter_base
-{
-public:
-  explicit buffer_sequence_adapter(const Buffers& buffer_sequence)
-    : count_(0), total_buffer_size_(0)
-  {
-    typename Buffers::const_iterator iter = buffer_sequence.begin();
-    typename Buffers::const_iterator end = buffer_sequence.end();
-    for (; iter != end && count_ < max_buffers; ++iter, ++count_)
-    {
-      Buffer buffer(*iter);
-      init_native_buffer(buffers_[count_], buffer);
-      total_buffer_size_ += asio::buffer_size(buffer);
-    }
-  }
-
-  native_buffer_type* buffers()
-  {
-    return buffers_;
-  }
-
-  std::size_t count() const
-  {
-    return count_;
-  }
-
-  bool all_empty() const
-  {
-    return total_buffer_size_ == 0;
-  }
-
-  static bool all_empty(const Buffers& buffer_sequence)
-  {
-    typename Buffers::const_iterator iter = buffer_sequence.begin();
-    typename Buffers::const_iterator end = buffer_sequence.end();
-    std::size_t i = 0;
-    for (; iter != end && i < max_buffers; ++iter, ++i)
-      if (asio::buffer_size(Buffer(*iter)) > 0)
-        return false;
-    return true;
-  }
-
-  static void validate(const Buffers& buffer_sequence)
-  {
-    typename Buffers::const_iterator iter = buffer_sequence.begin();
-    typename Buffers::const_iterator end = buffer_sequence.end();
-    for (; iter != end; ++iter)
-    {
-      Buffer buffer(*iter);
-      asio::buffer_cast<const void*>(buffer);
-    }
-  }
-
-  static Buffer first(const Buffers& buffer_sequence)
-  {
-    typename Buffers::const_iterator iter = buffer_sequence.begin();
-    typename Buffers::const_iterator end = buffer_sequence.end();
-    for (; iter != end; ++iter)
-    {
-      Buffer buffer(*iter);
-      if (asio::buffer_size(buffer) != 0)
-        return buffer;
-    }
-    return Buffer();
-  }
-
-private:
-  native_buffer_type buffers_[max_buffers];
-  std::size_t count_;
-  std::size_t total_buffer_size_;
-};
-
-template <typename Buffer>
-class buffer_sequence_adapter<Buffer, asio::mutable_buffers_1>
-  : buffer_sequence_adapter_base
-{
-public:
-  explicit buffer_sequence_adapter(
-      const asio::mutable_buffers_1& buffer_sequence)
-  {
-    init_native_buffer(buffer_, Buffer(buffer_sequence));
-    total_buffer_size_ = asio::buffer_size(buffer_sequence);
-  }
-
-  native_buffer_type* buffers()
-  {
-    return &buffer_;
-  }
-
-  std::size_t count() const
-  {
-    return 1;
-  }
-
-  bool all_empty() const
-  {
-    return total_buffer_size_ == 0;
-  }
-
-  static bool all_empty(const asio::mutable_buffers_1& buffer_sequence)
-  {
-    return asio::buffer_size(buffer_sequence) == 0;
-  }
-
-  static void validate(const asio::mutable_buffers_1& buffer_sequence)
-  {
-    asio::buffer_cast<const void*>(buffer_sequence);
-  }
-
-  static Buffer first(const asio::mutable_buffers_1& buffer_sequence)
-  {
-    return Buffer(buffer_sequence);
-  }
-
-private:
-  native_buffer_type buffer_;
-  std::size_t total_buffer_size_;
-};
-
-template <typename Buffer>
-class buffer_sequence_adapter<Buffer, asio::const_buffers_1>
-  : buffer_sequence_adapter_base
-{
-public:
-  explicit buffer_sequence_adapter(
-      const asio::const_buffers_1& buffer_sequence)
-  {
-    init_native_buffer(buffer_, Buffer(buffer_sequence));
-    total_buffer_size_ = asio::buffer_size(buffer_sequence);
-  }
-
-  native_buffer_type* buffers()
-  {
-    return &buffer_;
-  }
-
-  std::size_t count() const
-  {
-    return 1;
-  }
-
-  bool all_empty() const
-  {
-    return total_buffer_size_ == 0;
-  }
-
-  static bool all_empty(const asio::const_buffers_1& buffer_sequence)
-  {
-    return asio::buffer_size(buffer_sequence) == 0;
-  }
-
-  static void validate(const asio::const_buffers_1& buffer_sequence)
-  {
-    asio::buffer_cast<const void*>(buffer_sequence);
-  }
-
-  static Buffer first(const asio::const_buffers_1& buffer_sequence)
-  {
-    return Buffer(buffer_sequence);
-  }
-
-private:
-  native_buffer_type buffer_;
-  std::size_t total_buffer_size_;
-};
-
-template <typename Buffer, typename Elem>
-class buffer_sequence_adapter<Buffer, boost::array<Elem, 2> >
-  : buffer_sequence_adapter_base
-{
-public:
-  explicit buffer_sequence_adapter(
-      const boost::array<Elem, 2>& buffer_sequence)
-  {
-    init_native_buffer(buffers_[0], Buffer(buffer_sequence[0]));
-    init_native_buffer(buffers_[1], Buffer(buffer_sequence[1]));
-    total_buffer_size_ = asio::buffer_size(buffer_sequence[0])
-      + asio::buffer_size(buffer_sequence[1]);
-  }
-
-  native_buffer_type* buffers()
-  {
-    return buffers_;
-  }
-
-  std::size_t count() const
-  {
-    return 2;
-  }
-
-  bool all_empty() const
-  {
-    return total_buffer_size_ == 0;
-  }
-
-  static bool all_empty(const boost::array<Elem, 2>& buffer_sequence)
-  {
-    return asio::buffer_size(buffer_sequence[0]) == 0
-      && asio::buffer_size(buffer_sequence[1]) == 0;
-  }
-
-  static void validate(const boost::array<Elem, 2>& buffer_sequence)
-  {
-    asio::buffer_cast<const void*>(buffer_sequence[0]);
-    asio::buffer_cast<const void*>(buffer_sequence[1]);
-  }
-
-  static Buffer first(const boost::array<Elem, 2>& buffer_sequence)
-  {
-    return Buffer(asio::buffer_size(buffer_sequence[0]) != 0
-        ? buffer_sequence[0] : buffer_sequence[1]);
-  }
-
-private:
-  native_buffer_type buffers_[2];
-  std::size_t total_buffer_size_;
-};
-
-#if defined(ASIO_HAS_STD_ARRAY)
-
-template <typename Buffer, typename Elem>
-class buffer_sequence_adapter<Buffer, std::array<Elem, 2> >
-  : buffer_sequence_adapter_base
-{
-public:
-  explicit buffer_sequence_adapter(
-      const std::array<Elem, 2>& buffer_sequence)
-  {
-    init_native_buffer(buffers_[0], Buffer(buffer_sequence[0]));
-    init_native_buffer(buffers_[1], Buffer(buffer_sequence[1]));
-    total_buffer_size_ = asio::buffer_size(buffer_sequence[0])
-      + asio::buffer_size(buffer_sequence[1]);
-  }
-
-  native_buffer_type* buffers()
-  {
-    return buffers_;
-  }
-
-  std::size_t count() const
-  {
-    return 2;
-  }
-
-  bool all_empty() const
-  {
-    return total_buffer_size_ == 0;
-  }
-
-  static bool all_empty(const std::array<Elem, 2>& buffer_sequence)
-  {
-    return asio::buffer_size(buffer_sequence[0]) == 0
-      && asio::buffer_size(buffer_sequence[1]) == 0;
-  }
-
-  static void validate(const std::array<Elem, 2>& buffer_sequence)
-  {
-    asio::buffer_cast<const void*>(buffer_sequence[0]);
-    asio::buffer_cast<const void*>(buffer_sequence[1]);
-  }
-
-  static Buffer first(const std::array<Elem, 2>& buffer_sequence)
-  {
-    return Buffer(asio::buffer_size(buffer_sequence[0]) != 0
-        ? buffer_sequence[0] : buffer_sequence[1]);
-  }
-
-private:
-  native_buffer_type buffers_[2];
-  std::size_t total_buffer_size_;
-};
-
-#endif // defined(ASIO_HAS_STD_ARRAY)
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#if defined(ASIO_HEADER_ONLY)
-# include "asio/detail/impl/buffer_sequence_adapter.ipp"
-#endif // defined(ASIO_HEADER_ONLY)
-
-#endif // ASIO_DETAIL_BUFFER_SEQUENCE_ADAPTER_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/buffered_stream_storage.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/buffered_stream_storage.hpp
deleted file mode 100644
index 5fd9f7929f3a..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/buffered_stream_storage.hpp
+++ /dev/null
@@ -1,126 +0,0 @@
-//
-// detail/buffered_stream_storage.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_BUFFERED_STREAM_STORAGE_HPP
-#define ASIO_DETAIL_BUFFERED_STREAM_STORAGE_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include "asio/buffer.hpp"
-#include "asio/detail/assert.hpp"
-#include <cstddef>
-#include <cstring>
-#include <vector>
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-class buffered_stream_storage
-{
-public:
-  // The type of the bytes stored in the buffer.
-  typedef unsigned char byte_type;
-
-  // The type used for offsets into the buffer.
-  typedef std::size_t size_type;
-
-  // Constructor.
-  explicit buffered_stream_storage(std::size_t buffer_capacity)
-    : begin_offset_(0),
-      end_offset_(0),
-      buffer_(buffer_capacity)
-  {
-  }
-
-  /// Clear the buffer.
-  void clear()
-  {
-    begin_offset_ = 0;
-    end_offset_ = 0;
-  }
-
-  // Return a pointer to the beginning of the unread data.
-  mutable_buffer data()
-  {
-    return asio::buffer(buffer_) + begin_offset_;
-  }
-
-  // Return a pointer to the beginning of the unread data.
-  const_buffer data() const
-  {
-    return asio::buffer(buffer_) + begin_offset_;
-  }
-
-  // Is there no unread data in the buffer.
-  bool empty() const
-  {
-    return begin_offset_ == end_offset_;
-  }
-
-  // Return the amount of unread data the is in the buffer.
-  size_type size() const
-  {
-    return end_offset_ - begin_offset_;
-  }
-
-  // Resize the buffer to the specified length.
-  void resize(size_type length)
-  {
-    ASIO_ASSERT(length <= capacity());
-    if (begin_offset_ + length <= capacity())
-    {
-      end_offset_ = begin_offset_ + length;
-    }
-    else
-    {
-      using namespace std; // For memmove.
-      memmove(&buffer_[0], &buffer_[0] + begin_offset_, size());
-      end_offset_ = length;
-      begin_offset_ = 0;
-    }
-  }
-
-  // Return the maximum size for data in the buffer.
-  size_type capacity() const
-  {
-    return buffer_.size();
-  }
-
-  // Consume multiple bytes from the beginning of the buffer.
-  void consume(size_type count)
-  {
-    ASIO_ASSERT(begin_offset_ + count <= end_offset_);
-    begin_offset_ += count;
-    if (empty())
-      clear();
-  }
-
-private:
-  // The offset to the beginning of the unread data.
-  size_type begin_offset_;
-
-  // The offset to the end of the unread data.
-  size_type end_offset_;
-  
-  // The data in the buffer.
-  std::vector<byte_type> buffer_;
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_DETAIL_BUFFERED_STREAM_STORAGE_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/call_stack.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/call_stack.hpp
deleted file mode 100644
index e3496ca50137..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/call_stack.hpp
+++ /dev/null
@@ -1,125 +0,0 @@
-//
-// detail/call_stack.hpp
-// ~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_CALL_STACK_HPP
-#define ASIO_DETAIL_CALL_STACK_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include "asio/detail/noncopyable.hpp"
-#include "asio/detail/tss_ptr.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-// Helper class to determine whether or not the current thread is inside an
-// invocation of io_service::run() for a specified io_service object.
-template <typename Key, typename Value = unsigned char>
-class call_stack
-{
-public:
-  // Context class automatically pushes the key/value pair on to the stack.
-  class context
-    : private noncopyable
-  {
-  public:
-    // Push the key on to the stack.
-    explicit context(Key* k)
-      : key_(k),
-        next_(call_stack<Key, Value>::top_)
-    {
-      value_ = reinterpret_cast<unsigned char*>(this);
-      call_stack<Key, Value>::top_ = this;
-    }
-
-    // Push the key/value pair on to the stack.
-    context(Key* k, Value& v)
-      : key_(k),
-        value_(&v),
-        next_(call_stack<Key, Value>::top_)
-    {
-      call_stack<Key, Value>::top_ = this;
-    }
-
-    // Pop the key/value pair from the stack.
-    ~context()
-    {
-      call_stack<Key, Value>::top_ = next_;
-    }
-
-    // Find the next context with the same key.
-    Value* next_by_key() const
-    {
-      context* elem = next_;
-      while (elem)
-      {
-        if (elem->key_ == key_)
-          return elem->value_;
-        elem = elem->next_;
-      }
-      return 0;
-    }
-
-  private:
-    friend class call_stack<Key, Value>;
-
-    // The key associated with the context.
-    Key* key_;
-
-    // The value associated with the context.
-    Value* value_;
-
-    // The next element in the stack.
-    context* next_;
-  };
-
-  friend class context;
-
-  // Determine whether the specified owner is on the stack. Returns address of
-  // key if present, 0 otherwise.
-  static Value* contains(Key* k)
-  {
-    context* elem = top_;
-    while (elem)
-    {
-      if (elem->key_ == k)
-        return elem->value_;
-      elem = elem->next_;
-    }
-    return 0;
-  }
-
-  // Obtain the value at the top of the stack.
-  static Value* top()
-  {
-    context* elem = top_;
-    return elem ? elem->value_ : 0;
-  }
-
-private:
-  // The top of the stack of calls for the current thread.
-  static tss_ptr<context> top_;
-};
-
-template <typename Key, typename Value>
-tss_ptr<typename call_stack<Key, Value>::context>
-call_stack<Key, Value>::top_;
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_DETAIL_CALL_STACK_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/chrono_time_traits.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/chrono_time_traits.hpp
deleted file mode 100644
index 255777b4a7a1..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/chrono_time_traits.hpp
+++ /dev/null
@@ -1,190 +0,0 @@
-//
-// detail/chrono_time_traits.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_CHRONO_TIME_TRAITS_HPP
-#define ASIO_DETAIL_CHRONO_TIME_TRAITS_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/cstdint.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-// Helper template to compute the greatest common divisor.
-template <int64_t v1, int64_t v2>
-struct gcd { enum { value = gcd<v2, v1 % v2>::value }; };
-
-template <int64_t v1>
-struct gcd<v1, 0> { enum { value = v1 }; };
-
-// Adapts std::chrono clocks for use with a deadline timer.
-template <typename Clock, typename WaitTraits>
-struct chrono_time_traits
-{
-  // The clock type.
-  typedef Clock clock_type;
-
-  // The duration type of the clock.
-  typedef typename clock_type::duration duration_type;
-
-  // The time point type of the clock.
-  typedef typename clock_type::time_point time_type;
-
-  // The period of the clock.
-  typedef typename duration_type::period period_type;
-
-  // Get the current time.
-  static time_type now()
-  {
-    return clock_type::now();
-  }
-
-  // Add a duration to a time.
-  static time_type add(const time_type& t, const duration_type& d)
-  {
-    const time_type epoch;
-    if (t >= epoch)
-    {
-      if ((time_type::max)() - t < d)
-        return (time_type::max)();
-    }
-    else // t < epoch
-    {
-      if (-(t - (time_type::min)()) > d)
-        return (time_type::min)();
-    }
-
-    return t + d;
-  }
-
-  // Subtract one time from another.
-  static duration_type subtract(const time_type& t1, const time_type& t2)
-  {
-    const time_type epoch;
-    if (t1 >= epoch)
-    {
-      if (t2 >= epoch)
-      {
-        return t1 - t2;
-      }
-      else if (t2 == (time_type::min)())
-      {
-        return (duration_type::max)();
-      }
-      else if ((time_type::max)() - t1 < epoch - t2)
-      {
-        return (duration_type::max)();
-      }
-      else
-      {
-        return t1 - t2;
-      }
-    }
-    else // t1 < epoch
-    {
-      if (t2 < epoch)
-      {
-        return t1 - t2;
-      }
-      else if (t1 == (time_type::min)())
-      {
-        return (duration_type::min)();
-      }
-      else if ((time_type::max)() - t2 < epoch - t1)
-      {
-        return (duration_type::min)();
-      }
-      else
-      {
-        return -(t2 - t1);
-      }
-    }
-  }
-
-  // Test whether one time is less than another.
-  static bool less_than(const time_type& t1, const time_type& t2)
-  {
-    return t1 < t2;
-  }
-
-  // Implement just enough of the posix_time::time_duration interface to supply
-  // what the timer_queue requires.
-  class posix_time_duration
-  {
-  public:
-    explicit posix_time_duration(const duration_type& d)
-      : d_(d)
-    {
-    }
-
-    int64_t ticks() const
-    {
-      return d_.count();
-    }
-
-    int64_t total_seconds() const
-    {
-      return duration_cast<1, 1>();
-    }
-
-    int64_t total_milliseconds() const
-    {
-      return duration_cast<1, 1000>();
-    }
-
-    int64_t total_microseconds() const
-    {
-      return duration_cast<1, 1000000>();
-    }
-
-  private:
-    template <int64_t Num, int64_t Den>
-    int64_t duration_cast() const
-    {
-      const int64_t num1 = period_type::num / gcd<period_type::num, Num>::value;
-      const int64_t num2 = Num / gcd<period_type::num, Num>::value;
-
-      const int64_t den1 = period_type::den / gcd<period_type::den, Den>::value;
-      const int64_t den2 = Den / gcd<period_type::den, Den>::value;
-
-      const int64_t num = num1 * den2;
-      const int64_t den = num2 * den1;
-
-      if (num == 1 && den == 1)
-        return ticks();
-      else if (num != 1 && den == 1)
-        return ticks() * num;
-      else if (num == 1 && period_type::den != 1)
-        return ticks() / den;
-      else
-        return ticks() * num / den;
-    }
-
-    duration_type d_;
-  };
-
-  // Convert to POSIX duration type.
-  static posix_time_duration to_posix_duration(const duration_type& d)
-  {
-    return posix_time_duration(WaitTraits::to_wait_duration(d));
-  }
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_DETAIL_CHRONO_TIME_TRAITS_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/completion_handler.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/completion_handler.hpp
deleted file mode 100644
index 71769c3adfb0..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/completion_handler.hpp
+++ /dev/null
@@ -1,81 +0,0 @@
-//
-// detail/completion_handler.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_COMPLETION_HANDLER_HPP
-#define ASIO_DETAIL_COMPLETION_HANDLER_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/addressof.hpp"
-#include "asio/detail/config.hpp"
-#include "asio/detail/fenced_block.hpp"
-#include "asio/detail/handler_alloc_helpers.hpp"
-#include "asio/detail/handler_invoke_helpers.hpp"
-#include "asio/detail/operation.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-template <typename Handler>
-class completion_handler : public operation
-{
-public:
-  ASIO_DEFINE_HANDLER_PTR(completion_handler);
-
-  completion_handler(Handler& h)
-    : operation(&completion_handler::do_complete),
-      handler_(ASIO_MOVE_CAST(Handler)(h))
-  {
-  }
-
-  static void do_complete(io_service_impl* owner, operation* base,
-      const asio::error_code& /*ec*/,
-      std::size_t /*bytes_transferred*/)
-  {
-    // Take ownership of the handler object.
-    completion_handler* h(static_cast<completion_handler*>(base));
-    ptr p = { asio::detail::addressof(h->handler_), h, h };
-
-    ASIO_HANDLER_COMPLETION((h));
-
-    // Make a copy of the handler so that the memory can be deallocated before
-    // the upcall is made. Even if we're not about to make an upcall, a
-    // sub-object of the handler may be the true owner of the memory associated
-    // with the handler. Consequently, a local copy of the handler is required
-    // to ensure that any owning sub-object remains valid until after we have
-    // deallocated the memory here.
-    Handler handler(ASIO_MOVE_CAST(Handler)(h->handler_));
-    p.h = asio::detail::addressof(handler);
-    p.reset();
-
-    // Make the upcall if required.
-    if (owner)
-    {
-      fenced_block b(fenced_block::half);
-      ASIO_HANDLER_INVOCATION_BEGIN(());
-      asio_handler_invoke_helpers::invoke(handler, handler);
-      ASIO_HANDLER_INVOCATION_END;
-    }
-  }
-
-private:
-  Handler handler_;
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_DETAIL_COMPLETION_HANDLER_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/config.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/config.hpp
deleted file mode 100644
index 3b7875e2b1eb..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/config.hpp
+++ /dev/null
@@ -1,895 +0,0 @@
-//
-// detail/config.hpp
-// ~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_CONFIG_HPP
-#define ASIO_DETAIL_CONFIG_HPP
-
-#if defined(ASIO_STANDALONE)
-# define ASIO_DISABLE_BOOST_ARRAY 1
-# define ASIO_DISABLE_BOOST_ASSERT 1
-# define ASIO_DISABLE_BOOST_BIND 1
-# define ASIO_DISABLE_BOOST_CHRONO 1
-# define ASIO_DISABLE_BOOST_DATE_TIME 1
-# define ASIO_DISABLE_BOOST_LIMITS 1
-# define ASIO_DISABLE_BOOST_REGEX 1
-# define ASIO_DISABLE_BOOST_STATIC_CONSTANT 1
-# define ASIO_DISABLE_BOOST_THROW_EXCEPTION 1
-# define ASIO_DISABLE_BOOST_WORKAROUND 1
-#else // defined(ASIO_STANDALONE)
-# include <boost/config.hpp>
-# include <boost/version.hpp>
-# define ASIO_HAS_BOOST_CONFIG 1
-#endif // defined(ASIO_STANDALONE)
-
-// Default to a header-only implementation. The user must specifically request
-// separate compilation by defining either ASIO_SEPARATE_COMPILATION or
-// ASIO_DYN_LINK (as a DLL/shared library implies separate compilation).
-#if !defined(ASIO_HEADER_ONLY)
-# if !defined(ASIO_SEPARATE_COMPILATION)
-#  if !defined(ASIO_DYN_LINK)
-#   define ASIO_HEADER_ONLY 1
-#  endif // !defined(ASIO_DYN_LINK)
-# endif // !defined(ASIO_SEPARATE_COMPILATION)
-#endif // !defined(ASIO_HEADER_ONLY)
-
-#if defined(ASIO_HEADER_ONLY)
-# define ASIO_DECL inline
-#else // defined(ASIO_HEADER_ONLY)
-# if defined(_MSC_VER) || defined(__BORLANDC__) || defined(__CODEGEARC__)
-// We need to import/export our code only if the user has specifically asked
-// for it by defining ASIO_DYN_LINK.
-#  if defined(ASIO_DYN_LINK)
-// Export if this is our own source, otherwise import.
-#   if defined(ASIO_SOURCE)
-#    define ASIO_DECL __declspec(dllexport)
-#   else // defined(ASIO_SOURCE)
-#    define ASIO_DECL __declspec(dllimport)
-#   endif // defined(ASIO_SOURCE)
-#  endif // defined(ASIO_DYN_LINK)
-# endif // defined(_MSC_VER) || defined(__BORLANDC__) || defined(__CODEGEARC__)
-#endif // defined(ASIO_HEADER_ONLY)
-
-// If ASIO_DECL isn't defined yet define it now.
-#if !defined(ASIO_DECL)
-# define ASIO_DECL
-#endif // !defined(ASIO_DECL)
-
-// Microsoft Visual C++ detection.
-#if !defined(ASIO_MSVC)
-# if defined(ASIO_HAS_BOOST_CONFIG) && defined(BOOST_MSVC)
-#  define ASIO_MSVC BOOST_MSVC
-# elif defined(_MSC_VER) && !defined(__MWERKS__) && !defined(__EDG_VERSION__)
-#  define ASIO_MSVC _MSC_VER
-# endif // defined(ASIO_HAS_BOOST_CONFIG) && defined(BOOST_MSVC)
-#endif // defined(ASIO_MSVC)
-
-// Clang / libc++ detection.
-#if defined(__clang__)
-# if (__cplusplus >= 201103)
-#  if __has_include(<__config>)
-#   include <__config>
-#   if defined(_LIBCPP_VERSION)
-#    define ASIO_HAS_CLANG_LIBCXX 1
-#   endif // defined(_LIBCPP_VERSION)
-#  endif // __has_include(<__config>)
-# endif // (__cplusplus >= 201103)
-#endif // defined(__clang__)
-
-// Support move construction and assignment on compilers known to allow it.
-#if !defined(ASIO_HAS_MOVE)
-# if !defined(ASIO_DISABLE_MOVE)
-#  if defined(__clang__)
-#   if __has_feature(__cxx_rvalue_references__)
-#    define ASIO_HAS_MOVE 1
-#   endif // __has_feature(__cxx_rvalue_references__)
-#  endif // defined(__clang__)
-#  if defined(__GNUC__)
-#   if ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 5)) || (__GNUC__ > 4)
-#    if defined(__GXX_EXPERIMENTAL_CXX0X__)
-#     define ASIO_HAS_MOVE 1
-#    endif // defined(__GXX_EXPERIMENTAL_CXX0X__)
-#   endif // ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 5)) || (__GNUC__ > 4)
-#  endif // defined(__GNUC__)
-#  if defined(ASIO_MSVC)
-#   if (_MSC_VER >= 1700)
-#    define ASIO_HAS_MOVE 1
-#   endif // (_MSC_VER >= 1700)
-#  endif // defined(ASIO_MSVC)
-# endif // !defined(ASIO_DISABLE_MOVE)
-#endif // !defined(ASIO_HAS_MOVE)
-
-// If ASIO_MOVE_CAST isn't defined, and move support is available, define
-// ASIO_MOVE_ARG and ASIO_MOVE_CAST to take advantage of rvalue
-// references and perfect forwarding.
-#if defined(ASIO_HAS_MOVE) && !defined(ASIO_MOVE_CAST)
-# define ASIO_MOVE_ARG(type) type&&
-# define ASIO_MOVE_CAST(type) static_cast<type&&>
-# define ASIO_MOVE_CAST2(type1, type2) static_cast<type1, type2&&>
-#endif // defined(ASIO_HAS_MOVE) && !defined(ASIO_MOVE_CAST)
-
-// If ASIO_MOVE_CAST still isn't defined, default to a C++03-compatible
-// implementation. Note that older g++ and MSVC versions don't like it when you
-// pass a non-member function through a const reference, so for most compilers
-// we'll play it safe and stick with the old approach of passing the handler by
-// value.
-#if !defined(ASIO_MOVE_CAST)
-# if defined(__GNUC__)
-#  if ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 1)) || (__GNUC__ > 4)
-#   define ASIO_MOVE_ARG(type) const type&
-#  else // ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 1)) || (__GNUC__ > 4)
-#   define ASIO_MOVE_ARG(type) type
-#  endif // ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 1)) || (__GNUC__ > 4)
-# elif defined(ASIO_MSVC)
-#  if (_MSC_VER >= 1400)
-#   define ASIO_MOVE_ARG(type) const type&
-#  else // (_MSC_VER >= 1400)
-#   define ASIO_MOVE_ARG(type) type
-#  endif // (_MSC_VER >= 1400)
-# else
-#  define ASIO_MOVE_ARG(type) type
-# endif
-# define ASIO_MOVE_CAST(type) static_cast<const type&>
-# define ASIO_MOVE_CAST2(type1, type2) static_cast<const type1, type2&>
-#endif // !defined(ASIO_MOVE_CAST)
-
-// Support variadic templates on compilers known to allow it.
-#if !defined(ASIO_HAS_VARIADIC_TEMPLATES)
-# if !defined(ASIO_DISABLE_VARIADIC_TEMPLATES)
-#  if defined(__clang__)
-#   if __has_feature(__cxx_variadic_templates__)
-#    define ASIO_HAS_VARIADIC_TEMPLATES 1
-#   endif // __has_feature(__cxx_variadic_templates__)
-#  endif // defined(__clang__)
-#  if defined(__GNUC__)
-#   if ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 3)) || (__GNUC__ > 4)
-#    if defined(__GXX_EXPERIMENTAL_CXX0X__)
-#     define ASIO_HAS_VARIADIC_TEMPLATES 1
-#    endif // defined(__GXX_EXPERIMENTAL_CXX0X__)
-#   endif // ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 3)) || (__GNUC__ > 4)
-#  endif // defined(__GNUC__)
-# endif // !defined(ASIO_DISABLE_VARIADIC_TEMPLATES)
-#endif // !defined(ASIO_HAS_VARIADIC_TEMPLATES)
-
-// Support constexpr on compilers known to allow it.
-#if !defined(ASIO_HAS_CONSTEXPR)
-# if !defined(ASIO_DISABLE_CONSTEXPR)
-#  if defined(__clang__)
-#   if __has_feature(__cxx_constexpr__)
-#    define ASIO_HAS_CONSTEXPR 1
-#   endif // __has_feature(__cxx_constexr__)
-#  endif // defined(__clang__)
-#  if defined(__GNUC__)
-#   if ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 6)) || (__GNUC__ > 4)
-#    if defined(__GXX_EXPERIMENTAL_CXX0X__)
-#     define ASIO_HAS_CONSTEXPR 1
-#    endif // defined(__GXX_EXPERIMENTAL_CXX0X__)
-#   endif // ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 6)) || (__GNUC__ > 4)
-#  endif // defined(__GNUC__)
-# endif // !defined(ASIO_DISABLE_CONSTEXPR)
-#endif // !defined(ASIO_HAS_CONSTEXPR)
-#if !defined(ASIO_CONSTEXPR)
-# if defined(ASIO_HAS_CONSTEXPR)
-#  define ASIO_CONSTEXPR constexpr
-# else // defined(ASIO_HAS_CONSTEXPR)
-#  define ASIO_CONSTEXPR
-# endif // defined(ASIO_HAS_CONSTEXPR)
-#endif // !defined(ASIO_CONSTEXPR)
-
-// Standard library support for system errors.
-#if !defined(ASIO_HAS_STD_SYSTEM_ERROR)
-# if !defined(ASIO_DISABLE_STD_SYSTEM_ERROR)
-#  if defined(ASIO_HAS_CLANG_LIBCXX)
-#   define ASIO_HAS_STD_SYSTEM_ERROR 1
-#  endif // defined(ASIO_HAS_CLANG_LIBCXX)
-#  if defined(__GNUC__)
-#   if ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 6)) || (__GNUC__ > 4)
-#    if defined(__GXX_EXPERIMENTAL_CXX0X__)
-#     define ASIO_HAS_STD_SYSTEM_ERROR 1
-#    endif // defined(__GXX_EXPERIMENTAL_CXX0X__)
-#   endif // ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 6)) || (__GNUC__ > 4)
-#  endif // defined(__GNUC__)
-#  if defined(ASIO_MSVC)
-#   if (_MSC_VER >= 1700)
-#    define ASIO_HAS_STD_SYSTEM_ERROR 1
-#   endif // (_MSC_VER >= 1700)
-#  endif // defined(ASIO_MSVC)
-# endif // !defined(ASIO_DISABLE_STD_SYSTEM_ERROR)
-#endif // !defined(ASIO_HAS_STD_SYSTEM_ERROR)
-
-// Compliant C++11 compilers put noexcept specifiers on error_category members.
-#if !defined(ASIO_ERROR_CATEGORY_NOEXCEPT)
-# if (BOOST_VERSION >= 105300)
-#  define ASIO_ERROR_CATEGORY_NOEXCEPT BOOST_NOEXCEPT
-# elif defined(__clang__)
-#  if __has_feature(__cxx_noexcept__)
-#   define ASIO_ERROR_CATEGORY_NOEXCEPT noexcept(true)
-#  endif // __has_feature(__cxx_noexcept__)
-# elif defined(__GNUC__)
-#  if ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 7)) || (__GNUC__ > 4)
-#   if defined(__GXX_EXPERIMENTAL_CXX0X__)
-#     define ASIO_ERROR_CATEGORY_NOEXCEPT noexcept(true)
-#   endif // defined(__GXX_EXPERIMENTAL_CXX0X__)
-#  endif // ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 7)) || (__GNUC__ > 4)
-# endif // defined(__GNUC__)
-# if !defined(ASIO_ERROR_CATEGORY_NOEXCEPT)
-#  define ASIO_ERROR_CATEGORY_NOEXCEPT
-# endif // !defined(ASIO_ERROR_CATEGORY_NOEXCEPT)
-#endif // !defined(ASIO_ERROR_CATEGORY_NOEXCEPT)
-
-// Standard library support for arrays.
-#if !defined(ASIO_HAS_STD_ARRAY)
-# if !defined(ASIO_DISABLE_STD_ARRAY)
-#  if defined(ASIO_HAS_CLANG_LIBCXX)
-#   define ASIO_HAS_STD_ARRAY 1
-#  endif // defined(ASIO_HAS_CLANG_LIBCXX)
-#  if defined(__GNUC__)
-#   if ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 3)) || (__GNUC__ > 4)
-#    if defined(__GXX_EXPERIMENTAL_CXX0X__)
-#     define ASIO_HAS_STD_ARRAY 1
-#    endif // defined(__GXX_EXPERIMENTAL_CXX0X__)
-#   endif // ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 3)) || (__GNUC__ > 4)
-#  endif // defined(__GNUC__)
-#  if defined(ASIO_MSVC)
-#   if (_MSC_VER >= 1600)
-#    define ASIO_HAS_STD_ARRAY 1
-#   endif // (_MSC_VER >= 1600)
-#  endif // defined(ASIO_MSVC)
-# endif // !defined(ASIO_DISABLE_STD_ARRAY)
-#endif // !defined(ASIO_HAS_STD_ARRAY)
-
-// Standard library support for shared_ptr and weak_ptr.
-#if !defined(ASIO_HAS_STD_SHARED_PTR)
-# if !defined(ASIO_DISABLE_STD_SHARED_PTR)
-#  if defined(ASIO_HAS_CLANG_LIBCXX)
-#   define ASIO_HAS_STD_SHARED_PTR 1
-#  endif // defined(ASIO_HAS_CLANG_LIBCXX)
-#  if defined(__GNUC__)
-#   if ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 3)) || (__GNUC__ > 4)
-#    if defined(__GXX_EXPERIMENTAL_CXX0X__)
-#     define ASIO_HAS_STD_SHARED_PTR 1
-#    endif // defined(__GXX_EXPERIMENTAL_CXX0X__)
-#   endif // ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 3)) || (__GNUC__ > 4)
-#  endif // defined(__GNUC__)
-#  if defined(ASIO_MSVC)
-#   if (_MSC_VER >= 1600)
-#    define ASIO_HAS_STD_SHARED_PTR 1
-#   endif // (_MSC_VER >= 1600)
-#  endif // defined(ASIO_MSVC)
-# endif // !defined(ASIO_DISABLE_STD_SHARED_PTR)
-#endif // !defined(ASIO_HAS_STD_SHARED_PTR)
-
-// Standard library support for atomic operations.
-#if !defined(ASIO_HAS_STD_ATOMIC)
-# if !defined(ASIO_DISABLE_STD_ATOMIC)
-#  if defined(ASIO_HAS_CLANG_LIBCXX)
-#   define ASIO_HAS_STD_ATOMIC 1
-#  endif // defined(ASIO_HAS_CLANG_LIBCXX)
-#  if defined(__GNUC__)
-#   if ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 5)) || (__GNUC__ > 4)
-#    if defined(__GXX_EXPERIMENTAL_CXX0X__)
-#     define ASIO_HAS_STD_ATOMIC 1
-#    endif // defined(__GXX_EXPERIMENTAL_CXX0X__)
-#   endif // ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 5)) || (__GNUC__ > 4)
-#  endif // defined(__GNUC__)
-#  if defined(ASIO_MSVC)
-#   if (_MSC_VER >= 1700)
-#    define ASIO_HAS_STD_ATOMIC 1
-#   endif // (_MSC_VER >= 1700)
-#  endif // defined(ASIO_MSVC)
-# endif // !defined(ASIO_DISABLE_STD_ATOMIC)
-#endif // !defined(ASIO_HAS_STD_ATOMIC)
-
-// Standard library support for chrono. Some standard libraries (such as the
-// libstdc++ shipped with gcc 4.6) provide monotonic_clock as per early C++0x
-// drafts, rather than the eventually standardised name of steady_clock.
-#if !defined(ASIO_HAS_STD_CHRONO)
-# if !defined(ASIO_DISABLE_STD_CHRONO)
-#  if defined(ASIO_HAS_CLANG_LIBCXX)
-#   define ASIO_HAS_STD_CHRONO 1
-#  endif // defined(ASIO_HAS_CLANG_LIBCXX)
-#  if defined(__GNUC__)
-#   if ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 6)) || (__GNUC__ > 4)
-#    if defined(__GXX_EXPERIMENTAL_CXX0X__)
-#     define ASIO_HAS_STD_CHRONO 1
-#     if ((__GNUC__ == 4) && (__GNUC_MINOR__ == 6))
-#      define ASIO_HAS_STD_CHRONO_MONOTONIC_CLOCK 1
-#     endif // ((__GNUC__ == 4) && (__GNUC_MINOR__ == 6))
-#    endif // defined(__GXX_EXPERIMENTAL_CXX0X__)
-#   endif // ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 6)) || (__GNUC__ > 4)
-#  endif // defined(__GNUC__)
-#  if defined(ASIO_MSVC)
-#   if (_MSC_VER >= 1700)
-#    define ASIO_HAS_STD_CHRONO 1
-#   endif // (_MSC_VER >= 1700)
-#  endif // defined(ASIO_MSVC)
-# endif // !defined(ASIO_DISABLE_STD_CHRONO)
-#endif // !defined(ASIO_HAS_STD_CHRONO)
-
-// Boost support for chrono.
-#if !defined(ASIO_HAS_BOOST_CHRONO)
-# if !defined(ASIO_DISABLE_BOOST_CHRONO)
-#  if (BOOST_VERSION >= 104700)
-#   define ASIO_HAS_BOOST_CHRONO 1
-#  endif // (BOOST_VERSION >= 104700)
-# endif // !defined(ASIO_DISABLE_BOOST_CHRONO)
-#endif // !defined(ASIO_HAS_BOOST_CHRONO)
-
-// Boost support for the DateTime library.
-#if !defined(ASIO_HAS_BOOST_DATE_TIME)
-# if !defined(ASIO_DISABLE_BOOST_DATE_TIME)
-#  define ASIO_HAS_BOOST_DATE_TIME 1
-# endif // !defined(ASIO_DISABLE_BOOST_DATE_TIME)
-#endif // !defined(ASIO_HAS_BOOST_DATE_TIME)
-
-// Standard library support for addressof.
-#if !defined(ASIO_HAS_STD_ADDRESSOF)
-# if !defined(ASIO_DISABLE_STD_ADDRESSOF)
-#  if defined(ASIO_HAS_CLANG_LIBCXX)
-#   define ASIO_HAS_STD_ADDRESSOF 1
-#  endif // defined(ASIO_HAS_CLANG_LIBCXX)
-#  if defined(__GNUC__)
-#   if ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 5)) || (__GNUC__ > 4)
-#    if defined(__GXX_EXPERIMENTAL_CXX0X__)
-#     define ASIO_HAS_STD_ADDRESSOF 1
-#    endif // defined(__GXX_EXPERIMENTAL_CXX0X__)
-#   endif // ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 5)) || (__GNUC__ > 4)
-#  endif // defined(__GNUC__)
-#  if defined(ASIO_MSVC)
-#   if (_MSC_VER >= 1700)
-#    define ASIO_HAS_STD_ADDRESSOF 1
-#   endif // (_MSC_VER >= 1700)
-#  endif // defined(ASIO_MSVC)
-# endif // !defined(ASIO_DISABLE_STD_ADDRESSOF)
-#endif // !defined(ASIO_HAS_STD_ADDRESSOF)
-
-// Standard library support for the function class.
-#if !defined(ASIO_HAS_STD_FUNCTION)
-# if !defined(ASIO_DISABLE_STD_FUNCTION)
-#  if defined(ASIO_HAS_CLANG_LIBCXX)
-#   define ASIO_HAS_STD_FUNCTION 1
-#  endif // defined(ASIO_HAS_CLANG_LIBCXX)
-#  if defined(__GNUC__)
-#   if ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 5)) || (__GNUC__ > 4)
-#    if defined(__GXX_EXPERIMENTAL_CXX0X__)
-#     define ASIO_HAS_STD_FUNCTION 1
-#    endif // defined(__GXX_EXPERIMENTAL_CXX0X__)
-#   endif // ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 5)) || (__GNUC__ > 4)
-#  endif // defined(__GNUC__)
-#  if defined(ASIO_MSVC)
-#   if (_MSC_VER >= 1700)
-#    define ASIO_HAS_STD_FUNCTION 1
-#   endif // (_MSC_VER >= 1700)
-#  endif // defined(ASIO_MSVC)
-# endif // !defined(ASIO_DISABLE_STD_FUNCTION)
-#endif // !defined(ASIO_HAS_STD_FUNCTION)
-
-// Standard library support for type traits.
-#if !defined(ASIO_HAS_STD_TYPE_TRAITS)
-# if !defined(ASIO_DISABLE_STD_TYPE_TRAITS)
-#  if defined(ASIO_HAS_CLANG_LIBCXX)
-#   define ASIO_HAS_STD_TYPE_TRAITS 1
-#  endif // defined(ASIO_HAS_CLANG_LIBCXX)
-#  if defined(__GNUC__)
-#   if ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 5)) || (__GNUC__ > 4)
-#    if defined(__GXX_EXPERIMENTAL_CXX0X__)
-#     define ASIO_HAS_STD_TYPE_TRAITS 1
-#    endif // defined(__GXX_EXPERIMENTAL_CXX0X__)
-#   endif // ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 5)) || (__GNUC__ > 4)
-#  endif // defined(__GNUC__)
-#  if defined(ASIO_MSVC)
-#   if (_MSC_VER >= 1700)
-#    define ASIO_HAS_STD_TYPE_TRAITS 1
-#   endif // (_MSC_VER >= 1700)
-#  endif // defined(ASIO_MSVC)
-# endif // !defined(ASIO_DISABLE_STD_TYPE_TRAITS)
-#endif // !defined(ASIO_HAS_STD_TYPE_TRAITS)
-
-// Standard library support for the cstdint header.
-#if !defined(ASIO_HAS_CSTDINT)
-# if !defined(ASIO_DISABLE_CSTDINT)
-#  if defined(ASIO_HAS_CLANG_LIBCXX)
-#   define ASIO_HAS_CSTDINT 1
-#  endif // defined(ASIO_HAS_CLANG_LIBCXX)
-#  if defined(__GNUC__)
-#   if ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 5)) || (__GNUC__ > 4)
-#    if defined(__GXX_EXPERIMENTAL_CXX0X__)
-#     define ASIO_HAS_CSTDINT 1
-#    endif // defined(__GXX_EXPERIMENTAL_CXX0X__)
-#   endif // ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 5)) || (__GNUC__ > 4)
-#  endif // defined(__GNUC__)
-#  if defined(ASIO_MSVC)
-#   if (_MSC_VER >= 1700)
-#    define ASIO_HAS_CSTDINT 1
-#   endif // (_MSC_VER >= 1700)
-#  endif // defined(ASIO_MSVC)
-# endif // !defined(ASIO_DISABLE_CSTDINT)
-#endif // !defined(ASIO_HAS_CSTDINT)
-
-// Standard library support for the thread class.
-#if !defined(ASIO_HAS_STD_THREAD)
-# if !defined(ASIO_DISABLE_STD_THREAD)
-#  if defined(ASIO_HAS_CLANG_LIBCXX)
-#   define ASIO_HAS_STD_THREAD 1
-#  endif // defined(ASIO_HAS_CLANG_LIBCXX)
-#  if defined(__GNUC__)
-#   if ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 7)) || (__GNUC__ > 4)
-#    if defined(__GXX_EXPERIMENTAL_CXX0X__)
-#     define ASIO_HAS_STD_THREAD 1
-#    endif // defined(__GXX_EXPERIMENTAL_CXX0X__)
-#   endif // ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 7)) || (__GNUC__ > 4)
-#  endif // defined(__GNUC__)
-#  if defined(ASIO_MSVC)
-#   if (_MSC_VER >= 1700)
-#    define ASIO_HAS_STD_THREAD 1
-#   endif // (_MSC_VER >= 1700)
-#  endif // defined(ASIO_MSVC)
-# endif // !defined(ASIO_DISABLE_STD_THREAD)
-#endif // !defined(ASIO_HAS_STD_THREAD)
-
-// Standard library support for the mutex and condition variable classes.
-#if !defined(ASIO_HAS_STD_MUTEX_AND_CONDVAR)
-# if !defined(ASIO_DISABLE_STD_MUTEX_AND_CONDVAR)
-#  if defined(ASIO_HAS_CLANG_LIBCXX)
-#   define ASIO_HAS_STD_MUTEX_AND_CONDVAR 1
-#  endif // defined(ASIO_HAS_CLANG_LIBCXX)
-#  if defined(__GNUC__)
-#   if ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 7)) || (__GNUC__ > 4)
-#    if defined(__GXX_EXPERIMENTAL_CXX0X__)
-#     define ASIO_HAS_STD_MUTEX_AND_CONDVAR 1
-#    endif // defined(__GXX_EXPERIMENTAL_CXX0X__)
-#   endif // ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 7)) || (__GNUC__ > 4)
-#  endif // defined(__GNUC__)
-#  if defined(ASIO_MSVC)
-#   if (_MSC_VER >= 1700)
-#    define ASIO_HAS_STD_MUTEX_AND_CONDVAR 1
-#   endif // (_MSC_VER >= 1700)
-#  endif // defined(ASIO_MSVC)
-# endif // !defined(ASIO_DISABLE_STD_MUTEX_AND_CONDVAR)
-#endif // !defined(ASIO_HAS_STD_MUTEX_AND_CONDVAR)
-
-// WinRT target.
-#if !defined(ASIO_WINDOWS_RUNTIME)
-# if defined(__cplusplus_winrt)
-#  include <winapifamily.h>
-#  if WINAPI_FAMILY_ONE_PARTITION(WINAPI_FAMILY, WINAPI_PARTITION_APP)
-#   define ASIO_WINDOWS_RUNTIME 1
-#  endif // WINAPI_FAMILY_ONE_PARTITION(WINAPI_FAMILY, WINAPI_PARTITION_APP)
-# endif // defined(__cplusplus_winrt)
-#endif // !defined(ASIO_WINDOWS_RUNTIME)
-
-// Windows target. Excludes WinRT.
-#if !defined(ASIO_WINDOWS)
-# if !defined(ASIO_WINDOWS_RUNTIME)
-#  if defined(ASIO_HAS_BOOST_CONFIG) && defined(BOOST_WINDOWS)
-#   define ASIO_WINDOWS 1
-#  elif defined(WIN32) || defined(_WIN32) || defined(__WIN32__)
-#   define ASIO_WINDOWS 1
-#  endif // defined(ASIO_HAS_BOOST_CONFIG) && defined(BOOST_WINDOWS)
-# endif // !defined(ASIO_WINDOWS_RUNTIME)
-#endif // !defined(ASIO_WINDOWS)
-
-// Windows: target OS version.
-#if defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-# if !defined(_WIN32_WINNT) && !defined(_WIN32_WINDOWS)
-#  if defined(_MSC_VER) || defined(__BORLANDC__)
-#   pragma message( \
-  "Please define _WIN32_WINNT or _WIN32_WINDOWS appropriately. For example:\n"\
-  "- add -D_WIN32_WINNT=0x0501 to the compiler command line; or\n"\
-  "- add _WIN32_WINNT=0x0501 to your project's Preprocessor Definitions.\n"\
-  "Assuming _WIN32_WINNT=0x0501 (i.e. Windows XP target).")
-#  else // defined(_MSC_VER) || defined(__BORLANDC__)
-#   warning Please define _WIN32_WINNT or _WIN32_WINDOWS appropriately.
-#   warning For example, add -D_WIN32_WINNT=0x0501 to the compiler command line.
-#   warning Assuming _WIN32_WINNT=0x0501 (i.e. Windows XP target).
-#  endif // defined(_MSC_VER) || defined(__BORLANDC__)
-#  define _WIN32_WINNT 0x0501
-# endif // !defined(_WIN32_WINNT) && !defined(_WIN32_WINDOWS)
-# if defined(_MSC_VER)
-#  if defined(_WIN32) && !defined(WIN32)
-#   if !defined(_WINSOCK2API_)
-#    define WIN32 // Needed for correct types in winsock2.h
-#   else // !defined(_WINSOCK2API_)
-#    error Please define the macro WIN32 in your compiler options
-#   endif // !defined(_WINSOCK2API_)
-#  endif // defined(_WIN32) && !defined(WIN32)
-# endif // defined(_MSC_VER)
-# if defined(__BORLANDC__)
-#  if defined(__WIN32__) && !defined(WIN32)
-#   if !defined(_WINSOCK2API_)
-#    define WIN32 // Needed for correct types in winsock2.h
-#   else // !defined(_WINSOCK2API_)
-#    error Please define the macro WIN32 in your compiler options
-#   endif // !defined(_WINSOCK2API_)
-#  endif // defined(__WIN32__) && !defined(WIN32)
-# endif // defined(__BORLANDC__)
-# if defined(__CYGWIN__)
-#  if !defined(__USE_W32_SOCKETS)
-#   error You must add -D__USE_W32_SOCKETS to your compiler options.
-#  endif // !defined(__USE_W32_SOCKETS)
-# endif // defined(__CYGWIN__)
-#endif // defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-
-// Windows: minimise header inclusion.
-#if defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-# if !defined(ASIO_NO_WIN32_LEAN_AND_MEAN)
-#  if !defined(WIN32_LEAN_AND_MEAN)
-#   define WIN32_LEAN_AND_MEAN
-#  endif // !defined(WIN32_LEAN_AND_MEAN)
-# endif // !defined(ASIO_NO_WIN32_LEAN_AND_MEAN)
-#endif // defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-
-// Windows: suppress definition of "min" and "max" macros.
-#if defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-# if !defined(ASIO_NO_NOMINMAX)
-#  if !defined(NOMINMAX)
-#   define NOMINMAX 1
-#  endif // !defined(NOMINMAX)
-# endif // !defined(ASIO_NO_NOMINMAX)
-#endif // defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-
-// Windows: IO Completion Ports.
-#if !defined(ASIO_HAS_IOCP)
-# if defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-#  if defined(_WIN32_WINNT) && (_WIN32_WINNT >= 0x0400)
-#   if !defined(UNDER_CE)
-#    if !defined(ASIO_DISABLE_IOCP)
-#     define ASIO_HAS_IOCP 1
-#    endif // !defined(ASIO_DISABLE_IOCP)
-#   endif // !defined(UNDER_CE)
-#  endif // defined(_WIN32_WINNT) && (_WIN32_WINNT >= 0x0400)
-# endif // defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-#endif // !defined(ASIO_HAS_IOCP)
-
-// Linux: epoll, eventfd and timerfd.
-#if defined(__linux__)
-# include <linux/version.h>
-# if !defined(ASIO_HAS_EPOLL)
-#  if !defined(ASIO_DISABLE_EPOLL)
-#   if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,45)
-#    define ASIO_HAS_EPOLL 1
-#   endif // LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,45)
-#  endif // !defined(ASIO_DISABLE_EPOLL)
-# endif // !defined(ASIO_HAS_EPOLL)
-# if !defined(ASIO_HAS_EVENTFD)
-#  if !defined(ASIO_DISABLE_EVENTFD)
-#   if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,22)
-#    define ASIO_HAS_EVENTFD 1
-#   endif // LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,22)
-#  endif // !defined(ASIO_DISABLE_EVENTFD)
-# endif // !defined(ASIO_HAS_EVENTFD)
-# if !defined(ASIO_HAS_TIMERFD)
-#  if defined(ASIO_HAS_EPOLL)
-#   if (__GLIBC__ > 2) || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 8)
-#    define ASIO_HAS_TIMERFD 1
-#   endif // (__GLIBC__ > 2) || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 8)
-#  endif // defined(ASIO_HAS_EPOLL)
-# endif // !defined(ASIO_HAS_TIMERFD)
-#endif // defined(__linux__)
-
-// Mac OS X, FreeBSD, NetBSD, OpenBSD: kqueue.
-#if (defined(__MACH__) && defined(__APPLE__)) \
-  || defined(__FreeBSD__) \
-  || defined(__NetBSD__) \
-  || defined(__OpenBSD__)
-# if !defined(ASIO_HAS_KQUEUE)
-#  if !defined(ASIO_DISABLE_KQUEUE)
-#   define ASIO_HAS_KQUEUE 1
-#  endif // !defined(ASIO_DISABLE_KQUEUE)
-# endif // !defined(ASIO_HAS_KQUEUE)
-#endif // (defined(__MACH__) && defined(__APPLE__))
-       //   || defined(__FreeBSD__)
-       //   || defined(__NetBSD__)
-       //   || defined(__OpenBSD__)
-
-// Solaris: /dev/poll.
-#if defined(__sun)
-# if !defined(ASIO_HAS_DEV_POLL)
-#  if !defined(ASIO_DISABLE_DEV_POLL)
-#   define ASIO_HAS_DEV_POLL 1
-#  endif // !defined(ASIO_DISABLE_DEV_POLL)
-# endif // !defined(ASIO_HAS_DEV_POLL)
-#endif // defined(__sun)
-
-// Serial ports.
-#if !defined(ASIO_HAS_SERIAL_PORT)
-# if defined(ASIO_HAS_IOCP) \
-  || !defined(ASIO_WINDOWS) \
-  && !defined(ASIO_WINDOWS_RUNTIME) \
-  && !defined(__CYGWIN__)
-#  if !defined(__SYMBIAN32__)
-#   if !defined(ASIO_DISABLE_SERIAL_PORT)
-#    define ASIO_HAS_SERIAL_PORT 1
-#   endif // !defined(ASIO_DISABLE_SERIAL_PORT)
-#  endif // !defined(__SYMBIAN32__)
-# endif // defined(ASIO_HAS_IOCP)
-        //   || !defined(ASIO_WINDOWS)
-        //   && !defined(ASIO_WINDOWS_RUNTIME)
-        //   && !defined(__CYGWIN__)
-#endif // !defined(ASIO_HAS_SERIAL_PORT)
-
-// Windows: stream handles.
-#if !defined(ASIO_HAS_WINDOWS_STREAM_HANDLE)
-# if !defined(ASIO_DISABLE_WINDOWS_STREAM_HANDLE)
-#  if defined(ASIO_HAS_IOCP)
-#   define ASIO_HAS_WINDOWS_STREAM_HANDLE 1
-#  endif // defined(ASIO_HAS_IOCP)
-# endif // !defined(ASIO_DISABLE_WINDOWS_STREAM_HANDLE)
-#endif // !defined(ASIO_HAS_WINDOWS_STREAM_HANDLE)
-
-// Windows: random access handles.
-#if !defined(ASIO_HAS_WINDOWS_RANDOM_ACCESS_HANDLE)
-# if !defined(ASIO_DISABLE_WINDOWS_RANDOM_ACCESS_HANDLE)
-#  if defined(ASIO_HAS_IOCP)
-#   define ASIO_HAS_WINDOWS_RANDOM_ACCESS_HANDLE 1
-#  endif // defined(ASIO_HAS_IOCP)
-# endif // !defined(ASIO_DISABLE_WINDOWS_RANDOM_ACCESS_HANDLE)
-#endif // !defined(ASIO_HAS_WINDOWS_RANDOM_ACCESS_HANDLE)
-
-// Windows: object handles.
-#if !defined(ASIO_HAS_WINDOWS_OBJECT_HANDLE)
-# if !defined(ASIO_DISABLE_WINDOWS_OBJECT_HANDLE)
-#  if defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-#   if !defined(UNDER_CE)
-#    define ASIO_HAS_WINDOWS_OBJECT_HANDLE 1
-#   endif // !defined(UNDER_CE)
-#  endif // defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-# endif // !defined(ASIO_DISABLE_WINDOWS_OBJECT_HANDLE)
-#endif // !defined(ASIO_HAS_WINDOWS_OBJECT_HANDLE)
-
-// Windows: OVERLAPPED wrapper.
-#if !defined(ASIO_HAS_WINDOWS_OVERLAPPED_PTR)
-# if !defined(ASIO_DISABLE_WINDOWS_OVERLAPPED_PTR)
-#  if defined(ASIO_HAS_IOCP)
-#   define ASIO_HAS_WINDOWS_OVERLAPPED_PTR 1
-#  endif // defined(ASIO_HAS_IOCP)
-# endif // !defined(ASIO_DISABLE_WINDOWS_OVERLAPPED_PTR)
-#endif // !defined(ASIO_HAS_WINDOWS_OVERLAPPED_PTR)
-
-// POSIX: stream-oriented file descriptors.
-#if !defined(ASIO_HAS_POSIX_STREAM_DESCRIPTOR)
-# if !defined(ASIO_DISABLE_POSIX_STREAM_DESCRIPTOR)
-#  if !defined(ASIO_WINDOWS) \
-  && !defined(ASIO_WINDOWS_RUNTIME) \
-  && !defined(__CYGWIN__)
-#   define ASIO_HAS_POSIX_STREAM_DESCRIPTOR 1
-#  endif // !defined(ASIO_WINDOWS)
-         //   && !defined(ASIO_WINDOWS_RUNTIME)
-         //   && !defined(__CYGWIN__)
-# endif // !defined(ASIO_DISABLE_POSIX_STREAM_DESCRIPTOR)
-#endif // !defined(ASIO_HAS_POSIX_STREAM_DESCRIPTOR)
-
-// UNIX domain sockets.
-#if !defined(ASIO_HAS_LOCAL_SOCKETS)
-# if !defined(ASIO_DISABLE_LOCAL_SOCKETS)
-#  if !defined(ASIO_WINDOWS) \
-  && !defined(ASIO_WINDOWS_RUNTIME) \
-  && !defined(__CYGWIN__)
-#   define ASIO_HAS_LOCAL_SOCKETS 1
-#  endif // !defined(ASIO_WINDOWS)
-         //   && !defined(ASIO_WINDOWS_RUNTIME)
-         //   && !defined(__CYGWIN__)
-# endif // !defined(ASIO_DISABLE_LOCAL_SOCKETS)
-#endif // !defined(ASIO_HAS_LOCAL_SOCKETS)
-
-// Can use sigaction() instead of signal().
-#if !defined(ASIO_HAS_SIGACTION)
-# if !defined(ASIO_DISABLE_SIGACTION)
-#  if !defined(ASIO_WINDOWS) \
-  && !defined(ASIO_WINDOWS_RUNTIME) \
-  && !defined(__CYGWIN__)
-#   define ASIO_HAS_SIGACTION 1
-#  endif // !defined(ASIO_WINDOWS)
-         //   && !defined(ASIO_WINDOWS_RUNTIME)
-         //   && !defined(__CYGWIN__)
-# endif // !defined(ASIO_DISABLE_SIGACTION)
-#endif // !defined(ASIO_HAS_SIGACTION)
-
-// Can use signal().
-#if !defined(ASIO_HAS_SIGNAL)
-# if !defined(ASIO_DISABLE_SIGNAL)
-#  if !defined(UNDER_CE)
-#   define ASIO_HAS_SIGNAL 1
-#  endif // !defined(UNDER_CE)
-# endif // !defined(ASIO_DISABLE_SIGNAL)
-#endif // !defined(ASIO_HAS_SIGNAL)
-
-// Whether standard iostreams are disabled.
-#if !defined(ASIO_NO_IOSTREAM)
-# if defined(ASIO_HAS_BOOST_CONFIG) && defined(BOOST_NO_IOSTREAM)
-#  define ASIO_NO_IOSTREAM 1
-# endif // !defined(BOOST_NO_IOSTREAM)
-#endif // !defined(ASIO_NO_IOSTREAM)
-
-// Whether exception handling is disabled.
-#if !defined(ASIO_NO_EXCEPTIONS)
-# if defined(ASIO_HAS_BOOST_CONFIG) && defined(BOOST_NO_EXCEPTIONS)
-#  define ASIO_NO_EXCEPTIONS 1
-# endif // !defined(BOOST_NO_EXCEPTIONS)
-#endif // !defined(ASIO_NO_EXCEPTIONS)
-
-// Whether the typeid operator is supported.
-#if !defined(ASIO_NO_TYPEID)
-# if defined(ASIO_HAS_BOOST_CONFIG) && defined(BOOST_NO_TYPEID)
-#  define ASIO_NO_TYPEID 1
-# endif // !defined(BOOST_NO_TYPEID)
-#endif // !defined(ASIO_NO_TYPEID)
-
-// On POSIX (and POSIX-like) platforms we need to include unistd.h in order to
-// get access to the various platform feature macros, e.g. to be able to test
-// for threads support.
-#if !defined(ASIO_HAS_UNISTD_H)
-# if !defined(ASIO_HAS_BOOST_CONFIG)
-#  if defined(unix) \
-   || defined(__unix) \
-   || defined(_XOPEN_SOURCE) \
-   || defined(_POSIX_SOURCE) \
-   || (defined(__MACH__) && defined(__APPLE__)) \
-   || defined(__FreeBSD__) \
-   || defined(__NetBSD__) \
-   || defined(__OpenBSD__) \
-   || defined(__linux__)
-#   define ASIO_HAS_UNISTD_H 1
-#  endif
-# endif // !defined(ASIO_HAS_BOOST_CONFIG)
-#endif // !defined(ASIO_HAS_UNISTD_H)
-#if defined(ASIO_HAS_UNISTD_H)
-# include <unistd.h>
-#endif // defined(ASIO_HAS_UNISTD_H)
-
-// Threads.
-#if !defined(ASIO_HAS_THREADS)
-# if !defined(ASIO_DISABLE_THREADS)
-#  if defined(ASIO_HAS_BOOST_CONFIG) && defined(BOOST_HAS_THREADS)
-#   define ASIO_HAS_THREADS 1
-#  elif defined(_MSC_VER) && defined(_MT)
-#   define ASIO_HAS_THREADS 1
-#  elif defined(__BORLANDC__) && defined(__MT__)
-#   define ASIO_HAS_THREADS 1
-#  elif defined(_POSIX_THREADS)
-#   define ASIO_HAS_THREADS 1
-#  endif // defined(ASIO_HAS_BOOST_CONFIG) && defined(BOOST_HAS_THREADS)
-# endif // !defined(ASIO_DISABLE_THREADS)
-#endif // !defined(ASIO_HAS_THREADS)
-
-// POSIX threads.
-#if !defined(ASIO_HAS_PTHREADS)
-# if defined(ASIO_HAS_THREADS)
-#  if defined(ASIO_HAS_BOOST_CONFIG) && defined(BOOST_HAS_PTHREADS)
-#   define ASIO_HAS_PTHREADS 1
-#  elif defined(_POSIX_THREADS)
-#   define ASIO_HAS_PTHREADS 1
-#  endif // defined(ASIO_HAS_BOOST_CONFIG) && defined(BOOST_HAS_PTHREADS)
-# endif // defined(ASIO_HAS_THREADS)
-#endif // !defined(ASIO_HAS_PTHREADS)
-
-// Helper to prevent macro expansion.
-#define ASIO_PREVENT_MACRO_SUBSTITUTION
-
-// Helper to define in-class constants.
-#if !defined(ASIO_STATIC_CONSTANT)
-# if !defined(ASIO_DISABLE_BOOST_STATIC_CONSTANT)
-#  define ASIO_STATIC_CONSTANT(type, assignment) \
-    BOOST_STATIC_CONSTANT(type, assignment)
-# else // !defined(ASIO_DISABLE_BOOST_STATIC_CONSTANT)
-#  define ASIO_STATIC_CONSTANT(type, assignment) \
-    static const type assignment
-# endif // !defined(ASIO_DISABLE_BOOST_STATIC_CONSTANT)
-#endif // !defined(ASIO_STATIC_CONSTANT)
-
-// Boost array library.
-#if !defined(ASIO_HAS_BOOST_ARRAY)
-# if !defined(ASIO_DISABLE_BOOST_ARRAY)
-#  define ASIO_HAS_BOOST_ARRAY 1
-# endif // !defined(ASIO_DISABLE_BOOST_ARRAY)
-#endif // !defined(ASIO_HAS_BOOST_ARRAY)
-
-// Boost assert macro.
-#if !defined(ASIO_HAS_BOOST_ASSERT)
-# if !defined(ASIO_DISABLE_BOOST_ASSERT)
-#  define ASIO_HAS_BOOST_ASSERT 1
-# endif // !defined(ASIO_DISABLE_BOOST_ASSERT)
-#endif // !defined(ASIO_HAS_BOOST_ASSERT)
-
-// Boost limits header.
-#if !defined(ASIO_HAS_BOOST_LIMITS)
-# if !defined(ASIO_DISABLE_BOOST_LIMITS)
-#  define ASIO_HAS_BOOST_LIMITS 1
-# endif // !defined(ASIO_DISABLE_BOOST_LIMITS)
-#endif // !defined(ASIO_HAS_BOOST_LIMITS)
-
-// Boost throw_exception function.
-#if !defined(ASIO_HAS_BOOST_THROW_EXCEPTION)
-# if !defined(ASIO_DISABLE_BOOST_THROW_EXCEPTION)
-#  define ASIO_HAS_BOOST_THROW_EXCEPTION 1
-# endif // !defined(ASIO_DISABLE_BOOST_THROW_EXCEPTION)
-#endif // !defined(ASIO_HAS_BOOST_THROW_EXCEPTION)
-
-// Boost regex library.
-#if !defined(ASIO_HAS_BOOST_REGEX)
-# if !defined(ASIO_DISABLE_BOOST_REGEX)
-#  define ASIO_HAS_BOOST_REGEX 1
-# endif // !defined(ASIO_DISABLE_BOOST_REGEX)
-#endif // !defined(ASIO_HAS_BOOST_REGEX)
-
-// Boost bind function.
-#if !defined(ASIO_HAS_BOOST_BIND)
-# if !defined(ASIO_DISABLE_BOOST_BIND)
-#  define ASIO_HAS_BOOST_BIND 1
-# endif // !defined(ASIO_DISABLE_BOOST_BIND)
-#endif // !defined(ASIO_HAS_BOOST_BIND)
-
-// Boost's BOOST_WORKAROUND macro.
-#if !defined(ASIO_HAS_BOOST_WORKAROUND)
-# if !defined(ASIO_DISABLE_BOOST_WORKAROUND)
-#  define ASIO_HAS_BOOST_WORKAROUND 1
-# endif // !defined(ASIO_DISABLE_BOOST_WORKAROUND)
-#endif // !defined(ASIO_HAS_BOOST_WORKAROUND)
-
-// Microsoft Visual C++'s secure C runtime library.
-#if !defined(ASIO_HAS_SECURE_RTL)
-# if !defined(ASIO_DISABLE_SECURE_RTL)
-#  if defined(ASIO_MSVC) \
-    && (ASIO_MSVC >= 1400) \
-    && !defined(UNDER_CE)
-#   define ASIO_HAS_SECURE_RTL 1
-#  endif // defined(ASIO_MSVC)
-         // && (ASIO_MSVC >= 1400)
-         // && !defined(UNDER_CE)
-# endif // !defined(ASIO_DISABLE_SECURE_RTL)
-#endif // !defined(ASIO_HAS_SECURE_RTL)
-
-// Handler hooking. Disabled for ancient Borland C++ and gcc compilers.
-#if !defined(ASIO_HAS_HANDLER_HOOKS)
-# if !defined(ASIO_DISABLE_HANDLER_HOOKS)
-#  if defined(__GNUC__)
-#   if (__GNUC__ >= 3)
-#    define ASIO_HAS_HANDLER_HOOKS 1
-#   endif // (__GNUC__ >= 3)
-#  elif !defined(__BORLANDC__)
-#   define ASIO_HAS_HANDLER_HOOKS 1
-#  endif // !defined(__BORLANDC__)
-# endif // !defined(ASIO_DISABLE_HANDLER_HOOKS)
-#endif // !defined(ASIO_HAS_HANDLER_HOOKS)
-
-// Support for the __thread keyword extension.
-#if !defined(ASIO_DISABLE_THREAD_KEYWORD_EXTENSION)
-# if defined(__linux__)
-#  if defined(__GNUC__) && (defined(__i386__) || defined(__x86_64__))
-#   if ((__GNUC__ == 3) && (__GNUC_MINOR__ >= 3)) || (__GNUC__ > 3)
-#    if !defined(__INTEL_COMPILER) && !defined(__ICL)
-#     define ASIO_HAS_THREAD_KEYWORD_EXTENSION 1
-#     define ASIO_THREAD_KEYWORD __thread
-#    elif defined(__INTEL_COMPILER) && (__INTEL_COMPILER >= 1100)
-#     define ASIO_HAS_THREAD_KEYWORD_EXTENSION 1
-#    endif // defined(__INTEL_COMPILER) && (__INTEL_COMPILER >= 1100)
-#   endif // ((__GNUC__ == 3) && (__GNUC_MINOR__ >= 3)) || (__GNUC__ > 3)
-#  endif // defined(__GNUC__) && (defined(__i386__) || defined(__x86_64__))
-# endif // defined(__linux__)
-# if defined(ASIO_MSVC) && defined(ASIO_WINDOWS_RUNTIME)
-#  if (_MSC_VER >= 1700)
-#   define ASIO_HAS_THREAD_KEYWORD_EXTENSION 1
-#   define ASIO_THREAD_KEYWORD __declspec(thread)
-#  endif // (_MSC_VER >= 1700)
-# endif // defined(ASIO_MSVC) && defined(ASIO_WINDOWS_RUNTIME)
-#endif // !defined(ASIO_DISABLE_THREAD_KEYWORD_EXTENSION)
-#if !defined(ASIO_THREAD_KEYWORD)
-# define ASIO_THREAD_KEYWORD __thread
-#endif // !defined(ASIO_THREAD_KEYWORD)
-
-// Support for POSIX ssize_t typedef.
-#if !defined(ASIO_DISABLE_SSIZE_T)
-# if defined(__linux__) \
-   || (defined(__MACH__) && defined(__APPLE__))
-#  define ASIO_HAS_SSIZE_T 1
-# endif // defined(__linux__)
-        //   || (defined(__MACH__) && defined(__APPLE__))
-#endif // !defined(ASIO_DISABLE_SSIZE_T)
-
-#endif // ASIO_DETAIL_CONFIG_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/consuming_buffers.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/consuming_buffers.hpp
deleted file mode 100644
index 49121e27869e..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/consuming_buffers.hpp
+++ /dev/null
@@ -1,292 +0,0 @@
-//
-// detail/consuming_buffers.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_CONSUMING_BUFFERS_HPP
-#define ASIO_DETAIL_CONSUMING_BUFFERS_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include <cstddef>
-#include <iterator>
-#include "asio/buffer.hpp"
-#include "asio/detail/limits.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-// A proxy iterator for a sub-range in a list of buffers.
-template <typename Buffer, typename Buffer_Iterator>
-class consuming_buffers_iterator
-{
-public:
-  /// The type used for the distance between two iterators.
-  typedef std::ptrdiff_t difference_type;
-
-  /// The type of the value pointed to by the iterator.
-  typedef Buffer value_type;
-
-  /// The type of the result of applying operator->() to the iterator.
-  typedef const Buffer* pointer;
-
-  /// The type of the result of applying operator*() to the iterator.
-  typedef const Buffer& reference;
-
-  /// The iterator category.
-  typedef std::forward_iterator_tag iterator_category;
-
-  // Default constructor creates an end iterator.
-  consuming_buffers_iterator()
-    : at_end_(true)
-  {
-  }
-
-  // Construct with a buffer for the first entry and an iterator
-  // range for the remaining entries.
-  consuming_buffers_iterator(bool at_end, const Buffer& first,
-      Buffer_Iterator begin_remainder, Buffer_Iterator end_remainder,
-      std::size_t max_size)
-    : at_end_(max_size > 0 ? at_end : true),
-      first_(buffer(first, max_size)),
-      begin_remainder_(begin_remainder),
-      end_remainder_(end_remainder),
-      offset_(0),
-      max_size_(max_size)
-  {
-  }
-
-  // Dereference an iterator.
-  const Buffer& operator*() const
-  {
-    return dereference();
-  }
-
-  // Dereference an iterator.
-  const Buffer* operator->() const
-  {
-    return &dereference();
-  }
-
-  // Increment operator (prefix).
-  consuming_buffers_iterator& operator++()
-  {
-    increment();
-    return *this;
-  }
-
-  // Increment operator (postfix).
-  consuming_buffers_iterator operator++(int)
-  {
-    consuming_buffers_iterator tmp(*this);
-    ++*this;
-    return tmp;
-  }
-
-  // Test two iterators for equality.
-  friend bool operator==(const consuming_buffers_iterator& a,
-      const consuming_buffers_iterator& b)
-  {
-    return a.equal(b);
-  }
-
-  // Test two iterators for inequality.
-  friend bool operator!=(const consuming_buffers_iterator& a,
-      const consuming_buffers_iterator& b)
-  {
-    return !a.equal(b);
-  }
-
-private:
-  void increment()
-  {
-    if (!at_end_)
-    {
-      if (begin_remainder_ == end_remainder_
-          || offset_ + buffer_size(first_) >= max_size_)
-      {
-        at_end_ = true;
-      }
-      else
-      {
-        offset_ += buffer_size(first_);
-        first_ = buffer(*begin_remainder_++, max_size_ - offset_);
-      }
-    }
-  }
-
-  bool equal(const consuming_buffers_iterator& other) const
-  {
-    if (at_end_ && other.at_end_)
-      return true;
-    return !at_end_ && !other.at_end_
-      && buffer_cast<const void*>(first_)
-        == buffer_cast<const void*>(other.first_)
-      && buffer_size(first_) == buffer_size(other.first_)
-      && begin_remainder_ == other.begin_remainder_
-      && end_remainder_ == other.end_remainder_;
-  }
-
-  const Buffer& dereference() const
-  {
-    return first_;
-  }
-
-  bool at_end_;
-  Buffer first_;
-  Buffer_Iterator begin_remainder_;
-  Buffer_Iterator end_remainder_;
-  std::size_t offset_;
-  std::size_t max_size_;
-};
-
-// A proxy for a sub-range in a list of buffers.
-template <typename Buffer, typename Buffers>
-class consuming_buffers
-{
-public:
-  // The type for each element in the list of buffers.
-  typedef Buffer value_type;
-
-  // A forward-only iterator type that may be used to read elements.
-  typedef consuming_buffers_iterator<Buffer, typename Buffers::const_iterator>
-    const_iterator;
-
-  // Construct to represent the entire list of buffers.
-  consuming_buffers(const Buffers& buffers)
-    : buffers_(buffers),
-      at_end_(buffers_.begin() == buffers_.end()),
-      begin_remainder_(buffers_.begin()),
-      max_size_((std::numeric_limits<std::size_t>::max)())
-  {
-    if (!at_end_)
-    {
-      first_ = *buffers_.begin();
-      ++begin_remainder_;
-    }
-  }
-
-  // Copy constructor.
-  consuming_buffers(const consuming_buffers& other)
-    : buffers_(other.buffers_),
-      at_end_(other.at_end_),
-      first_(other.first_),
-      begin_remainder_(buffers_.begin()),
-      max_size_(other.max_size_)
-  {
-    typename Buffers::const_iterator first = other.buffers_.begin();
-    typename Buffers::const_iterator second = other.begin_remainder_;
-    std::advance(begin_remainder_, std::distance(first, second));
-  }
-
-  // Assignment operator.
-  consuming_buffers& operator=(const consuming_buffers& other)
-  {
-    buffers_ = other.buffers_;
-    at_end_ = other.at_end_;
-    first_ = other.first_;
-    begin_remainder_ = buffers_.begin();
-    typename Buffers::const_iterator first = other.buffers_.begin();
-    typename Buffers::const_iterator second = other.begin_remainder_;
-    std::advance(begin_remainder_, std::distance(first, second));
-    max_size_ = other.max_size_;
-    return *this;
-  }
-
-  // Get a forward-only iterator to the first element.
-  const_iterator begin() const
-  {
-    return const_iterator(at_end_, first_,
-        begin_remainder_, buffers_.end(), max_size_);
-  }
-
-  // Get a forward-only iterator for one past the last element.
-  const_iterator end() const
-  {
-    return const_iterator();
-  }
-
-  // Set the maximum size for a single transfer.
-  void prepare(std::size_t max_size)
-  {
-    max_size_ = max_size;
-  }
-
-  // Consume the specified number of bytes from the buffers.
-  void consume(std::size_t size)
-  {
-    // Remove buffers from the start until the specified size is reached.
-    while (size > 0 && !at_end_)
-    {
-      if (buffer_size(first_) <= size)
-      {
-        size -= buffer_size(first_);
-        if (begin_remainder_ == buffers_.end())
-          at_end_ = true;
-        else
-          first_ = *begin_remainder_++;
-      }
-      else
-      {
-        first_ = first_ + size;
-        size = 0;
-      }
-    }
-
-    // Remove any more empty buffers at the start.
-    while (!at_end_ && buffer_size(first_) == 0)
-    {
-      if (begin_remainder_ == buffers_.end())
-        at_end_ = true;
-      else
-        first_ = *begin_remainder_++;
-    }
-  }
-
-private:
-  Buffers buffers_;
-  bool at_end_;
-  Buffer first_;
-  typename Buffers::const_iterator begin_remainder_;
-  std::size_t max_size_;
-};
-
-// Specialisation for null_buffers to ensure that the null_buffers type is
-// always passed through to the underlying read or write operation.
-template <typename Buffer>
-class consuming_buffers<Buffer, asio::null_buffers>
-  : public asio::null_buffers
-{
-public:
-  consuming_buffers(const asio::null_buffers&)
-  {
-    // No-op.
-  }
-
-  void prepare(std::size_t)
-  {
-    // No-op.
-  }
-
-  void consume(std::size_t)
-  {
-    // No-op.
-  }
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_DETAIL_CONSUMING_BUFFERS_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/cstdint.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/cstdint.hpp
deleted file mode 100644
index 897610e0ef21..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/cstdint.hpp
+++ /dev/null
@@ -1,46 +0,0 @@
-//
-// detail/cstdint.hpp
-// ~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_CSTDINT_HPP
-#define ASIO_DETAIL_CSTDINT_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_HAS_CSTDINT)
-# include <cstdint>
-#else // defined(ASIO_HAS_CSTDINT)
-# include <boost/cstdint.hpp>
-#endif // defined(ASIO_HAS_CSTDINT)
-
-namespace asio {
-
-#if defined(ASIO_HAS_CSTDINT)
-using std::int16_t;
-using std::uint16_t;
-using std::int32_t;
-using std::uint32_t;
-using std::int64_t;
-using std::uint64_t;
-#else // defined(ASIO_HAS_CSTDINT)
-using boost::int16_t;
-using boost::uint16_t;
-using boost::int32_t;
-using boost::uint32_t;
-using boost::int64_t;
-using boost::uint64_t;
-#endif // defined(ASIO_HAS_CSTDINT)
-
-} // namespace asio
-
-#endif // ASIO_DETAIL_CSTDINT_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/date_time_fwd.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/date_time_fwd.hpp
deleted file mode 100644
index a8966c9171c3..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/date_time_fwd.hpp
+++ /dev/null
@@ -1,34 +0,0 @@
-//
-// detail/date_time_fwd.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_DATE_TIME_FWD_HPP
-#define ASIO_DETAIL_DATE_TIME_FWD_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-namespace boost {
-namespace date_time {
-
-template<class T, class TimeSystem>
-class base_time;
-
-} // namespace date_time
-namespace posix_time {
-
-class ptime;
-
-} // namespace posix_time
-} // namespace boost
-
-#endif // ASIO_DETAIL_DATE_TIME_FWD_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/deadline_timer_service.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/deadline_timer_service.hpp
deleted file mode 100644
index ddffc2e9586e..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/deadline_timer_service.hpp
+++ /dev/null
@@ -1,227 +0,0 @@
-//
-// detail/deadline_timer_service.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_DEADLINE_TIMER_SERVICE_HPP
-#define ASIO_DETAIL_DEADLINE_TIMER_SERVICE_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include <cstddef>
-#include "asio/error.hpp"
-#include "asio/io_service.hpp"
-#include "asio/detail/addressof.hpp"
-#include "asio/detail/bind_handler.hpp"
-#include "asio/detail/fenced_block.hpp"
-#include "asio/detail/noncopyable.hpp"
-#include "asio/detail/socket_ops.hpp"
-#include "asio/detail/socket_types.hpp"
-#include "asio/detail/timer_queue.hpp"
-#include "asio/detail/timer_scheduler.hpp"
-#include "asio/detail/wait_handler.hpp"
-#include "asio/detail/wait_op.hpp"
-
-#if defined(ASIO_WINDOWS_RUNTIME)
-# include <chrono>
-# include <thread>
-#endif // defined(ASIO_WINDOWS_RUNTIME)
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-template <typename Time_Traits>
-class deadline_timer_service
-{
-public:
-  // The time type.
-  typedef typename Time_Traits::time_type time_type;
-
-  // The duration type.
-  typedef typename Time_Traits::duration_type duration_type;
-
-  // The implementation type of the timer. This type is dependent on the
-  // underlying implementation of the timer service.
-  struct implementation_type
-    : private asio::detail::noncopyable
-  {
-    time_type expiry;
-    bool might_have_pending_waits;
-    typename timer_queue<Time_Traits>::per_timer_data timer_data;
-  };
-
-  // Constructor.
-  deadline_timer_service(asio::io_service& io_service)
-    : scheduler_(asio::use_service<timer_scheduler>(io_service))
-  {
-    scheduler_.init_task();
-    scheduler_.add_timer_queue(timer_queue_);
-  }
-
-  // Destructor.
-  ~deadline_timer_service()
-  {
-    scheduler_.remove_timer_queue(timer_queue_);
-  }
-
-  // Destroy all user-defined handler objects owned by the service.
-  void shutdown_service()
-  {
-  }
-
-  // Construct a new timer implementation.
-  void construct(implementation_type& impl)
-  {
-    impl.expiry = time_type();
-    impl.might_have_pending_waits = false;
-  }
-
-  // Destroy a timer implementation.
-  void destroy(implementation_type& impl)
-  {
-    asio::error_code ec;
-    cancel(impl, ec);
-  }
-
-  // Cancel any asynchronous wait operations associated with the timer.
-  std::size_t cancel(implementation_type& impl, asio::error_code& ec)
-  {
-    if (!impl.might_have_pending_waits)
-    {
-      ec = asio::error_code();
-      return 0;
-    }
-
-    ASIO_HANDLER_OPERATION(("deadline_timer", &impl, "cancel"));
-
-    std::size_t count = scheduler_.cancel_timer(timer_queue_, impl.timer_data);
-    impl.might_have_pending_waits = false;
-    ec = asio::error_code();
-    return count;
-  }
-
-  // Cancels one asynchronous wait operation associated with the timer.
-  std::size_t cancel_one(implementation_type& impl,
-      asio::error_code& ec)
-  {
-    if (!impl.might_have_pending_waits)
-    {
-      ec = asio::error_code();
-      return 0;
-    }
-
-    ASIO_HANDLER_OPERATION(("deadline_timer", &impl, "cancel_one"));
-
-    std::size_t count = scheduler_.cancel_timer(
-        timer_queue_, impl.timer_data, 1);
-    if (count == 0)
-      impl.might_have_pending_waits = false;
-    ec = asio::error_code();
-    return count;
-  }
-
-  // Get the expiry time for the timer as an absolute time.
-  time_type expires_at(const implementation_type& impl) const
-  {
-    return impl.expiry;
-  }
-
-  // Set the expiry time for the timer as an absolute time.
-  std::size_t expires_at(implementation_type& impl,
-      const time_type& expiry_time, asio::error_code& ec)
-  {
-    std::size_t count = cancel(impl, ec);
-    impl.expiry = expiry_time;
-    ec = asio::error_code();
-    return count;
-  }
-
-  // Get the expiry time for the timer relative to now.
-  duration_type expires_from_now(const implementation_type& impl) const
-  {
-    return Time_Traits::subtract(expires_at(impl), Time_Traits::now());
-  }
-
-  // Set the expiry time for the timer relative to now.
-  std::size_t expires_from_now(implementation_type& impl,
-      const duration_type& expiry_time, asio::error_code& ec)
-  {
-    return expires_at(impl,
-        Time_Traits::add(Time_Traits::now(), expiry_time), ec);
-  }
-
-  // Perform a blocking wait on the timer.
-  void wait(implementation_type& impl, asio::error_code& ec)
-  {
-    time_type now = Time_Traits::now();
-    ec = asio::error_code();
-    while (Time_Traits::less_than(now, impl.expiry) && !ec)
-    {
-      this->do_wait(Time_Traits::to_posix_duration(
-            Time_Traits::subtract(impl.expiry, now)), ec);
-      now = Time_Traits::now();
-    }
-  }
-
-  // Start an asynchronous wait on the timer.
-  template <typename Handler>
-  void async_wait(implementation_type& impl, Handler& handler)
-  {
-    // Allocate and construct an operation to wrap the handler.
-    typedef wait_handler<Handler> op;
-    typename op::ptr p = { asio::detail::addressof(handler),
-      asio_handler_alloc_helpers::allocate(
-        sizeof(op), handler), 0 };
-    p.p = new (p.v) op(handler);
-
-    impl.might_have_pending_waits = true;
-
-    ASIO_HANDLER_CREATION((p.p, "deadline_timer", &impl, "async_wait"));
-
-    scheduler_.schedule_timer(timer_queue_, impl.expiry, impl.timer_data, p.p);
-    p.v = p.p = 0;
-  }
-
-private:
-  // Helper function to wait given a duration type. The duration type should
-  // either be of type boost::posix_time::time_duration, or implement the
-  // required subset of its interface.
-  template <typename Duration>
-  void do_wait(const Duration& timeout, asio::error_code& ec)
-  {
-#if defined(ASIO_WINDOWS_RUNTIME)
-    std::this_thread::sleep_for(
-        std::chrono::seconds(timeout.total_seconds())
-        + std::chrono::microseconds(timeout.total_microseconds()));
-    ec = asio::error_code();
-#else // defined(ASIO_WINDOWS_RUNTIME)
-    ::timeval tv;
-    tv.tv_sec = timeout.total_seconds();
-    tv.tv_usec = timeout.total_microseconds() % 1000000;
-    socket_ops::select(0, 0, 0, 0, &tv, ec);
-#endif // defined(ASIO_WINDOWS_RUNTIME)
-  }
-
-  // The queue of timers.
-  timer_queue<Time_Traits> timer_queue_;
-
-  // The object that schedules and executes timers. Usually a reactor.
-  timer_scheduler& scheduler_;
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_DETAIL_DEADLINE_TIMER_SERVICE_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/dependent_type.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/dependent_type.hpp
deleted file mode 100644
index a2014cbff5f4..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/dependent_type.hpp
+++ /dev/null
@@ -1,36 +0,0 @@
-//
-// detail/dependent_type.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_DEPENDENT_TYPE_HPP
-#define ASIO_DETAIL_DEPENDENT_TYPE_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-template <typename DependsOn, typename T>
-struct dependent_type
-{
-  typedef T type;
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_DETAIL_DEPENDENT_TYPE_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/descriptor_ops.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/descriptor_ops.hpp
deleted file mode 100644
index 25bf7c754e80..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/descriptor_ops.hpp
+++ /dev/null
@@ -1,117 +0,0 @@
-//
-// detail/descriptor_ops.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_DESCRIPTOR_OPS_HPP
-#define ASIO_DETAIL_DESCRIPTOR_OPS_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if !defined(ASIO_WINDOWS) \
-  && !defined(ASIO_WINDOWS_RUNTIME) \
-  && !defined(__CYGWIN__)
-
-#include <cstddef>
-#include "asio/error_code.hpp"
-#include "asio/detail/socket_types.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-namespace descriptor_ops {
-
-// Descriptor state bits.
-enum
-{
-  // The user wants a non-blocking descriptor.
-  user_set_non_blocking = 1,
-
-  // The descriptor has been set non-blocking.
-  internal_non_blocking = 2,
-
-  // Helper "state" used to determine whether the descriptor is non-blocking.
-  non_blocking = user_set_non_blocking | internal_non_blocking,
-
-  // The descriptor may have been dup()-ed.
-  possible_dup = 4
-};
-
-typedef unsigned char state_type;
-
-template <typename ReturnType>
-inline ReturnType error_wrapper(ReturnType return_value,
-    asio::error_code& ec)
-{
-  ec = asio::error_code(errno,
-      asio::error::get_system_category());
-  return return_value;
-}
-
-ASIO_DECL int open(const char* path, int flags,
-    asio::error_code& ec);
-
-ASIO_DECL int close(int d, state_type& state,
-    asio::error_code& ec);
-
-ASIO_DECL bool set_user_non_blocking(int d,
-    state_type& state, bool value, asio::error_code& ec);
-
-ASIO_DECL bool set_internal_non_blocking(int d,
-    state_type& state, bool value, asio::error_code& ec);
-
-typedef iovec buf;
-
-ASIO_DECL std::size_t sync_read(int d, state_type state, buf* bufs,
-    std::size_t count, bool all_empty, asio::error_code& ec);
-
-ASIO_DECL bool non_blocking_read(int d, buf* bufs, std::size_t count,
-    asio::error_code& ec, std::size_t& bytes_transferred);
-
-ASIO_DECL std::size_t sync_write(int d, state_type state,
-    const buf* bufs, std::size_t count, bool all_empty,
-    asio::error_code& ec);
-
-ASIO_DECL bool non_blocking_write(int d,
-    const buf* bufs, std::size_t count,
-    asio::error_code& ec, std::size_t& bytes_transferred);
-
-ASIO_DECL int ioctl(int d, state_type& state, long cmd,
-    ioctl_arg_type* arg, asio::error_code& ec);
-
-ASIO_DECL int fcntl(int d, int cmd, asio::error_code& ec);
-
-ASIO_DECL int fcntl(int d, int cmd,
-    long arg, asio::error_code& ec);
-
-ASIO_DECL int poll_read(int d,
-    state_type state, asio::error_code& ec);
-
-ASIO_DECL int poll_write(int d,
-    state_type state, asio::error_code& ec);
-
-} // namespace descriptor_ops
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#if defined(ASIO_HEADER_ONLY)
-# include "asio/detail/impl/descriptor_ops.ipp"
-#endif // defined(ASIO_HEADER_ONLY)
-
-#endif // !defined(ASIO_WINDOWS)
-       //   && !defined(ASIO_WINDOWS_RUNTIME)
-       //   && !defined(__CYGWIN__)
-
-#endif // ASIO_DETAIL_DESCRIPTOR_OPS_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/descriptor_read_op.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/descriptor_read_op.hpp
deleted file mode 100644
index e833d3636d33..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/descriptor_read_op.hpp
+++ /dev/null
@@ -1,119 +0,0 @@
-//
-// detail/descriptor_read_op.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_DESCRIPTOR_READ_OP_HPP
-#define ASIO_DETAIL_DESCRIPTOR_READ_OP_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if !defined(ASIO_WINDOWS) && !defined(__CYGWIN__)
-
-#include "asio/detail/addressof.hpp"
-#include "asio/detail/bind_handler.hpp"
-#include "asio/detail/buffer_sequence_adapter.hpp"
-#include "asio/detail/descriptor_ops.hpp"
-#include "asio/detail/fenced_block.hpp"
-#include "asio/detail/reactor_op.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-template <typename MutableBufferSequence>
-class descriptor_read_op_base : public reactor_op
-{
-public:
-  descriptor_read_op_base(int descriptor,
-      const MutableBufferSequence& buffers, func_type complete_func)
-    : reactor_op(&descriptor_read_op_base::do_perform, complete_func),
-      descriptor_(descriptor),
-      buffers_(buffers)
-  {
-  }
-
-  static bool do_perform(reactor_op* base)
-  {
-    descriptor_read_op_base* o(static_cast<descriptor_read_op_base*>(base));
-
-    buffer_sequence_adapter<asio::mutable_buffer,
-        MutableBufferSequence> bufs(o->buffers_);
-
-    return descriptor_ops::non_blocking_read(o->descriptor_,
-        bufs.buffers(), bufs.count(), o->ec_, o->bytes_transferred_);
-  }
-
-private:
-  int descriptor_;
-  MutableBufferSequence buffers_;
-};
-
-template <typename MutableBufferSequence, typename Handler>
-class descriptor_read_op
-  : public descriptor_read_op_base<MutableBufferSequence>
-{
-public:
-  ASIO_DEFINE_HANDLER_PTR(descriptor_read_op);
-
-  descriptor_read_op(int descriptor,
-      const MutableBufferSequence& buffers, Handler& handler)
-    : descriptor_read_op_base<MutableBufferSequence>(
-        descriptor, buffers, &descriptor_read_op::do_complete),
-      handler_(ASIO_MOVE_CAST(Handler)(handler))
-  {
-  }
-
-  static void do_complete(io_service_impl* owner, operation* base,
-      const asio::error_code& /*ec*/,
-      std::size_t /*bytes_transferred*/)
-  {
-    // Take ownership of the handler object.
-    descriptor_read_op* o(static_cast<descriptor_read_op*>(base));
-    ptr p = { asio::detail::addressof(o->handler_), o, o };
-
-    ASIO_HANDLER_COMPLETION((o));
-
-    // Make a copy of the handler so that the memory can be deallocated before
-    // the upcall is made. Even if we're not about to make an upcall, a
-    // sub-object of the handler may be the true owner of the memory associated
-    // with the handler. Consequently, a local copy of the handler is required
-    // to ensure that any owning sub-object remains valid until after we have
-    // deallocated the memory here.
-    detail::binder2<Handler, asio::error_code, std::size_t>
-      handler(o->handler_, o->ec_, o->bytes_transferred_);
-    p.h = asio::detail::addressof(handler.handler_);
-    p.reset();
-
-    // Make the upcall if required.
-    if (owner)
-    {
-      fenced_block b(fenced_block::half);
-      ASIO_HANDLER_INVOCATION_BEGIN((handler.arg1_, handler.arg2_));
-      asio_handler_invoke_helpers::invoke(handler, handler.handler_);
-      ASIO_HANDLER_INVOCATION_END;
-    }
-  }
-
-private:
-  Handler handler_;
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // !defined(ASIO_WINDOWS) && !defined(__CYGWIN__)
-
-#endif // ASIO_DETAIL_DESCRIPTOR_READ_OP_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/descriptor_write_op.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/descriptor_write_op.hpp
deleted file mode 100644
index 721c26386d5b..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/descriptor_write_op.hpp
+++ /dev/null
@@ -1,119 +0,0 @@
-//
-// detail/descriptor_write_op.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_DESCRIPTOR_WRITE_OP_HPP
-#define ASIO_DETAIL_DESCRIPTOR_WRITE_OP_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if !defined(ASIO_WINDOWS) && !defined(__CYGWIN__)
-
-#include "asio/detail/addressof.hpp"
-#include "asio/detail/bind_handler.hpp"
-#include "asio/detail/buffer_sequence_adapter.hpp"
-#include "asio/detail/descriptor_ops.hpp"
-#include "asio/detail/fenced_block.hpp"
-#include "asio/detail/reactor_op.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-template <typename ConstBufferSequence>
-class descriptor_write_op_base : public reactor_op
-{
-public:
-  descriptor_write_op_base(int descriptor,
-      const ConstBufferSequence& buffers, func_type complete_func)
-    : reactor_op(&descriptor_write_op_base::do_perform, complete_func),
-      descriptor_(descriptor),
-      buffers_(buffers)
-  {
-  }
-
-  static bool do_perform(reactor_op* base)
-  {
-    descriptor_write_op_base* o(static_cast<descriptor_write_op_base*>(base));
-
-    buffer_sequence_adapter<asio::const_buffer,
-        ConstBufferSequence> bufs(o->buffers_);
-
-    return descriptor_ops::non_blocking_write(o->descriptor_,
-        bufs.buffers(), bufs.count(), o->ec_, o->bytes_transferred_);
-  }
-
-private:
-  int descriptor_;
-  ConstBufferSequence buffers_;
-};
-
-template <typename ConstBufferSequence, typename Handler>
-class descriptor_write_op
-  : public descriptor_write_op_base<ConstBufferSequence>
-{
-public:
-  ASIO_DEFINE_HANDLER_PTR(descriptor_write_op);
-
-  descriptor_write_op(int descriptor,
-      const ConstBufferSequence& buffers, Handler& handler)
-    : descriptor_write_op_base<ConstBufferSequence>(
-        descriptor, buffers, &descriptor_write_op::do_complete),
-      handler_(ASIO_MOVE_CAST(Handler)(handler))
-  {
-  }
-
-  static void do_complete(io_service_impl* owner, operation* base,
-      const asio::error_code& /*ec*/,
-      std::size_t /*bytes_transferred*/)
-  {
-    // Take ownership of the handler object.
-    descriptor_write_op* o(static_cast<descriptor_write_op*>(base));
-    ptr p = { asio::detail::addressof(o->handler_), o, o };
-
-    ASIO_HANDLER_COMPLETION((o));
-
-    // Make a copy of the handler so that the memory can be deallocated before
-    // the upcall is made. Even if we're not about to make an upcall, a
-    // sub-object of the handler may be the true owner of the memory associated
-    // with the handler. Consequently, a local copy of the handler is required
-    // to ensure that any owning sub-object remains valid until after we have
-    // deallocated the memory here.
-    detail::binder2<Handler, asio::error_code, std::size_t>
-      handler(o->handler_, o->ec_, o->bytes_transferred_);
-    p.h = asio::detail::addressof(handler.handler_);
-    p.reset();
-
-    // Make the upcall if required.
-    if (owner)
-    {
-      fenced_block b(fenced_block::half);
-      ASIO_HANDLER_INVOCATION_BEGIN((handler.arg1_, handler.arg2_));
-      asio_handler_invoke_helpers::invoke(handler, handler.handler_);
-      ASIO_HANDLER_INVOCATION_END;
-    }
-  }
-
-private:
-  Handler handler_;
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // !defined(ASIO_WINDOWS) && !defined(__CYGWIN__)
-
-#endif // ASIO_DETAIL_DESCRIPTOR_WRITE_OP_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/dev_poll_reactor.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/dev_poll_reactor.hpp
deleted file mode 100644
index 0dab12aa929c..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/dev_poll_reactor.hpp
+++ /dev/null
@@ -1,210 +0,0 @@
-//
-// detail/dev_poll_reactor.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_DEV_POLL_REACTOR_HPP
-#define ASIO_DETAIL_DEV_POLL_REACTOR_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_HAS_DEV_POLL)
-
-#include <cstddef>
-#include <vector>
-#include <sys/devpoll.h>
-#include "asio/detail/hash_map.hpp"
-#include "asio/detail/limits.hpp"
-#include "asio/detail/mutex.hpp"
-#include "asio/detail/op_queue.hpp"
-#include "asio/detail/reactor_op.hpp"
-#include "asio/detail/reactor_op_queue.hpp"
-#include "asio/detail/select_interrupter.hpp"
-#include "asio/detail/socket_types.hpp"
-#include "asio/detail/timer_queue_base.hpp"
-#include "asio/detail/timer_queue_set.hpp"
-#include "asio/detail/wait_op.hpp"
-#include "asio/io_service.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-class dev_poll_reactor
-  : public asio::detail::service_base<dev_poll_reactor>
-{
-public:
-  enum op_types { read_op = 0, write_op = 1,
-    connect_op = 1, except_op = 2, max_ops = 3 };
-
-  // Per-descriptor data.
-  struct per_descriptor_data
-  {
-  };
-
-  // Constructor.
-  ASIO_DECL dev_poll_reactor(asio::io_service& io_service);
-
-  // Destructor.
-  ASIO_DECL ~dev_poll_reactor();
-
-  // Destroy all user-defined handler objects owned by the service.
-  ASIO_DECL void shutdown_service();
-
-  // Recreate internal descriptors following a fork.
-  ASIO_DECL void fork_service(
-      asio::io_service::fork_event fork_ev);
-
-  // Initialise the task.
-  ASIO_DECL void init_task();
-
-  // Register a socket with the reactor. Returns 0 on success, system error
-  // code on failure.
-  ASIO_DECL int register_descriptor(socket_type, per_descriptor_data&);
-
-  // Register a descriptor with an associated single operation. Returns 0 on
-  // success, system error code on failure.
-  ASIO_DECL int register_internal_descriptor(
-      int op_type, socket_type descriptor,
-      per_descriptor_data& descriptor_data, reactor_op* op);
-
-  // Move descriptor registration from one descriptor_data object to another.
-  ASIO_DECL void move_descriptor(socket_type descriptor,
-      per_descriptor_data& target_descriptor_data,
-      per_descriptor_data& source_descriptor_data);
-
-  // Post a reactor operation for immediate completion.
-  void post_immediate_completion(reactor_op* op, bool is_continuation)
-  {
-    io_service_.post_immediate_completion(op, is_continuation);
-  }
-
-  // Start a new operation. The reactor operation will be performed when the
-  // given descriptor is flagged as ready, or an error has occurred.
-  ASIO_DECL void start_op(int op_type, socket_type descriptor,
-      per_descriptor_data&, reactor_op* op,
-      bool is_continuation, bool allow_speculative);
-
-  // Cancel all operations associated with the given descriptor. The
-  // handlers associated with the descriptor will be invoked with the
-  // operation_aborted error.
-  ASIO_DECL void cancel_ops(socket_type descriptor, per_descriptor_data&);
-
-  // Cancel any operations that are running against the descriptor and remove
-  // its registration from the reactor.
-  ASIO_DECL void deregister_descriptor(socket_type descriptor,
-      per_descriptor_data&, bool closing);
-
-  // Cancel any operations that are running against the descriptor and remove
-  // its registration from the reactor.
-  ASIO_DECL void deregister_internal_descriptor(
-      socket_type descriptor, per_descriptor_data&);
-
-  // Add a new timer queue to the reactor.
-  template <typename Time_Traits>
-  void add_timer_queue(timer_queue<Time_Traits>& queue);
-
-  // Remove a timer queue from the reactor.
-  template <typename Time_Traits>
-  void remove_timer_queue(timer_queue<Time_Traits>& queue);
-
-  // Schedule a new operation in the given timer queue to expire at the
-  // specified absolute time.
-  template <typename Time_Traits>
-  void schedule_timer(timer_queue<Time_Traits>& queue,
-      const typename Time_Traits::time_type& time,
-      typename timer_queue<Time_Traits>::per_timer_data& timer, wait_op* op);
-
-  // Cancel the timer operations associated with the given token. Returns the
-  // number of operations that have been posted or dispatched.
-  template <typename Time_Traits>
-  std::size_t cancel_timer(timer_queue<Time_Traits>& queue,
-      typename timer_queue<Time_Traits>::per_timer_data& timer,
-      std::size_t max_cancelled = (std::numeric_limits<std::size_t>::max)());
-
-  // Run /dev/poll once until interrupted or events are ready to be dispatched.
-  ASIO_DECL void run(bool block, op_queue<operation>& ops);
-
-  // Interrupt the select loop.
-  ASIO_DECL void interrupt();
-
-private:
-  // Create the /dev/poll file descriptor. Throws an exception if the descriptor
-  // cannot be created.
-  ASIO_DECL static int do_dev_poll_create();
-
-  // Helper function to add a new timer queue.
-  ASIO_DECL void do_add_timer_queue(timer_queue_base& queue);
-
-  // Helper function to remove a timer queue.
-  ASIO_DECL void do_remove_timer_queue(timer_queue_base& queue);
-
-  // Get the timeout value for the /dev/poll DP_POLL operation. The timeout
-  // value is returned as a number of milliseconds. A return value of -1
-  // indicates that the poll should block indefinitely.
-  ASIO_DECL int get_timeout();
-
-  // Cancel all operations associated with the given descriptor. The do_cancel
-  // function of the handler objects will be invoked. This function does not
-  // acquire the dev_poll_reactor's mutex.
-  ASIO_DECL void cancel_ops_unlocked(socket_type descriptor,
-      const asio::error_code& ec);
-
-  // Helper class used to reregister descriptors after a fork.
-  class fork_helper;
-  friend class fork_helper;
-
-  // Add a pending event entry for the given descriptor.
-  ASIO_DECL ::pollfd& add_pending_event_change(int descriptor);
-
-  // The io_service implementation used to post completions.
-  io_service_impl& io_service_;
-
-  // Mutex to protect access to internal data.
-  asio::detail::mutex mutex_;
-
-  // The /dev/poll file descriptor.
-  int dev_poll_fd_;
-
-  // Vector of /dev/poll events waiting to be written to the descriptor.
-  std::vector< ::pollfd> pending_event_changes_;
-
-  // Hash map to associate a descriptor with a pending event change index.
-  hash_map<int, std::size_t> pending_event_change_index_;
-
-  // The interrupter is used to break a blocking DP_POLL operation.
-  select_interrupter interrupter_;
-
-  // The queues of read, write and except operations.
-  reactor_op_queue<socket_type> op_queue_[max_ops];
-
-  // The timer queues.
-  timer_queue_set timer_queues_;
-
-  // Whether the service has been shut down.
-  bool shutdown_;
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#include "asio/detail/impl/dev_poll_reactor.hpp"
-#if defined(ASIO_HEADER_ONLY)
-# include "asio/detail/impl/dev_poll_reactor.ipp"
-#endif // defined(ASIO_HEADER_ONLY)
-
-#endif // defined(ASIO_HAS_DEV_POLL)
-
-#endif // ASIO_DETAIL_DEV_POLL_REACTOR_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/epoll_reactor.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/epoll_reactor.hpp
deleted file mode 100644
index 2d5bd76fbce9..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/epoll_reactor.hpp
+++ /dev/null
@@ -1,242 +0,0 @@
-//
-// detail/epoll_reactor.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_EPOLL_REACTOR_HPP
-#define ASIO_DETAIL_EPOLL_REACTOR_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_HAS_EPOLL)
-
-#include "asio/io_service.hpp"
-#include "asio/detail/atomic_count.hpp"
-#include "asio/detail/limits.hpp"
-#include "asio/detail/mutex.hpp"
-#include "asio/detail/object_pool.hpp"
-#include "asio/detail/op_queue.hpp"
-#include "asio/detail/reactor_op.hpp"
-#include "asio/detail/select_interrupter.hpp"
-#include "asio/detail/socket_types.hpp"
-#include "asio/detail/timer_queue_base.hpp"
-#include "asio/detail/timer_queue_set.hpp"
-#include "asio/detail/wait_op.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-class epoll_reactor
-  : public asio::detail::service_base<epoll_reactor>
-{
-public:
-  enum op_types { read_op = 0, write_op = 1,
-    connect_op = 1, except_op = 2, max_ops = 3 };
-
-  // Per-descriptor queues.
-  class descriptor_state : operation
-  {
-    friend class epoll_reactor;
-    friend class object_pool_access;
-
-    descriptor_state* next_;
-    descriptor_state* prev_;
-
-    mutex mutex_;
-    epoll_reactor* reactor_;
-    int descriptor_;
-    uint32_t registered_events_;
-    op_queue<reactor_op> op_queue_[max_ops];
-    bool shutdown_;
-
-    ASIO_DECL descriptor_state();
-    void set_ready_events(uint32_t events) { task_result_ = events; }
-    ASIO_DECL operation* perform_io(uint32_t events);
-    ASIO_DECL static void do_complete(
-        io_service_impl* owner, operation* base,
-        const asio::error_code& ec, std::size_t bytes_transferred);
-  };
-
-  // Per-descriptor data.
-  typedef descriptor_state* per_descriptor_data;
-
-  // Constructor.
-  ASIO_DECL epoll_reactor(asio::io_service& io_service);
-
-  // Destructor.
-  ASIO_DECL ~epoll_reactor();
-
-  // Destroy all user-defined handler objects owned by the service.
-  ASIO_DECL void shutdown_service();
-
-  // Recreate internal descriptors following a fork.
-  ASIO_DECL void fork_service(
-      asio::io_service::fork_event fork_ev);
-
-  // Initialise the task.
-  ASIO_DECL void init_task();
-
-  // Register a socket with the reactor. Returns 0 on success, system error
-  // code on failure.
-  ASIO_DECL int register_descriptor(socket_type descriptor,
-      per_descriptor_data& descriptor_data);
-
-  // Register a descriptor with an associated single operation. Returns 0 on
-  // success, system error code on failure.
-  ASIO_DECL int register_internal_descriptor(
-      int op_type, socket_type descriptor,
-      per_descriptor_data& descriptor_data, reactor_op* op);
-
-  // Move descriptor registration from one descriptor_data object to another.
-  ASIO_DECL void move_descriptor(socket_type descriptor,
-      per_descriptor_data& target_descriptor_data,
-      per_descriptor_data& source_descriptor_data);
-
-  // Post a reactor operation for immediate completion.
-  void post_immediate_completion(reactor_op* op, bool is_continuation)
-  {
-    io_service_.post_immediate_completion(op, is_continuation);
-  }
-
-  // Start a new operation. The reactor operation will be performed when the
-  // given descriptor is flagged as ready, or an error has occurred.
-  ASIO_DECL void start_op(int op_type, socket_type descriptor,
-      per_descriptor_data& descriptor_data, reactor_op* op,
-      bool is_continuation, bool allow_speculative);
-
-  // Cancel all operations associated with the given descriptor. The
-  // handlers associated with the descriptor will be invoked with the
-  // operation_aborted error.
-  ASIO_DECL void cancel_ops(socket_type descriptor,
-      per_descriptor_data& descriptor_data);
-
-  // Cancel any operations that are running against the descriptor and remove
-  // its registration from the reactor.
-  ASIO_DECL void deregister_descriptor(socket_type descriptor,
-      per_descriptor_data& descriptor_data, bool closing);
-
-  // Remote the descriptor's registration from the reactor.
-  ASIO_DECL void deregister_internal_descriptor(
-      socket_type descriptor, per_descriptor_data& descriptor_data);
-
-  // Add a new timer queue to the reactor.
-  template <typename Time_Traits>
-  void add_timer_queue(timer_queue<Time_Traits>& timer_queue);
-
-  // Remove a timer queue from the reactor.
-  template <typename Time_Traits>
-  void remove_timer_queue(timer_queue<Time_Traits>& timer_queue);
-
-  // Schedule a new operation in the given timer queue to expire at the
-  // specified absolute time.
-  template <typename Time_Traits>
-  void schedule_timer(timer_queue<Time_Traits>& queue,
-      const typename Time_Traits::time_type& time,
-      typename timer_queue<Time_Traits>::per_timer_data& timer, wait_op* op);
-
-  // Cancel the timer operations associated with the given token. Returns the
-  // number of operations that have been posted or dispatched.
-  template <typename Time_Traits>
-  std::size_t cancel_timer(timer_queue<Time_Traits>& queue,
-      typename timer_queue<Time_Traits>::per_timer_data& timer,
-      std::size_t max_cancelled = (std::numeric_limits<std::size_t>::max)());
-
-  // Run epoll once until interrupted or events are ready to be dispatched.
-  ASIO_DECL void run(bool block, op_queue<operation>& ops);
-
-  // Interrupt the select loop.
-  ASIO_DECL void interrupt();
-
-private:
-  // The hint to pass to epoll_create to size its data structures.
-  enum { epoll_size = 20000 };
-
-  // Create the epoll file descriptor. Throws an exception if the descriptor
-  // cannot be created.
-  ASIO_DECL static int do_epoll_create();
-
-  // Create the timerfd file descriptor. Does not throw.
-  ASIO_DECL static int do_timerfd_create();
-
-  // Allocate a new descriptor state object.
-  ASIO_DECL descriptor_state* allocate_descriptor_state();
-
-  // Free an existing descriptor state object.
-  ASIO_DECL void free_descriptor_state(descriptor_state* s);
-
-  // Helper function to add a new timer queue.
-  ASIO_DECL void do_add_timer_queue(timer_queue_base& queue);
-
-  // Helper function to remove a timer queue.
-  ASIO_DECL void do_remove_timer_queue(timer_queue_base& queue);
-
-  // Called to recalculate and update the timeout.
-  ASIO_DECL void update_timeout();
-
-  // Get the timeout value for the epoll_wait call. The timeout value is
-  // returned as a number of milliseconds. A return value of -1 indicates
-  // that epoll_wait should block indefinitely.
-  ASIO_DECL int get_timeout();
-
-#if defined(ASIO_HAS_TIMERFD)
-  // Get the timeout value for the timer descriptor. The return value is the
-  // flag argument to be used when calling timerfd_settime.
-  ASIO_DECL int get_timeout(itimerspec& ts);
-#endif // defined(ASIO_HAS_TIMERFD)
-
-  // The io_service implementation used to post completions.
-  io_service_impl& io_service_;
-
-  // Mutex to protect access to internal data.
-  mutex mutex_;
-
-  // The interrupter is used to break a blocking epoll_wait call.
-  select_interrupter interrupter_;
-
-  // The epoll file descriptor.
-  int epoll_fd_;
-
-  // The timer file descriptor.
-  int timer_fd_;
-
-  // The timer queues.
-  timer_queue_set timer_queues_;
-
-  // Whether the service has been shut down.
-  bool shutdown_;
-
-  // Mutex to protect access to the registered descriptors.
-  mutex registered_descriptors_mutex_;
-
-  // Keep track of all registered descriptors.
-  object_pool<descriptor_state> registered_descriptors_;
-
-  // Helper class to do post-perform_io cleanup.
-  struct perform_io_cleanup_on_block_exit;
-  friend struct perform_io_cleanup_on_block_exit;
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#include "asio/detail/impl/epoll_reactor.hpp"
-#if defined(ASIO_HEADER_ONLY)
-# include "asio/detail/impl/epoll_reactor.ipp"
-#endif // defined(ASIO_HEADER_ONLY)
-
-#endif // defined(ASIO_HAS_EPOLL)
-
-#endif // ASIO_DETAIL_EPOLL_REACTOR_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/event.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/event.hpp
deleted file mode 100644
index c4a3c2be42d0..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/event.hpp
+++ /dev/null
@@ -1,48 +0,0 @@
-//
-// detail/event.hpp
-// ~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_EVENT_HPP
-#define ASIO_DETAIL_EVENT_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if !defined(ASIO_HAS_THREADS)
-# include "asio/detail/null_event.hpp"
-#elif defined(ASIO_WINDOWS)
-# include "asio/detail/win_event.hpp"
-#elif defined(ASIO_HAS_PTHREADS)
-# include "asio/detail/posix_event.hpp"
-#elif defined(ASIO_HAS_STD_MUTEX_AND_CONDVAR)
-# include "asio/detail/std_event.hpp"
-#else
-# error Only Windows, POSIX and std::condition_variable are supported!
-#endif
-
-namespace asio {
-namespace detail {
-
-#if !defined(ASIO_HAS_THREADS)
-typedef null_event event;
-#elif defined(ASIO_WINDOWS)
-typedef win_event event;
-#elif defined(ASIO_HAS_PTHREADS)
-typedef posix_event event;
-#elif defined(ASIO_HAS_STD_MUTEX_AND_CONDVAR)
-typedef std_event event;
-#endif
-
-} // namespace detail
-} // namespace asio
-
-#endif // ASIO_DETAIL_EVENT_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/eventfd_select_interrupter.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/eventfd_select_interrupter.hpp
deleted file mode 100644
index 8beb658f4df9..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/eventfd_select_interrupter.hpp
+++ /dev/null
@@ -1,83 +0,0 @@
-//
-// detail/eventfd_select_interrupter.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-// Copyright (c) 2008 Roelof Naude (roelof.naude at gmail dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_EVENTFD_SELECT_INTERRUPTER_HPP
-#define ASIO_DETAIL_EVENTFD_SELECT_INTERRUPTER_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_HAS_EVENTFD)
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-class eventfd_select_interrupter
-{
-public:
-  // Constructor.
-  ASIO_DECL eventfd_select_interrupter();
-
-  // Destructor.
-  ASIO_DECL ~eventfd_select_interrupter();
-
-  // Recreate the interrupter's descriptors. Used after a fork.
-  ASIO_DECL void recreate();
-
-  // Interrupt the select call.
-  ASIO_DECL void interrupt();
-
-  // Reset the select interrupt. Returns true if the call was interrupted.
-  ASIO_DECL bool reset();
-
-  // Get the read descriptor to be passed to select.
-  int read_descriptor() const
-  {
-    return read_descriptor_;
-  }
-
-private:
-  // Open the descriptors. Throws on error.
-  ASIO_DECL void open_descriptors();
-
-  // Close the descriptors.
-  ASIO_DECL void close_descriptors();
-
-  // The read end of a connection used to interrupt the select call. This file
-  // descriptor is passed to select such that when it is time to stop, a single
-  // 64bit value will be written on the other end of the connection and this
-  // descriptor will become readable.
-  int read_descriptor_;
-
-  // The write end of a connection used to interrupt the select call. A single
-  // 64bit non-zero value may be written to this to wake up the select which is
-  // waiting for the other end to become readable. This descriptor will only
-  // differ from the read descriptor when a pipe is used.
-  int write_descriptor_;
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#if defined(ASIO_HEADER_ONLY)
-# include "asio/detail/impl/eventfd_select_interrupter.ipp"
-#endif // defined(ASIO_HEADER_ONLY)
-
-#endif // defined(ASIO_HAS_EVENTFD)
-
-#endif // ASIO_DETAIL_EVENTFD_SELECT_INTERRUPTER_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/fd_set_adapter.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/fd_set_adapter.hpp
deleted file mode 100644
index af85e09a0bac..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/fd_set_adapter.hpp
+++ /dev/null
@@ -1,39 +0,0 @@
-//
-// detail/fd_set_adapter.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_FD_SET_ADAPTER_HPP
-#define ASIO_DETAIL_FD_SET_ADAPTER_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if !defined(ASIO_WINDOWS_RUNTIME)
-
-#include "asio/detail/posix_fd_set_adapter.hpp"
-#include "asio/detail/win_fd_set_adapter.hpp"
-
-namespace asio {
-namespace detail {
-
-#if defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-typedef win_fd_set_adapter fd_set_adapter;
-#else
-typedef posix_fd_set_adapter fd_set_adapter;
-#endif
-
-} // namespace detail
-} // namespace asio
-
-#endif // !defined(ASIO_WINDOWS_RUNTIME)
-
-#endif // ASIO_DETAIL_FD_SET_ADAPTER_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/fenced_block.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/fenced_block.hpp
deleted file mode 100644
index fab1d8c18055..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/fenced_block.hpp
+++ /dev/null
@@ -1,76 +0,0 @@
-//
-// detail/fenced_block.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_FENCED_BLOCK_HPP
-#define ASIO_DETAIL_FENCED_BLOCK_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if !defined(ASIO_HAS_THREADS) \
-  || defined(ASIO_DISABLE_FENCED_BLOCK)
-# include "asio/detail/null_fenced_block.hpp"
-#elif defined(__MACH__) && defined(__APPLE__)
-# include "asio/detail/macos_fenced_block.hpp"
-#elif defined(__sun)
-# include "asio/detail/solaris_fenced_block.hpp"
-#elif defined(__GNUC__) && defined(__arm__) \
-  && !defined(__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4)
-# include "asio/detail/gcc_arm_fenced_block.hpp"
-#elif defined(__GNUC__) && (defined(__hppa) || defined(__hppa__))
-# include "asio/detail/gcc_hppa_fenced_block.hpp"
-#elif defined(__GNUC__) && (defined(__i386__) || defined(__x86_64__))
-# include "asio/detail/gcc_x86_fenced_block.hpp"
-#elif defined(__GNUC__) \
-  && ((__GNUC__ == 4 && __GNUC_MINOR__ >= 1) || (__GNUC__ > 4)) \
-  && !defined(__INTEL_COMPILER) && !defined(__ICL) \
-  && !defined(__ICC) && !defined(__ECC) && !defined(__PATHSCALE__)
-# include "asio/detail/gcc_sync_fenced_block.hpp"
-#elif defined(ASIO_WINDOWS) && !defined(UNDER_CE)
-# include "asio/detail/win_fenced_block.hpp"
-#else
-# include "asio/detail/null_fenced_block.hpp"
-#endif
-
-namespace asio {
-namespace detail {
-
-#if !defined(ASIO_HAS_THREADS) \
-  || defined(ASIO_DISABLE_FENCED_BLOCK)
-typedef null_fenced_block fenced_block;
-#elif defined(__MACH__) && defined(__APPLE__)
-typedef macos_fenced_block fenced_block;
-#elif defined(__sun)
-typedef solaris_fenced_block fenced_block;
-#elif defined(__GNUC__) && defined(__arm__) \
-  && !defined(__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4)
-typedef gcc_arm_fenced_block fenced_block;
-#elif defined(__GNUC__) && (defined(__hppa) || defined(__hppa__))
-typedef gcc_hppa_fenced_block fenced_block;
-#elif defined(__GNUC__) && (defined(__i386__) || defined(__x86_64__))
-typedef gcc_x86_fenced_block fenced_block;
-#elif defined(__GNUC__) \
-  && ((__GNUC__ == 4 && __GNUC_MINOR__ >= 1) || (__GNUC__ > 4)) \
-  && !defined(__INTEL_COMPILER) && !defined(__ICL) \
-  && !defined(__ICC) && !defined(__ECC) && !defined(__PATHSCALE__)
-typedef gcc_sync_fenced_block fenced_block;
-#elif defined(ASIO_WINDOWS) && !defined(UNDER_CE)
-typedef win_fenced_block fenced_block;
-#else
-typedef null_fenced_block fenced_block;
-#endif
-
-} // namespace detail
-} // namespace asio
-
-#endif // ASIO_DETAIL_FENCED_BLOCK_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/function.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/function.hpp
deleted file mode 100644
index 854ef3f826e6..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/function.hpp
+++ /dev/null
@@ -1,38 +0,0 @@
-//
-// detail/function.hpp
-// ~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_FUNCTION_HPP
-#define ASIO_DETAIL_FUNCTION_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_HAS_STD_FUNCTION)
-# include <functional>
-#else // defined(ASIO_HAS_STD_FUNCTION)
-# include <boost/function.hpp>
-#endif // defined(ASIO_HAS_STD_FUNCTION)
-
-namespace asio {
-namespace detail {
-
-#if defined(ASIO_HAS_STD_FUNCTION)
-using std::function;
-#else // defined(ASIO_HAS_STD_FUNCTION)
-using boost::function;
-#endif // defined(ASIO_HAS_STD_FUNCTION)
-
-} // namespace detail
-} // namespace asio
-
-#endif // ASIO_DETAIL_FUNCTION_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/gcc_arm_fenced_block.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/gcc_arm_fenced_block.hpp
deleted file mode 100644
index 5248634e5968..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/gcc_arm_fenced_block.hpp
+++ /dev/null
@@ -1,89 +0,0 @@
-//
-// detail/gcc_arm_fenced_block.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_GCC_ARM_FENCED_BLOCK_HPP
-#define ASIO_DETAIL_GCC_ARM_FENCED_BLOCK_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(__GNUC__) && defined(__arm__)
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-class gcc_arm_fenced_block
-  : private noncopyable
-{
-public:
-  enum half_t { half };
-  enum full_t { full };
-
-  // Constructor for a half fenced block.
-  explicit gcc_arm_fenced_block(half_t)
-  {
-  }
-
-  // Constructor for a full fenced block.
-  explicit gcc_arm_fenced_block(full_t)
-  {
-    barrier();
-  }
-
-  // Destructor.
-  ~gcc_arm_fenced_block()
-  {
-    barrier();
-  }
-
-private:
-  static void barrier()
-  {
-#if defined(__ARM_ARCH_4__) \
-    || defined(__ARM_ARCH_4T__) \
-    || defined(__ARM_ARCH_5__) \
-    || defined(__ARM_ARCH_5E__) \
-    || defined(__ARM_ARCH_5T__) \
-    || defined(__ARM_ARCH_5TE__) \
-    || defined(__ARM_ARCH_5TEJ__) \
-    || defined(__ARM_ARCH_6__) \
-    || defined(__ARM_ARCH_6J__) \
-    || defined(__ARM_ARCH_6K__) \
-    || defined(__ARM_ARCH_6Z__) \
-    || defined(__ARM_ARCH_6ZK__) \
-    || defined(__ARM_ARCH_6T2__)
-# if defined(__thumb__)
-    // This is just a placeholder and almost certainly not sufficient.
-    __asm__ __volatile__ ("" : : : "memory");
-# else // defined(__thumb__)
-    int a = 0, b = 0;
-    __asm__ __volatile__ ("swp %0, %1, [%2]"
-        : "=&r"(a) : "r"(1), "r"(&b) : "memory", "cc");
-# endif // defined(__thumb__)
-#else
-    // ARMv7 and later.
-    __asm__ __volatile__ ("dmb" : : : "memory");
-#endif
-  }
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // defined(__GNUC__) && defined(__arm__)
-
-#endif // ASIO_DETAIL_GCC_ARM_FENCED_BLOCK_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/gcc_hppa_fenced_block.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/gcc_hppa_fenced_block.hpp
deleted file mode 100644
index 27bde7e70f62..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/gcc_hppa_fenced_block.hpp
+++ /dev/null
@@ -1,66 +0,0 @@
-//
-// detail/gcc_hppa_fenced_block.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_GCC_HPPA_FENCED_BLOCK_HPP
-#define ASIO_DETAIL_GCC_HPPA_FENCED_BLOCK_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(__GNUC__) && (defined(__hppa) || defined(__hppa__))
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-class gcc_hppa_fenced_block
-  : private noncopyable
-{
-public:
-  enum half_t { half };
-  enum full_t { full };
-
-  // Constructor for a half fenced block.
-  explicit gcc_hppa_fenced_block(half_t)
-  {
-  }
-
-  // Constructor for a full fenced block.
-  explicit gcc_hppa_fenced_block(full_t)
-  {
-    barrier();
-  }
-
-  // Destructor.
-  ~gcc_hppa_fenced_block()
-  {
-    barrier();
-  }
-
-private:
-  static void barrier()
-  {
-    // This is just a placeholder and almost certainly not sufficient.
-    __asm__ __volatile__ ("" : : : "memory");
-  }
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // defined(__GNUC__) && (defined(__hppa) || defined(__hppa__))
-
-#endif // ASIO_DETAIL_GCC_HPPA_FENCED_BLOCK_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/gcc_sync_fenced_block.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/gcc_sync_fenced_block.hpp
deleted file mode 100644
index 53cc8f9db55c..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/gcc_sync_fenced_block.hpp
+++ /dev/null
@@ -1,63 +0,0 @@
-//
-// detail/gcc_sync_fenced_block.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_GCC_SYNC_FENCED_BLOCK_HPP
-#define ASIO_DETAIL_GCC_SYNC_FENCED_BLOCK_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(__GNUC__) \
-  && ((__GNUC__ == 4 && __GNUC_MINOR__ >= 1) || (__GNUC__ > 4)) \
-  && !defined(__INTEL_COMPILER) && !defined(__ICL) \
-  && !defined(__ICC) && !defined(__ECC) && !defined(__PATHSCALE__)
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-class gcc_sync_fenced_block
-  : private noncopyable
-{
-public:
-  enum half_or_full_t { half, full };
-
-  // Constructor.
-  explicit gcc_sync_fenced_block(half_or_full_t)
-    : value_(0)
-  {
-    __sync_lock_test_and_set(&value_, 1);
-  }
-
-  // Destructor.
-  ~gcc_sync_fenced_block()
-  {
-    __sync_lock_release(&value_);
-  }
-
-private:
-  int value_;
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // defined(__GNUC__)
-       // && ((__GNUC__ == 4 && __GNUC_MINOR__ >= 1) || (__GNUC__ > 4))
-       // && !defined(__INTEL_COMPILER) && !defined(__ICL)
-       // && !defined(__ICC) && !defined(__ECC) && !defined(__PATHSCALE__)
-
-#endif // ASIO_DETAIL_GCC_SYNC_FENCED_BLOCK_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/gcc_x86_fenced_block.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/gcc_x86_fenced_block.hpp
deleted file mode 100644
index fc64cd721925..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/gcc_x86_fenced_block.hpp
+++ /dev/null
@@ -1,89 +0,0 @@
-//
-// detail/gcc_x86_fenced_block.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_GCC_X86_FENCED_BLOCK_HPP
-#define ASIO_DETAIL_GCC_X86_FENCED_BLOCK_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(__GNUC__) && (defined(__i386__) || defined(__x86_64__))
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-class gcc_x86_fenced_block
-  : private noncopyable
-{
-public:
-  enum half_t { half };
-  enum full_t { full };
-
-  // Constructor for a half fenced block.
-  explicit gcc_x86_fenced_block(half_t)
-  {
-  }
-
-  // Constructor for a full fenced block.
-  explicit gcc_x86_fenced_block(full_t)
-  {
-    lbarrier();
-  }
-
-  // Destructor.
-  ~gcc_x86_fenced_block()
-  {
-    sbarrier();
-  }
-
-private:
-  static int barrier()
-  {
-    int r = 0, m = 1;
-    __asm__ __volatile__ (
-        "xchgl %0, %1" :
-        "=r"(r), "=m"(m) :
-        "0"(1), "m"(m) :
-        "memory", "cc");
-    return r;
-  }
-
-  static void lbarrier()
-  {
-#if defined(__SSE2__)
-    __asm__ __volatile__ ("lfence" ::: "memory");
-#else // defined(__SSE2__)
-    barrier();
-#endif // defined(__SSE2__)
-  }
-
-  static void sbarrier()
-  {
-#if defined(__SSE2__)
-    __asm__ __volatile__ ("sfence" ::: "memory");
-#else // defined(__SSE2__)
-    barrier();
-#endif // defined(__SSE2__)
-  }
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // defined(__GNUC__) && (defined(__i386__) || defined(__x86_64__))
-
-#endif // ASIO_DETAIL_GCC_X86_FENCED_BLOCK_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/handler_alloc_helpers.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/handler_alloc_helpers.hpp
deleted file mode 100644
index e52640dd215b..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/handler_alloc_helpers.hpp
+++ /dev/null
@@ -1,82 +0,0 @@
-//
-// detail/handler_alloc_helpers.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_HANDLER_ALLOC_HELPERS_HPP
-#define ASIO_DETAIL_HANDLER_ALLOC_HELPERS_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include "asio/detail/addressof.hpp"
-#include "asio/detail/noncopyable.hpp"
-#include "asio/handler_alloc_hook.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-// Calls to asio_handler_allocate and asio_handler_deallocate must be made from
-// a namespace that does not contain any overloads of these functions. The
-// asio_handler_alloc_helpers namespace is defined here for that purpose.
-namespace asio_handler_alloc_helpers {
-
-template <typename Handler>
-inline void* allocate(std::size_t s, Handler& h)
-{
-#if !defined(ASIO_HAS_HANDLER_HOOKS)
-  return ::operator new(s);
-#else
-  using asio::asio_handler_allocate;
-  return asio_handler_allocate(s, asio::detail::addressof(h));
-#endif
-}
-
-template <typename Handler>
-inline void deallocate(void* p, std::size_t s, Handler& h)
-{
-#if !defined(ASIO_HAS_HANDLER_HOOKS)
-  ::operator delete(p);
-#else
-  using asio::asio_handler_deallocate;
-  asio_handler_deallocate(p, s, asio::detail::addressof(h));
-#endif
-}
-
-} // namespace asio_handler_alloc_helpers
-
-#define ASIO_DEFINE_HANDLER_PTR(op) \
-  struct ptr \
-  { \
-    Handler* h; \
-    void* v; \
-    op* p; \
-    ~ptr() \
-    { \
-      reset(); \
-    } \
-    void reset() \
-    { \
-      if (p) \
-      { \
-        p->~op(); \
-        p = 0; \
-      } \
-      if (v) \
-      { \
-        asio_handler_alloc_helpers::deallocate(v, sizeof(op), *h); \
-        v = 0; \
-      } \
-    } \
-  } \
-  /**/
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_DETAIL_HANDLER_ALLOC_HELPERS_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/handler_cont_helpers.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/handler_cont_helpers.hpp
deleted file mode 100644
index 2eabe39edc18..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/handler_cont_helpers.hpp
+++ /dev/null
@@ -1,45 +0,0 @@
-//
-// detail/handler_cont_helpers.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_HANDLER_CONT_HELPERS_HPP
-#define ASIO_DETAIL_HANDLER_CONT_HELPERS_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include "asio/detail/addressof.hpp"
-#include "asio/handler_continuation_hook.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-// Calls to asio_handler_is_continuation must be made from a namespace that
-// does not contain overloads of this function. This namespace is defined here
-// for that purpose.
-namespace asio_handler_cont_helpers {
-
-template <typename Context>
-inline bool is_continuation(Context& context)
-{
-#if !defined(ASIO_HAS_HANDLER_HOOKS)
-  return false;
-#else
-  using asio::asio_handler_is_continuation;
-  return asio_handler_is_continuation(
-      asio::detail::addressof(context));
-#endif
-}
-
-} // namespace asio_handler_cont_helpers
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_DETAIL_HANDLER_CONT_HELPERS_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/handler_invoke_helpers.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/handler_invoke_helpers.hpp
deleted file mode 100644
index ec23b0fcb6af..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/handler_invoke_helpers.hpp
+++ /dev/null
@@ -1,57 +0,0 @@
-//
-// detail/handler_invoke_helpers.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_HANDLER_INVOKE_HELPERS_HPP
-#define ASIO_DETAIL_HANDLER_INVOKE_HELPERS_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include "asio/detail/addressof.hpp"
-#include "asio/handler_invoke_hook.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-// Calls to asio_handler_invoke must be made from a namespace that does not
-// contain overloads of this function. The asio_handler_invoke_helpers
-// namespace is defined here for that purpose.
-namespace asio_handler_invoke_helpers {
-
-template <typename Function, typename Context>
-inline void invoke(Function& function, Context& context)
-{
-#if !defined(ASIO_HAS_HANDLER_HOOKS)
-  Function tmp(function);
-  tmp();
-#else
-  using asio::asio_handler_invoke;
-  asio_handler_invoke(function, asio::detail::addressof(context));
-#endif
-}
-
-template <typename Function, typename Context>
-inline void invoke(const Function& function, Context& context)
-{
-#if !defined(ASIO_HAS_HANDLER_HOOKS)
-  Function tmp(function);
-  tmp();
-#else
-  using asio::asio_handler_invoke;
-  asio_handler_invoke(function, asio::detail::addressof(context));
-#endif
-}
-
-} // namespace asio_handler_invoke_helpers
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_DETAIL_HANDLER_INVOKE_HELPERS_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/handler_tracking.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/handler_tracking.hpp
deleted file mode 100644
index eb25abe0afae..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/handler_tracking.hpp
+++ /dev/null
@@ -1,159 +0,0 @@
-//
-// detail/handler_tracking.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_HANDLER_TRACKING_HPP
-#define ASIO_DETAIL_HANDLER_TRACKING_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_ENABLE_HANDLER_TRACKING)
-# include "asio/error_code.hpp"
-# include "asio/detail/cstdint.hpp"
-# include "asio/detail/static_mutex.hpp"
-# include "asio/detail/tss_ptr.hpp"
-#endif // defined(ASIO_ENABLE_HANDLER_TRACKING)
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-#if defined(ASIO_ENABLE_HANDLER_TRACKING)
-
-class handler_tracking
-{
-public:
-  class completion;
-
-  // Base class for objects containing tracked handlers.
-  class tracked_handler
-  {
-  private:
-    // Only the handler_tracking class will have access to the id.
-    friend class handler_tracking;
-    friend class completion;
-    uint64_t id_;
-
-  protected:
-    // Constructor initialises with no id.
-    tracked_handler() : id_(0) {}
-
-    // Prevent deletion through this type.
-    ~tracked_handler() {}
-  };
-
-  // Initialise the tracking system.
-  ASIO_DECL static void init();
-
-  // Record the creation of a tracked handler.
-  ASIO_DECL static void creation(tracked_handler* h,
-      const char* object_type, void* object, const char* op_name);
-
-  class completion
-  {
-  public:
-    // Constructor records that handler is to be invoked with no arguments.
-    ASIO_DECL explicit completion(tracked_handler* h);
-
-    // Destructor records only when an exception is thrown from the handler, or
-    // if the memory is being freed without the handler having been invoked.
-    ASIO_DECL ~completion();
-
-    // Records that handler is to be invoked with no arguments.
-    ASIO_DECL void invocation_begin();
-
-    // Records that handler is to be invoked with one arguments.
-    ASIO_DECL void invocation_begin(const asio::error_code& ec);
-
-    // Constructor records that handler is to be invoked with two arguments.
-    ASIO_DECL void invocation_begin(
-        const asio::error_code& ec, std::size_t bytes_transferred);
-
-    // Constructor records that handler is to be invoked with two arguments.
-    ASIO_DECL void invocation_begin(
-        const asio::error_code& ec, int signal_number);
-
-    // Constructor records that handler is to be invoked with two arguments.
-    ASIO_DECL void invocation_begin(
-        const asio::error_code& ec, const char* arg);
-
-    // Record that handler invocation has ended.
-    ASIO_DECL void invocation_end();
-
-  private:
-    friend class handler_tracking;
-    uint64_t id_;
-    bool invoked_;
-    completion* next_;
-  };
-
-  // Record an operation that affects pending handlers.
-  ASIO_DECL static void operation(const char* object_type,
-      void* object, const char* op_name);
-
-  // Write a line of output.
-  ASIO_DECL static void write_line(const char* format, ...);
-
-private:
-  struct tracking_state;
-  ASIO_DECL static tracking_state* get_state();
-};
-
-# define ASIO_INHERIT_TRACKED_HANDLER \
-  : public asio::detail::handler_tracking::tracked_handler
-
-# define ASIO_ALSO_INHERIT_TRACKED_HANDLER \
-  , public asio::detail::handler_tracking::tracked_handler
-
-# define ASIO_HANDLER_TRACKING_INIT \
-  asio::detail::handler_tracking::init()
-
-# define ASIO_HANDLER_CREATION(args) \
-  asio::detail::handler_tracking::creation args
-
-# define ASIO_HANDLER_COMPLETION(args) \
-  asio::detail::handler_tracking::completion tracked_completion args
-
-# define ASIO_HANDLER_INVOCATION_BEGIN(args) \
-  tracked_completion.invocation_begin args
-
-# define ASIO_HANDLER_INVOCATION_END \
-  tracked_completion.invocation_end()
-
-# define ASIO_HANDLER_OPERATION(args) \
-  asio::detail::handler_tracking::operation args
-
-#else // defined(ASIO_ENABLE_HANDLER_TRACKING)
-
-# define ASIO_INHERIT_TRACKED_HANDLER
-# define ASIO_ALSO_INHERIT_TRACKED_HANDLER
-# define ASIO_HANDLER_TRACKING_INIT (void)0
-# define ASIO_HANDLER_CREATION(args) (void)0
-# define ASIO_HANDLER_COMPLETION(args) (void)0
-# define ASIO_HANDLER_INVOCATION_BEGIN(args) (void)0
-# define ASIO_HANDLER_INVOCATION_END (void)0
-# define ASIO_HANDLER_OPERATION(args) (void)0
-
-#endif // defined(ASIO_ENABLE_HANDLER_TRACKING)
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#if defined(ASIO_HEADER_ONLY)
-# include "asio/detail/impl/handler_tracking.ipp"
-#endif // defined(ASIO_HEADER_ONLY)
-
-#endif // ASIO_DETAIL_HANDLER_TRACKING_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/handler_type_requirements.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/handler_type_requirements.hpp
deleted file mode 100644
index fdf3a55d895d..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/handler_type_requirements.hpp
+++ /dev/null
@@ -1,488 +0,0 @@
-//
-// detail/handler_type_requirements.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_HANDLER_TYPE_REQUIREMENTS_HPP
-#define ASIO_DETAIL_HANDLER_TYPE_REQUIREMENTS_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-// Older versions of gcc have difficulty compiling the sizeof expressions where
-// we test the handler type requirements. We'll disable checking of handler type
-// requirements for those compilers, but otherwise enable it by default.
-#if !defined(ASIO_DISABLE_HANDLER_TYPE_REQUIREMENTS)
-# if !defined(__GNUC__) || (__GNUC__ >= 4)
-#  define ASIO_ENABLE_HANDLER_TYPE_REQUIREMENTS 1
-# endif // !defined(__GNUC__) || (__GNUC__ >= 4)
-#endif // !defined(ASIO_DISABLE_HANDLER_TYPE_REQUIREMENTS)
-
-// With C++0x we can use a combination of enhanced SFINAE and static_assert to
-// generate better template error messages. As this technique is not yet widely
-// portable, we'll only enable it for tested compilers.
-#if !defined(ASIO_DISABLE_HANDLER_TYPE_REQUIREMENTS_ASSERT)
-# if defined(__GNUC__)
-#  if ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 5)) || (__GNUC__ > 4)
-#   if defined(__GXX_EXPERIMENTAL_CXX0X__)
-#    define ASIO_ENABLE_HANDLER_TYPE_REQUIREMENTS_ASSERT 1
-#   endif // defined(__GXX_EXPERIMENTAL_CXX0X__)
-#  endif // ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 5)) || (__GNUC__ > 4)
-# endif // defined(__GNUC__)
-# if defined(ASIO_MSVC)
-#  if (_MSC_VER >= 1600)
-#   define ASIO_ENABLE_HANDLER_TYPE_REQUIREMENTS_ASSERT 1
-#  endif // (_MSC_VER >= 1600)
-# endif // defined(ASIO_MSVC)
-# if defined(__clang__)
-#  if __has_feature(__cxx_static_assert__)
-#   define ASIO_ENABLE_HANDLER_TYPE_REQUIREMENTS_ASSERT 1
-#  endif // __has_feature(cxx_static_assert)
-# endif // defined(__clang__)
-#endif // !defined(ASIO_DISABLE_HANDLER_TYPE_REQUIREMENTS)
-
-#if defined(ASIO_ENABLE_HANDLER_TYPE_REQUIREMENTS)
-# include "asio/handler_type.hpp"
-#endif // defined(ASIO_ENABLE_HANDLER_TYPE_REQUIREMENTS)
-
-// Newer gcc needs special treatment to suppress unused typedef warnings.
-#if defined(__GNUC__)
-# if ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 8)) || (__GNUC__ > 4)
-#  define ASIO_UNUSED_TYPEDEF __attribute__((__unused__))
-# endif // ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 8)) || (__GNUC__ > 4)
-#endif // defined(__GNUC__)
-#if !defined(ASIO_UNUSED_TYPEDEF)
-# define ASIO_UNUSED_TYPEDEF
-#endif // !defined(ASIO_UNUSED_TYPEDEF)
-
-namespace asio {
-namespace detail {
-
-#if defined(ASIO_ENABLE_HANDLER_TYPE_REQUIREMENTS)
-
-# if defined(ASIO_ENABLE_HANDLER_TYPE_REQUIREMENTS_ASSERT)
-
-template <typename Handler>
-auto zero_arg_handler_test(Handler h, void*)
-  -> decltype(
-    sizeof(Handler(static_cast<const Handler&>(h))),
-    ((h)()),
-    char(0));
-
-template <typename Handler>
-char (&zero_arg_handler_test(Handler, ...))[2];
-
-template <typename Handler, typename Arg1>
-auto one_arg_handler_test(Handler h, Arg1* a1)
-  -> decltype(
-    sizeof(Handler(static_cast<const Handler&>(h))),
-    ((h)(*a1)),
-    char(0));
-
-template <typename Handler>
-char (&one_arg_handler_test(Handler h, ...))[2];
-
-template <typename Handler, typename Arg1, typename Arg2>
-auto two_arg_handler_test(Handler h, Arg1* a1, Arg2* a2)
-  -> decltype(
-    sizeof(Handler(static_cast<const Handler&>(h))),
-    ((h)(*a1, *a2)),
-    char(0));
-
-template <typename Handler>
-char (&two_arg_handler_test(Handler, ...))[2];
-
-#  define ASIO_HANDLER_TYPE_REQUIREMENTS_ASSERT(expr, msg) \
-     static_assert(expr, msg);
-
-# else // defined(ASIO_ENABLE_HANDLER_TYPE_REQUIREMENTS_ASSERT)
-
-#  define ASIO_HANDLER_TYPE_REQUIREMENTS_ASSERT(expr, msg)
-
-# endif // defined(ASIO_ENABLE_HANDLER_TYPE_REQUIREMENTS_ASSERT)
-
-template <typename T> T& lvref();
-template <typename T> T& lvref(T);
-template <typename T> const T& clvref();
-template <typename T> const T& clvref(T);
-template <typename T> char argbyv(T);
-
-template <int>
-struct handler_type_requirements
-{
-};
-
-#define ASIO_COMPLETION_HANDLER_CHECK( \
-    handler_type, handler) \
-  \
-  typedef ASIO_HANDLER_TYPE(handler_type, \
-      void()) asio_true_handler_type; \
-  \
-  ASIO_HANDLER_TYPE_REQUIREMENTS_ASSERT( \
-      sizeof(asio::detail::zero_arg_handler_test( \
-          asio::detail::clvref< \
-            asio_true_handler_type>(), 0)) == 1, \
-      "CompletionHandler type requirements not met") \
-  \
-  typedef asio::detail::handler_type_requirements< \
-      sizeof( \
-        asio::detail::argbyv( \
-          asio::detail::clvref< \
-            asio_true_handler_type>())) + \
-      sizeof( \
-        asio::detail::lvref< \
-          asio_true_handler_type>()(), \
-        char(0))> ASIO_UNUSED_TYPEDEF
-
-#define ASIO_READ_HANDLER_CHECK( \
-    handler_type, handler) \
-  \
-  typedef ASIO_HANDLER_TYPE(handler_type, \
-      void(asio::error_code, std::size_t)) \
-    asio_true_handler_type; \
-  \
-  ASIO_HANDLER_TYPE_REQUIREMENTS_ASSERT( \
-      sizeof(asio::detail::two_arg_handler_test( \
-          asio::detail::clvref< \
-            asio_true_handler_type>(), \
-          static_cast<const asio::error_code*>(0), \
-          static_cast<const std::size_t*>(0))) == 1, \
-      "ReadHandler type requirements not met") \
-  \
-  typedef asio::detail::handler_type_requirements< \
-      sizeof( \
-        asio::detail::argbyv( \
-          asio::detail::clvref< \
-            asio_true_handler_type>())) + \
-      sizeof( \
-        asio::detail::lvref< \
-          asio_true_handler_type>()( \
-            asio::detail::lvref<const asio::error_code>(), \
-            asio::detail::lvref<const std::size_t>()), \
-        char(0))> ASIO_UNUSED_TYPEDEF
-
-
-#define ASIO_WRITE_HANDLER_CHECK( \
-    handler_type, handler) \
-  \
-  typedef ASIO_HANDLER_TYPE(handler_type, \
-      void(asio::error_code, std::size_t)) \
-    asio_true_handler_type; \
-  \
-  ASIO_HANDLER_TYPE_REQUIREMENTS_ASSERT( \
-      sizeof(asio::detail::two_arg_handler_test( \
-          asio::detail::clvref< \
-            asio_true_handler_type>(), \
-          static_cast<const asio::error_code*>(0), \
-          static_cast<const std::size_t*>(0))) == 1, \
-      "WriteHandler type requirements not met") \
-  \
-  typedef asio::detail::handler_type_requirements< \
-      sizeof( \
-        asio::detail::argbyv( \
-          asio::detail::clvref< \
-            asio_true_handler_type>())) + \
-      sizeof( \
-        asio::detail::lvref< \
-          asio_true_handler_type>()( \
-            asio::detail::lvref<const asio::error_code>(), \
-            asio::detail::lvref<const std::size_t>()), \
-        char(0))> ASIO_UNUSED_TYPEDEF
-
-#define ASIO_ACCEPT_HANDLER_CHECK( \
-    handler_type, handler) \
-  \
-  typedef ASIO_HANDLER_TYPE(handler_type, \
-      void(asio::error_code)) \
-    asio_true_handler_type; \
-  \
-  ASIO_HANDLER_TYPE_REQUIREMENTS_ASSERT( \
-      sizeof(asio::detail::one_arg_handler_test( \
-          asio::detail::clvref< \
-            asio_true_handler_type>(), \
-          static_cast<const asio::error_code*>(0))) == 1, \
-      "AcceptHandler type requirements not met") \
-  \
-  typedef asio::detail::handler_type_requirements< \
-      sizeof( \
-        asio::detail::argbyv( \
-          asio::detail::clvref< \
-            asio_true_handler_type>())) + \
-      sizeof( \
-        asio::detail::lvref< \
-          asio_true_handler_type>()( \
-            asio::detail::lvref<const asio::error_code>()), \
-        char(0))> ASIO_UNUSED_TYPEDEF
-
-#define ASIO_CONNECT_HANDLER_CHECK( \
-    handler_type, handler) \
-  \
-  typedef ASIO_HANDLER_TYPE(handler_type, \
-      void(asio::error_code)) \
-    asio_true_handler_type; \
-  \
-  ASIO_HANDLER_TYPE_REQUIREMENTS_ASSERT( \
-      sizeof(asio::detail::one_arg_handler_test( \
-          asio::detail::clvref< \
-            asio_true_handler_type>(), \
-          static_cast<const asio::error_code*>(0))) == 1, \
-      "ConnectHandler type requirements not met") \
-  \
-  typedef asio::detail::handler_type_requirements< \
-      sizeof( \
-        asio::detail::argbyv( \
-          asio::detail::clvref< \
-            asio_true_handler_type>())) + \
-      sizeof( \
-        asio::detail::lvref< \
-          asio_true_handler_type>()( \
-            asio::detail::lvref<const asio::error_code>()), \
-        char(0))> ASIO_UNUSED_TYPEDEF
-
-#define ASIO_COMPOSED_CONNECT_HANDLER_CHECK( \
-    handler_type, handler, iter_type) \
-  \
-  typedef ASIO_HANDLER_TYPE(handler_type, \
-      void(asio::error_code, iter_type)) \
-    asio_true_handler_type; \
-  \
-  ASIO_HANDLER_TYPE_REQUIREMENTS_ASSERT( \
-      sizeof(asio::detail::two_arg_handler_test( \
-          asio::detail::clvref< \
-            asio_true_handler_type>(), \
-          static_cast<const asio::error_code*>(0), \
-          static_cast<const iter_type*>(0))) == 1, \
-      "ComposedConnectHandler type requirements not met") \
-  \
-  typedef asio::detail::handler_type_requirements< \
-      sizeof( \
-        asio::detail::argbyv( \
-          asio::detail::clvref< \
-            asio_true_handler_type>())) + \
-      sizeof( \
-        asio::detail::lvref< \
-          asio_true_handler_type>()( \
-            asio::detail::lvref<const asio::error_code>(), \
-            asio::detail::lvref<const iter_type>()), \
-        char(0))> ASIO_UNUSED_TYPEDEF
-
-#define ASIO_RESOLVE_HANDLER_CHECK( \
-    handler_type, handler, iter_type) \
-  \
-  typedef ASIO_HANDLER_TYPE(handler_type, \
-      void(asio::error_code, iter_type)) \
-    asio_true_handler_type; \
-  \
-  ASIO_HANDLER_TYPE_REQUIREMENTS_ASSERT( \
-      sizeof(asio::detail::two_arg_handler_test( \
-          asio::detail::clvref< \
-            asio_true_handler_type>(), \
-          static_cast<const asio::error_code*>(0), \
-          static_cast<const iter_type*>(0))) == 1, \
-      "ResolveHandler type requirements not met") \
-  \
-  typedef asio::detail::handler_type_requirements< \
-      sizeof( \
-        asio::detail::argbyv( \
-          asio::detail::clvref< \
-            asio_true_handler_type>())) + \
-      sizeof( \
-        asio::detail::lvref< \
-          asio_true_handler_type>()( \
-            asio::detail::lvref<const asio::error_code>(), \
-            asio::detail::lvref<const iter_type>()), \
-        char(0))> ASIO_UNUSED_TYPEDEF
-
-#define ASIO_WAIT_HANDLER_CHECK( \
-    handler_type, handler) \
-  \
-  typedef ASIO_HANDLER_TYPE(handler_type, \
-      void(asio::error_code)) \
-    asio_true_handler_type; \
-  \
-  ASIO_HANDLER_TYPE_REQUIREMENTS_ASSERT( \
-      sizeof(asio::detail::one_arg_handler_test( \
-          asio::detail::clvref< \
-            asio_true_handler_type>(), \
-          static_cast<const asio::error_code*>(0))) == 1, \
-      "WaitHandler type requirements not met") \
-  \
-  typedef asio::detail::handler_type_requirements< \
-      sizeof( \
-        asio::detail::argbyv( \
-          asio::detail::clvref< \
-            asio_true_handler_type>())) + \
-      sizeof( \
-        asio::detail::lvref< \
-          asio_true_handler_type>()( \
-            asio::detail::lvref<const asio::error_code>()), \
-        char(0))> ASIO_UNUSED_TYPEDEF
-
-#define ASIO_SIGNAL_HANDLER_CHECK( \
-    handler_type, handler) \
-  \
-  typedef ASIO_HANDLER_TYPE(handler_type, \
-      void(asio::error_code, int)) \
-    asio_true_handler_type; \
-  \
-  ASIO_HANDLER_TYPE_REQUIREMENTS_ASSERT( \
-      sizeof(asio::detail::two_arg_handler_test( \
-          asio::detail::clvref< \
-            asio_true_handler_type>(), \
-          static_cast<const asio::error_code*>(0), \
-          static_cast<const int*>(0))) == 1, \
-      "SignalHandler type requirements not met") \
-  \
-  typedef asio::detail::handler_type_requirements< \
-      sizeof( \
-        asio::detail::argbyv( \
-          asio::detail::clvref< \
-            asio_true_handler_type>())) + \
-      sizeof( \
-        asio::detail::lvref< \
-          asio_true_handler_type>()( \
-            asio::detail::lvref<const asio::error_code>(), \
-            asio::detail::lvref<const int>()), \
-        char(0))> ASIO_UNUSED_TYPEDEF
-
-#define ASIO_HANDSHAKE_HANDLER_CHECK( \
-    handler_type, handler) \
-  \
-  typedef ASIO_HANDLER_TYPE(handler_type, \
-      void(asio::error_code)) \
-    asio_true_handler_type; \
-  \
-  ASIO_HANDLER_TYPE_REQUIREMENTS_ASSERT( \
-      sizeof(asio::detail::one_arg_handler_test( \
-          asio::detail::clvref< \
-            asio_true_handler_type>(), \
-          static_cast<const asio::error_code*>(0))) == 1, \
-      "HandshakeHandler type requirements not met") \
-  \
-  typedef asio::detail::handler_type_requirements< \
-      sizeof( \
-        asio::detail::argbyv( \
-          asio::detail::clvref< \
-            asio_true_handler_type>())) + \
-      sizeof( \
-        asio::detail::lvref< \
-          asio_true_handler_type>()( \
-            asio::detail::lvref<const asio::error_code>()), \
-        char(0))> ASIO_UNUSED_TYPEDEF
-
-#define ASIO_BUFFERED_HANDSHAKE_HANDLER_CHECK( \
-    handler_type, handler) \
-  \
-  typedef ASIO_HANDLER_TYPE(handler_type, \
-      void(asio::error_code, std::size_t)) \
-    asio_true_handler_type; \
-  \
-  ASIO_HANDLER_TYPE_REQUIREMENTS_ASSERT( \
-      sizeof(asio::detail::two_arg_handler_test( \
-          asio::detail::clvref< \
-            asio_true_handler_type>(), \
-          static_cast<const asio::error_code*>(0), \
-          static_cast<const std::size_t*>(0))) == 1, \
-      "BufferedHandshakeHandler type requirements not met") \
-  \
-  typedef asio::detail::handler_type_requirements< \
-      sizeof( \
-        asio::detail::argbyv( \
-          asio::detail::clvref< \
-            asio_true_handler_type>())) + \
-      sizeof( \
-        asio::detail::lvref< \
-          asio_true_handler_type>()( \
-          asio::detail::lvref<const asio::error_code>(), \
-          asio::detail::lvref<const std::size_t>()), \
-        char(0))> ASIO_UNUSED_TYPEDEF
-
-#define ASIO_SHUTDOWN_HANDLER_CHECK( \
-    handler_type, handler) \
-  \
-  typedef ASIO_HANDLER_TYPE(handler_type, \
-      void(asio::error_code)) \
-    asio_true_handler_type; \
-  \
-  ASIO_HANDLER_TYPE_REQUIREMENTS_ASSERT( \
-      sizeof(asio::detail::one_arg_handler_test( \
-          asio::detail::clvref< \
-            asio_true_handler_type>(), \
-          static_cast<const asio::error_code*>(0))) == 1, \
-      "ShutdownHandler type requirements not met") \
-  \
-  typedef asio::detail::handler_type_requirements< \
-      sizeof( \
-        asio::detail::argbyv( \
-          asio::detail::clvref< \
-            asio_true_handler_type>())) + \
-      sizeof( \
-        asio::detail::lvref< \
-          asio_true_handler_type>()( \
-            asio::detail::lvref<const asio::error_code>()), \
-        char(0))> ASIO_UNUSED_TYPEDEF
-
-#else // !defined(ASIO_ENABLE_HANDLER_TYPE_REQUIREMENTS)
-
-#define ASIO_COMPLETION_HANDLER_CHECK( \
-    handler_type, handler) \
-  typedef int ASIO_UNUSED_TYPEDEF
-
-#define ASIO_READ_HANDLER_CHECK( \
-    handler_type, handler) \
-  typedef int ASIO_UNUSED_TYPEDEF
-
-#define ASIO_WRITE_HANDLER_CHECK( \
-    handler_type, handler) \
-  typedef int ASIO_UNUSED_TYPEDEF
-
-#define ASIO_ACCEPT_HANDLER_CHECK( \
-    handler_type, handler) \
-  typedef int ASIO_UNUSED_TYPEDEF
-
-#define ASIO_CONNECT_HANDLER_CHECK( \
-    handler_type, handler) \
-  typedef int ASIO_UNUSED_TYPEDEF
-
-#define ASIO_COMPOSED_CONNECT_HANDLER_CHECK( \
-    handler_type, handler, iter_type) \
-  typedef int ASIO_UNUSED_TYPEDEF
-
-#define ASIO_RESOLVE_HANDLER_CHECK( \
-    handler_type, handler, iter_type) \
-  typedef int ASIO_UNUSED_TYPEDEF
-
-#define ASIO_WAIT_HANDLER_CHECK( \
-    handler_type, handler) \
-  typedef int ASIO_UNUSED_TYPEDEF
-
-#define ASIO_SIGNAL_HANDLER_CHECK( \
-    handler_type, handler) \
-  typedef int ASIO_UNUSED_TYPEDEF
-
-#define ASIO_HANDSHAKE_HANDLER_CHECK( \
-    handler_type, handler) \
-  typedef int ASIO_UNUSED_TYPEDEF
-
-#define ASIO_BUFFERED_HANDSHAKE_HANDLER_CHECK( \
-    handler_type, handler) \
-  typedef int ASIO_UNUSED_TYPEDEF
-
-#define ASIO_SHUTDOWN_HANDLER_CHECK( \
-    handler_type, handler) \
-  typedef int ASIO_UNUSED_TYPEDEF
-
-#endif // !defined(ASIO_ENABLE_HANDLER_TYPE_REQUIREMENTS)
-
-} // namespace detail
-} // namespace asio
-
-#endif // ASIO_DETAIL_HANDLER_TYPE_REQUIREMENTS_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/hash_map.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/hash_map.hpp
deleted file mode 100644
index 4e54976a5ddd..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/hash_map.hpp
+++ /dev/null
@@ -1,331 +0,0 @@
-//
-// detail/hash_map.hpp
-// ~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_HASH_MAP_HPP
-#define ASIO_DETAIL_HASH_MAP_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include <list>
-#include <utility>
-#include "asio/detail/assert.hpp"
-#include "asio/detail/noncopyable.hpp"
-
-#if defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-# include "asio/detail/socket_types.hpp"
-#endif // defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-inline std::size_t calculate_hash_value(int i)
-{
-  return static_cast<std::size_t>(i);
-}
-
-inline std::size_t calculate_hash_value(void* p)
-{
-  return reinterpret_cast<std::size_t>(p)
-    + (reinterpret_cast<std::size_t>(p) >> 3);
-}
-
-#if defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-inline std::size_t calculate_hash_value(SOCKET s)
-{
-  return static_cast<std::size_t>(s);
-}
-#endif // defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-
-// Note: assumes K and V are POD types.
-template <typename K, typename V>
-class hash_map
-  : private noncopyable
-{
-public:
-  // The type of a value in the map.
-  typedef std::pair<K, V> value_type;
-
-  // The type of a non-const iterator over the hash map.
-  typedef typename std::list<value_type>::iterator iterator;
-
-  // The type of a const iterator over the hash map.
-  typedef typename std::list<value_type>::const_iterator const_iterator;
-
-  // Constructor.
-  hash_map()
-    : size_(0),
-      buckets_(0),
-      num_buckets_(0)
-  {
-  }
-
-  // Destructor.
-  ~hash_map()
-  {
-    delete[] buckets_;
-  }
-
-  // Get an iterator for the beginning of the map.
-  iterator begin()
-  {
-    return values_.begin();
-  }
-
-  // Get an iterator for the beginning of the map.
-  const_iterator begin() const
-  {
-    return values_.begin();
-  }
-
-  // Get an iterator for the end of the map.
-  iterator end()
-  {
-    return values_.end();
-  }
-
-  // Get an iterator for the end of the map.
-  const_iterator end() const
-  {
-    return values_.end();
-  }
-
-  // Check whether the map is empty.
-  bool empty() const
-  {
-    return values_.empty();
-  }
-
-  // Find an entry in the map.
-  iterator find(const K& k)
-  {
-    if (num_buckets_)
-    {
-      size_t bucket = calculate_hash_value(k) % num_buckets_;
-      iterator it = buckets_[bucket].first;
-      if (it == values_.end())
-        return values_.end();
-      iterator end_it = buckets_[bucket].last;
-      ++end_it;
-      while (it != end_it)
-      {
-        if (it->first == k)
-          return it;
-        ++it;
-      }
-    }
-    return values_.end();
-  }
-
-  // Find an entry in the map.
-  const_iterator find(const K& k) const
-  {
-    if (num_buckets_)
-    {
-      size_t bucket = calculate_hash_value(k) % num_buckets_;
-      const_iterator it = buckets_[bucket].first;
-      if (it == values_.end())
-        return it;
-      const_iterator end_it = buckets_[bucket].last;
-      ++end_it;
-      while (it != end_it)
-      {
-        if (it->first == k)
-          return it;
-        ++it;
-      }
-    }
-    return values_.end();
-  }
-
-  // Insert a new entry into the map.
-  std::pair<iterator, bool> insert(const value_type& v)
-  {
-    if (size_ + 1 >= num_buckets_)
-      rehash(hash_size(size_ + 1));
-    size_t bucket = calculate_hash_value(v.first) % num_buckets_;
-    iterator it = buckets_[bucket].first;
-    if (it == values_.end())
-    {
-      buckets_[bucket].first = buckets_[bucket].last =
-        values_insert(values_.end(), v);
-      ++size_;
-      return std::pair<iterator, bool>(buckets_[bucket].last, true);
-    }
-    iterator end_it = buckets_[bucket].last;
-    ++end_it;
-    while (it != end_it)
-    {
-      if (it->first == v.first)
-        return std::pair<iterator, bool>(it, false);
-      ++it;
-    }
-    buckets_[bucket].last = values_insert(end_it, v);
-    ++size_;
-    return std::pair<iterator, bool>(buckets_[bucket].last, true);
-  }
-
-  // Erase an entry from the map.
-  void erase(iterator it)
-  {
-    ASIO_ASSERT(it != values_.end());
-    ASIO_ASSERT(num_buckets_ != 0);
-
-    size_t bucket = calculate_hash_value(it->first) % num_buckets_;
-    bool is_first = (it == buckets_[bucket].first);
-    bool is_last = (it == buckets_[bucket].last);
-    if (is_first && is_last)
-      buckets_[bucket].first = buckets_[bucket].last = values_.end();
-    else if (is_first)
-      ++buckets_[bucket].first;
-    else if (is_last)
-      --buckets_[bucket].last;
-
-    values_erase(it);
-    --size_;
-  }
-
-  // Erase a key from the map.
-  void erase(const K& k)
-  {
-    iterator it = find(k);
-    if (it != values_.end())
-      erase(it);
-  }
-
-  // Remove all entries from the map.
-  void clear()
-  {
-    // Clear the values.
-    values_.clear();
-    size_ = 0;
-
-    // Initialise all buckets to empty.
-    iterator end_it = values_.end();
-    for (size_t i = 0; i < num_buckets_; ++i)
-      buckets_[i].first = buckets_[i].last = end_it;
-  }
-
-private:
-  // Calculate the hash size for the specified number of elements.
-  static std::size_t hash_size(std::size_t num_elems)
-  {
-    static std::size_t sizes[] =
-    {
-#if defined(ASIO_HASH_MAP_BUCKETS)
-      ASIO_HASH_MAP_BUCKETS
-#else // ASIO_HASH_MAP_BUCKETS
-      3, 13, 23, 53, 97, 193, 389, 769, 1543, 3079, 6151, 12289, 24593,
-      49157, 98317, 196613, 393241, 786433, 1572869, 3145739, 6291469,
-      12582917, 25165843
-#endif // ASIO_HASH_MAP_BUCKETS
-    };
-    const std::size_t nth_size = sizeof(sizes) / sizeof(std::size_t) - 1;
-    for (std::size_t i = 0; i < nth_size; ++i)
-      if (num_elems < sizes[i])
-        return sizes[i];
-    return sizes[nth_size];
-  }
-
-  // Re-initialise the hash from the values already contained in the list.
-  void rehash(std::size_t num_buckets)
-  {
-    if (num_buckets == num_buckets_)
-      return;
-    num_buckets_ = num_buckets;
-    ASIO_ASSERT(num_buckets_ != 0);
-
-    iterator end_iter = values_.end();
-
-    // Update number of buckets and initialise all buckets to empty.
-    bucket_type* tmp = new bucket_type[num_buckets_];
-    delete[] buckets_;
-    buckets_ = tmp;
-    for (std::size_t i = 0; i < num_buckets_; ++i)
-      buckets_[i].first = buckets_[i].last = end_iter;
-
-    // Put all values back into the hash.
-    iterator iter = values_.begin();
-    while (iter != end_iter)
-    {
-      std::size_t bucket = calculate_hash_value(iter->first) % num_buckets_;
-      if (buckets_[bucket].last == end_iter)
-      {
-        buckets_[bucket].first = buckets_[bucket].last = iter++;
-      }
-      else if (++buckets_[bucket].last == iter)
-      {
-        ++iter;
-      }
-      else
-      {
-        values_.splice(buckets_[bucket].last, values_, iter++);
-        --buckets_[bucket].last;
-      }
-    }
-  }
-
-  // Insert an element into the values list by splicing from the spares list,
-  // if a spare is available, and otherwise by inserting a new element.
-  iterator values_insert(iterator it, const value_type& v)
-  {
-    if (spares_.empty())
-    {
-      return values_.insert(it, v);
-    }
-    else
-    {
-      spares_.front() = v;
-      values_.splice(it, spares_, spares_.begin());
-      return --it;
-    }
-  }
-
-  // Erase an element from the values list by splicing it to the spares list.
-  void values_erase(iterator it)
-  {
-    *it = value_type();
-    spares_.splice(spares_.begin(), values_, it);
-  }
-
-  // The number of elements in the hash.
-  std::size_t size_;
-
-  // The list of all values in the hash map.
-  std::list<value_type> values_;
-
-  // The list of spare nodes waiting to be recycled. Assumes that POD types only
-  // are stored in the hash map.
-  std::list<value_type> spares_;
-
-  // The type for a bucket in the hash table.
-  struct bucket_type
-  {
-    iterator first;
-    iterator last;
-  };
-
-  // The buckets in the hash.
-  bucket_type* buckets_;
-
-  // The number of buckets in the hash.
-  std::size_t num_buckets_;
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_DETAIL_HASH_MAP_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/buffer_sequence_adapter.ipp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/buffer_sequence_adapter.ipp
deleted file mode 100644
index 7a57a137d9ce..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/buffer_sequence_adapter.ipp
+++ /dev/null
@@ -1,118 +0,0 @@
-//
-// detail/impl/buffer_sequence_adapter.ipp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_IMPL_BUFFER_SEQUENCE_ADAPTER_IPP
-#define ASIO_DETAIL_IMPL_BUFFER_SEQUENCE_ADAPTER_IPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_WINDOWS_RUNTIME)
-
-#include <robuffer.h>
-#include <windows.storage.streams.h>
-#include <wrl/implements.h>
-#include "asio/detail/buffer_sequence_adapter.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-class winrt_buffer_impl :
-  public Microsoft::WRL::RuntimeClass<
-    Microsoft::WRL::RuntimeClassFlags<
-      Microsoft::WRL::RuntimeClassType::WinRtClassicComMix>,
-    ABI::Windows::Storage::Streams::IBuffer,
-    Windows::Storage::Streams::IBufferByteAccess>
-{
-public:
-  explicit winrt_buffer_impl(const asio::const_buffer& b)
-  {
-    bytes_ = const_cast<byte*>(asio::buffer_cast<const byte*>(b));
-    length_ = asio::buffer_size(b);
-    capacity_ = asio::buffer_size(b);
-  }
-
-  explicit winrt_buffer_impl(const asio::mutable_buffer& b)
-  {
-    bytes_ = const_cast<byte*>(asio::buffer_cast<const byte*>(b));
-    length_ = 0;
-    capacity_ = asio::buffer_size(b);
-  }
-
-  ~winrt_buffer_impl()
-  {
-  }
-
-  STDMETHODIMP Buffer(byte** value)
-  {
-    *value = bytes_;
-    return S_OK;
-  }
-
-  STDMETHODIMP get_Capacity(UINT32* value)
-  {
-    *value = capacity_;
-    return S_OK;
-  }
-
-  STDMETHODIMP get_Length(UINT32 *value)
-  {
-    *value = length_;
-    return S_OK;
-  }
-
-  STDMETHODIMP put_Length(UINT32 value)
-  {
-    if (value > capacity_)
-      return E_INVALIDARG;
-    length_ = value;
-    return S_OK;
-  }
-
-private:
-  byte* bytes_;
-  UINT32 length_;
-  UINT32 capacity_;
-};
-
-void buffer_sequence_adapter_base::init_native_buffer(
-    buffer_sequence_adapter_base::native_buffer_type& buf,
-    const asio::mutable_buffer& buffer)
-{
-  std::memset(&buf, 0, sizeof(native_buffer_type));
-  Microsoft::WRL::ComPtr<IInspectable> insp
-    = Microsoft::WRL::Make<winrt_buffer_impl>(buffer);
-  buf = reinterpret_cast<Windows::Storage::Streams::IBuffer^>(insp.Get());
-}
-
-void buffer_sequence_adapter_base::init_native_buffer(
-    buffer_sequence_adapter_base::native_buffer_type& buf,
-    const asio::const_buffer& buffer)
-{
-  std::memset(&buf, 0, sizeof(native_buffer_type));
-  Microsoft::WRL::ComPtr<IInspectable> insp
-    = Microsoft::WRL::Make<winrt_buffer_impl>(buffer);
-  Platform::Object^ buf_obj = reinterpret_cast<Platform::Object^>(insp.Get());
-  buf = reinterpret_cast<Windows::Storage::Streams::IBuffer^>(insp.Get());
-}
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // defined(ASIO_WINDOWS_RUNTIME)
-
-#endif // ASIO_DETAIL_IMPL_BUFFER_SEQUENCE_ADAPTER_IPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/descriptor_ops.ipp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/descriptor_ops.ipp
deleted file mode 100644
index b260841f91a8..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/descriptor_ops.ipp
+++ /dev/null
@@ -1,451 +0,0 @@
-//
-// detail/impl/descriptor_ops.ipp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_IMPL_DESCRIPTOR_OPS_IPP
-#define ASIO_DETAIL_IMPL_DESCRIPTOR_OPS_IPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include <cerrno>
-#include "asio/detail/descriptor_ops.hpp"
-#include "asio/error.hpp"
-
-#if !defined(ASIO_WINDOWS) \
-  && !defined(ASIO_WINDOWS_RUNTIME) \
-  && !defined(__CYGWIN__)
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-namespace descriptor_ops {
-
-int open(const char* path, int flags, asio::error_code& ec)
-{
-  errno = 0;
-  int result = error_wrapper(::open(path, flags), ec);
-  if (result >= 0)
-    ec = asio::error_code();
-  return result;
-}
-
-int close(int d, state_type& state, asio::error_code& ec)
-{
-  int result = 0;
-  if (d != -1)
-  {
-    errno = 0;
-    result = error_wrapper(::close(d), ec);
-
-    if (result != 0
-        && (ec == asio::error::would_block
-          || ec == asio::error::try_again))
-    {
-      // According to UNIX Network Programming Vol. 1, it is possible for
-      // close() to fail with EWOULDBLOCK under certain circumstances. What
-      // isn't clear is the state of the descriptor after this error. The one
-      // current OS where this behaviour is seen, Windows, says that the socket
-      // remains open. Therefore we'll put the descriptor back into blocking
-      // mode and have another attempt at closing it.
-#if defined(__SYMBIAN32__)
-      int flags = ::fcntl(d, F_GETFL, 0);
-      if (flags >= 0)
-        ::fcntl(d, F_SETFL, flags & ~O_NONBLOCK);
-#else // defined(__SYMBIAN32__)
-      ioctl_arg_type arg = 0;
-      ::ioctl(d, FIONBIO, &arg);
-#endif // defined(__SYMBIAN32__)
-      state &= ~non_blocking;
-
-      errno = 0;
-      result = error_wrapper(::close(d), ec);
-    }
-  }
-
-  if (result == 0)
-    ec = asio::error_code();
-  return result;
-}
-
-bool set_user_non_blocking(int d, state_type& state,
-    bool value, asio::error_code& ec)
-{
-  if (d == -1)
-  {
-    ec = asio::error::bad_descriptor;
-    return false;
-  }
-
-  errno = 0;
-#if defined(__SYMBIAN32__)
-  int result = error_wrapper(::fcntl(d, F_GETFL, 0), ec);
-  if (result >= 0)
-  {
-    errno = 0;
-    int flag = (value ? (result | O_NONBLOCK) : (result & ~O_NONBLOCK));
-    result = error_wrapper(::fcntl(d, F_SETFL, flag), ec);
-  }
-#else // defined(__SYMBIAN32__)
-  ioctl_arg_type arg = (value ? 1 : 0);
-  int result = error_wrapper(::ioctl(d, FIONBIO, &arg), ec);
-#endif // defined(__SYMBIAN32__)
-
-  if (result >= 0)
-  {
-    ec = asio::error_code();
-    if (value)
-      state |= user_set_non_blocking;
-    else
-    {
-      // Clearing the user-set non-blocking mode always overrides any
-      // internally-set non-blocking flag. Any subsequent asynchronous
-      // operations will need to re-enable non-blocking I/O.
-      state &= ~(user_set_non_blocking | internal_non_blocking);
-    }
-    return true;
-  }
-
-  return false;
-}
-
-bool set_internal_non_blocking(int d, state_type& state,
-    bool value, asio::error_code& ec)
-{
-  if (d == -1)
-  {
-    ec = asio::error::bad_descriptor;
-    return false;
-  }
-
-  if (!value && (state & user_set_non_blocking))
-  {
-    // It does not make sense to clear the internal non-blocking flag if the
-    // user still wants non-blocking behaviour. Return an error and let the
-    // caller figure out whether to update the user-set non-blocking flag.
-    ec = asio::error::invalid_argument;
-    return false;
-  }
-
-  errno = 0;
-#if defined(__SYMBIAN32__)
-  int result = error_wrapper(::fcntl(d, F_GETFL, 0), ec);
-  if (result >= 0)
-  {
-    errno = 0;
-    int flag = (value ? (result | O_NONBLOCK) : (result & ~O_NONBLOCK));
-    result = error_wrapper(::fcntl(d, F_SETFL, flag), ec);
-  }
-#else // defined(__SYMBIAN32__)
-  ioctl_arg_type arg = (value ? 1 : 0);
-  int result = error_wrapper(::ioctl(d, FIONBIO, &arg), ec);
-#endif // defined(__SYMBIAN32__)
-
-  if (result >= 0)
-  {
-    ec = asio::error_code();
-    if (value)
-      state |= internal_non_blocking;
-    else
-      state &= ~internal_non_blocking;
-    return true;
-  }
-
-  return false;
-}
-
-std::size_t sync_read(int d, state_type state, buf* bufs,
-    std::size_t count, bool all_empty, asio::error_code& ec)
-{
-  if (d == -1)
-  {
-    ec = asio::error::bad_descriptor;
-    return 0;
-  }
-
-  // A request to read 0 bytes on a stream is a no-op.
-  if (all_empty)
-  {
-    ec = asio::error_code();
-    return 0;
-  }
-
-  // Read some data.
-  for (;;)
-  {
-    // Try to complete the operation without blocking.
-    errno = 0;
-    signed_size_type bytes = error_wrapper(::readv(
-          d, bufs, static_cast<int>(count)), ec);
-
-    // Check if operation succeeded.
-    if (bytes > 0)
-      return bytes;
-
-    // Check for EOF.
-    if (bytes == 0)
-    {
-      ec = asio::error::eof;
-      return 0;
-    }
-
-    // Operation failed.
-    if ((state & user_set_non_blocking)
-        || (ec != asio::error::would_block
-          && ec != asio::error::try_again))
-      return 0;
-
-    // Wait for descriptor to become ready.
-    if (descriptor_ops::poll_read(d, 0, ec) < 0)
-      return 0;
-  }
-}
-
-bool non_blocking_read(int d, buf* bufs, std::size_t count,
-    asio::error_code& ec, std::size_t& bytes_transferred)
-{
-  for (;;)
-  {
-    // Read some data.
-    errno = 0;
-    signed_size_type bytes = error_wrapper(::readv(
-          d, bufs, static_cast<int>(count)), ec);
-
-    // Check for end of stream.
-    if (bytes == 0)
-    {
-      ec = asio::error::eof;
-      return true;
-    }
-
-    // Retry operation if interrupted by signal.
-    if (ec == asio::error::interrupted)
-      continue;
-
-    // Check if we need to run the operation again.
-    if (ec == asio::error::would_block
-        || ec == asio::error::try_again)
-      return false;
-
-    // Operation is complete.
-    if (bytes > 0)
-    {
-      ec = asio::error_code();
-      bytes_transferred = bytes;
-    }
-    else
-      bytes_transferred = 0;
-
-    return true;
-  }
-}
-
-std::size_t sync_write(int d, state_type state, const buf* bufs,
-    std::size_t count, bool all_empty, asio::error_code& ec)
-{
-  if (d == -1)
-  {
-    ec = asio::error::bad_descriptor;
-    return 0;
-  }
-
-  // A request to write 0 bytes on a stream is a no-op.
-  if (all_empty)
-  {
-    ec = asio::error_code();
-    return 0;
-  }
-
-  // Write some data.
-  for (;;)
-  {
-    // Try to complete the operation without blocking.
-    errno = 0;
-    signed_size_type bytes = error_wrapper(::writev(
-          d, bufs, static_cast<int>(count)), ec);
-
-    // Check if operation succeeded.
-    if (bytes > 0)
-      return bytes;
-
-    // Operation failed.
-    if ((state & user_set_non_blocking)
-        || (ec != asio::error::would_block
-          && ec != asio::error::try_again))
-      return 0;
-
-    // Wait for descriptor to become ready.
-    if (descriptor_ops::poll_write(d, 0, ec) < 0)
-      return 0;
-  }
-}
-
-bool non_blocking_write(int d, const buf* bufs, std::size_t count,
-    asio::error_code& ec, std::size_t& bytes_transferred)
-{
-  for (;;)
-  {
-    // Write some data.
-    errno = 0;
-    signed_size_type bytes = error_wrapper(::writev(
-          d, bufs, static_cast<int>(count)), ec);
-
-    // Retry operation if interrupted by signal.
-    if (ec == asio::error::interrupted)
-      continue;
-
-    // Check if we need to run the operation again.
-    if (ec == asio::error::would_block
-        || ec == asio::error::try_again)
-      return false;
-
-    // Operation is complete.
-    if (bytes >= 0)
-    {
-      ec = asio::error_code();
-      bytes_transferred = bytes;
-    }
-    else
-      bytes_transferred = 0;
-
-    return true;
-  }
-}
-
-int ioctl(int d, state_type& state, long cmd,
-    ioctl_arg_type* arg, asio::error_code& ec)
-{
-  if (d == -1)
-  {
-    ec = asio::error::bad_descriptor;
-    return -1;
-  }
-
-  errno = 0;
-  int result = error_wrapper(::ioctl(d, cmd, arg), ec);
-
-  if (result >= 0)
-  {
-    ec = asio::error_code();
-
-    // When updating the non-blocking mode we always perform the ioctl syscall,
-    // even if the flags would otherwise indicate that the descriptor is
-    // already in the correct state. This ensures that the underlying
-    // descriptor is put into the state that has been requested by the user. If
-    // the ioctl syscall was successful then we need to update the flags to
-    // match.
-    if (cmd == static_cast<long>(FIONBIO))
-    {
-      if (*arg)
-      {
-        state |= user_set_non_blocking;
-      }
-      else
-      {
-        // Clearing the non-blocking mode always overrides any internally-set
-        // non-blocking flag. Any subsequent asynchronous operations will need
-        // to re-enable non-blocking I/O.
-        state &= ~(user_set_non_blocking | internal_non_blocking);
-      }
-    }
-  }
-
-  return result;
-}
-
-int fcntl(int d, int cmd, asio::error_code& ec)
-{
-  if (d == -1)
-  {
-    ec = asio::error::bad_descriptor;
-    return -1;
-  }
-
-  errno = 0;
-  int result = error_wrapper(::fcntl(d, cmd), ec);
-  if (result != -1)
-    ec = asio::error_code();
-  return result;
-}
-
-int fcntl(int d, int cmd, long arg, asio::error_code& ec)
-{
-  if (d == -1)
-  {
-    ec = asio::error::bad_descriptor;
-    return -1;
-  }
-
-  errno = 0;
-  int result = error_wrapper(::fcntl(d, cmd, arg), ec);
-  if (result != -1)
-    ec = asio::error_code();
-  return result;
-}
-
-int poll_read(int d, state_type state, asio::error_code& ec)
-{
-  if (d == -1)
-  {
-    ec = asio::error::bad_descriptor;
-    return -1;
-  }
-
-  pollfd fds;
-  fds.fd = d;
-  fds.events = POLLIN;
-  fds.revents = 0;
-  int timeout = (state & user_set_non_blocking) ? 0 : -1;
-  errno = 0;
-  int result = error_wrapper(::poll(&fds, 1, timeout), ec);
-  if (result == 0)
-    ec = (state & user_set_non_blocking)
-      ? asio::error::would_block : asio::error_code();
-  else if (result > 0)
-    ec = asio::error_code();
-  return result;
-}
-
-int poll_write(int d, state_type state, asio::error_code& ec)
-{
-  if (d == -1)
-  {
-    ec = asio::error::bad_descriptor;
-    return -1;
-  }
-
-  pollfd fds;
-  fds.fd = d;
-  fds.events = POLLOUT;
-  fds.revents = 0;
-  int timeout = (state & user_set_non_blocking) ? 0 : -1;
-  errno = 0;
-  int result = error_wrapper(::poll(&fds, 1, timeout), ec);
-  if (result == 0)
-    ec = (state & user_set_non_blocking)
-      ? asio::error::would_block : asio::error_code();
-  else if (result > 0)
-    ec = asio::error_code();
-  return result;
-}
-
-} // namespace descriptor_ops
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // !defined(ASIO_WINDOWS)
-       //   && !defined(ASIO_WINDOWS_RUNTIME)
-       //   && !defined(__CYGWIN__)
-
-#endif // ASIO_DETAIL_IMPL_DESCRIPTOR_OPS_IPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/dev_poll_reactor.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/dev_poll_reactor.hpp
deleted file mode 100644
index f43cab2e7a1d..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/dev_poll_reactor.hpp
+++ /dev/null
@@ -1,78 +0,0 @@
-//
-// detail/impl/dev_poll_reactor.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_IMPL_DEV_POLL_REACTOR_HPP
-#define ASIO_DETAIL_IMPL_DEV_POLL_REACTOR_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_HAS_DEV_POLL)
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-template <typename Time_Traits>
-void dev_poll_reactor::add_timer_queue(timer_queue<Time_Traits>& queue)
-{
-  do_add_timer_queue(queue);
-}
-
-template <typename Time_Traits>
-void dev_poll_reactor::remove_timer_queue(timer_queue<Time_Traits>& queue)
-{
-  do_remove_timer_queue(queue);
-}
-
-template <typename Time_Traits>
-void dev_poll_reactor::schedule_timer(timer_queue<Time_Traits>& queue,
-    const typename Time_Traits::time_type& time,
-    typename timer_queue<Time_Traits>::per_timer_data& timer, wait_op* op)
-{
-  asio::detail::mutex::scoped_lock lock(mutex_);
-
-  if (shutdown_)
-  {
-    io_service_.post_immediate_completion(op, false);
-    return;
-  }
-
-  bool earliest = queue.enqueue_timer(time, timer, op);
-  io_service_.work_started();
-  if (earliest)
-    interrupter_.interrupt();
-}
-
-template <typename Time_Traits>
-std::size_t dev_poll_reactor::cancel_timer(timer_queue<Time_Traits>& queue,
-    typename timer_queue<Time_Traits>::per_timer_data& timer,
-    std::size_t max_cancelled)
-{
-  asio::detail::mutex::scoped_lock lock(mutex_);
-  op_queue<operation> ops;
-  std::size_t n = queue.cancel_timer(timer, ops, max_cancelled);
-  lock.unlock();
-  io_service_.post_deferred_completions(ops);
-  return n;
-}
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // defined(ASIO_HAS_DEV_POLL)
-
-#endif // ASIO_DETAIL_IMPL_DEV_POLL_REACTOR_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/dev_poll_reactor.ipp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/dev_poll_reactor.ipp
deleted file mode 100644
index 1f365dfc036d..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/dev_poll_reactor.ipp
+++ /dev/null
@@ -1,445 +0,0 @@
-//
-// detail/impl/dev_poll_reactor.ipp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_IMPL_DEV_POLL_REACTOR_IPP
-#define ASIO_DETAIL_IMPL_DEV_POLL_REACTOR_IPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_HAS_DEV_POLL)
-
-#include "asio/detail/dev_poll_reactor.hpp"
-#include "asio/detail/assert.hpp"
-#include "asio/detail/throw_error.hpp"
-#include "asio/error.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-dev_poll_reactor::dev_poll_reactor(asio::io_service& io_service)
-  : asio::detail::service_base<dev_poll_reactor>(io_service),
-    io_service_(use_service<io_service_impl>(io_service)),
-    mutex_(),
-    dev_poll_fd_(do_dev_poll_create()),
-    interrupter_(),
-    shutdown_(false)
-{
-  // Add the interrupter's descriptor to /dev/poll.
-  ::pollfd ev = { 0, 0, 0 };
-  ev.fd = interrupter_.read_descriptor();
-  ev.events = POLLIN | POLLERR;
-  ev.revents = 0;
-  ::write(dev_poll_fd_, &ev, sizeof(ev));
-}
-
-dev_poll_reactor::~dev_poll_reactor()
-{
-  shutdown_service();
-  ::close(dev_poll_fd_);
-}
-
-void dev_poll_reactor::shutdown_service()
-{
-  asio::detail::mutex::scoped_lock lock(mutex_);
-  shutdown_ = true;
-  lock.unlock();
-
-  op_queue<operation> ops;
-
-  for (int i = 0; i < max_ops; ++i)
-    op_queue_[i].get_all_operations(ops);
-
-  timer_queues_.get_all_timers(ops);
-
-  io_service_.abandon_operations(ops);
-} 
-
-// Helper class to re-register all descriptors with /dev/poll.
-class dev_poll_reactor::fork_helper
-{
-public:
-  fork_helper(dev_poll_reactor* reactor, short events)
-    : reactor_(reactor), events_(events)
-  {
-  }
-
-  bool set(int descriptor)
-  {
-    ::pollfd& ev = reactor_->add_pending_event_change(descriptor);
-    ev.events = events_;
-    return true;
-  }
-
-private:
-  dev_poll_reactor* reactor_;
-  short events_;
-};
-
-void dev_poll_reactor::fork_service(asio::io_service::fork_event fork_ev)
-{
-  if (fork_ev == asio::io_service::fork_child)
-  {
-    detail::mutex::scoped_lock lock(mutex_);
-
-    if (dev_poll_fd_ != -1)
-      ::close(dev_poll_fd_);
-    dev_poll_fd_ = -1;
-    dev_poll_fd_ = do_dev_poll_create();
-
-    interrupter_.recreate();
-
-    // Add the interrupter's descriptor to /dev/poll.
-    ::pollfd ev = { 0, 0, 0 };
-    ev.fd = interrupter_.read_descriptor();
-    ev.events = POLLIN | POLLERR;
-    ev.revents = 0;
-    ::write(dev_poll_fd_, &ev, sizeof(ev));
-
-    // Re-register all descriptors with /dev/poll. The changes will be written
-    // to the /dev/poll descriptor the next time the reactor is run.
-    op_queue<operation> ops;
-    fork_helper read_op_helper(this, POLLERR | POLLHUP | POLLIN);
-    op_queue_[read_op].get_descriptors(read_op_helper, ops);
-    fork_helper write_op_helper(this, POLLERR | POLLHUP | POLLOUT);
-    op_queue_[write_op].get_descriptors(write_op_helper, ops);
-    fork_helper except_op_helper(this, POLLERR | POLLHUP | POLLPRI);
-    op_queue_[except_op].get_descriptors(except_op_helper, ops);
-    interrupter_.interrupt();
-
-    // The ops op_queue will always be empty because the fork_helper's set()
-    // member function never returns false.
-    ASIO_ASSERT(ops.empty());
-  }
-}
-
-void dev_poll_reactor::init_task()
-{
-  io_service_.init_task();
-}
-
-int dev_poll_reactor::register_descriptor(socket_type, per_descriptor_data&)
-{
-  return 0;
-}
-
-int dev_poll_reactor::register_internal_descriptor(int op_type,
-    socket_type descriptor, per_descriptor_data&, reactor_op* op)
-{
-  asio::detail::mutex::scoped_lock lock(mutex_);
-
-  op_queue_[op_type].enqueue_operation(descriptor, op);
-  ::pollfd& ev = add_pending_event_change(descriptor);
-  ev.events = POLLERR | POLLHUP;
-  switch (op_type)
-  {
-  case read_op: ev.events |= POLLIN; break;
-  case write_op: ev.events |= POLLOUT; break;
-  case except_op: ev.events |= POLLPRI; break;
-  default: break;
-  }
-  interrupter_.interrupt();
-
-  return 0;
-}
-
-void dev_poll_reactor::move_descriptor(socket_type,
-    dev_poll_reactor::per_descriptor_data&,
-    dev_poll_reactor::per_descriptor_data&)
-{
-}
-
-void dev_poll_reactor::start_op(int op_type, socket_type descriptor,
-    dev_poll_reactor::per_descriptor_data&, reactor_op* op,
-    bool is_continuation, bool allow_speculative)
-{
-  asio::detail::mutex::scoped_lock lock(mutex_);
-
-  if (shutdown_)
-  {
-    post_immediate_completion(op, is_continuation);
-    return;
-  }
-
-  if (allow_speculative)
-  {
-    if (op_type != read_op || !op_queue_[except_op].has_operation(descriptor))
-    {
-      if (!op_queue_[op_type].has_operation(descriptor))
-      {
-        if (op->perform())
-        {
-          lock.unlock();
-          io_service_.post_immediate_completion(op, is_continuation);
-          return;
-        }
-      }
-    }
-  }
-
-  bool first = op_queue_[op_type].enqueue_operation(descriptor, op);
-  io_service_.work_started();
-  if (first)
-  {
-    ::pollfd& ev = add_pending_event_change(descriptor);
-    ev.events = POLLERR | POLLHUP;
-    if (op_type == read_op
-        || op_queue_[read_op].has_operation(descriptor))
-      ev.events |= POLLIN;
-    if (op_type == write_op
-        || op_queue_[write_op].has_operation(descriptor))
-      ev.events |= POLLOUT;
-    if (op_type == except_op
-        || op_queue_[except_op].has_operation(descriptor))
-      ev.events |= POLLPRI;
-    interrupter_.interrupt();
-  }
-}
-
-void dev_poll_reactor::cancel_ops(socket_type descriptor,
-    dev_poll_reactor::per_descriptor_data&)
-{
-  asio::detail::mutex::scoped_lock lock(mutex_);
-  cancel_ops_unlocked(descriptor, asio::error::operation_aborted);
-}
-
-void dev_poll_reactor::deregister_descriptor(socket_type descriptor,
-    dev_poll_reactor::per_descriptor_data&, bool)
-{
-  asio::detail::mutex::scoped_lock lock(mutex_);
-
-  // Remove the descriptor from /dev/poll.
-  ::pollfd& ev = add_pending_event_change(descriptor);
-  ev.events = POLLREMOVE;
-  interrupter_.interrupt();
-
-  // Cancel any outstanding operations associated with the descriptor.
-  cancel_ops_unlocked(descriptor, asio::error::operation_aborted);
-}
-
-void dev_poll_reactor::deregister_internal_descriptor(
-    socket_type descriptor, dev_poll_reactor::per_descriptor_data&)
-{
-  asio::detail::mutex::scoped_lock lock(mutex_);
-
-  // Remove the descriptor from /dev/poll. Since this function is only called
-  // during a fork, we can apply the change immediately.
-  ::pollfd ev = { 0, 0, 0 };
-  ev.fd = descriptor;
-  ev.events = POLLREMOVE;
-  ev.revents = 0;
-  ::write(dev_poll_fd_, &ev, sizeof(ev));
-
-  // Destroy all operations associated with the descriptor.
-  op_queue<operation> ops;
-  asio::error_code ec;
-  for (int i = 0; i < max_ops; ++i)
-    op_queue_[i].cancel_operations(descriptor, ops, ec);
-}
-
-void dev_poll_reactor::run(bool block, op_queue<operation>& ops)
-{
-  asio::detail::mutex::scoped_lock lock(mutex_);
-
-  // We can return immediately if there's no work to do and the reactor is
-  // not supposed to block.
-  if (!block && op_queue_[read_op].empty() && op_queue_[write_op].empty()
-      && op_queue_[except_op].empty() && timer_queues_.all_empty())
-    return;
-
-  // Write the pending event registration changes to the /dev/poll descriptor.
-  std::size_t events_size = sizeof(::pollfd) * pending_event_changes_.size();
-  if (events_size > 0)
-  {
-    errno = 0;
-    int result = ::write(dev_poll_fd_,
-        &pending_event_changes_[0], events_size);
-    if (result != static_cast<int>(events_size))
-    {
-      asio::error_code ec = asio::error_code(
-          errno, asio::error::get_system_category());
-      for (std::size_t i = 0; i < pending_event_changes_.size(); ++i)
-      {
-        int descriptor = pending_event_changes_[i].fd;
-        for (int j = 0; j < max_ops; ++j)
-          op_queue_[j].cancel_operations(descriptor, ops, ec);
-      }
-    }
-    pending_event_changes_.clear();
-    pending_event_change_index_.clear();
-  }
-
-  int timeout = block ? get_timeout() : 0;
-  lock.unlock();
-
-  // Block on the /dev/poll descriptor.
-  ::pollfd events[128] = { { 0, 0, 0 } };
-  ::dvpoll dp = { 0, 0, 0 };
-  dp.dp_fds = events;
-  dp.dp_nfds = 128;
-  dp.dp_timeout = timeout;
-  int num_events = ::ioctl(dev_poll_fd_, DP_POLL, &dp);
-
-  lock.lock();
-
-  // Dispatch the waiting events.
-  for (int i = 0; i < num_events; ++i)
-  {
-    int descriptor = events[i].fd;
-    if (descriptor == interrupter_.read_descriptor())
-    {
-      interrupter_.reset();
-    }
-    else
-    {
-      bool more_reads = false;
-      bool more_writes = false;
-      bool more_except = false;
-
-      // Exception operations must be processed first to ensure that any
-      // out-of-band data is read before normal data.
-      if (events[i].events & (POLLPRI | POLLERR | POLLHUP))
-        more_except =
-          op_queue_[except_op].perform_operations(descriptor, ops);
-      else
-        more_except = op_queue_[except_op].has_operation(descriptor);
-
-      if (events[i].events & (POLLIN | POLLERR | POLLHUP))
-        more_reads = op_queue_[read_op].perform_operations(descriptor, ops);
-      else
-        more_reads = op_queue_[read_op].has_operation(descriptor);
-
-      if (events[i].events & (POLLOUT | POLLERR | POLLHUP))
-        more_writes = op_queue_[write_op].perform_operations(descriptor, ops);
-      else
-        more_writes = op_queue_[write_op].has_operation(descriptor);
-
-      if ((events[i].events & (POLLERR | POLLHUP)) != 0
-            && !more_except && !more_reads && !more_writes)
-      {
-        // If we have an event and no operations associated with the
-        // descriptor then we need to delete the descriptor from /dev/poll.
-        // The poll operation can produce POLLHUP or POLLERR events when there
-        // is no operation pending, so if we do not remove the descriptor we
-        // can end up in a tight polling loop.
-        ::pollfd ev = { 0, 0, 0 };
-        ev.fd = descriptor;
-        ev.events = POLLREMOVE;
-        ev.revents = 0;
-        ::write(dev_poll_fd_, &ev, sizeof(ev));
-      }
-      else
-      {
-        ::pollfd ev = { 0, 0, 0 };
-        ev.fd = descriptor;
-        ev.events = POLLERR | POLLHUP;
-        if (more_reads)
-          ev.events |= POLLIN;
-        if (more_writes)
-          ev.events |= POLLOUT;
-        if (more_except)
-          ev.events |= POLLPRI;
-        ev.revents = 0;
-        int result = ::write(dev_poll_fd_, &ev, sizeof(ev));
-        if (result != sizeof(ev))
-        {
-          asio::error_code ec(errno,
-              asio::error::get_system_category());
-          for (int j = 0; j < max_ops; ++j)
-            op_queue_[j].cancel_operations(descriptor, ops, ec);
-        }
-      }
-    }
-  }
-  timer_queues_.get_ready_timers(ops);
-}
-
-void dev_poll_reactor::interrupt()
-{
-  interrupter_.interrupt();
-}
-
-int dev_poll_reactor::do_dev_poll_create()
-{
-  int fd = ::open("/dev/poll", O_RDWR);
-  if (fd == -1)
-  {
-    asio::error_code ec(errno,
-        asio::error::get_system_category());
-    asio::detail::throw_error(ec, "/dev/poll");
-  }
-  return fd;
-}
-
-void dev_poll_reactor::do_add_timer_queue(timer_queue_base& queue)
-{
-  mutex::scoped_lock lock(mutex_);
-  timer_queues_.insert(&queue);
-}
-
-void dev_poll_reactor::do_remove_timer_queue(timer_queue_base& queue)
-{
-  mutex::scoped_lock lock(mutex_);
-  timer_queues_.erase(&queue);
-}
-
-int dev_poll_reactor::get_timeout()
-{
-  // By default we will wait no longer than 5 minutes. This will ensure that
-  // any changes to the system clock are detected after no longer than this.
-  return timer_queues_.wait_duration_msec(5 * 60 * 1000);
-}
-
-void dev_poll_reactor::cancel_ops_unlocked(socket_type descriptor,
-    const asio::error_code& ec)
-{
-  bool need_interrupt = false;
-  op_queue<operation> ops;
-  for (int i = 0; i < max_ops; ++i)
-    need_interrupt = op_queue_[i].cancel_operations(
-        descriptor, ops, ec) || need_interrupt;
-  io_service_.post_deferred_completions(ops);
-  if (need_interrupt)
-    interrupter_.interrupt();
-}
-
-::pollfd& dev_poll_reactor::add_pending_event_change(int descriptor)
-{
-  hash_map<int, std::size_t>::iterator iter
-    = pending_event_change_index_.find(descriptor);
-  if (iter == pending_event_change_index_.end())
-  {
-    std::size_t index = pending_event_changes_.size();
-    pending_event_changes_.reserve(pending_event_changes_.size() + 1);
-    pending_event_change_index_.insert(std::make_pair(descriptor, index));
-    pending_event_changes_.push_back(::pollfd());
-    pending_event_changes_[index].fd = descriptor;
-    pending_event_changes_[index].revents = 0;
-    return pending_event_changes_[index];
-  }
-  else
-  {
-    return pending_event_changes_[iter->second];
-  }
-}
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // defined(ASIO_HAS_DEV_POLL)
-
-#endif // ASIO_DETAIL_IMPL_DEV_POLL_REACTOR_IPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/epoll_reactor.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/epoll_reactor.hpp
deleted file mode 100644
index df60c01d6e68..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/epoll_reactor.hpp
+++ /dev/null
@@ -1,76 +0,0 @@
-//
-// detail/impl/epoll_reactor.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_IMPL_EPOLL_REACTOR_HPP
-#define ASIO_DETAIL_IMPL_EPOLL_REACTOR_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#if defined(ASIO_HAS_EPOLL)
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-template <typename Time_Traits>
-void epoll_reactor::add_timer_queue(timer_queue<Time_Traits>& queue)
-{
-  do_add_timer_queue(queue);
-}
-
-template <typename Time_Traits>
-void epoll_reactor::remove_timer_queue(timer_queue<Time_Traits>& queue)
-{
-  do_remove_timer_queue(queue);
-}
-
-template <typename Time_Traits>
-void epoll_reactor::schedule_timer(timer_queue<Time_Traits>& queue,
-    const typename Time_Traits::time_type& time,
-    typename timer_queue<Time_Traits>::per_timer_data& timer, wait_op* op)
-{
-  mutex::scoped_lock lock(mutex_);
-
-  if (shutdown_)
-  {
-    io_service_.post_immediate_completion(op, false);
-    return;
-  }
-
-  bool earliest = queue.enqueue_timer(time, timer, op);
-  io_service_.work_started();
-  if (earliest)
-    update_timeout();
-}
-
-template <typename Time_Traits>
-std::size_t epoll_reactor::cancel_timer(timer_queue<Time_Traits>& queue,
-    typename timer_queue<Time_Traits>::per_timer_data& timer,
-    std::size_t max_cancelled)
-{
-  mutex::scoped_lock lock(mutex_);
-  op_queue<operation> ops;
-  std::size_t n = queue.cancel_timer(timer, ops, max_cancelled);
-  lock.unlock();
-  io_service_.post_deferred_completions(ops);
-  return n;
-}
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // defined(ASIO_HAS_EPOLL)
-
-#endif // ASIO_DETAIL_IMPL_EPOLL_REACTOR_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/epoll_reactor.ipp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/epoll_reactor.ipp
deleted file mode 100644
index 6452f3d7a684..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/epoll_reactor.ipp
+++ /dev/null
@@ -1,662 +0,0 @@
-//
-// detail/impl/epoll_reactor.ipp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_IMPL_EPOLL_REACTOR_IPP
-#define ASIO_DETAIL_IMPL_EPOLL_REACTOR_IPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_HAS_EPOLL)
-
-#include <cstddef>
-#include <sys/epoll.h>
-#include "asio/detail/epoll_reactor.hpp"
-#include "asio/detail/throw_error.hpp"
-#include "asio/error.hpp"
-
-#if defined(ASIO_HAS_TIMERFD)
-# include <sys/timerfd.h>
-#endif // defined(ASIO_HAS_TIMERFD)
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-epoll_reactor::epoll_reactor(asio::io_service& io_service)
-  : asio::detail::service_base<epoll_reactor>(io_service),
-    io_service_(use_service<io_service_impl>(io_service)),
-    mutex_(),
-    interrupter_(),
-    epoll_fd_(do_epoll_create()),
-    timer_fd_(do_timerfd_create()),
-    shutdown_(false)
-{
-  // Add the interrupter's descriptor to epoll.
-  epoll_event ev = { 0, { 0 } };
-  ev.events = EPOLLIN | EPOLLERR | EPOLLET;
-  ev.data.ptr = &interrupter_;
-  epoll_ctl(epoll_fd_, EPOLL_CTL_ADD, interrupter_.read_descriptor(), &ev);
-  interrupter_.interrupt();
-
-  // Add the timer descriptor to epoll.
-  if (timer_fd_ != -1)
-  {
-    ev.events = EPOLLIN | EPOLLERR;
-    ev.data.ptr = &timer_fd_;
-    epoll_ctl(epoll_fd_, EPOLL_CTL_ADD, timer_fd_, &ev);
-  }
-}
-
-epoll_reactor::~epoll_reactor()
-{
-  if (epoll_fd_ != -1)
-    close(epoll_fd_);
-  if (timer_fd_ != -1)
-    close(timer_fd_);
-}
-
-void epoll_reactor::shutdown_service()
-{
-  mutex::scoped_lock lock(mutex_);
-  shutdown_ = true;
-  lock.unlock();
-
-  op_queue<operation> ops;
-
-  while (descriptor_state* state = registered_descriptors_.first())
-  {
-    for (int i = 0; i < max_ops; ++i)
-      ops.push(state->op_queue_[i]);
-    state->shutdown_ = true;
-    registered_descriptors_.free(state);
-  }
-
-  timer_queues_.get_all_timers(ops);
-
-  io_service_.abandon_operations(ops);
-}
-
-void epoll_reactor::fork_service(asio::io_service::fork_event fork_ev)
-{
-  if (fork_ev == asio::io_service::fork_child)
-  {
-    if (epoll_fd_ != -1)
-      ::close(epoll_fd_);
-    epoll_fd_ = -1;
-    epoll_fd_ = do_epoll_create();
-
-    if (timer_fd_ != -1)
-      ::close(timer_fd_);
-    timer_fd_ = -1;
-    timer_fd_ = do_timerfd_create();
-
-    interrupter_.recreate();
-
-    // Add the interrupter's descriptor to epoll.
-    epoll_event ev = { 0, { 0 } };
-    ev.events = EPOLLIN | EPOLLERR | EPOLLET;
-    ev.data.ptr = &interrupter_;
-    epoll_ctl(epoll_fd_, EPOLL_CTL_ADD, interrupter_.read_descriptor(), &ev);
-    interrupter_.interrupt();
-
-    // Add the timer descriptor to epoll.
-    if (timer_fd_ != -1)
-    {
-      ev.events = EPOLLIN | EPOLLERR;
-      ev.data.ptr = &timer_fd_;
-      epoll_ctl(epoll_fd_, EPOLL_CTL_ADD, timer_fd_, &ev);
-    }
-
-    update_timeout();
-
-    // Re-register all descriptors with epoll.
-    mutex::scoped_lock descriptors_lock(registered_descriptors_mutex_);
-    for (descriptor_state* state = registered_descriptors_.first();
-        state != 0; state = state->next_)
-    {
-      ev.events = state->registered_events_;
-      ev.data.ptr = state;
-      int result = epoll_ctl(epoll_fd_, EPOLL_CTL_ADD, state->descriptor_, &ev);
-      if (result != 0)
-      {
-        asio::error_code ec(errno,
-            asio::error::get_system_category());
-        asio::detail::throw_error(ec, "epoll re-registration");
-      }
-    }
-  }
-}
-
-void epoll_reactor::init_task()
-{
-  io_service_.init_task();
-}
-
-int epoll_reactor::register_descriptor(socket_type descriptor,
-    epoll_reactor::per_descriptor_data& descriptor_data)
-{
-  descriptor_data = allocate_descriptor_state();
-
-  {
-    mutex::scoped_lock descriptor_lock(descriptor_data->mutex_);
-
-    descriptor_data->reactor_ = this;
-    descriptor_data->descriptor_ = descriptor;
-    descriptor_data->shutdown_ = false;
-  }
-
-  epoll_event ev = { 0, { 0 } };
-  ev.events = EPOLLIN | EPOLLERR | EPOLLHUP | EPOLLPRI | EPOLLET;
-  descriptor_data->registered_events_ = ev.events;
-  ev.data.ptr = descriptor_data;
-  int result = epoll_ctl(epoll_fd_, EPOLL_CTL_ADD, descriptor, &ev);
-  if (result != 0)
-    return errno;
-
-  return 0;
-}
-
-int epoll_reactor::register_internal_descriptor(
-    int op_type, socket_type descriptor,
-    epoll_reactor::per_descriptor_data& descriptor_data, reactor_op* op)
-{
-  descriptor_data = allocate_descriptor_state();
-
-  {
-    mutex::scoped_lock descriptor_lock(descriptor_data->mutex_);
-
-    descriptor_data->reactor_ = this;
-    descriptor_data->descriptor_ = descriptor;
-    descriptor_data->shutdown_ = false;
-    descriptor_data->op_queue_[op_type].push(op);
-  }
-
-  epoll_event ev = { 0, { 0 } };
-  ev.events = EPOLLIN | EPOLLERR | EPOLLHUP | EPOLLPRI | EPOLLET;
-  descriptor_data->registered_events_ = ev.events;
-  ev.data.ptr = descriptor_data;
-  int result = epoll_ctl(epoll_fd_, EPOLL_CTL_ADD, descriptor, &ev);
-  if (result != 0)
-    return errno;
-
-  return 0;
-}
-
-void epoll_reactor::move_descriptor(socket_type,
-    epoll_reactor::per_descriptor_data& target_descriptor_data,
-    epoll_reactor::per_descriptor_data& source_descriptor_data)
-{
-  target_descriptor_data = source_descriptor_data;
-  source_descriptor_data = 0;
-}
-
-void epoll_reactor::start_op(int op_type, socket_type descriptor,
-    epoll_reactor::per_descriptor_data& descriptor_data, reactor_op* op,
-    bool is_continuation, bool allow_speculative)
-{
-  if (!descriptor_data)
-  {
-    op->ec_ = asio::error::bad_descriptor;
-    post_immediate_completion(op, is_continuation);
-    return;
-  }
-
-  mutex::scoped_lock descriptor_lock(descriptor_data->mutex_);
-
-  if (descriptor_data->shutdown_)
-  {
-    post_immediate_completion(op, is_continuation);
-    return;
-  }
-
-  if (descriptor_data->op_queue_[op_type].empty())
-  {
-    if (allow_speculative
-        && (op_type != read_op
-          || descriptor_data->op_queue_[except_op].empty()))
-    {
-      if (op->perform())
-      {
-        descriptor_lock.unlock();
-        io_service_.post_immediate_completion(op, is_continuation);
-        return;
-      }
-
-      if (op_type == write_op)
-      {
-        if ((descriptor_data->registered_events_ & EPOLLOUT) == 0)
-        {
-          epoll_event ev = { 0, { 0 } };
-          ev.events = descriptor_data->registered_events_ | EPOLLOUT;
-          ev.data.ptr = descriptor_data;
-          if (epoll_ctl(epoll_fd_, EPOLL_CTL_MOD, descriptor, &ev) == 0)
-          {
-            descriptor_data->registered_events_ |= ev.events;
-          }
-          else
-          {
-            op->ec_ = asio::error_code(errno,
-                asio::error::get_system_category());
-            io_service_.post_immediate_completion(op, is_continuation);
-            return;
-          }
-        }
-      }
-    }
-    else
-    {
-      if (op_type == write_op)
-      {
-        descriptor_data->registered_events_ |= EPOLLOUT;
-      }
-
-      epoll_event ev = { 0, { 0 } };
-      ev.events = descriptor_data->registered_events_;
-      ev.data.ptr = descriptor_data;
-      epoll_ctl(epoll_fd_, EPOLL_CTL_MOD, descriptor, &ev);
-    }
-  }
-
-  descriptor_data->op_queue_[op_type].push(op);
-  io_service_.work_started();
-}
-
-void epoll_reactor::cancel_ops(socket_type,
-    epoll_reactor::per_descriptor_data& descriptor_data)
-{
-  if (!descriptor_data)
-    return;
-
-  mutex::scoped_lock descriptor_lock(descriptor_data->mutex_);
-
-  op_queue<operation> ops;
-  for (int i = 0; i < max_ops; ++i)
-  {
-    while (reactor_op* op = descriptor_data->op_queue_[i].front())
-    {
-      op->ec_ = asio::error::operation_aborted;
-      descriptor_data->op_queue_[i].pop();
-      ops.push(op);
-    }
-  }
-
-  descriptor_lock.unlock();
-
-  io_service_.post_deferred_completions(ops);
-}
-
-void epoll_reactor::deregister_descriptor(socket_type descriptor,
-    epoll_reactor::per_descriptor_data& descriptor_data, bool closing)
-{
-  if (!descriptor_data)
-    return;
-
-  mutex::scoped_lock descriptor_lock(descriptor_data->mutex_);
-
-  if (!descriptor_data->shutdown_)
-  {
-    if (closing)
-    {
-      // The descriptor will be automatically removed from the epoll set when
-      // it is closed.
-    }
-    else
-    {
-      epoll_event ev = { 0, { 0 } };
-      epoll_ctl(epoll_fd_, EPOLL_CTL_DEL, descriptor, &ev);
-    }
-
-    op_queue<operation> ops;
-    for (int i = 0; i < max_ops; ++i)
-    {
-      while (reactor_op* op = descriptor_data->op_queue_[i].front())
-      {
-        op->ec_ = asio::error::operation_aborted;
-        descriptor_data->op_queue_[i].pop();
-        ops.push(op);
-      }
-    }
-
-    descriptor_data->descriptor_ = -1;
-    descriptor_data->shutdown_ = true;
-
-    descriptor_lock.unlock();
-
-    free_descriptor_state(descriptor_data);
-    descriptor_data = 0;
-
-    io_service_.post_deferred_completions(ops);
-  }
-}
-
-void epoll_reactor::deregister_internal_descriptor(socket_type descriptor,
-    epoll_reactor::per_descriptor_data& descriptor_data)
-{
-  if (!descriptor_data)
-    return;
-
-  mutex::scoped_lock descriptor_lock(descriptor_data->mutex_);
-
-  if (!descriptor_data->shutdown_)
-  {
-    epoll_event ev = { 0, { 0 } };
-    epoll_ctl(epoll_fd_, EPOLL_CTL_DEL, descriptor, &ev);
-
-    op_queue<operation> ops;
-    for (int i = 0; i < max_ops; ++i)
-      ops.push(descriptor_data->op_queue_[i]);
-
-    descriptor_data->descriptor_ = -1;
-    descriptor_data->shutdown_ = true;
-
-    descriptor_lock.unlock();
-
-    free_descriptor_state(descriptor_data);
-    descriptor_data = 0;
-  }
-}
-
-void epoll_reactor::run(bool block, op_queue<operation>& ops)
-{
-  // This code relies on the fact that the task_io_service queues the reactor
-  // task behind all descriptor operations generated by this function. This
-  // means, that by the time we reach this point, any previously returned
-  // descriptor operations have already been dequeued. Therefore it is now safe
-  // for us to reuse and return them for the task_io_service to queue again.
-
-  // Calculate a timeout only if timerfd is not used.
-  int timeout;
-  if (timer_fd_ != -1)
-    timeout = block ? -1 : 0;
-  else
-  {
-    mutex::scoped_lock lock(mutex_);
-    timeout = block ? get_timeout() : 0;
-  }
-
-  // Block on the epoll descriptor.
-  epoll_event events[128];
-  int num_events = epoll_wait(epoll_fd_, events, 128, timeout);
-
-#if defined(ASIO_HAS_TIMERFD)
-  bool check_timers = (timer_fd_ == -1);
-#else // defined(ASIO_HAS_TIMERFD)
-  bool check_timers = true;
-#endif // defined(ASIO_HAS_TIMERFD)
-
-  // Dispatch the waiting events.
-  for (int i = 0; i < num_events; ++i)
-  {
-    void* ptr = events[i].data.ptr;
-    if (ptr == &interrupter_)
-    {
-      // No need to reset the interrupter since we're leaving the descriptor
-      // in a ready-to-read state and relying on edge-triggered notifications
-      // to make it so that we only get woken up when the descriptor's epoll
-      // registration is updated.
-
-#if defined(ASIO_HAS_TIMERFD)
-      if (timer_fd_ == -1)
-        check_timers = true;
-#else // defined(ASIO_HAS_TIMERFD)
-      check_timers = true;
-#endif // defined(ASIO_HAS_TIMERFD)
-    }
-#if defined(ASIO_HAS_TIMERFD)
-    else if (ptr == &timer_fd_)
-    {
-      check_timers = true;
-    }
-#endif // defined(ASIO_HAS_TIMERFD)
-    else
-    {
-      // The descriptor operation doesn't count as work in and of itself, so we
-      // don't call work_started() here. This still allows the io_service to
-      // stop if the only remaining operations are descriptor operations.
-      descriptor_state* descriptor_data = static_cast<descriptor_state*>(ptr);
-      descriptor_data->set_ready_events(events[i].events);
-      ops.push(descriptor_data);
-    }
-  }
-
-  if (check_timers)
-  {
-    mutex::scoped_lock common_lock(mutex_);
-    timer_queues_.get_ready_timers(ops);
-
-#if defined(ASIO_HAS_TIMERFD)
-    if (timer_fd_ != -1)
-    {
-      itimerspec new_timeout;
-      itimerspec old_timeout;
-      int flags = get_timeout(new_timeout);
-      timerfd_settime(timer_fd_, flags, &new_timeout, &old_timeout);
-    }
-#endif // defined(ASIO_HAS_TIMERFD)
-  }
-}
-
-void epoll_reactor::interrupt()
-{
-  epoll_event ev = { 0, { 0 } };
-  ev.events = EPOLLIN | EPOLLERR | EPOLLET;
-  ev.data.ptr = &interrupter_;
-  epoll_ctl(epoll_fd_, EPOLL_CTL_MOD, interrupter_.read_descriptor(), &ev);
-}
-
-int epoll_reactor::do_epoll_create()
-{
-#if defined(EPOLL_CLOEXEC)
-  int fd = epoll_create1(EPOLL_CLOEXEC);
-#else // defined(EPOLL_CLOEXEC)
-  int fd = -1;
-  errno = EINVAL;
-#endif // defined(EPOLL_CLOEXEC)
-
-  if (fd == -1 && (errno == EINVAL || errno == ENOSYS))
-  {
-    fd = epoll_create(epoll_size);
-    if (fd != -1)
-      ::fcntl(fd, F_SETFD, FD_CLOEXEC);
-  }
-
-  if (fd == -1)
-  {
-    asio::error_code ec(errno,
-        asio::error::get_system_category());
-    asio::detail::throw_error(ec, "epoll");
-  }
-
-  return fd;
-}
-
-int epoll_reactor::do_timerfd_create()
-{
-#if defined(ASIO_HAS_TIMERFD)
-# if defined(TFD_CLOEXEC)
-  int fd = timerfd_create(CLOCK_MONOTONIC, TFD_CLOEXEC);
-# else // defined(TFD_CLOEXEC)
-  int fd = -1;
-  errno = EINVAL;
-# endif // defined(TFD_CLOEXEC)
-
-  if (fd == -1 && errno == EINVAL)
-  {
-    fd = timerfd_create(CLOCK_MONOTONIC, 0);
-    if (fd != -1)
-      ::fcntl(fd, F_SETFD, FD_CLOEXEC);
-  }
-
-  return fd;
-#else // defined(ASIO_HAS_TIMERFD)
-  return -1;
-#endif // defined(ASIO_HAS_TIMERFD)
-}
-
-epoll_reactor::descriptor_state* epoll_reactor::allocate_descriptor_state()
-{
-  mutex::scoped_lock descriptors_lock(registered_descriptors_mutex_);
-  return registered_descriptors_.alloc();
-}
-
-void epoll_reactor::free_descriptor_state(epoll_reactor::descriptor_state* s)
-{
-  mutex::scoped_lock descriptors_lock(registered_descriptors_mutex_);
-  registered_descriptors_.free(s);
-}
-
-void epoll_reactor::do_add_timer_queue(timer_queue_base& queue)
-{
-  mutex::scoped_lock lock(mutex_);
-  timer_queues_.insert(&queue);
-}
-
-void epoll_reactor::do_remove_timer_queue(timer_queue_base& queue)
-{
-  mutex::scoped_lock lock(mutex_);
-  timer_queues_.erase(&queue);
-}
-
-void epoll_reactor::update_timeout()
-{
-#if defined(ASIO_HAS_TIMERFD)
-  if (timer_fd_ != -1)
-  {
-    itimerspec new_timeout;
-    itimerspec old_timeout;
-    int flags = get_timeout(new_timeout);
-    timerfd_settime(timer_fd_, flags, &new_timeout, &old_timeout);
-    return;
-  }
-#endif // defined(ASIO_HAS_TIMERFD)
-  interrupt();
-}
-
-int epoll_reactor::get_timeout()
-{
-  // By default we will wait no longer than 5 minutes. This will ensure that
-  // any changes to the system clock are detected after no longer than this.
-  return timer_queues_.wait_duration_msec(5 * 60 * 1000);
-}
-
-#if defined(ASIO_HAS_TIMERFD)
-int epoll_reactor::get_timeout(itimerspec& ts)
-{
-  ts.it_interval.tv_sec = 0;
-  ts.it_interval.tv_nsec = 0;
-
-  long usec = timer_queues_.wait_duration_usec(5 * 60 * 1000 * 1000);
-  ts.it_value.tv_sec = usec / 1000000;
-  ts.it_value.tv_nsec = usec ? (usec % 1000000) * 1000 : 1;
-
-  return usec ? 0 : TFD_TIMER_ABSTIME;
-}
-#endif // defined(ASIO_HAS_TIMERFD)
-
-struct epoll_reactor::perform_io_cleanup_on_block_exit
-{
-  explicit perform_io_cleanup_on_block_exit(epoll_reactor* r)
-    : reactor_(r), first_op_(0)
-  {
-  }
-
-  ~perform_io_cleanup_on_block_exit()
-  {
-    if (first_op_)
-    {
-      // Post the remaining completed operations for invocation.
-      if (!ops_.empty())
-        reactor_->io_service_.post_deferred_completions(ops_);
-
-      // A user-initiated operation has completed, but there's no need to
-      // explicitly call work_finished() here. Instead, we'll take advantage of
-      // the fact that the task_io_service will call work_finished() once we
-      // return.
-    }
-    else
-    {
-      // No user-initiated operations have completed, so we need to compensate
-      // for the work_finished() call that the task_io_service will make once
-      // this operation returns.
-      reactor_->io_service_.work_started();
-    }
-  }
-
-  epoll_reactor* reactor_;
-  op_queue<operation> ops_;
-  operation* first_op_;
-};
-
-epoll_reactor::descriptor_state::descriptor_state()
-  : operation(&epoll_reactor::descriptor_state::do_complete)
-{
-}
-
-operation* epoll_reactor::descriptor_state::perform_io(uint32_t events)
-{
-  mutex_.lock();
-  perform_io_cleanup_on_block_exit io_cleanup(reactor_);
-  mutex::scoped_lock descriptor_lock(mutex_, mutex::scoped_lock::adopt_lock);
-
-  // Exception operations must be processed first to ensure that any
-  // out-of-band data is read before normal data.
-  static const int flag[max_ops] = { EPOLLIN, EPOLLOUT, EPOLLPRI };
-  for (int j = max_ops - 1; j >= 0; --j)
-  {
-    if (events & (flag[j] | EPOLLERR | EPOLLHUP))
-    {
-      while (reactor_op* op = op_queue_[j].front())
-      {
-        if (op->perform())
-        {
-          op_queue_[j].pop();
-          io_cleanup.ops_.push(op);
-        }
-        else
-          break;
-      }
-    }
-  }
-
-  // The first operation will be returned for completion now. The others will
-  // be posted for later by the io_cleanup object's destructor.
-  io_cleanup.first_op_ = io_cleanup.ops_.front();
-  io_cleanup.ops_.pop();
-  return io_cleanup.first_op_;
-}
-
-void epoll_reactor::descriptor_state::do_complete(
-    io_service_impl* owner, operation* base,
-    const asio::error_code& ec, std::size_t bytes_transferred)
-{
-  if (owner)
-  {
-    descriptor_state* descriptor_data = static_cast<descriptor_state*>(base);
-    uint32_t events = static_cast<uint32_t>(bytes_transferred);
-    if (operation* op = descriptor_data->perform_io(events))
-    {
-      op->complete(*owner, ec, 0);
-    }
-  }
-}
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // defined(ASIO_HAS_EPOLL)
-
-#endif // ASIO_DETAIL_IMPL_EPOLL_REACTOR_IPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/eventfd_select_interrupter.ipp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/eventfd_select_interrupter.ipp
deleted file mode 100644
index 351c488a6f5a..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/eventfd_select_interrupter.ipp
+++ /dev/null
@@ -1,165 +0,0 @@
-//
-// detail/impl/eventfd_select_interrupter.ipp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-// Copyright (c) 2008 Roelof Naude (roelof.naude at gmail dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_IMPL_EVENTFD_SELECT_INTERRUPTER_IPP
-#define ASIO_DETAIL_IMPL_EVENTFD_SELECT_INTERRUPTER_IPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_HAS_EVENTFD)
-
-#include <sys/stat.h>
-#include <sys/types.h>
-#include <fcntl.h>
-#if __GLIBC__ == 2 && __GLIBC_MINOR__ < 8
-# include <asm/unistd.h>
-#else // __GLIBC__ == 2 && __GLIBC_MINOR__ < 8
-# include <sys/eventfd.h>
-#endif // __GLIBC__ == 2 && __GLIBC_MINOR__ < 8
-#include "asio/detail/cstdint.hpp"
-#include "asio/detail/eventfd_select_interrupter.hpp"
-#include "asio/detail/throw_error.hpp"
-#include "asio/error.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-eventfd_select_interrupter::eventfd_select_interrupter()
-{
-  open_descriptors();
-}
-
-void eventfd_select_interrupter::open_descriptors()
-{
-#if __GLIBC__ == 2 && __GLIBC_MINOR__ < 8
-  write_descriptor_ = read_descriptor_ = syscall(__NR_eventfd, 0);
-  if (read_descriptor_ != -1)
-  {
-    ::fcntl(read_descriptor_, F_SETFL, O_NONBLOCK);
-    ::fcntl(read_descriptor_, F_SETFD, FD_CLOEXEC);
-  }
-#else // __GLIBC__ == 2 && __GLIBC_MINOR__ < 8
-# if defined(EFD_CLOEXEC) && defined(EFD_NONBLOCK)
-  write_descriptor_ = read_descriptor_ =
-    ::eventfd(0, EFD_CLOEXEC | EFD_NONBLOCK);
-# else // defined(EFD_CLOEXEC) && defined(EFD_NONBLOCK)
-  errno = EINVAL;
-  write_descriptor_ = read_descriptor_ = -1;
-# endif // defined(EFD_CLOEXEC) && defined(EFD_NONBLOCK)
-  if (read_descriptor_ == -1 && errno == EINVAL)
-  {
-    write_descriptor_ = read_descriptor_ = ::eventfd(0, 0);
-    if (read_descriptor_ != -1)
-    {
-      ::fcntl(read_descriptor_, F_SETFL, O_NONBLOCK);
-      ::fcntl(read_descriptor_, F_SETFD, FD_CLOEXEC);
-    }
-  }
-#endif // __GLIBC__ == 2 && __GLIBC_MINOR__ < 8
-
-  if (read_descriptor_ == -1)
-  {
-    int pipe_fds[2];
-    if (pipe(pipe_fds) == 0)
-    {
-      read_descriptor_ = pipe_fds[0];
-      ::fcntl(read_descriptor_, F_SETFL, O_NONBLOCK);
-      ::fcntl(read_descriptor_, F_SETFD, FD_CLOEXEC);
-      write_descriptor_ = pipe_fds[1];
-      ::fcntl(write_descriptor_, F_SETFL, O_NONBLOCK);
-      ::fcntl(write_descriptor_, F_SETFD, FD_CLOEXEC);
-    }
-    else
-    {
-      asio::error_code ec(errno,
-          asio::error::get_system_category());
-      asio::detail::throw_error(ec, "eventfd_select_interrupter");
-    }
-  }
-}
-
-eventfd_select_interrupter::~eventfd_select_interrupter()
-{
-  close_descriptors();
-}
-
-void eventfd_select_interrupter::close_descriptors()
-{
-  if (write_descriptor_ != -1 && write_descriptor_ != read_descriptor_)
-    ::close(write_descriptor_);
-  if (read_descriptor_ != -1)
-    ::close(read_descriptor_);
-}
-
-void eventfd_select_interrupter::recreate()
-{
-  close_descriptors();
-
-  write_descriptor_ = -1;
-  read_descriptor_ = -1;
-
-  open_descriptors();
-}
-
-void eventfd_select_interrupter::interrupt()
-{
-  uint64_t counter(1UL);
-  int result = ::write(write_descriptor_, &counter, sizeof(uint64_t));
-  (void)result;
-}
-
-bool eventfd_select_interrupter::reset()
-{
-  if (write_descriptor_ == read_descriptor_)
-  {
-    for (;;)
-    {
-      // Only perform one read. The kernel maintains an atomic counter.
-      uint64_t counter(0);
-      errno = 0;
-      int bytes_read = ::read(read_descriptor_, &counter, sizeof(uint64_t));
-      if (bytes_read < 0 && errno == EINTR)
-        continue;
-      bool was_interrupted = (bytes_read > 0);
-      return was_interrupted;
-    }
-  }
-  else
-  {
-    for (;;)
-    {
-      // Clear all data from the pipe.
-      char data[1024];
-      int bytes_read = ::read(read_descriptor_, data, sizeof(data));
-      if (bytes_read < 0 && errno == EINTR)
-        continue;
-      bool was_interrupted = (bytes_read > 0);
-      while (bytes_read == sizeof(data))
-        bytes_read = ::read(read_descriptor_, data, sizeof(data));
-      return was_interrupted;
-    }
-  }
-}
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // defined(ASIO_HAS_EVENTFD)
-
-#endif // ASIO_DETAIL_IMPL_EVENTFD_SELECT_INTERRUPTER_IPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/handler_tracking.ipp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/handler_tracking.ipp
deleted file mode 100644
index e588582c2c1f..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/handler_tracking.ipp
+++ /dev/null
@@ -1,305 +0,0 @@
-//
-// detail/impl/handler_tracking.ipp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_IMPL_HANDLER_TRACKING_IPP
-#define ASIO_DETAIL_IMPL_HANDLER_TRACKING_IPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_ENABLE_HANDLER_TRACKING)
-
-#include <cstdarg>
-#include <cstdio>
-#include "asio/detail/handler_tracking.hpp"
-
-#if defined(ASIO_HAS_BOOST_DATE_TIME)
-# include "asio/time_traits.hpp"
-#else // defined(ASIO_HAS_BOOST_DATE_TIME)
-# if defined(ASIO_HAS_STD_CHRONO)
-#  include <chrono>
-# elif defined(ASIO_HAS_BOOST_CHRONO)
-#  include <boost/chrono/system_clocks.hpp>
-# endif
-# include "asio/detail/chrono_time_traits.hpp"
-# include "asio/wait_traits.hpp"
-#endif // defined(ASIO_HAS_BOOST_DATE_TIME)
-
-#if !defined(ASIO_WINDOWS)
-# include <unistd.h>
-#endif // !defined(ASIO_WINDOWS)
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-struct handler_tracking_timestamp
-{
-  uint64_t seconds;
-  uint64_t microseconds;
-
-  handler_tracking_timestamp()
-  {
-#if defined(ASIO_HAS_BOOST_DATE_TIME)
-    boost::posix_time::ptime epoch(boost::gregorian::date(1970, 1, 1));
-    boost::posix_time::time_duration now =
-      boost::posix_time::microsec_clock::universal_time() - epoch;
-#elif defined(ASIO_HAS_STD_CHRONO)
-    typedef chrono_time_traits<std::chrono::system_clock,
-        asio::wait_traits<std::chrono::system_clock> > traits_helper;
-    traits_helper::posix_time_duration now(
-        std::chrono::system_clock::now().time_since_epoch());
-#elif defined(ASIO_HAS_BOOST_CHRONO)
-    typedef chrono_time_traits<boost::chrono::system_clock,
-        asio::wait_traits<boost::chrono::system_clock> > traits_helper;
-    traits_helper::posix_time_duration now(
-        boost::chrono::system_clock::now().time_since_epoch());
-#endif
-    seconds = static_cast<uint64_t>(now.total_seconds());
-    microseconds = static_cast<uint64_t>(now.total_microseconds() % 1000000);
-  }
-};
-
-struct handler_tracking::tracking_state
-{
-  static_mutex mutex_;
-  uint64_t next_id_;
-  tss_ptr<completion>* current_completion_;
-};
-
-handler_tracking::tracking_state* handler_tracking::get_state()
-{
-  static tracking_state state = { ASIO_STATIC_MUTEX_INIT, 1, 0 };
-  return &state;
-}
-
-void handler_tracking::init()
-{
-  static tracking_state* state = get_state();
-
-  state->mutex_.init();
-
-  static_mutex::scoped_lock lock(state->mutex_);
-  if (state->current_completion_ == 0)
-    state->current_completion_ = new tss_ptr<completion>;
-}
-
-void handler_tracking::creation(handler_tracking::tracked_handler* h,
-    const char* object_type, void* object, const char* op_name)
-{
-  static tracking_state* state = get_state();
-
-  static_mutex::scoped_lock lock(state->mutex_);
-  h->id_ = state->next_id_++;
-  lock.unlock();
-
-  handler_tracking_timestamp timestamp;
-
-  uint64_t current_id = 0;
-  if (completion* current_completion = *state->current_completion_)
-    current_id = current_completion->id_;
-
-  write_line(
-#if defined(ASIO_WINDOWS)
-      "@asio|%I64u.%06I64u|%I64u*%I64u|%.20s@%p.%.50s\n",
-#else // defined(ASIO_WINDOWS)
-      "@asio|%llu.%06llu|%llu*%llu|%.20s@%p.%.50s\n",
-#endif // defined(ASIO_WINDOWS)
-      timestamp.seconds, timestamp.microseconds,
-      current_id, h->id_, object_type, object, op_name);
-}
-
-handler_tracking::completion::completion(handler_tracking::tracked_handler* h)
-  : id_(h->id_),
-    invoked_(false),
-    next_(*get_state()->current_completion_)
-{
-  *get_state()->current_completion_ = this;
-}
-
-handler_tracking::completion::~completion()
-{
-  if (id_)
-  {
-    handler_tracking_timestamp timestamp;
-
-    write_line(
-#if defined(ASIO_WINDOWS)
-        "@asio|%I64u.%06I64u|%c%I64u|\n",
-#else // defined(ASIO_WINDOWS)
-        "@asio|%llu.%06llu|%c%llu|\n",
-#endif // defined(ASIO_WINDOWS)
-        timestamp.seconds, timestamp.microseconds,
-        invoked_ ? '!' : '~', id_);
-  }
-
-  *get_state()->current_completion_ = next_;
-}
-
-void handler_tracking::completion::invocation_begin()
-{
-  handler_tracking_timestamp timestamp;
-
-  write_line(
-#if defined(ASIO_WINDOWS)
-      "@asio|%I64u.%06I64u|>%I64u|\n",
-#else // defined(ASIO_WINDOWS)
-      "@asio|%llu.%06llu|>%llu|\n",
-#endif // defined(ASIO_WINDOWS)
-      timestamp.seconds, timestamp.microseconds, id_);
-
-  invoked_ = true;
-}
-
-void handler_tracking::completion::invocation_begin(
-    const asio::error_code& ec)
-{
-  handler_tracking_timestamp timestamp;
-
-  write_line(
-#if defined(ASIO_WINDOWS)
-      "@asio|%I64u.%06I64u|>%I64u|ec=%.20s:%d\n",
-#else // defined(ASIO_WINDOWS)
-      "@asio|%llu.%06llu|>%llu|ec=%.20s:%d\n",
-#endif // defined(ASIO_WINDOWS)
-      timestamp.seconds, timestamp.microseconds,
-      id_, ec.category().name(), ec.value());
-
-  invoked_ = true;
-}
-
-void handler_tracking::completion::invocation_begin(
-    const asio::error_code& ec, std::size_t bytes_transferred)
-{
-  handler_tracking_timestamp timestamp;
-
-  write_line(
-#if defined(ASIO_WINDOWS)
-      "@asio|%I64u.%06I64u|>%I64u|ec=%.20s:%d,bytes_transferred=%I64u\n",
-#else // defined(ASIO_WINDOWS)
-      "@asio|%llu.%06llu|>%llu|ec=%.20s:%d,bytes_transferred=%llu\n",
-#endif // defined(ASIO_WINDOWS)
-      timestamp.seconds, timestamp.microseconds,
-      id_, ec.category().name(), ec.value(),
-      static_cast<uint64_t>(bytes_transferred));
-
-  invoked_ = true;
-}
-
-void handler_tracking::completion::invocation_begin(
-    const asio::error_code& ec, int signal_number)
-{
-  handler_tracking_timestamp timestamp;
-
-  write_line(
-#if defined(ASIO_WINDOWS)
-      "@asio|%I64u.%06I64u|>%I64u|ec=%.20s:%d,signal_number=%d\n",
-#else // defined(ASIO_WINDOWS)
-      "@asio|%llu.%06llu|>%llu|ec=%.20s:%d,signal_number=%d\n",
-#endif // defined(ASIO_WINDOWS)
-      timestamp.seconds, timestamp.microseconds,
-      id_, ec.category().name(), ec.value(), signal_number);
-
-  invoked_ = true;
-}
-
-void handler_tracking::completion::invocation_begin(
-    const asio::error_code& ec, const char* arg)
-{
-  handler_tracking_timestamp timestamp;
-
-  write_line(
-#if defined(ASIO_WINDOWS)
-      "@asio|%I64u.%06I64u|>%I64u|ec=%.20s:%d,%.50s\n",
-#else // defined(ASIO_WINDOWS)
-      "@asio|%llu.%06llu|>%llu|ec=%.20s:%d,%.50s\n",
-#endif // defined(ASIO_WINDOWS)
-      timestamp.seconds, timestamp.microseconds,
-      id_, ec.category().name(), ec.value(), arg);
-
-  invoked_ = true;
-}
-
-void handler_tracking::completion::invocation_end()
-{
-  if (id_)
-  {
-    handler_tracking_timestamp timestamp;
-
-    write_line(
-#if defined(ASIO_WINDOWS)
-        "@asio|%I64u.%06I64u|<%I64u|\n",
-#else // defined(ASIO_WINDOWS)
-        "@asio|%llu.%06llu|<%llu|\n",
-#endif // defined(ASIO_WINDOWS)
-        timestamp.seconds, timestamp.microseconds, id_);
-
-    id_ = 0;
-  }
-}
-
-void handler_tracking::operation(const char* object_type,
-    void* object, const char* op_name)
-{
-  static tracking_state* state = get_state();
-
-  handler_tracking_timestamp timestamp;
-
-  unsigned long long current_id = 0;
-  if (completion* current_completion = *state->current_completion_)
-    current_id = current_completion->id_;
-
-  write_line(
-#if defined(ASIO_WINDOWS)
-      "@asio|%I64u.%06I64u|%I64u|%.20s@%p.%.50s\n",
-#else // defined(ASIO_WINDOWS)
-      "@asio|%llu.%06llu|%llu|%.20s@%p.%.50s\n",
-#endif // defined(ASIO_WINDOWS)
-      timestamp.seconds, timestamp.microseconds,
-      current_id, object_type, object, op_name);
-}
-
-void handler_tracking::write_line(const char* format, ...)
-{
-  using namespace std; // For sprintf (or equivalent).
-
-  va_list args;
-  va_start(args, format);
-
-  char line[256] = "";
-#if defined(ASIO_HAS_SECURE_RTL)
-  int length = vsprintf_s(line, sizeof(line), format, args);
-#else // defined(ASIO_HAS_SECURE_RTL)
-  int length = vsprintf(line, format, args);
-#endif // defined(ASIO_HAS_SECURE_RTL)
-
-  va_end(args);
-
-#if defined(ASIO_WINDOWS)
-  HANDLE stderr_handle = ::GetStdHandle(STD_ERROR_HANDLE);
-  DWORD bytes_written = 0;
-  ::WriteFile(stderr_handle, line, length, &bytes_written, 0);
-#else // defined(ASIO_WINDOWS)
-  ::write(STDERR_FILENO, line, length);
-#endif // defined(ASIO_WINDOWS)
-}
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // defined(ASIO_ENABLE_HANDLER_TRACKING)
-
-#endif // ASIO_DETAIL_IMPL_HANDLER_TRACKING_IPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/kqueue_reactor.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/kqueue_reactor.hpp
deleted file mode 100644
index 1146017b8473..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/kqueue_reactor.hpp
+++ /dev/null
@@ -1,80 +0,0 @@
-//
-// detail/impl/kqueue_reactor.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-// Copyright (c) 2005 Stefan Arentz (stefan at soze dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_IMPL_KQUEUE_REACTOR_HPP
-#define ASIO_DETAIL_IMPL_KQUEUE_REACTOR_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_HAS_KQUEUE)
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-template <typename Time_Traits>
-void kqueue_reactor::add_timer_queue(timer_queue<Time_Traits>& queue)
-{
-  do_add_timer_queue(queue);
-}
-
-// Remove a timer queue from the reactor.
-template <typename Time_Traits>
-void kqueue_reactor::remove_timer_queue(timer_queue<Time_Traits>& queue)
-{
-  do_remove_timer_queue(queue);
-}
-
-template <typename Time_Traits>
-void kqueue_reactor::schedule_timer(timer_queue<Time_Traits>& queue,
-    const typename Time_Traits::time_type& time,
-    typename timer_queue<Time_Traits>::per_timer_data& timer, wait_op* op)
-{
-  asio::detail::mutex::scoped_lock lock(mutex_);
-
-  if (shutdown_)
-  {
-    io_service_.post_immediate_completion(op, false);
-    return;
-  }
-
-  bool earliest = queue.enqueue_timer(time, timer, op);
-  io_service_.work_started();
-  if (earliest)
-    interrupt();
-}
-
-template <typename Time_Traits>
-std::size_t kqueue_reactor::cancel_timer(timer_queue<Time_Traits>& queue,
-    typename timer_queue<Time_Traits>::per_timer_data& timer,
-    std::size_t max_cancelled)
-{
-  asio::detail::mutex::scoped_lock lock(mutex_);
-  op_queue<operation> ops;
-  std::size_t n = queue.cancel_timer(timer, ops, max_cancelled);
-  lock.unlock();
-  io_service_.post_deferred_completions(ops);
-  return n;
-}
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // defined(ASIO_HAS_KQUEUE)
-
-#endif // ASIO_DETAIL_IMPL_KQUEUE_REACTOR_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/kqueue_reactor.ipp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/kqueue_reactor.ipp
deleted file mode 100644
index 5e65a0c87464..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/kqueue_reactor.ipp
+++ /dev/null
@@ -1,463 +0,0 @@
-//
-// detail/impl/kqueue_reactor.ipp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-// Copyright (c) 2005 Stefan Arentz (stefan at soze dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_IMPL_KQUEUE_REACTOR_IPP
-#define ASIO_DETAIL_IMPL_KQUEUE_REACTOR_IPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_HAS_KQUEUE)
-
-#include "asio/detail/kqueue_reactor.hpp"
-#include "asio/detail/throw_error.hpp"
-#include "asio/error.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-#if defined(__NetBSD__)
-# define ASIO_KQUEUE_EV_SET(ev, ident, filt, flags, fflags, data, udata) \
-    EV_SET(ev, ident, filt, flags, fflags, data, \
-      reinterpret_cast<intptr_t>(static_cast<void*>(udata)))
-#else
-# define ASIO_KQUEUE_EV_SET(ev, ident, filt, flags, fflags, data, udata) \
-    EV_SET(ev, ident, filt, flags, fflags, data, udata)
-#endif
-
-namespace asio {
-namespace detail {
-
-kqueue_reactor::kqueue_reactor(asio::io_service& io_service)
-  : asio::detail::service_base<kqueue_reactor>(io_service),
-    io_service_(use_service<io_service_impl>(io_service)),
-    mutex_(),
-    kqueue_fd_(do_kqueue_create()),
-    interrupter_(),
-    shutdown_(false)
-{
-  struct kevent event;
-  ASIO_KQUEUE_EV_SET(&event, interrupter_.read_descriptor(),
-      EVFILT_READ, EV_ADD | EV_CLEAR, 0, 0, &interrupter_);
-  if (::kevent(kqueue_fd_, &event, 1, 0, 0, 0) == -1)
-  {
-    asio::error_code error(errno,
-        asio::error::get_system_category());
-    asio::detail::throw_error(error);
-  }
-}
-
-kqueue_reactor::~kqueue_reactor()
-{
-  close(kqueue_fd_);
-}
-
-void kqueue_reactor::shutdown_service()
-{
-  mutex::scoped_lock lock(mutex_);
-  shutdown_ = true;
-  lock.unlock();
-
-  op_queue<operation> ops;
-
-  while (descriptor_state* state = registered_descriptors_.first())
-  {
-    for (int i = 0; i < max_ops; ++i)
-      ops.push(state->op_queue_[i]);
-    state->shutdown_ = true;
-    registered_descriptors_.free(state);
-  }
-
-  timer_queues_.get_all_timers(ops);
-
-  io_service_.abandon_operations(ops);
-}
-
-void kqueue_reactor::fork_service(asio::io_service::fork_event fork_ev)
-{
-  if (fork_ev == asio::io_service::fork_child)
-  {
-    // The kqueue descriptor is automatically closed in the child.
-    kqueue_fd_ = -1;
-    kqueue_fd_ = do_kqueue_create();
-
-    interrupter_.recreate();
-
-    struct kevent event;
-    ASIO_KQUEUE_EV_SET(&event, interrupter_.read_descriptor(),
-        EVFILT_READ, EV_ADD | EV_CLEAR, 0, 0, &interrupter_);
-    if (::kevent(kqueue_fd_, &event, 1, 0, 0, 0) == -1)
-    {
-      asio::error_code error(errno,
-          asio::error::get_system_category());
-      asio::detail::throw_error(error);
-    }
-
-    // Re-register all descriptors with kqueue.
-    mutex::scoped_lock descriptors_lock(registered_descriptors_mutex_);
-    for (descriptor_state* state = registered_descriptors_.first();
-        state != 0; state = state->next_)
-    {
-      struct kevent events[2];
-      ASIO_KQUEUE_EV_SET(&events[0], state->descriptor_,
-          EVFILT_READ, EV_ADD | EV_CLEAR, 0, 0, state);
-      ASIO_KQUEUE_EV_SET(&events[1], state->descriptor_,
-          EVFILT_WRITE, EV_ADD | EV_CLEAR, 0, 0, state);
-      if (::kevent(kqueue_fd_, events, 2, 0, 0, 0) == -1)
-      {
-        asio::error_code error(errno,
-            asio::error::get_system_category());
-        asio::detail::throw_error(error);
-      }
-    }
-  }
-}
-
-void kqueue_reactor::init_task()
-{
-  io_service_.init_task();
-}
-
-int kqueue_reactor::register_descriptor(socket_type descriptor,
-    kqueue_reactor::per_descriptor_data& descriptor_data)
-{
-  descriptor_data = allocate_descriptor_state();
-
-  mutex::scoped_lock lock(descriptor_data->mutex_);
-
-  descriptor_data->descriptor_ = descriptor;
-  descriptor_data->shutdown_ = false;
-
-  struct kevent events[2];
-  ASIO_KQUEUE_EV_SET(&events[0], descriptor, EVFILT_READ,
-      EV_ADD | EV_CLEAR, 0, 0, descriptor_data);
-  ASIO_KQUEUE_EV_SET(&events[1], descriptor, EVFILT_WRITE,
-      EV_ADD | EV_CLEAR, 0, 0, descriptor_data);
-  if (::kevent(kqueue_fd_, events, 2, 0, 0, 0) == -1)
-    return errno;
-
-  return 0;
-}
-
-int kqueue_reactor::register_internal_descriptor(
-    int op_type, socket_type descriptor,
-    kqueue_reactor::per_descriptor_data& descriptor_data, reactor_op* op)
-{
-  descriptor_data = allocate_descriptor_state();
-
-  mutex::scoped_lock lock(descriptor_data->mutex_);
-
-  descriptor_data->descriptor_ = descriptor;
-  descriptor_data->shutdown_ = false;
-  descriptor_data->op_queue_[op_type].push(op);
-
-  struct kevent events[2];
-  ASIO_KQUEUE_EV_SET(&events[0], descriptor, EVFILT_READ,
-      EV_ADD | EV_CLEAR, 0, 0, descriptor_data);
-  ASIO_KQUEUE_EV_SET(&events[1], descriptor, EVFILT_WRITE,
-      EV_ADD | EV_CLEAR, 0, 0, descriptor_data);
-  if (::kevent(kqueue_fd_, events, 2, 0, 0, 0) == -1)
-    return errno;
-
-  return 0;
-}
-
-void kqueue_reactor::move_descriptor(socket_type,
-    kqueue_reactor::per_descriptor_data& target_descriptor_data,
-    kqueue_reactor::per_descriptor_data& source_descriptor_data)
-{
-  target_descriptor_data = source_descriptor_data;
-  source_descriptor_data = 0;
-}
-
-void kqueue_reactor::start_op(int op_type, socket_type descriptor,
-    kqueue_reactor::per_descriptor_data& descriptor_data, reactor_op* op,
-    bool is_continuation, bool allow_speculative)
-{
-  if (!descriptor_data)
-  {
-    op->ec_ = asio::error::bad_descriptor;
-    post_immediate_completion(op, is_continuation);
-    return;
-  }
-
-  mutex::scoped_lock descriptor_lock(descriptor_data->mutex_);
-
-  if (descriptor_data->shutdown_)
-  {
-    post_immediate_completion(op, is_continuation);
-    return;
-  }
-
-  bool first = descriptor_data->op_queue_[op_type].empty();
-  if (first)
-  {
-    if (allow_speculative
-        && (op_type != read_op
-          || descriptor_data->op_queue_[except_op].empty()))
-    {
-      if (op->perform())
-      {
-        descriptor_lock.unlock();
-        io_service_.post_immediate_completion(op, is_continuation);
-        return;
-      }
-    }
-    else
-    {
-      struct kevent events[2];
-      ASIO_KQUEUE_EV_SET(&events[0], descriptor, EVFILT_READ,
-          EV_ADD | EV_CLEAR, 0, 0, descriptor_data);
-      ASIO_KQUEUE_EV_SET(&events[1], descriptor, EVFILT_WRITE,
-          EV_ADD | EV_CLEAR, 0, 0, descriptor_data);
-      ::kevent(kqueue_fd_, events, 2, 0, 0, 0);
-    }
-  }
-
-  descriptor_data->op_queue_[op_type].push(op);
-  io_service_.work_started();
-}
-
-void kqueue_reactor::cancel_ops(socket_type,
-    kqueue_reactor::per_descriptor_data& descriptor_data)
-{
-  if (!descriptor_data)
-    return;
-
-  mutex::scoped_lock descriptor_lock(descriptor_data->mutex_);
-
-  op_queue<operation> ops;
-  for (int i = 0; i < max_ops; ++i)
-  {
-    while (reactor_op* op = descriptor_data->op_queue_[i].front())
-    {
-      op->ec_ = asio::error::operation_aborted;
-      descriptor_data->op_queue_[i].pop();
-      ops.push(op);
-    }
-  }
-
-  descriptor_lock.unlock();
-
-  io_service_.post_deferred_completions(ops);
-}
-
-void kqueue_reactor::deregister_descriptor(socket_type descriptor,
-    kqueue_reactor::per_descriptor_data& descriptor_data, bool closing)
-{
-  if (!descriptor_data)
-    return;
-
-  mutex::scoped_lock descriptor_lock(descriptor_data->mutex_);
-
-  if (!descriptor_data->shutdown_)
-  {
-    if (closing)
-    {
-      // The descriptor will be automatically removed from the kqueue when it
-      // is closed.
-    }
-    else
-    {
-      struct kevent events[2];
-      ASIO_KQUEUE_EV_SET(&events[0], descriptor,
-          EVFILT_READ, EV_DELETE, 0, 0, 0);
-      ASIO_KQUEUE_EV_SET(&events[1], descriptor,
-          EVFILT_WRITE, EV_DELETE, 0, 0, 0);
-      ::kevent(kqueue_fd_, events, 2, 0, 0, 0);
-    }
-
-    op_queue<operation> ops;
-    for (int i = 0; i < max_ops; ++i)
-    {
-      while (reactor_op* op = descriptor_data->op_queue_[i].front())
-      {
-        op->ec_ = asio::error::operation_aborted;
-        descriptor_data->op_queue_[i].pop();
-        ops.push(op);
-      }
-    }
-
-    descriptor_data->descriptor_ = -1;
-    descriptor_data->shutdown_ = true;
-
-    descriptor_lock.unlock();
-
-    free_descriptor_state(descriptor_data);
-    descriptor_data = 0;
-
-    io_service_.post_deferred_completions(ops);
-  }
-}
-
-void kqueue_reactor::deregister_internal_descriptor(socket_type descriptor,
-    kqueue_reactor::per_descriptor_data& descriptor_data)
-{
-  if (!descriptor_data)
-    return;
-
-  mutex::scoped_lock descriptor_lock(descriptor_data->mutex_);
-
-  if (!descriptor_data->shutdown_)
-  {
-    struct kevent events[2];
-    ASIO_KQUEUE_EV_SET(&events[0], descriptor,
-        EVFILT_READ, EV_DELETE, 0, 0, 0);
-    ASIO_KQUEUE_EV_SET(&events[1], descriptor,
-        EVFILT_WRITE, EV_DELETE, 0, 0, 0);
-    ::kevent(kqueue_fd_, events, 2, 0, 0, 0);
-
-    op_queue<operation> ops;
-    for (int i = 0; i < max_ops; ++i)
-      ops.push(descriptor_data->op_queue_[i]);
-
-    descriptor_data->descriptor_ = -1;
-    descriptor_data->shutdown_ = true;
-
-    descriptor_lock.unlock();
-
-    free_descriptor_state(descriptor_data);
-    descriptor_data = 0;
-  }
-}
-
-void kqueue_reactor::run(bool block, op_queue<operation>& ops)
-{
-  mutex::scoped_lock lock(mutex_);
-
-  // Determine how long to block while waiting for events.
-  timespec timeout_buf = { 0, 0 };
-  timespec* timeout = block ? get_timeout(timeout_buf) : &timeout_buf;
-
-  lock.unlock();
-
-  // Block on the kqueue descriptor.
-  struct kevent events[128];
-  int num_events = kevent(kqueue_fd_, 0, 0, events, 128, timeout);
-
-  // Dispatch the waiting events.
-  for (int i = 0; i < num_events; ++i)
-  {
-    void* ptr = reinterpret_cast<void*>(events[i].udata);
-    if (ptr == &interrupter_)
-    {
-      interrupter_.reset();
-    }
-    else
-    {
-      descriptor_state* descriptor_data = static_cast<descriptor_state*>(ptr);
-      mutex::scoped_lock descriptor_lock(descriptor_data->mutex_);
-
-      // Exception operations must be processed first to ensure that any
-      // out-of-band data is read before normal data.
-#if defined(__NetBSD__)
-      static const unsigned int filter[max_ops] =
-#else
-      static const int filter[max_ops] =
-#endif
-        { EVFILT_READ, EVFILT_WRITE, EVFILT_READ };
-      for (int j = max_ops - 1; j >= 0; --j)
-      {
-        if (events[i].filter == filter[j])
-        {
-          if (j != except_op || events[i].flags & EV_OOBAND)
-          {
-            while (reactor_op* op = descriptor_data->op_queue_[j].front())
-            {
-              if (events[i].flags & EV_ERROR)
-              {
-                op->ec_ = asio::error_code(
-                    static_cast<int>(events[i].data),
-                    asio::error::get_system_category());
-                descriptor_data->op_queue_[j].pop();
-                ops.push(op);
-              }
-              if (op->perform())
-              {
-                descriptor_data->op_queue_[j].pop();
-                ops.push(op);
-              }
-              else
-                break;
-            }
-          }
-        }
-      }
-    }
-  }
-
-  lock.lock();
-  timer_queues_.get_ready_timers(ops);
-}
-
-void kqueue_reactor::interrupt()
-{
-  interrupter_.interrupt();
-}
-
-int kqueue_reactor::do_kqueue_create()
-{
-  int fd = ::kqueue();
-  if (fd == -1)
-  {
-    asio::error_code ec(errno,
-        asio::error::get_system_category());
-    asio::detail::throw_error(ec, "kqueue");
-  }
-  return fd;
-}
-
-kqueue_reactor::descriptor_state* kqueue_reactor::allocate_descriptor_state()
-{
-  mutex::scoped_lock descriptors_lock(registered_descriptors_mutex_);
-  return registered_descriptors_.alloc();
-}
-
-void kqueue_reactor::free_descriptor_state(kqueue_reactor::descriptor_state* s)
-{
-  mutex::scoped_lock descriptors_lock(registered_descriptors_mutex_);
-  registered_descriptors_.free(s);
-}
-
-void kqueue_reactor::do_add_timer_queue(timer_queue_base& queue)
-{
-  mutex::scoped_lock lock(mutex_);
-  timer_queues_.insert(&queue);
-}
-
-void kqueue_reactor::do_remove_timer_queue(timer_queue_base& queue)
-{
-  mutex::scoped_lock lock(mutex_);
-  timer_queues_.erase(&queue);
-}
-
-timespec* kqueue_reactor::get_timeout(timespec& ts)
-{
-  // By default we will wait no longer than 5 minutes. This will ensure that
-  // any changes to the system clock are detected after no longer than this.
-  long usec = timer_queues_.wait_duration_usec(5 * 60 * 1000 * 1000);
-  ts.tv_sec = usec / 1000000;
-  ts.tv_nsec = (usec % 1000000) * 1000;
-  return &ts;
-}
-
-} // namespace detail
-} // namespace asio
-
-#undef ASIO_KQUEUE_EV_SET
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // defined(ASIO_HAS_KQUEUE)
-
-#endif // ASIO_DETAIL_IMPL_KQUEUE_REACTOR_IPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/pipe_select_interrupter.ipp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/pipe_select_interrupter.ipp
deleted file mode 100644
index 192f251720da..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/pipe_select_interrupter.ipp
+++ /dev/null
@@ -1,124 +0,0 @@
-//
-// detail/impl/pipe_select_interrupter.ipp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_IMPL_PIPE_SELECT_INTERRUPTER_IPP
-#define ASIO_DETAIL_IMPL_PIPE_SELECT_INTERRUPTER_IPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if !defined(ASIO_WINDOWS_RUNTIME)
-#if !defined(ASIO_WINDOWS)
-#if !defined(__CYGWIN__)
-#if !defined(__SYMBIAN32__)
-#if !defined(ASIO_HAS_EVENTFD)
-
-#include <fcntl.h>
-#include <sys/stat.h>
-#include <sys/types.h>
-#include <unistd.h>
-#include "asio/detail/pipe_select_interrupter.hpp"
-#include "asio/detail/socket_types.hpp"
-#include "asio/detail/throw_error.hpp"
-#include "asio/error.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-pipe_select_interrupter::pipe_select_interrupter()
-{
-  open_descriptors();
-}
-
-void pipe_select_interrupter::open_descriptors()
-{
-  int pipe_fds[2];
-  if (pipe(pipe_fds) == 0)
-  {
-    read_descriptor_ = pipe_fds[0];
-    ::fcntl(read_descriptor_, F_SETFL, O_NONBLOCK);
-    write_descriptor_ = pipe_fds[1];
-    ::fcntl(write_descriptor_, F_SETFL, O_NONBLOCK);
-
-#if defined(FD_CLOEXEC)
-    ::fcntl(read_descriptor_, F_SETFD, FD_CLOEXEC);
-    ::fcntl(write_descriptor_, F_SETFD, FD_CLOEXEC);
-#endif // defined(FD_CLOEXEC)
-  }
-  else
-  {
-    asio::error_code ec(errno,
-        asio::error::get_system_category());
-    asio::detail::throw_error(ec, "pipe_select_interrupter");
-  }
-}
-
-pipe_select_interrupter::~pipe_select_interrupter()
-{
-  close_descriptors();
-}
-
-void pipe_select_interrupter::close_descriptors()
-{
-  if (read_descriptor_ != -1)
-    ::close(read_descriptor_);
-  if (write_descriptor_ != -1)
-    ::close(write_descriptor_);
-}
-
-void pipe_select_interrupter::recreate()
-{
-  close_descriptors();
-
-  write_descriptor_ = -1;
-  read_descriptor_ = -1;
-
-  open_descriptors();
-}
-
-void pipe_select_interrupter::interrupt()
-{
-  char byte = 0;
-  signed_size_type result = ::write(write_descriptor_, &byte, 1);
-  (void)result;
-}
-
-bool pipe_select_interrupter::reset()
-{
-  for (;;)
-  {
-    char data[1024];
-    signed_size_type bytes_read = ::read(read_descriptor_, data, sizeof(data));
-    if (bytes_read < 0 && errno == EINTR)
-      continue;
-    bool was_interrupted = (bytes_read > 0);
-    while (bytes_read == sizeof(data))
-      bytes_read = ::read(read_descriptor_, data, sizeof(data));
-    return was_interrupted;
-  }
-}
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // !defined(ASIO_HAS_EVENTFD)
-#endif // !defined(__SYMBIAN32__)
-#endif // !defined(__CYGWIN__)
-#endif // !defined(ASIO_WINDOWS)
-#endif // !defined(ASIO_WINDOWS_RUNTIME)
-
-#endif // ASIO_DETAIL_IMPL_PIPE_SELECT_INTERRUPTER_IPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/posix_event.ipp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/posix_event.ipp
deleted file mode 100644
index 1bc6563aca45..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/posix_event.ipp
+++ /dev/null
@@ -1,47 +0,0 @@
-//
-// detail/impl/posix_event.ipp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_IMPL_POSIX_EVENT_IPP
-#define ASIO_DETAIL_IMPL_POSIX_EVENT_IPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_HAS_PTHREADS)
-
-#include "asio/detail/posix_event.hpp"
-#include "asio/detail/throw_error.hpp"
-#include "asio/error.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-posix_event::posix_event()
-  : state_(0)
-{
-  int error = ::pthread_cond_init(&cond_, 0);
-  asio::error_code ec(error,
-      asio::error::get_system_category());
-  asio::detail::throw_error(ec, "event");
-}
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // defined(ASIO_HAS_PTHREADS)
-
-#endif // ASIO_DETAIL_IMPL_POSIX_EVENT_IPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/posix_mutex.ipp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/posix_mutex.ipp
deleted file mode 100644
index e0f67abab945..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/posix_mutex.ipp
+++ /dev/null
@@ -1,46 +0,0 @@
-//
-// detail/impl/posix_mutex.ipp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_IMPL_POSIX_MUTEX_IPP
-#define ASIO_DETAIL_IMPL_POSIX_MUTEX_IPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_HAS_PTHREADS)
-
-#include "asio/detail/posix_mutex.hpp"
-#include "asio/detail/throw_error.hpp"
-#include "asio/error.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-posix_mutex::posix_mutex()
-{
-  int error = ::pthread_mutex_init(&mutex_, 0);
-  asio::error_code ec(error,
-      asio::error::get_system_category());
-  asio::detail::throw_error(ec, "mutex");
-}
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // defined(ASIO_HAS_PTHREADS)
-
-#endif // ASIO_DETAIL_IMPL_POSIX_MUTEX_IPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/posix_thread.ipp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/posix_thread.ipp
deleted file mode 100644
index ea12383bb7b9..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/posix_thread.ipp
+++ /dev/null
@@ -1,74 +0,0 @@
-//
-// detail/impl/posix_thread.ipp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_IMPL_POSIX_THREAD_IPP
-#define ASIO_DETAIL_IMPL_POSIX_THREAD_IPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_HAS_PTHREADS)
-
-#include "asio/detail/posix_thread.hpp"
-#include "asio/detail/throw_error.hpp"
-#include "asio/error.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-posix_thread::~posix_thread()
-{
-  if (!joined_)
-    ::pthread_detach(thread_);
-}
-
-void posix_thread::join()
-{
-  if (!joined_)
-  {
-    ::pthread_join(thread_, 0);
-    joined_ = true;
-  }
-}
-
-void posix_thread::start_thread(func_base* arg)
-{
-  int error = ::pthread_create(&thread_, 0,
-        asio_detail_posix_thread_function, arg);
-  if (error != 0)
-  {
-    delete arg;
-    asio::error_code ec(error,
-        asio::error::get_system_category());
-    asio::detail::throw_error(ec, "thread");
-  }
-}
-
-void* asio_detail_posix_thread_function(void* arg)
-{
-  posix_thread::auto_func_base_ptr func = {
-      static_cast<posix_thread::func_base*>(arg) };
-  func.ptr->run();
-  return 0;
-}
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // defined(ASIO_HAS_PTHREADS)
-
-#endif // ASIO_DETAIL_IMPL_POSIX_THREAD_IPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/posix_tss_ptr.ipp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/posix_tss_ptr.ipp
deleted file mode 100644
index 1e4ac820cc1c..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/posix_tss_ptr.ipp
+++ /dev/null
@@ -1,46 +0,0 @@
-//
-// detail/impl/posix_tss_ptr.ipp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_IMPL_POSIX_TSS_PTR_IPP
-#define ASIO_DETAIL_IMPL_POSIX_TSS_PTR_IPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_HAS_PTHREADS)
-
-#include "asio/detail/posix_tss_ptr.hpp"
-#include "asio/detail/throw_error.hpp"
-#include "asio/error.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-void posix_tss_ptr_create(pthread_key_t& key)
-{
-  int error = ::pthread_key_create(&key, 0);
-  asio::error_code ec(error,
-      asio::error::get_system_category());
-  asio::detail::throw_error(ec, "tss");
-}
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // defined(ASIO_HAS_PTHREADS)
-
-#endif // ASIO_DETAIL_IMPL_POSIX_TSS_PTR_IPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/reactive_descriptor_service.ipp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/reactive_descriptor_service.ipp
deleted file mode 100644
index 23d8e13c358d..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/reactive_descriptor_service.ipp
+++ /dev/null
@@ -1,208 +0,0 @@
-//
-// detail/impl/reactive_descriptor_service.ipp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_IMPL_REACTIVE_DESCRIPTOR_SERVICE_IPP
-#define ASIO_DETAIL_IMPL_REACTIVE_DESCRIPTOR_SERVICE_IPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if !defined(ASIO_WINDOWS) \
-  && !defined(ASIO_WINDOWS_RUNTIME) \
-  && !defined(__CYGWIN__)
-
-#include "asio/error.hpp"
-#include "asio/detail/reactive_descriptor_service.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-reactive_descriptor_service::reactive_descriptor_service(
-    asio::io_service& io_service)
-  : reactor_(asio::use_service<reactor>(io_service))
-{
-  reactor_.init_task();
-}
-
-void reactive_descriptor_service::shutdown_service()
-{
-}
-
-void reactive_descriptor_service::construct(
-    reactive_descriptor_service::implementation_type& impl)
-{
-  impl.descriptor_ = -1;
-  impl.state_ = 0;
-}
-
-void reactive_descriptor_service::move_construct(
-    reactive_descriptor_service::implementation_type& impl,
-    reactive_descriptor_service::implementation_type& other_impl)
-{
-  impl.descriptor_ = other_impl.descriptor_;
-  other_impl.descriptor_ = -1;
-
-  impl.state_ = other_impl.state_;
-  other_impl.state_ = 0;
-
-  reactor_.move_descriptor(impl.descriptor_,
-      impl.reactor_data_, other_impl.reactor_data_);
-}
-
-void reactive_descriptor_service::move_assign(
-    reactive_descriptor_service::implementation_type& impl,
-    reactive_descriptor_service& other_service,
-    reactive_descriptor_service::implementation_type& other_impl)
-{
-  destroy(impl);
-
-  impl.descriptor_ = other_impl.descriptor_;
-  other_impl.descriptor_ = -1;
-
-  impl.state_ = other_impl.state_;
-  other_impl.state_ = 0;
-
-  other_service.reactor_.move_descriptor(impl.descriptor_,
-      impl.reactor_data_, other_impl.reactor_data_);
-}
-
-void reactive_descriptor_service::destroy(
-    reactive_descriptor_service::implementation_type& impl)
-{
-  if (is_open(impl))
-  {
-    ASIO_HANDLER_OPERATION(("descriptor", &impl, "close"));
-
-    reactor_.deregister_descriptor(impl.descriptor_, impl.reactor_data_,
-        (impl.state_ & descriptor_ops::possible_dup) == 0);
-  }
-
-  asio::error_code ignored_ec;
-  descriptor_ops::close(impl.descriptor_, impl.state_, ignored_ec);
-}
-
-asio::error_code reactive_descriptor_service::assign(
-    reactive_descriptor_service::implementation_type& impl,
-    const native_handle_type& native_descriptor, asio::error_code& ec)
-{
-  if (is_open(impl))
-  {
-    ec = asio::error::already_open;
-    return ec;
-  }
-
-  if (int err = reactor_.register_descriptor(
-        native_descriptor, impl.reactor_data_))
-  {
-    ec = asio::error_code(err,
-        asio::error::get_system_category());
-    return ec;
-  }
-
-  impl.descriptor_ = native_descriptor;
-  impl.state_ = descriptor_ops::possible_dup;
-  ec = asio::error_code();
-  return ec;
-}
-
-asio::error_code reactive_descriptor_service::close(
-    reactive_descriptor_service::implementation_type& impl,
-    asio::error_code& ec)
-{
-  if (is_open(impl))
-  {
-    ASIO_HANDLER_OPERATION(("descriptor", &impl, "close"));
-
-    reactor_.deregister_descriptor(impl.descriptor_, impl.reactor_data_,
-        (impl.state_ & descriptor_ops::possible_dup) == 0);
-  }
-
-  descriptor_ops::close(impl.descriptor_, impl.state_, ec);
-
-  // The descriptor is closed by the OS even if close() returns an error.
-  //
-  // (Actually, POSIX says the state of the descriptor is unspecified. On
-  // Linux the descriptor is apparently closed anyway; e.g. see
-  //   http://lkml.org/lkml/2005/9/10/129
-  // We'll just have to assume that other OSes follow the same behaviour.)
-  construct(impl);
-
-  return ec;
-}
-
-reactive_descriptor_service::native_handle_type
-reactive_descriptor_service::release(
-    reactive_descriptor_service::implementation_type& impl)
-{
-  native_handle_type descriptor = impl.descriptor_;
-
-  if (is_open(impl))
-  {
-    ASIO_HANDLER_OPERATION(("descriptor", &impl, "release"));
-
-    reactor_.deregister_descriptor(impl.descriptor_, impl.reactor_data_, false);
-    construct(impl);
-  }
-
-  return descriptor;
-}
-
-asio::error_code reactive_descriptor_service::cancel(
-    reactive_descriptor_service::implementation_type& impl,
-    asio::error_code& ec)
-{
-  if (!is_open(impl))
-  {
-    ec = asio::error::bad_descriptor;
-    return ec;
-  }
-
-  ASIO_HANDLER_OPERATION(("descriptor", &impl, "cancel"));
-
-  reactor_.cancel_ops(impl.descriptor_, impl.reactor_data_);
-  ec = asio::error_code();
-  return ec;
-}
-
-void reactive_descriptor_service::start_op(
-    reactive_descriptor_service::implementation_type& impl,
-    int op_type, reactor_op* op, bool is_continuation,
-    bool is_non_blocking, bool noop)
-{
-  if (!noop)
-  {
-    if ((impl.state_ & descriptor_ops::non_blocking) ||
-        descriptor_ops::set_internal_non_blocking(
-          impl.descriptor_, impl.state_, true, op->ec_))
-    {
-      reactor_.start_op(op_type, impl.descriptor_,
-          impl.reactor_data_, op, is_continuation, is_non_blocking);
-      return;
-    }
-  }
-
-  reactor_.post_immediate_completion(op, is_continuation);
-}
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // !defined(ASIO_WINDOWS)
-       //   && !defined(ASIO_WINDOWS_RUNTIME)
-       //   && !defined(__CYGWIN__)
-
-#endif // ASIO_DETAIL_IMPL_REACTIVE_DESCRIPTOR_SERVICE_IPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/reactive_serial_port_service.ipp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/reactive_serial_port_service.ipp
deleted file mode 100644
index 19748760b519..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/reactive_serial_port_service.ipp
+++ /dev/null
@@ -1,151 +0,0 @@
-//
-// detail/impl/reactive_serial_port_service.ipp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-// Copyright (c) 2008 Rep Invariant Systems, Inc. (info@repinvariant.com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_IMPL_REACTIVE_SERIAL_PORT_SERVICE_IPP
-#define ASIO_DETAIL_IMPL_REACTIVE_SERIAL_PORT_SERVICE_IPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_HAS_SERIAL_PORT)
-#if !defined(ASIO_WINDOWS) && !defined(__CYGWIN__)
-
-#include <cstring>
-#include "asio/detail/reactive_serial_port_service.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-reactive_serial_port_service::reactive_serial_port_service(
-    asio::io_service& io_service)
-  : descriptor_service_(io_service)
-{
-}
-
-void reactive_serial_port_service::shutdown_service()
-{
-  descriptor_service_.shutdown_service();
-}
-
-asio::error_code reactive_serial_port_service::open(
-    reactive_serial_port_service::implementation_type& impl,
-    const std::string& device, asio::error_code& ec)
-{
-  if (is_open(impl))
-  {
-    ec = asio::error::already_open;
-    return ec;
-  }
-
-  descriptor_ops::state_type state = 0;
-  int fd = descriptor_ops::open(device.c_str(),
-      O_RDWR | O_NONBLOCK | O_NOCTTY, ec);
-  if (fd < 0)
-    return ec;
-
-  int s = descriptor_ops::fcntl(fd, F_GETFL, ec);
-  if (s >= 0)
-    s = descriptor_ops::fcntl(fd, F_SETFL, s | O_NONBLOCK, ec);
-  if (s < 0)
-  {
-    asio::error_code ignored_ec;
-    descriptor_ops::close(fd, state, ignored_ec);
-    return ec;
-  }
-
-  // Set up default serial port options.
-  termios ios;
-  errno = 0;
-  s = descriptor_ops::error_wrapper(::tcgetattr(fd, &ios), ec);
-  if (s >= 0)
-  {
-#if defined(_BSD_SOURCE)
-    ::cfmakeraw(&ios);
-#else
-    ios.c_iflag &= ~(IGNBRK | BRKINT | PARMRK
-        | ISTRIP | INLCR | IGNCR | ICRNL | IXON);
-    ios.c_oflag &= ~OPOST;
-    ios.c_lflag &= ~(ECHO | ECHONL | ICANON | ISIG | IEXTEN);
-    ios.c_cflag &= ~(CSIZE | PARENB);
-    ios.c_cflag |= CS8;
-#endif
-    ios.c_iflag |= IGNPAR;
-    ios.c_cflag |= CREAD | CLOCAL;
-    errno = 0;
-    s = descriptor_ops::error_wrapper(::tcsetattr(fd, TCSANOW, &ios), ec);
-  }
-  if (s < 0)
-  {
-    asio::error_code ignored_ec;
-    descriptor_ops::close(fd, state, ignored_ec);
-    return ec;
-  }
-
-  // We're done. Take ownership of the serial port descriptor.
-  if (descriptor_service_.assign(impl, fd, ec))
-  {
-    asio::error_code ignored_ec;
-    descriptor_ops::close(fd, state, ignored_ec);
-  }
-
-  return ec;
-}
-
-asio::error_code reactive_serial_port_service::do_set_option(
-    reactive_serial_port_service::implementation_type& impl,
-    reactive_serial_port_service::store_function_type store,
-    const void* option, asio::error_code& ec)
-{
-  termios ios;
-  errno = 0;
-  descriptor_ops::error_wrapper(::tcgetattr(
-        descriptor_service_.native_handle(impl), &ios), ec);
-  if (ec)
-    return ec;
-
-  if (store(option, ios, ec))
-    return ec;
-
-  errno = 0;
-  descriptor_ops::error_wrapper(::tcsetattr(
-        descriptor_service_.native_handle(impl), TCSANOW, &ios), ec);
-  return ec;
-}
-
-asio::error_code reactive_serial_port_service::do_get_option(
-    const reactive_serial_port_service::implementation_type& impl,
-    reactive_serial_port_service::load_function_type load,
-    void* option, asio::error_code& ec) const
-{
-  termios ios;
-  errno = 0;
-  descriptor_ops::error_wrapper(::tcgetattr(
-        descriptor_service_.native_handle(impl), &ios), ec);
-  if (ec)
-    return ec;
-
-  return load(option, ios, ec);
-}
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // !defined(ASIO_WINDOWS) && !defined(__CYGWIN__)
-#endif // defined(ASIO_HAS_SERIAL_PORT)
-
-#endif // ASIO_DETAIL_IMPL_REACTIVE_SERIAL_PORT_SERVICE_IPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/reactive_socket_service_base.ipp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/reactive_socket_service_base.ipp
deleted file mode 100644
index a0363edb9d1e..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/reactive_socket_service_base.ipp
+++ /dev/null
@@ -1,267 +0,0 @@
-//
-// detail/reactive_socket_service_base.ipp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_IMPL_REACTIVE_SOCKET_SERVICE_BASE_IPP
-#define ASIO_DETAIL_IMPL_REACTIVE_SOCKET_SERVICE_BASE_IPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if !defined(ASIO_HAS_IOCP) \
-  && !defined(ASIO_WINDOWS_RUNTIME)
-
-#include "asio/detail/reactive_socket_service_base.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-reactive_socket_service_base::reactive_socket_service_base(
-    asio::io_service& io_service)
-  : reactor_(use_service<reactor>(io_service))
-{
-  reactor_.init_task();
-}
-
-void reactive_socket_service_base::shutdown_service()
-{
-}
-
-void reactive_socket_service_base::construct(
-    reactive_socket_service_base::base_implementation_type& impl)
-{
-  impl.socket_ = invalid_socket;
-  impl.state_ = 0;
-}
-
-void reactive_socket_service_base::base_move_construct(
-    reactive_socket_service_base::base_implementation_type& impl,
-    reactive_socket_service_base::base_implementation_type& other_impl)
-{
-  impl.socket_ = other_impl.socket_;
-  other_impl.socket_ = invalid_socket;
-
-  impl.state_ = other_impl.state_;
-  other_impl.state_ = 0;
-
-  reactor_.move_descriptor(impl.socket_,
-      impl.reactor_data_, other_impl.reactor_data_);
-}
-
-void reactive_socket_service_base::base_move_assign(
-    reactive_socket_service_base::base_implementation_type& impl,
-    reactive_socket_service_base& other_service,
-    reactive_socket_service_base::base_implementation_type& other_impl)
-{
-  destroy(impl);
-
-  impl.socket_ = other_impl.socket_;
-  other_impl.socket_ = invalid_socket;
-
-  impl.state_ = other_impl.state_;
-  other_impl.state_ = 0;
-
-  other_service.reactor_.move_descriptor(impl.socket_,
-      impl.reactor_data_, other_impl.reactor_data_);
-}
-
-void reactive_socket_service_base::destroy(
-    reactive_socket_service_base::base_implementation_type& impl)
-{
-  if (impl.socket_ != invalid_socket)
-  {
-    ASIO_HANDLER_OPERATION(("socket", &impl, "close"));
-
-    reactor_.deregister_descriptor(impl.socket_, impl.reactor_data_,
-        (impl.state_ & socket_ops::possible_dup) == 0);
-
-    asio::error_code ignored_ec;
-    socket_ops::close(impl.socket_, impl.state_, true, ignored_ec);
-  }
-}
-
-asio::error_code reactive_socket_service_base::close(
-    reactive_socket_service_base::base_implementation_type& impl,
-    asio::error_code& ec)
-{
-  if (is_open(impl))
-  {
-    ASIO_HANDLER_OPERATION(("socket", &impl, "close"));
-
-    reactor_.deregister_descriptor(impl.socket_, impl.reactor_data_,
-        (impl.state_ & socket_ops::possible_dup) == 0);
-  }
-
-  socket_ops::close(impl.socket_, impl.state_, false, ec);
-
-  // The descriptor is closed by the OS even if close() returns an error.
-  //
-  // (Actually, POSIX says the state of the descriptor is unspecified. On
-  // Linux the descriptor is apparently closed anyway; e.g. see
-  //   http://lkml.org/lkml/2005/9/10/129
-  // We'll just have to assume that other OSes follow the same behaviour. The
-  // known exception is when Windows's closesocket() function fails with
-  // WSAEWOULDBLOCK, but this case is handled inside socket_ops::close().
-  construct(impl);
-
-  return ec;
-}
-
-asio::error_code reactive_socket_service_base::cancel(
-    reactive_socket_service_base::base_implementation_type& impl,
-    asio::error_code& ec)
-{
-  if (!is_open(impl))
-  {
-    ec = asio::error::bad_descriptor;
-    return ec;
-  }
-
-  ASIO_HANDLER_OPERATION(("socket", &impl, "cancel"));
-
-  reactor_.cancel_ops(impl.socket_, impl.reactor_data_);
-  ec = asio::error_code();
-  return ec;
-}
-
-asio::error_code reactive_socket_service_base::do_open(
-    reactive_socket_service_base::base_implementation_type& impl,
-    int af, int type, int protocol, asio::error_code& ec)
-{
-  if (is_open(impl))
-  {
-    ec = asio::error::already_open;
-    return ec;
-  }
-
-  socket_holder sock(socket_ops::socket(af, type, protocol, ec));
-  if (sock.get() == invalid_socket)
-    return ec;
-
-  if (int err = reactor_.register_descriptor(sock.get(), impl.reactor_data_))
-  {
-    ec = asio::error_code(err,
-        asio::error::get_system_category());
-    return ec;
-  }
-
-  impl.socket_ = sock.release();
-  switch (type)
-  {
-  case SOCK_STREAM: impl.state_ = socket_ops::stream_oriented; break;
-  case SOCK_DGRAM: impl.state_ = socket_ops::datagram_oriented; break;
-  default: impl.state_ = 0; break;
-  }
-  ec = asio::error_code();
-  return ec;
-}
-
-asio::error_code reactive_socket_service_base::do_assign(
-    reactive_socket_service_base::base_implementation_type& impl, int type,
-    const reactive_socket_service_base::native_handle_type& native_socket,
-    asio::error_code& ec)
-{
-  if (is_open(impl))
-  {
-    ec = asio::error::already_open;
-    return ec;
-  }
-
-  if (int err = reactor_.register_descriptor(
-        native_socket, impl.reactor_data_))
-  {
-    ec = asio::error_code(err,
-        asio::error::get_system_category());
-    return ec;
-  }
-
-  impl.socket_ = native_socket;
-  switch (type)
-  {
-  case SOCK_STREAM: impl.state_ = socket_ops::stream_oriented; break;
-  case SOCK_DGRAM: impl.state_ = socket_ops::datagram_oriented; break;
-  default: impl.state_ = 0; break;
-  }
-  impl.state_ |= socket_ops::possible_dup;
-  ec = asio::error_code();
-  return ec;
-}
-
-void reactive_socket_service_base::start_op(
-    reactive_socket_service_base::base_implementation_type& impl,
-    int op_type, reactor_op* op, bool is_continuation,
-    bool is_non_blocking, bool noop)
-{
-  if (!noop)
-  {
-    if ((impl.state_ & socket_ops::non_blocking)
-        || socket_ops::set_internal_non_blocking(
-          impl.socket_, impl.state_, true, op->ec_))
-    {
-      reactor_.start_op(op_type, impl.socket_,
-          impl.reactor_data_, op, is_continuation, is_non_blocking);
-      return;
-    }
-  }
-
-  reactor_.post_immediate_completion(op, is_continuation);
-}
-
-void reactive_socket_service_base::start_accept_op(
-    reactive_socket_service_base::base_implementation_type& impl,
-    reactor_op* op, bool is_continuation, bool peer_is_open)
-{
-  if (!peer_is_open)
-    start_op(impl, reactor::read_op, op, true, is_continuation, false);
-  else
-  {
-    op->ec_ = asio::error::already_open;
-    reactor_.post_immediate_completion(op, is_continuation);
-  }
-}
-
-void reactive_socket_service_base::start_connect_op(
-    reactive_socket_service_base::base_implementation_type& impl,
-    reactor_op* op, bool is_continuation,
-    const socket_addr_type* addr, size_t addrlen)
-{
-  if ((impl.state_ & socket_ops::non_blocking)
-      || socket_ops::set_internal_non_blocking(
-        impl.socket_, impl.state_, true, op->ec_))
-  {
-    if (socket_ops::connect(impl.socket_, addr, addrlen, op->ec_) != 0)
-    {
-      if (op->ec_ == asio::error::in_progress
-          || op->ec_ == asio::error::would_block)
-      {
-        op->ec_ = asio::error_code();
-        reactor_.start_op(reactor::connect_op, impl.socket_,
-            impl.reactor_data_, op, is_continuation, false);
-        return;
-      }
-    }
-  }
-
-  reactor_.post_immediate_completion(op, is_continuation);
-}
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // !defined(ASIO_HAS_IOCP)
-       //   && !defined(ASIO_WINDOWS_RUNTIME)
-
-#endif // ASIO_DETAIL_IMPL_REACTIVE_SOCKET_SERVICE_BASE_IPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/resolver_service_base.ipp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/resolver_service_base.ipp
deleted file mode 100644
index 2f999835b1d8..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/resolver_service_base.ipp
+++ /dev/null
@@ -1,130 +0,0 @@
-//
-// detail/impl/resolver_service_base.ipp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_IMPL_RESOLVER_SERVICE_BASE_IPP
-#define ASIO_DETAIL_IMPL_RESOLVER_SERVICE_BASE_IPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include "asio/detail/resolver_service_base.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-class resolver_service_base::work_io_service_runner
-{
-public:
-  work_io_service_runner(asio::io_service& io_service)
-    : io_service_(io_service) {}
-  void operator()() { io_service_.run(); }
-private:
-  asio::io_service& io_service_;
-};
-
-resolver_service_base::resolver_service_base(
-    asio::io_service& io_service)
-  : io_service_impl_(asio::use_service<io_service_impl>(io_service)),
-    work_io_service_(new asio::io_service),
-    work_io_service_impl_(asio::use_service<
-        io_service_impl>(*work_io_service_)),
-    work_(new asio::io_service::work(*work_io_service_)),
-    work_thread_(0)
-{
-}
-
-resolver_service_base::~resolver_service_base()
-{
-  shutdown_service();
-}
-
-void resolver_service_base::shutdown_service()
-{
-  work_.reset();
-  if (work_io_service_.get())
-  {
-    work_io_service_->stop();
-    if (work_thread_.get())
-    {
-      work_thread_->join();
-      work_thread_.reset();
-    }
-    work_io_service_.reset();
-  }
-}
-
-void resolver_service_base::fork_service(
-    asio::io_service::fork_event fork_ev)
-{
-  if (work_thread_.get())
-  {
-    if (fork_ev == asio::io_service::fork_prepare)
-    {
-      work_io_service_->stop();
-      work_thread_->join();
-    }
-    else
-    {
-      work_io_service_->reset();
-      work_thread_.reset(new asio::detail::thread(
-            work_io_service_runner(*work_io_service_)));
-    }
-  }
-}
-
-void resolver_service_base::construct(
-    resolver_service_base::implementation_type& impl)
-{
-  impl.reset(static_cast<void*>(0), socket_ops::noop_deleter());
-}
-
-void resolver_service_base::destroy(
-    resolver_service_base::implementation_type& impl)
-{
-  ASIO_HANDLER_OPERATION(("resolver", &impl, "cancel"));
-
-  impl.reset();
-}
-
-void resolver_service_base::cancel(
-    resolver_service_base::implementation_type& impl)
-{
-  ASIO_HANDLER_OPERATION(("resolver", &impl, "cancel"));
-
-  impl.reset(static_cast<void*>(0), socket_ops::noop_deleter());
-}
-
-void resolver_service_base::start_resolve_op(operation* op)
-{
-  start_work_thread();
-  io_service_impl_.work_started();
-  work_io_service_impl_.post_immediate_completion(op, false);
-}
-
-void resolver_service_base::start_work_thread()
-{
-  asio::detail::mutex::scoped_lock lock(mutex_);
-  if (!work_thread_.get())
-  {
-    work_thread_.reset(new asio::detail::thread(
-          work_io_service_runner(*work_io_service_)));
-  }
-}
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_DETAIL_IMPL_RESOLVER_SERVICE_BASE_IPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/select_reactor.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/select_reactor.hpp
deleted file mode 100644
index 55724722cc8f..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/select_reactor.hpp
+++ /dev/null
@@ -1,87 +0,0 @@
-//
-// detail/impl/select_reactor.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_IMPL_SELECT_REACTOR_HPP
-#define ASIO_DETAIL_IMPL_SELECT_REACTOR_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_HAS_IOCP) \
-  || (!defined(ASIO_HAS_DEV_POLL) \
-      && !defined(ASIO_HAS_EPOLL) \
-      && !defined(ASIO_HAS_KQUEUE) \
-      && !defined(ASIO_WINDOWS_RUNTIME))
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-template <typename Time_Traits>
-void select_reactor::add_timer_queue(timer_queue<Time_Traits>& queue)
-{
-  do_add_timer_queue(queue);
-}
-
-// Remove a timer queue from the reactor.
-template <typename Time_Traits>
-void select_reactor::remove_timer_queue(timer_queue<Time_Traits>& queue)
-{
-  do_remove_timer_queue(queue);
-}
-
-template <typename Time_Traits>
-void select_reactor::schedule_timer(timer_queue<Time_Traits>& queue,
-    const typename Time_Traits::time_type& time,
-    typename timer_queue<Time_Traits>::per_timer_data& timer, wait_op* op)
-{
-  asio::detail::mutex::scoped_lock lock(mutex_);
-
-  if (shutdown_)
-  {
-    io_service_.post_immediate_completion(op, false);
-    return;
-  }
-
-  bool earliest = queue.enqueue_timer(time, timer, op);
-  io_service_.work_started();
-  if (earliest)
-    interrupter_.interrupt();
-}
-
-template <typename Time_Traits>
-std::size_t select_reactor::cancel_timer(timer_queue<Time_Traits>& queue,
-    typename timer_queue<Time_Traits>::per_timer_data& timer,
-    std::size_t max_cancelled)
-{
-  asio::detail::mutex::scoped_lock lock(mutex_);
-  op_queue<operation> ops;
-  std::size_t n = queue.cancel_timer(timer, ops, max_cancelled);
-  lock.unlock();
-  io_service_.post_deferred_completions(ops);
-  return n;
-}
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // defined(ASIO_HAS_IOCP)
-       //   || (!defined(ASIO_HAS_DEV_POLL)
-       //       && !defined(ASIO_HAS_EPOLL)
-       //       && !defined(ASIO_HAS_KQUEUE)
-       //       && !defined(ASIO_WINDOWS_RUNTIME))
-
-#endif // ASIO_DETAIL_IMPL_SELECT_REACTOR_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/select_reactor.ipp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/select_reactor.ipp
deleted file mode 100644
index d1ae2e99ed14..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/select_reactor.ipp
+++ /dev/null
@@ -1,313 +0,0 @@
-//
-// detail/impl/select_reactor.ipp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_IMPL_SELECT_REACTOR_IPP
-#define ASIO_DETAIL_IMPL_SELECT_REACTOR_IPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_HAS_IOCP) \
-  || (!defined(ASIO_HAS_DEV_POLL) \
-      && !defined(ASIO_HAS_EPOLL) \
-      && !defined(ASIO_HAS_KQUEUE) \
-      && !defined(ASIO_WINDOWS_RUNTIME))
-
-#include "asio/detail/bind_handler.hpp"
-#include "asio/detail/fd_set_adapter.hpp"
-#include "asio/detail/select_reactor.hpp"
-#include "asio/detail/signal_blocker.hpp"
-#include "asio/detail/socket_ops.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-select_reactor::select_reactor(asio::io_service& io_service)
-  : asio::detail::service_base<select_reactor>(io_service),
-    io_service_(use_service<io_service_impl>(io_service)),
-    mutex_(),
-    interrupter_(),
-#if defined(ASIO_HAS_IOCP)
-    stop_thread_(false),
-    thread_(0),
-#endif // defined(ASIO_HAS_IOCP)
-    shutdown_(false)
-{
-#if defined(ASIO_HAS_IOCP)
-  asio::detail::signal_blocker sb;
-  thread_ = new asio::detail::thread(
-      bind_handler(&select_reactor::call_run_thread, this));
-#endif // defined(ASIO_HAS_IOCP)
-}
-
-select_reactor::~select_reactor()
-{
-  shutdown_service();
-}
-
-void select_reactor::shutdown_service()
-{
-  asio::detail::mutex::scoped_lock lock(mutex_);
-  shutdown_ = true;
-#if defined(ASIO_HAS_IOCP)
-  stop_thread_ = true;
-#endif // defined(ASIO_HAS_IOCP)
-  lock.unlock();
-
-#if defined(ASIO_HAS_IOCP)
-  if (thread_)
-  {
-    interrupter_.interrupt();
-    thread_->join();
-    delete thread_;
-    thread_ = 0;
-  }
-#endif // defined(ASIO_HAS_IOCP)
-
-  op_queue<operation> ops;
-
-  for (int i = 0; i < max_ops; ++i)
-    op_queue_[i].get_all_operations(ops);
-
-  timer_queues_.get_all_timers(ops);
-
-  io_service_.abandon_operations(ops);
-}
-
-void select_reactor::fork_service(asio::io_service::fork_event fork_ev)
-{
-  if (fork_ev == asio::io_service::fork_child)
-    interrupter_.recreate();
-}
-
-void select_reactor::init_task()
-{
-  io_service_.init_task();
-}
-
-int select_reactor::register_descriptor(socket_type,
-    select_reactor::per_descriptor_data&)
-{
-  return 0;
-}
-
-int select_reactor::register_internal_descriptor(
-    int op_type, socket_type descriptor,
-    select_reactor::per_descriptor_data&, reactor_op* op)
-{
-  asio::detail::mutex::scoped_lock lock(mutex_);
-
-  op_queue_[op_type].enqueue_operation(descriptor, op);
-  interrupter_.interrupt();
-
-  return 0;
-}
-
-void select_reactor::move_descriptor(socket_type,
-    select_reactor::per_descriptor_data&,
-    select_reactor::per_descriptor_data&)
-{
-}
-
-void select_reactor::start_op(int op_type, socket_type descriptor,
-    select_reactor::per_descriptor_data&, reactor_op* op,
-    bool is_continuation, bool)
-{
-  asio::detail::mutex::scoped_lock lock(mutex_);
-
-  if (shutdown_)
-  {
-    post_immediate_completion(op, is_continuation);
-    return;
-  }
-
-  bool first = op_queue_[op_type].enqueue_operation(descriptor, op);
-  io_service_.work_started();
-  if (first)
-    interrupter_.interrupt();
-}
-
-void select_reactor::cancel_ops(socket_type descriptor,
-    select_reactor::per_descriptor_data&)
-{
-  asio::detail::mutex::scoped_lock lock(mutex_);
-  cancel_ops_unlocked(descriptor, asio::error::operation_aborted);
-}
-
-void select_reactor::deregister_descriptor(socket_type descriptor,
-    select_reactor::per_descriptor_data&, bool)
-{
-  asio::detail::mutex::scoped_lock lock(mutex_);
-  cancel_ops_unlocked(descriptor, asio::error::operation_aborted);
-}
-
-void select_reactor::deregister_internal_descriptor(
-    socket_type descriptor, select_reactor::per_descriptor_data&)
-{
-  asio::detail::mutex::scoped_lock lock(mutex_);
-  op_queue<operation> ops;
-  for (int i = 0; i < max_ops; ++i)
-    op_queue_[i].cancel_operations(descriptor, ops);
-}
-
-void select_reactor::run(bool block, op_queue<operation>& ops)
-{
-  asio::detail::mutex::scoped_lock lock(mutex_);
-
-#if defined(ASIO_HAS_IOCP)
-  // Check if the thread is supposed to stop.
-  if (stop_thread_)
-    return;
-#endif // defined(ASIO_HAS_IOCP)
-
-  // Set up the descriptor sets.
-  for (int i = 0; i < max_select_ops; ++i)
-    fd_sets_[i].reset();
-  fd_sets_[read_op].set(interrupter_.read_descriptor());
-  socket_type max_fd = 0;
-  bool have_work_to_do = !timer_queues_.all_empty();
-  for (int i = 0; i < max_select_ops; ++i)
-  {
-    have_work_to_do = have_work_to_do || !op_queue_[i].empty();
-    fd_sets_[i].set(op_queue_[i], ops);
-    if (fd_sets_[i].max_descriptor() > max_fd)
-      max_fd = fd_sets_[i].max_descriptor();
-  }
-
-#if defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-  // Connection operations on Windows use both except and write fd_sets.
-  have_work_to_do = have_work_to_do || !op_queue_[connect_op].empty();
-  fd_sets_[write_op].set(op_queue_[connect_op], ops);
-  if (fd_sets_[write_op].max_descriptor() > max_fd)
-    max_fd = fd_sets_[write_op].max_descriptor();
-  fd_sets_[except_op].set(op_queue_[connect_op], ops);
-  if (fd_sets_[except_op].max_descriptor() > max_fd)
-    max_fd = fd_sets_[except_op].max_descriptor();
-#endif // defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-
-  // We can return immediately if there's no work to do and the reactor is
-  // not supposed to block.
-  if (!block && !have_work_to_do)
-    return;
-
-  // Determine how long to block while waiting for events.
-  timeval tv_buf = { 0, 0 };
-  timeval* tv = block ? get_timeout(tv_buf) : &tv_buf;
-
-  lock.unlock();
-
-  // Block on the select call until descriptors become ready.
-  asio::error_code ec;
-  int retval = socket_ops::select(static_cast<int>(max_fd + 1),
-      fd_sets_[read_op], fd_sets_[write_op], fd_sets_[except_op], tv, ec);
-
-  // Reset the interrupter.
-  if (retval > 0 && fd_sets_[read_op].is_set(interrupter_.read_descriptor()))
-  {
-    interrupter_.reset();
-    --retval;
-  }
-
-  lock.lock();
-
-  // Dispatch all ready operations.
-  if (retval > 0)
-  {
-#if defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-    // Connection operations on Windows use both except and write fd_sets.
-    fd_sets_[except_op].perform(op_queue_[connect_op], ops);
-    fd_sets_[write_op].perform(op_queue_[connect_op], ops);
-#endif // defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-
-    // Exception operations must be processed first to ensure that any
-    // out-of-band data is read before normal data.
-    for (int i = max_select_ops - 1; i >= 0; --i)
-      fd_sets_[i].perform(op_queue_[i], ops);
-  }
-  timer_queues_.get_ready_timers(ops);
-}
-
-void select_reactor::interrupt()
-{
-  interrupter_.interrupt();
-}
-
-#if defined(ASIO_HAS_IOCP)
-void select_reactor::run_thread()
-{
-  asio::detail::mutex::scoped_lock lock(mutex_);
-  while (!stop_thread_)
-  {
-    lock.unlock();
-    op_queue<operation> ops;
-    run(true, ops);
-    io_service_.post_deferred_completions(ops);
-    lock.lock();
-  }
-}
-
-void select_reactor::call_run_thread(select_reactor* reactor)
-{
-  reactor->run_thread();
-}
-#endif // defined(ASIO_HAS_IOCP)
-
-void select_reactor::do_add_timer_queue(timer_queue_base& queue)
-{
-  mutex::scoped_lock lock(mutex_);
-  timer_queues_.insert(&queue);
-}
-
-void select_reactor::do_remove_timer_queue(timer_queue_base& queue)
-{
-  mutex::scoped_lock lock(mutex_);
-  timer_queues_.erase(&queue);
-}
-
-timeval* select_reactor::get_timeout(timeval& tv)
-{
-  // By default we will wait no longer than 5 minutes. This will ensure that
-  // any changes to the system clock are detected after no longer than this.
-  long usec = timer_queues_.wait_duration_usec(5 * 60 * 1000 * 1000);
-  tv.tv_sec = usec / 1000000;
-  tv.tv_usec = usec % 1000000;
-  return &tv;
-}
-
-void select_reactor::cancel_ops_unlocked(socket_type descriptor,
-    const asio::error_code& ec)
-{
-  bool need_interrupt = false;
-  op_queue<operation> ops;
-  for (int i = 0; i < max_ops; ++i)
-    need_interrupt = op_queue_[i].cancel_operations(
-        descriptor, ops, ec) || need_interrupt;
-  io_service_.post_deferred_completions(ops);
-  if (need_interrupt)
-    interrupter_.interrupt();
-}
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // defined(ASIO_HAS_IOCP)
-       //   || (!defined(ASIO_HAS_DEV_POLL)
-       //       && !defined(ASIO_HAS_EPOLL)
-       //       && !defined(ASIO_HAS_KQUEUE))
-       //       && !defined(ASIO_WINDOWS_RUNTIME))
-
-#endif // ASIO_DETAIL_IMPL_SELECT_REACTOR_IPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/service_registry.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/service_registry.hpp
deleted file mode 100644
index 722773f50868..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/service_registry.hpp
+++ /dev/null
@@ -1,88 +0,0 @@
-//
-// detail/impl/service_registry.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_IMPL_SERVICE_REGISTRY_HPP
-#define ASIO_DETAIL_IMPL_SERVICE_REGISTRY_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-template <typename Service, typename Arg>
-service_registry::service_registry(
-    asio::io_service& o, Service*, Arg arg)
-  : owner_(o),
-    first_service_(new Service(o, arg))
-{
-  asio::io_service::service::key key;
-  init_key(key, Service::id);
-  first_service_->key_ = key;
-  first_service_->next_ = 0;
-}
-
-template <typename Service>
-Service& service_registry::first_service()
-{
-  return *static_cast<Service*>(first_service_);
-}
-
-template <typename Service>
-Service& service_registry::use_service()
-{
-  asio::io_service::service::key key;
-  init_key(key, Service::id);
-  factory_type factory = &service_registry::create<Service>;
-  return *static_cast<Service*>(do_use_service(key, factory));
-}
-
-template <typename Service>
-void service_registry::add_service(Service* new_service)
-{
-  asio::io_service::service::key key;
-  init_key(key, Service::id);
-  return do_add_service(key, new_service);
-}
-
-template <typename Service>
-bool service_registry::has_service() const
-{
-  asio::io_service::service::key key;
-  init_key(key, Service::id);
-  return do_has_service(key);
-}
-
-#if !defined(ASIO_NO_TYPEID)
-template <typename Service>
-void service_registry::init_key(asio::io_service::service::key& key,
-    const asio::detail::service_id<Service>& /*id*/)
-{
-  key.type_info_ = &typeid(typeid_wrapper<Service>);
-  key.id_ = 0;
-}
-#endif // !defined(ASIO_NO_TYPEID)
-
-template <typename Service>
-asio::io_service::service* service_registry::create(
-    asio::io_service& owner)
-{
-  return new Service(owner);
-}
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_DETAIL_IMPL_SERVICE_REGISTRY_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/service_registry.ipp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/service_registry.ipp
deleted file mode 100644
index b5e66dc88495..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/service_registry.ipp
+++ /dev/null
@@ -1,188 +0,0 @@
-//
-// detail/impl/service_registry.ipp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_IMPL_SERVICE_REGISTRY_IPP
-#define ASIO_DETAIL_IMPL_SERVICE_REGISTRY_IPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include <vector>
-#include "asio/detail/service_registry.hpp"
-#include "asio/detail/throw_exception.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-service_registry::~service_registry()
-{
-  // Shutdown all services. This must be done in a separate loop before the
-  // services are destroyed since the destructors of user-defined handler
-  // objects may try to access other service objects.
-  asio::io_service::service* service = first_service_;
-  while (service)
-  {
-    service->shutdown_service();
-    service = service->next_;
-  }
-
-  // Destroy all services.
-  while (first_service_)
-  {
-    asio::io_service::service* next_service = first_service_->next_;
-    destroy(first_service_);
-    first_service_ = next_service;
-  }
-}
-
-void service_registry::notify_fork(asio::io_service::fork_event fork_ev)
-{
-  // Make a copy of all of the services while holding the lock. We don't want
-  // to hold the lock while calling into each service, as it may try to call
-  // back into this class.
-  std::vector<asio::io_service::service*> services;
-  {
-    asio::detail::mutex::scoped_lock lock(mutex_);
-    asio::io_service::service* service = first_service_;
-    while (service)
-    {
-      services.push_back(service);
-      service = service->next_;
-    }
-  }
-
-  // If processing the fork_prepare event, we want to go in reverse order of
-  // service registration, which happens to be the existing order of the
-  // services in the vector. For the other events we want to go in the other
-  // direction.
-  std::size_t num_services = services.size();
-  if (fork_ev == asio::io_service::fork_prepare)
-    for (std::size_t i = 0; i < num_services; ++i)
-      services[i]->fork_service(fork_ev);
-  else
-    for (std::size_t i = num_services; i > 0; --i)
-      services[i - 1]->fork_service(fork_ev);
-}
-
-void service_registry::init_key(asio::io_service::service::key& key,
-    const asio::io_service::id& id)
-{
-  key.type_info_ = 0;
-  key.id_ = &id;
-}
-
-bool service_registry::keys_match(
-    const asio::io_service::service::key& key1,
-    const asio::io_service::service::key& key2)
-{
-  if (key1.id_ && key2.id_)
-    if (key1.id_ == key2.id_)
-      return true;
-  if (key1.type_info_ && key2.type_info_)
-    if (*key1.type_info_ == *key2.type_info_)
-      return true;
-  return false;
-}
-
-void service_registry::destroy(asio::io_service::service* service)
-{
-  delete service;
-}
-
-asio::io_service::service* service_registry::do_use_service(
-    const asio::io_service::service::key& key,
-    factory_type factory)
-{
-  asio::detail::mutex::scoped_lock lock(mutex_);
-
-  // First see if there is an existing service object with the given key.
-  asio::io_service::service* service = first_service_;
-  while (service)
-  {
-    if (keys_match(service->key_, key))
-      return service;
-    service = service->next_;
-  }
-
-  // Create a new service object. The service registry's mutex is not locked
-  // at this time to allow for nested calls into this function from the new
-  // service's constructor.
-  lock.unlock();
-  auto_service_ptr new_service = { factory(owner_) };
-  new_service.ptr_->key_ = key;
-  lock.lock();
-
-  // Check that nobody else created another service object of the same type
-  // while the lock was released.
-  service = first_service_;
-  while (service)
-  {
-    if (keys_match(service->key_, key))
-      return service;
-    service = service->next_;
-  }
-
-  // Service was successfully initialised, pass ownership to registry.
-  new_service.ptr_->next_ = first_service_;
-  first_service_ = new_service.ptr_;
-  new_service.ptr_ = 0;
-  return first_service_;
-}
-
-void service_registry::do_add_service(
-    const asio::io_service::service::key& key,
-    asio::io_service::service* new_service)
-{
-  if (&owner_ != &new_service->get_io_service())
-    asio::detail::throw_exception(invalid_service_owner());
-
-  asio::detail::mutex::scoped_lock lock(mutex_);
-
-  // Check if there is an existing service object with the given key.
-  asio::io_service::service* service = first_service_;
-  while (service)
-  {
-    if (keys_match(service->key_, key))
-      asio::detail::throw_exception(service_already_exists());
-    service = service->next_;
-  }
-
-  // Take ownership of the service object.
-  new_service->key_ = key;
-  new_service->next_ = first_service_;
-  first_service_ = new_service;
-}
-
-bool service_registry::do_has_service(
-    const asio::io_service::service::key& key) const
-{
-  asio::detail::mutex::scoped_lock lock(mutex_);
-
-  asio::io_service::service* service = first_service_;
-  while (service)
-  {
-    if (keys_match(service->key_, key))
-      return true;
-    service = service->next_;
-  }
-
-  return false;
-}
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_DETAIL_IMPL_SERVICE_REGISTRY_IPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/signal_set_service.ipp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/signal_set_service.ipp
deleted file mode 100644
index 2429b4d20452..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/signal_set_service.ipp
+++ /dev/null
@@ -1,647 +0,0 @@
-//
-// detail/impl/signal_set_service.ipp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_IMPL_SIGNAL_SET_SERVICE_IPP
-#define ASIO_DETAIL_IMPL_SIGNAL_SET_SERVICE_IPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#include <cstring>
-#include "asio/detail/reactor.hpp"
-#include "asio/detail/signal_blocker.hpp"
-#include "asio/detail/signal_set_service.hpp"
-#include "asio/detail/static_mutex.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-struct signal_state
-{
-  // Mutex used for protecting global state.
-  static_mutex mutex_;
-
-  // The read end of the pipe used for signal notifications.
-  int read_descriptor_;
-
-  // The write end of the pipe used for signal notifications.
-  int write_descriptor_;
-
-  // Whether the signal state has been prepared for a fork.
-  bool fork_prepared_;
-
-  // The head of a linked list of all signal_set_service instances.
-  class signal_set_service* service_list_;
-
-  // A count of the number of objects that are registered for each signal.
-  std::size_t registration_count_[max_signal_number];
-};
-
-signal_state* get_signal_state()
-{
-  static signal_state state = {
-    ASIO_STATIC_MUTEX_INIT, -1, -1, false, 0, { 0 } };
-  return &state;
-}
-
-void asio_signal_handler(int signal_number)
-{
-#if defined(ASIO_WINDOWS) \
-  || defined(ASIO_WINDOWS_RUNTIME) \
-  || defined(__CYGWIN__)
-  signal_set_service::deliver_signal(signal_number);
-#else // defined(ASIO_WINDOWS)
-      //   || defined(ASIO_WINDOWS_RUNTIME)
-      //   || defined(__CYGWIN__)
-  int saved_errno = errno;
-  signal_state* state = get_signal_state();
-  signed_size_type result = ::write(state->write_descriptor_,
-      &signal_number, sizeof(signal_number));
-  (void)result;
-  errno = saved_errno;
-#endif // defined(ASIO_WINDOWS)
-       //   || defined(ASIO_WINDOWS_RUNTIME)
-       //   || defined(__CYGWIN__)
-
-#if defined(ASIO_HAS_SIGNAL) && !defined(ASIO_HAS_SIGACTION)
-  ::signal(signal_number, asio_signal_handler);
-#endif // defined(ASIO_HAS_SIGNAL) && !defined(ASIO_HAS_SIGACTION)
-}
-
-#if !defined(ASIO_WINDOWS) \
-  && !defined(ASIO_WINDOWS_RUNTIME) \
-  && !defined(__CYGWIN__)
-class signal_set_service::pipe_read_op : public reactor_op
-{
-public:
-  pipe_read_op()
-    : reactor_op(&pipe_read_op::do_perform, pipe_read_op::do_complete)
-  {
-  }
-
-  static bool do_perform(reactor_op*)
-  {
-    signal_state* state = get_signal_state();
-
-    int fd = state->read_descriptor_;
-    int signal_number = 0;
-    while (::read(fd, &signal_number, sizeof(int)) == sizeof(int))
-      if (signal_number >= 0 && signal_number < max_signal_number)
-        signal_set_service::deliver_signal(signal_number);
-
-    return false;
-  }
-
-  static void do_complete(io_service_impl* /*owner*/, operation* base,
-      const asio::error_code& /*ec*/,
-      std::size_t /*bytes_transferred*/)
-  {
-    pipe_read_op* o(static_cast<pipe_read_op*>(base));
-    delete o;
-  }
-};
-#endif // !defined(ASIO_WINDOWS)
-       //   && !defined(ASIO_WINDOWS_RUNTIME)
-       //   && !defined(__CYGWIN__)
-
-signal_set_service::signal_set_service(
-    asio::io_service& io_service)
-  : io_service_(asio::use_service<io_service_impl>(io_service)),
-#if !defined(ASIO_WINDOWS) \
-  && !defined(ASIO_WINDOWS_RUNTIME) \
-  && !defined(__CYGWIN__)
-    reactor_(asio::use_service<reactor>(io_service)),
-#endif // !defined(ASIO_WINDOWS)
-       //   && !defined(ASIO_WINDOWS_RUNTIME)
-       //   && !defined(__CYGWIN__)
-    next_(0),
-    prev_(0)
-{
-  get_signal_state()->mutex_.init();
-
-#if !defined(ASIO_WINDOWS) \
-  && !defined(ASIO_WINDOWS_RUNTIME) \
-  && !defined(__CYGWIN__)
-  reactor_.init_task();
-#endif // !defined(ASIO_WINDOWS)
-       //   && !defined(ASIO_WINDOWS_RUNTIME)
-       //   && !defined(__CYGWIN__)
-
-  for (int i = 0; i < max_signal_number; ++i)
-    registrations_[i] = 0;
-
-  add_service(this);
-}
-
-signal_set_service::~signal_set_service()
-{
-  remove_service(this);
-}
-
-void signal_set_service::shutdown_service()
-{
-  remove_service(this);
-
-  op_queue<operation> ops;
-
-  for (int i = 0; i < max_signal_number; ++i)
-  {
-    registration* reg = registrations_[i];
-    while (reg)
-    {
-      ops.push(*reg->queue_);
-      reg = reg->next_in_table_;
-    }
-  }
-
-  io_service_.abandon_operations(ops);
-}
-
-void signal_set_service::fork_service(
-    asio::io_service::fork_event fork_ev)
-{
-#if !defined(ASIO_WINDOWS) \
-  && !defined(ASIO_WINDOWS_RUNTIME) \
-  && !defined(__CYGWIN__)
-  signal_state* state = get_signal_state();
-  static_mutex::scoped_lock lock(state->mutex_);
-
-  switch (fork_ev)
-  {
-  case asio::io_service::fork_prepare:
-    {
-      int read_descriptor = state->read_descriptor_;
-      state->fork_prepared_ = true;
-      lock.unlock();
-      reactor_.deregister_internal_descriptor(read_descriptor, reactor_data_);
-    }
-    break;
-  case asio::io_service::fork_parent:
-    if (state->fork_prepared_)
-    {
-      int read_descriptor = state->read_descriptor_;
-      state->fork_prepared_ = false;
-      lock.unlock();
-      reactor_.register_internal_descriptor(reactor::read_op,
-          read_descriptor, reactor_data_, new pipe_read_op);
-    }
-    break;
-  case asio::io_service::fork_child:
-    if (state->fork_prepared_)
-    {
-      asio::detail::signal_blocker blocker;
-      close_descriptors();
-      open_descriptors();
-      int read_descriptor = state->read_descriptor_;
-      state->fork_prepared_ = false;
-      lock.unlock();
-      reactor_.register_internal_descriptor(reactor::read_op,
-          read_descriptor, reactor_data_, new pipe_read_op);
-    }
-    break;
-  default:
-    break;
-  }
-#else // !defined(ASIO_WINDOWS)
-      //   && !defined(ASIO_WINDOWS_RUNTIME)
-      //   && !defined(__CYGWIN__)
-  (void)fork_ev;
-#endif // !defined(ASIO_WINDOWS)
-       //   && !defined(ASIO_WINDOWS_RUNTIME)
-       //   && !defined(__CYGWIN__)
-}
-
-void signal_set_service::construct(
-    signal_set_service::implementation_type& impl)
-{
-  impl.signals_ = 0;
-}
-
-void signal_set_service::destroy(
-    signal_set_service::implementation_type& impl)
-{
-  asio::error_code ignored_ec;
-  clear(impl, ignored_ec);
-  cancel(impl, ignored_ec);
-}
-
-asio::error_code signal_set_service::add(
-    signal_set_service::implementation_type& impl,
-    int signal_number, asio::error_code& ec)
-{
-  // Check that the signal number is valid.
-  if (signal_number < 0 || signal_number > max_signal_number)
-  {
-    ec = asio::error::invalid_argument;
-    return ec;
-  }
-
-  signal_state* state = get_signal_state();
-  static_mutex::scoped_lock lock(state->mutex_);
-
-  // Find the appropriate place to insert the registration.
-  registration** insertion_point = &impl.signals_;
-  registration* next = impl.signals_;
-  while (next && next->signal_number_ < signal_number)
-  {
-    insertion_point = &next->next_in_set_;
-    next = next->next_in_set_;
-  }
-
-  // Only do something if the signal is not already registered.
-  if (next == 0 || next->signal_number_ != signal_number)
-  {
-    registration* new_registration = new registration;
-
-#if defined(ASIO_HAS_SIGNAL) || defined(ASIO_HAS_SIGACTION)
-    // Register for the signal if we're the first.
-    if (state->registration_count_[signal_number] == 0)
-    {
-# if defined(ASIO_HAS_SIGACTION)
-      using namespace std; // For memset.
-      struct sigaction sa;
-      memset(&sa, 0, sizeof(sa));
-      sa.sa_handler = asio_signal_handler;
-      sigfillset(&sa.sa_mask);
-      if (::sigaction(signal_number, &sa, 0) == -1)
-# else // defined(ASIO_HAS_SIGACTION)
-      if (::signal(signal_number, asio_signal_handler) == SIG_ERR)
-# endif // defined(ASIO_HAS_SIGACTION)
-      {
-# if defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-        ec = asio::error::invalid_argument;
-# else // defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-        ec = asio::error_code(errno,
-            asio::error::get_system_category());
-# endif // defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-        delete new_registration;
-        return ec;
-      }
-    }
-#endif // defined(ASIO_HAS_SIGNAL) || defined(ASIO_HAS_SIGACTION)
-
-    // Record the new registration in the set.
-    new_registration->signal_number_ = signal_number;
-    new_registration->queue_ = &impl.queue_;
-    new_registration->next_in_set_ = next;
-    *insertion_point = new_registration;
-
-    // Insert registration into the registration table.
-    new_registration->next_in_table_ = registrations_[signal_number];
-    if (registrations_[signal_number])
-      registrations_[signal_number]->prev_in_table_ = new_registration;
-    registrations_[signal_number] = new_registration;
-
-    ++state->registration_count_[signal_number];
-  }
-
-  ec = asio::error_code();
-  return ec;
-}
-
-asio::error_code signal_set_service::remove(
-    signal_set_service::implementation_type& impl,
-    int signal_number, asio::error_code& ec)
-{
-  // Check that the signal number is valid.
-  if (signal_number < 0 || signal_number > max_signal_number)
-  {
-    ec = asio::error::invalid_argument;
-    return ec;
-  }
-
-  signal_state* state = get_signal_state();
-  static_mutex::scoped_lock lock(state->mutex_);
-
-  // Find the signal number in the list of registrations.
-  registration** deletion_point = &impl.signals_;
-  registration* reg = impl.signals_;
-  while (reg && reg->signal_number_ < signal_number)
-  {
-    deletion_point = &reg->next_in_set_;
-    reg = reg->next_in_set_;
-  }
-
-  if (reg != 0 && reg->signal_number_ == signal_number)
-  {
-#if defined(ASIO_HAS_SIGNAL) || defined(ASIO_HAS_SIGACTION)
-    // Set signal handler back to the default if we're the last.
-    if (state->registration_count_[signal_number] == 1)
-    {
-# if defined(ASIO_HAS_SIGACTION)
-      using namespace std; // For memset.
-      struct sigaction sa;
-      memset(&sa, 0, sizeof(sa));
-      sa.sa_handler = SIG_DFL;
-      if (::sigaction(signal_number, &sa, 0) == -1)
-# else // defined(ASIO_HAS_SIGACTION)
-      if (::signal(signal_number, SIG_DFL) == SIG_ERR)
-# endif // defined(ASIO_HAS_SIGACTION)
-      {
-# if defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-        ec = asio::error::invalid_argument;
-# else // defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-        ec = asio::error_code(errno,
-            asio::error::get_system_category());
-# endif // defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-        return ec;
-      }
-    }
-#endif // defined(ASIO_HAS_SIGNAL) || defined(ASIO_HAS_SIGACTION)
-
-    // Remove the registration from the set.
-    *deletion_point = reg->next_in_set_;
-
-    // Remove the registration from the registration table.
-    if (registrations_[signal_number] == reg)
-      registrations_[signal_number] = reg->next_in_table_;
-    if (reg->prev_in_table_)
-      reg->prev_in_table_->next_in_table_ = reg->next_in_table_;
-    if (reg->next_in_table_)
-      reg->next_in_table_->prev_in_table_ = reg->prev_in_table_;
-
-    --state->registration_count_[signal_number];
-
-    delete reg;
-  }
-
-  ec = asio::error_code();
-  return ec;
-}
-
-asio::error_code signal_set_service::clear(
-    signal_set_service::implementation_type& impl,
-    asio::error_code& ec)
-{
-  signal_state* state = get_signal_state();
-  static_mutex::scoped_lock lock(state->mutex_);
-
-  while (registration* reg = impl.signals_)
-  {
-#if defined(ASIO_HAS_SIGNAL) || defined(ASIO_HAS_SIGACTION)
-    // Set signal handler back to the default if we're the last.
-    if (state->registration_count_[reg->signal_number_] == 1)
-    {
-# if defined(ASIO_HAS_SIGACTION)
-      using namespace std; // For memset.
-      struct sigaction sa;
-      memset(&sa, 0, sizeof(sa));
-      sa.sa_handler = SIG_DFL;
-      if (::sigaction(reg->signal_number_, &sa, 0) == -1)
-# else // defined(ASIO_HAS_SIGACTION)
-      if (::signal(reg->signal_number_, SIG_DFL) == SIG_ERR)
-# endif // defined(ASIO_HAS_SIGACTION)
-      {
-# if defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-        ec = asio::error::invalid_argument;
-# else // defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-        ec = asio::error_code(errno,
-            asio::error::get_system_category());
-# endif // defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-        return ec;
-      }
-    }
-#endif // defined(ASIO_HAS_SIGNAL) || defined(ASIO_HAS_SIGACTION)
-
-    // Remove the registration from the registration table.
-    if (registrations_[reg->signal_number_] == reg)
-      registrations_[reg->signal_number_] = reg->next_in_table_;
-    if (reg->prev_in_table_)
-      reg->prev_in_table_->next_in_table_ = reg->next_in_table_;
-    if (reg->next_in_table_)
-      reg->next_in_table_->prev_in_table_ = reg->prev_in_table_;
-
-    --state->registration_count_[reg->signal_number_];
-
-    impl.signals_ = reg->next_in_set_;
-    delete reg;
-  }
-
-  ec = asio::error_code();
-  return ec;
-}
-
-asio::error_code signal_set_service::cancel(
-    signal_set_service::implementation_type& impl,
-    asio::error_code& ec)
-{
-  ASIO_HANDLER_OPERATION(("signal_set", &impl, "cancel"));
-
-  op_queue<operation> ops;
-  {
-    signal_state* state = get_signal_state();
-    static_mutex::scoped_lock lock(state->mutex_);
-
-    while (signal_op* op = impl.queue_.front())
-    {
-      op->ec_ = asio::error::operation_aborted;
-      impl.queue_.pop();
-      ops.push(op);
-    }
-  }
-
-  io_service_.post_deferred_completions(ops);
-
-  ec = asio::error_code();
-  return ec;
-}
-
-void signal_set_service::deliver_signal(int signal_number)
-{
-  signal_state* state = get_signal_state();
-  static_mutex::scoped_lock lock(state->mutex_);
-
-  signal_set_service* service = state->service_list_;
-  while (service)
-  {
-    op_queue<operation> ops;
-
-    registration* reg = service->registrations_[signal_number];
-    while (reg)
-    {
-      if (reg->queue_->empty())
-      {
-        ++reg->undelivered_;
-      }
-      else
-      {
-        while (signal_op* op = reg->queue_->front())
-        {
-          op->signal_number_ = signal_number;
-          reg->queue_->pop();
-          ops.push(op);
-        }
-      }
-
-      reg = reg->next_in_table_;
-    }
-
-    service->io_service_.post_deferred_completions(ops);
-
-    service = service->next_;
-  }
-}
-
-void signal_set_service::add_service(signal_set_service* service)
-{
-  signal_state* state = get_signal_state();
-  static_mutex::scoped_lock lock(state->mutex_);
-
-#if !defined(ASIO_WINDOWS) && !defined(__CYGWIN__)
-  // If this is the first service to be created, open a new pipe.
-  if (state->service_list_ == 0)
-    open_descriptors();
-#endif // !defined(ASIO_WINDOWS) && !defined(__CYGWIN__)
-
-  // Insert service into linked list of all services.
-  service->next_ = state->service_list_;
-  service->prev_ = 0;
-  if (state->service_list_)
-    state->service_list_->prev_ = service;
-  state->service_list_ = service;
-
-#if !defined(ASIO_WINDOWS) \
-  && !defined(ASIO_WINDOWS_RUNTIME) \
-  && !defined(__CYGWIN__)
-  // Register for pipe readiness notifications.
-  int read_descriptor = state->read_descriptor_;
-  lock.unlock();
-  service->reactor_.register_internal_descriptor(reactor::read_op,
-      read_descriptor, service->reactor_data_, new pipe_read_op);
-#endif // !defined(ASIO_WINDOWS)
-       //   && !defined(ASIO_WINDOWS_RUNTIME)
-       //   && !defined(__CYGWIN__)
-}
-
-void signal_set_service::remove_service(signal_set_service* service)
-{
-  signal_state* state = get_signal_state();
-  static_mutex::scoped_lock lock(state->mutex_);
-
-  if (service->next_ || service->prev_ || state->service_list_ == service)
-  {
-#if !defined(ASIO_WINDOWS) \
-  && !defined(ASIO_WINDOWS_RUNTIME) \
-  && !defined(__CYGWIN__)
-    // Disable the pipe readiness notifications.
-    int read_descriptor = state->read_descriptor_;
-    lock.unlock();
-    service->reactor_.deregister_descriptor(
-        read_descriptor, service->reactor_data_, false);
-    lock.lock();
-#endif // !defined(ASIO_WINDOWS)
-       //   && !defined(ASIO_WINDOWS_RUNTIME)
-       //   && !defined(__CYGWIN__)
-
-    // Remove service from linked list of all services.
-    if (state->service_list_ == service)
-      state->service_list_ = service->next_;
-    if (service->prev_)
-      service->prev_->next_ = service->next_;
-    if (service->next_)
-      service->next_->prev_= service->prev_;
-    service->next_ = 0;
-    service->prev_ = 0;
-
-#if !defined(ASIO_WINDOWS) && !defined(__CYGWIN__)
-    // If this is the last service to be removed, close the pipe.
-    if (state->service_list_ == 0)
-      close_descriptors();
-#endif // !defined(ASIO_WINDOWS) && !defined(__CYGWIN__)
-  }
-}
-
-void signal_set_service::open_descriptors()
-{
-#if !defined(ASIO_WINDOWS) \
-  && !defined(ASIO_WINDOWS_RUNTIME) \
-  && !defined(__CYGWIN__)
-  signal_state* state = get_signal_state();
-
-  int pipe_fds[2];
-  if (::pipe(pipe_fds) == 0)
-  {
-    state->read_descriptor_ = pipe_fds[0];
-    ::fcntl(state->read_descriptor_, F_SETFL, O_NONBLOCK);
-
-    state->write_descriptor_ = pipe_fds[1];
-    ::fcntl(state->write_descriptor_, F_SETFL, O_NONBLOCK);
-
-#if defined(FD_CLOEXEC)
-    ::fcntl(state->read_descriptor_, F_SETFD, FD_CLOEXEC);
-    ::fcntl(state->write_descriptor_, F_SETFD, FD_CLOEXEC);
-#endif // defined(FD_CLOEXEC)
-  }
-  else
-  {
-    asio::error_code ec(errno,
-        asio::error::get_system_category());
-    asio::detail::throw_error(ec, "signal_set_service pipe");
-  }
-#endif // !defined(ASIO_WINDOWS)
-       //   && !defined(ASIO_WINDOWS_RUNTIME)
-       //   && !defined(__CYGWIN__)
-}
-
-void signal_set_service::close_descriptors()
-{
-#if !defined(ASIO_WINDOWS) \
-  && !defined(ASIO_WINDOWS_RUNTIME) \
-  && !defined(__CYGWIN__)
-  signal_state* state = get_signal_state();
-
-  if (state->read_descriptor_ != -1)
-    ::close(state->read_descriptor_);
-  state->read_descriptor_ = -1;
-
-  if (state->write_descriptor_ != -1)
-    ::close(state->write_descriptor_);
-  state->write_descriptor_ = -1;
-#endif // !defined(ASIO_WINDOWS)
-       //   && !defined(ASIO_WINDOWS_RUNTIME)
-       //   && !defined(__CYGWIN__)
-}
-
-void signal_set_service::start_wait_op(
-    signal_set_service::implementation_type& impl, signal_op* op)
-{
-  io_service_.work_started();
-
-  signal_state* state = get_signal_state();
-  static_mutex::scoped_lock lock(state->mutex_);
-
-  registration* reg = impl.signals_;
-  while (reg)
-  {
-    if (reg->undelivered_ > 0)
-    {
-      --reg->undelivered_;
-      op->signal_number_ = reg->signal_number_;
-      io_service_.post_deferred_completion(op);
-      return;
-    }
-
-    reg = reg->next_in_set_;
-  }
-
-  impl.queue_.push(op);
-}
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_DETAIL_IMPL_SIGNAL_SET_SERVICE_IPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/socket_ops.ipp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/socket_ops.ipp
deleted file mode 100644
index c6012103cc22..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/socket_ops.ipp
+++ /dev/null
@@ -1,3394 +0,0 @@
-//
-// detail/impl/socket_ops.ipp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_SOCKET_OPS_IPP
-#define ASIO_DETAIL_SOCKET_OPS_IPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#include <cctype>
-#include <cstdio>
-#include <cstdlib>
-#include <cstring>
-#include <cerrno>
-#include <new>
-#include "asio/detail/assert.hpp"
-#include "asio/detail/socket_ops.hpp"
-#include "asio/error.hpp"
-
-#if defined(ASIO_WINDOWS_RUNTIME)
-# include <codecvt>
-# include <locale>
-# include <string>
-#endif // defined(ASIO_WINDOWS_RUNTIME)
-
-#if defined(ASIO_WINDOWS) || defined(__CYGWIN__) \
-  || defined(__MACH__) && defined(__APPLE__)
-# if defined(ASIO_HAS_PTHREADS)
-#  include <pthread.h>
-# endif // defined(ASIO_HAS_PTHREADS)
-#endif // defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-       // || defined(__MACH__) && defined(__APPLE__)
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-namespace socket_ops {
-
-#if !defined(ASIO_WINDOWS_RUNTIME)
-
-#if defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-struct msghdr { int msg_namelen; };
-#endif // defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-
-#if defined(__hpux)
-// HP-UX doesn't declare these functions extern "C", so they are declared again
-// here to avoid linker errors about undefined symbols.
-extern "C" char* if_indextoname(unsigned int, char*);
-extern "C" unsigned int if_nametoindex(const char*);
-#endif // defined(__hpux)
-
-#endif // !defined(ASIO_WINDOWS_RUNTIME)
-
-inline void clear_last_error()
-{
-#if defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-  WSASetLastError(0);
-#else
-  errno = 0;
-#endif
-}
-
-#if !defined(ASIO_WINDOWS_RUNTIME)
-
-template <typename ReturnType>
-inline ReturnType error_wrapper(ReturnType return_value,
-    asio::error_code& ec)
-{
-#if defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-  ec = asio::error_code(WSAGetLastError(),
-      asio::error::get_system_category());
-#else
-  ec = asio::error_code(errno,
-      asio::error::get_system_category());
-#endif
-  return return_value;
-}
-
-template <typename SockLenType>
-inline socket_type call_accept(SockLenType msghdr::*,
-    socket_type s, socket_addr_type* addr, std::size_t* addrlen)
-{
-  SockLenType tmp_addrlen = addrlen ? (SockLenType)*addrlen : 0;
-  socket_type result = ::accept(s, addr, addrlen ? &tmp_addrlen : 0);
-  if (addrlen)
-    *addrlen = (std::size_t)tmp_addrlen;
-  return result;
-}
-
-socket_type accept(socket_type s, socket_addr_type* addr,
-    std::size_t* addrlen, asio::error_code& ec)
-{
-  if (s == invalid_socket)
-  {
-    ec = asio::error::bad_descriptor;
-    return invalid_socket;
-  }
-
-  clear_last_error();
-
-  socket_type new_s = error_wrapper(call_accept(
-        &msghdr::msg_namelen, s, addr, addrlen), ec);
-  if (new_s == invalid_socket)
-    return new_s;
-
-#if defined(__MACH__) && defined(__APPLE__) || defined(__FreeBSD__)
-  int optval = 1;
-  int result = error_wrapper(::setsockopt(new_s,
-        SOL_SOCKET, SO_NOSIGPIPE, &optval, sizeof(optval)), ec);
-  if (result != 0)
-  {
-    ::close(new_s);
-    return invalid_socket;
-  }
-#endif
-
-  ec = asio::error_code();
-  return new_s;
-}
-
-socket_type sync_accept(socket_type s, state_type state,
-    socket_addr_type* addr, std::size_t* addrlen, asio::error_code& ec)
-{
-  // Accept a socket.
-  for (;;)
-  {
-    // Try to complete the operation without blocking.
-    socket_type new_socket = socket_ops::accept(s, addr, addrlen, ec);
-
-    // Check if operation succeeded.
-    if (new_socket != invalid_socket)
-      return new_socket;
-
-    // Operation failed.
-    if (ec == asio::error::would_block
-        || ec == asio::error::try_again)
-    {
-      if (state & user_set_non_blocking)
-        return invalid_socket;
-      // Fall through to retry operation.
-    }
-    else if (ec == asio::error::connection_aborted)
-    {
-      if (state & enable_connection_aborted)
-        return invalid_socket;
-      // Fall through to retry operation.
-    }
-#if defined(EPROTO)
-    else if (ec.value() == EPROTO)
-    {
-      if (state & enable_connection_aborted)
-        return invalid_socket;
-      // Fall through to retry operation.
-    }
-#endif // defined(EPROTO)
-    else
-      return invalid_socket;
-
-    // Wait for socket to become ready.
-    if (socket_ops::poll_read(s, 0, ec) < 0)
-      return invalid_socket;
-  }
-}
-
-#if defined(ASIO_HAS_IOCP)
-
-void complete_iocp_accept(socket_type s,
-    void* output_buffer, DWORD address_length,
-    socket_addr_type* addr, std::size_t* addrlen,
-    socket_type new_socket, asio::error_code& ec)
-{
-  // Map non-portable errors to their portable counterparts.
-  if (ec.value() == ERROR_NETNAME_DELETED)
-    ec = asio::error::connection_aborted;
-
-  if (!ec)
-  {
-    // Get the address of the peer.
-    if (addr && addrlen)
-    {
-      LPSOCKADDR local_addr = 0;
-      int local_addr_length = 0;
-      LPSOCKADDR remote_addr = 0;
-      int remote_addr_length = 0;
-      GetAcceptExSockaddrs(output_buffer, 0, address_length,
-          address_length, &local_addr, &local_addr_length,
-          &remote_addr, &remote_addr_length);
-      if (static_cast<std::size_t>(remote_addr_length) > *addrlen)
-      {
-        ec = asio::error::invalid_argument;
-      }
-      else
-      {
-        using namespace std; // For memcpy.
-        memcpy(addr, remote_addr, remote_addr_length);
-        *addrlen = static_cast<std::size_t>(remote_addr_length);
-      }
-    }
-
-    // Need to set the SO_UPDATE_ACCEPT_CONTEXT option so that getsockname
-    // and getpeername will work on the accepted socket.
-    SOCKET update_ctx_param = s;
-    socket_ops::state_type state = 0;
-    socket_ops::setsockopt(new_socket, state,
-          SOL_SOCKET, SO_UPDATE_ACCEPT_CONTEXT,
-          &update_ctx_param, sizeof(SOCKET), ec);
-  }
-}
-
-#else // defined(ASIO_HAS_IOCP)
-
-bool non_blocking_accept(socket_type s,
-    state_type state, socket_addr_type* addr, std::size_t* addrlen,
-    asio::error_code& ec, socket_type& new_socket)
-{
-  for (;;)
-  {
-    // Accept the waiting connection.
-    new_socket = socket_ops::accept(s, addr, addrlen, ec);
-
-    // Check if operation succeeded.
-    if (new_socket != invalid_socket)
-      return true;
-
-    // Retry operation if interrupted by signal.
-    if (ec == asio::error::interrupted)
-      continue;
-
-    // Operation failed.
-    if (ec == asio::error::would_block
-        || ec == asio::error::try_again)
-    {
-      if (state & user_set_non_blocking)
-        return true;
-      // Fall through to retry operation.
-    }
-    else if (ec == asio::error::connection_aborted)
-    {
-      if (state & enable_connection_aborted)
-        return true;
-      // Fall through to retry operation.
-    }
-#if defined(EPROTO)
-    else if (ec.value() == EPROTO)
-    {
-      if (state & enable_connection_aborted)
-        return true;
-      // Fall through to retry operation.
-    }
-#endif // defined(EPROTO)
-    else
-      return true;
-
-    return false;
-  }
-}
-
-#endif // defined(ASIO_HAS_IOCP)
-
-template <typename SockLenType>
-inline int call_bind(SockLenType msghdr::*,
-    socket_type s, const socket_addr_type* addr, std::size_t addrlen)
-{
-  return ::bind(s, addr, (SockLenType)addrlen);
-}
-
-int bind(socket_type s, const socket_addr_type* addr,
-    std::size_t addrlen, asio::error_code& ec)
-{
-  if (s == invalid_socket)
-  {
-    ec = asio::error::bad_descriptor;
-    return socket_error_retval;
-  }
-
-  clear_last_error();
-  int result = error_wrapper(call_bind(
-        &msghdr::msg_namelen, s, addr, addrlen), ec);
-  if (result == 0)
-    ec = asio::error_code();
-  return result;
-}
-
-int close(socket_type s, state_type& state,
-    bool destruction, asio::error_code& ec)
-{
-  int result = 0;
-  if (s != invalid_socket)
-  {
-    // We don't want the destructor to block, so set the socket to linger in
-    // the background. If the user doesn't like this behaviour then they need
-    // to explicitly close the socket.
-    if (destruction && (state & user_set_linger))
-    {
-      ::linger opt;
-      opt.l_onoff = 0;
-      opt.l_linger = 0;
-      asio::error_code ignored_ec;
-      socket_ops::setsockopt(s, state, SOL_SOCKET,
-          SO_LINGER, &opt, sizeof(opt), ignored_ec);
-    }
-
-    clear_last_error();
-#if defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-    result = error_wrapper(::closesocket(s), ec);
-#else // defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-    result = error_wrapper(::close(s), ec);
-#endif // defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-
-    if (result != 0
-        && (ec == asio::error::would_block
-          || ec == asio::error::try_again))
-    {
-      // According to UNIX Network Programming Vol. 1, it is possible for
-      // close() to fail with EWOULDBLOCK under certain circumstances. What
-      // isn't clear is the state of the descriptor after this error. The one
-      // current OS where this behaviour is seen, Windows, says that the socket
-      // remains open. Therefore we'll put the descriptor back into blocking
-      // mode and have another attempt at closing it.
-#if defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-      ioctl_arg_type arg = 0;
-      ::ioctlsocket(s, FIONBIO, &arg);
-#else // defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-# if defined(__SYMBIAN32__)
-      int flags = ::fcntl(s, F_GETFL, 0);
-      if (flags >= 0)
-        ::fcntl(s, F_SETFL, flags & ~O_NONBLOCK);
-# else // defined(__SYMBIAN32__)
-      ioctl_arg_type arg = 0;
-      ::ioctl(s, FIONBIO, &arg);
-# endif // defined(__SYMBIAN32__)
-#endif // defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-      state &= ~non_blocking;
-
-      clear_last_error();
-#if defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-      result = error_wrapper(::closesocket(s), ec);
-#else // defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-      result = error_wrapper(::close(s), ec);
-#endif // defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-    }
-  }
-
-  if (result == 0)
-    ec = asio::error_code();
-  return result;
-}
-
-bool set_user_non_blocking(socket_type s,
-    state_type& state, bool value, asio::error_code& ec)
-{
-  if (s == invalid_socket)
-  {
-    ec = asio::error::bad_descriptor;
-    return false;
-  }
-
-  clear_last_error();
-#if defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-  ioctl_arg_type arg = (value ? 1 : 0);
-  int result = error_wrapper(::ioctlsocket(s, FIONBIO, &arg), ec);
-#elif defined(__SYMBIAN32__)
-  int result = error_wrapper(::fcntl(s, F_GETFL, 0), ec);
-  if (result >= 0)
-  {
-    clear_last_error();
-    int flag = (value ? (result | O_NONBLOCK) : (result & ~O_NONBLOCK));
-    result = error_wrapper(::fcntl(s, F_SETFL, flag), ec);
-  }
-#else
-  ioctl_arg_type arg = (value ? 1 : 0);
-  int result = error_wrapper(::ioctl(s, FIONBIO, &arg), ec);
-#endif
-
-  if (result >= 0)
-  {
-    ec = asio::error_code();
-    if (value)
-      state |= user_set_non_blocking;
-    else
-    {
-      // Clearing the user-set non-blocking mode always overrides any
-      // internally-set non-blocking flag. Any subsequent asynchronous
-      // operations will need to re-enable non-blocking I/O.
-      state &= ~(user_set_non_blocking | internal_non_blocking);
-    }
-    return true;
-  }
-
-  return false;
-}
-
-bool set_internal_non_blocking(socket_type s,
-    state_type& state, bool value, asio::error_code& ec)
-{
-  if (s == invalid_socket)
-  {
-    ec = asio::error::bad_descriptor;
-    return false;
-  }
-
-  if (!value && (state & user_set_non_blocking))
-  {
-    // It does not make sense to clear the internal non-blocking flag if the
-    // user still wants non-blocking behaviour. Return an error and let the
-    // caller figure out whether to update the user-set non-blocking flag.
-    ec = asio::error::invalid_argument;
-    return false;
-  }
-
-  clear_last_error();
-#if defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-  ioctl_arg_type arg = (value ? 1 : 0);
-  int result = error_wrapper(::ioctlsocket(s, FIONBIO, &arg), ec);
-#elif defined(__SYMBIAN32__)
-  int result = error_wrapper(::fcntl(s, F_GETFL, 0), ec);
-  if (result >= 0)
-  {
-    clear_last_error();
-    int flag = (value ? (result | O_NONBLOCK) : (result & ~O_NONBLOCK));
-    result = error_wrapper(::fcntl(s, F_SETFL, flag), ec);
-  }
-#else
-  ioctl_arg_type arg = (value ? 1 : 0);
-  int result = error_wrapper(::ioctl(s, FIONBIO, &arg), ec);
-#endif
-
-  if (result >= 0)
-  {
-    ec = asio::error_code();
-    if (value)
-      state |= internal_non_blocking;
-    else
-      state &= ~internal_non_blocking;
-    return true;
-  }
-
-  return false;
-}
-
-int shutdown(socket_type s, int what, asio::error_code& ec)
-{
-  if (s == invalid_socket)
-  {
-    ec = asio::error::bad_descriptor;
-    return socket_error_retval;
-  }
-
-  clear_last_error();
-  int result = error_wrapper(::shutdown(s, what), ec);
-  if (result == 0)
-    ec = asio::error_code();
-  return result;
-}
-
-template <typename SockLenType>
-inline int call_connect(SockLenType msghdr::*,
-    socket_type s, const socket_addr_type* addr, std::size_t addrlen)
-{
-  return ::connect(s, addr, (SockLenType)addrlen);
-}
-
-int connect(socket_type s, const socket_addr_type* addr,
-    std::size_t addrlen, asio::error_code& ec)
-{
-  if (s == invalid_socket)
-  {
-    ec = asio::error::bad_descriptor;
-    return socket_error_retval;
-  }
-
-  clear_last_error();
-  int result = error_wrapper(call_connect(
-        &msghdr::msg_namelen, s, addr, addrlen), ec);
-  if (result == 0)
-    ec = asio::error_code();
-#if defined(__linux__)
-  else if (ec == asio::error::try_again)
-    ec = asio::error::no_buffer_space;
-#endif // defined(__linux__)
-  return result;
-}
-
-void sync_connect(socket_type s, const socket_addr_type* addr,
-    std::size_t addrlen, asio::error_code& ec)
-{
-  // Perform the connect operation.
-  socket_ops::connect(s, addr, addrlen, ec);
-  if (ec != asio::error::in_progress
-      && ec != asio::error::would_block)
-  {
-    // The connect operation finished immediately.
-    return;
-  }
-
-  // Wait for socket to become ready.
-  if (socket_ops::poll_connect(s, ec) < 0)
-    return;
-
-  // Get the error code from the connect operation.
-  int connect_error = 0;
-  size_t connect_error_len = sizeof(connect_error);
-  if (socket_ops::getsockopt(s, 0, SOL_SOCKET, SO_ERROR,
-        &connect_error, &connect_error_len, ec) == socket_error_retval)
-    return;
-
-  // Return the result of the connect operation.
-  ec = asio::error_code(connect_error,
-      asio::error::get_system_category());
-}
-
-#if defined(ASIO_HAS_IOCP)
-
-void complete_iocp_connect(socket_type s, asio::error_code& ec)
-{
-  if (!ec)
-  {
-    // Need to set the SO_UPDATE_CONNECT_CONTEXT option so that getsockname
-    // and getpeername will work on the connected socket.
-    socket_ops::state_type state = 0;
-    socket_ops::setsockopt(s, state, SOL_SOCKET,
-        SO_UPDATE_CONNECT_CONTEXT, 0, 0, ec);
-  }
-}
-
-#endif // defined(ASIO_HAS_IOCP)
-
-bool non_blocking_connect(socket_type s, asio::error_code& ec)
-{
-  // Check if the connect operation has finished. This is required since we may
-  // get spurious readiness notifications from the reactor.
-#if defined(ASIO_WINDOWS) \
-  || defined(__CYGWIN__) \
-  || defined(__SYMBIAN32__)
-  fd_set write_fds;
-  FD_ZERO(&write_fds);
-  FD_SET(s, &write_fds);
-  fd_set except_fds;
-  FD_ZERO(&except_fds);
-  FD_SET(s, &except_fds);
-  timeval zero_timeout;
-  zero_timeout.tv_sec = 0;
-  zero_timeout.tv_usec = 0;
-  int ready = ::select(s + 1, 0, &write_fds, &except_fds, &zero_timeout);
-#else // defined(ASIO_WINDOWS)
-      // || defined(__CYGWIN__)
-      // || defined(__SYMBIAN32__)
-  pollfd fds;
-  fds.fd = s;
-  fds.events = POLLOUT;
-  fds.revents = 0;
-  int ready = ::poll(&fds, 1, 0);
-#endif // defined(ASIO_WINDOWS)
-       // || defined(__CYGWIN__)
-       // || defined(__SYMBIAN32__)
-  if (ready == 0)
-  {
-    // The asynchronous connect operation is still in progress.
-    return false;
-  }
-
-  // Get the error code from the connect operation.
-  int connect_error = 0;
-  size_t connect_error_len = sizeof(connect_error);
-  if (socket_ops::getsockopt(s, 0, SOL_SOCKET, SO_ERROR,
-        &connect_error, &connect_error_len, ec) == 0)
-  {
-    if (connect_error)
-    {
-      ec = asio::error_code(connect_error,
-          asio::error::get_system_category());
-    }
-    else
-      ec = asio::error_code();
-  }
-
-  return true;
-}
-
-int socketpair(int af, int type, int protocol,
-    socket_type sv[2], asio::error_code& ec)
-{
-#if defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-  (void)(af);
-  (void)(type);
-  (void)(protocol);
-  (void)(sv);
-  ec = asio::error::operation_not_supported;
-  return socket_error_retval;
-#else
-  clear_last_error();
-  int result = error_wrapper(::socketpair(af, type, protocol, sv), ec);
-  if (result == 0)
-    ec = asio::error_code();
-  return result;
-#endif
-}
-
-bool sockatmark(socket_type s, asio::error_code& ec)
-{
-  if (s == invalid_socket)
-  {
-    ec = asio::error::bad_descriptor;
-    return false;
-  }
-
-#if defined(SIOCATMARK)
-  ioctl_arg_type value = 0;
-# if defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-  int result = error_wrapper(::ioctlsocket(s, SIOCATMARK, &value), ec);
-# else // defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-  int result = error_wrapper(::ioctl(s, SIOCATMARK, &value), ec);
-# endif // defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-  if (result == 0)
-    ec = asio::error_code();
-# if defined(ENOTTY)
-  if (ec.value() == ENOTTY)
-    ec = asio::error::not_socket;
-# endif // defined(ENOTTY)
-#else // defined(SIOCATMARK)
-  int value = error_wrapper(::sockatmark(s), ec);
-  if (value != -1)
-    ec = asio::error_code();
-#endif // defined(SIOCATMARK)
-
-  return ec ? false : value != 0;
-}
-
-size_t available(socket_type s, asio::error_code& ec)
-{
-  if (s == invalid_socket)
-  {
-    ec = asio::error::bad_descriptor;
-    return 0;
-  }
-
-  ioctl_arg_type value = 0;
-#if defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-  int result = error_wrapper(::ioctlsocket(s, FIONREAD, &value), ec);
-#else // defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-  int result = error_wrapper(::ioctl(s, FIONREAD, &value), ec);
-#endif // defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-  if (result == 0)
-    ec = asio::error_code();
-#if defined(ENOTTY)
-  if (ec.value() == ENOTTY)
-    ec = asio::error::not_socket;
-#endif // defined(ENOTTY)
-
-  return ec ? static_cast<size_t>(0) : static_cast<size_t>(value);
-}
-
-int listen(socket_type s, int backlog, asio::error_code& ec)
-{
-  if (s == invalid_socket)
-  {
-    ec = asio::error::bad_descriptor;
-    return socket_error_retval;
-  }
-
-  clear_last_error();
-  int result = error_wrapper(::listen(s, backlog), ec);
-  if (result == 0)
-    ec = asio::error_code();
-  return result;
-}
-
-inline void init_buf_iov_base(void*& base, void* addr)
-{
-  base = addr;
-}
-
-template <typename T>
-inline void init_buf_iov_base(T& base, void* addr)
-{
-  base = static_cast<T>(addr);
-}
-
-#if defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-typedef WSABUF buf;
-#else // defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-typedef iovec buf;
-#endif // defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-
-void init_buf(buf& b, void* data, size_t size)
-{
-#if defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-  b.buf = static_cast<char*>(data);
-  b.len = static_cast<u_long>(size);
-#else // defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-  init_buf_iov_base(b.iov_base, data);
-  b.iov_len = size;
-#endif // defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-}
-
-void init_buf(buf& b, const void* data, size_t size)
-{
-#if defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-  b.buf = static_cast<char*>(const_cast<void*>(data));
-  b.len = static_cast<u_long>(size);
-#else // defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-  init_buf_iov_base(b.iov_base, const_cast<void*>(data));
-  b.iov_len = size;
-#endif // defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-}
-
-inline void init_msghdr_msg_name(void*& name, socket_addr_type* addr)
-{
-  name = addr;
-}
-
-inline void init_msghdr_msg_name(void*& name, const socket_addr_type* addr)
-{
-  name = const_cast<socket_addr_type*>(addr);
-}
-
-template <typename T>
-inline void init_msghdr_msg_name(T& name, socket_addr_type* addr)
-{
-  name = reinterpret_cast<T>(addr);
-}
-
-template <typename T>
-inline void init_msghdr_msg_name(T& name, const socket_addr_type* addr)
-{
-  name = reinterpret_cast<T>(const_cast<socket_addr_type*>(addr));
-}
-
-signed_size_type recv(socket_type s, buf* bufs, size_t count,
-    int flags, asio::error_code& ec)
-{
-  clear_last_error();
-#if defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-  // Receive some data.
-  DWORD recv_buf_count = static_cast<DWORD>(count);
-  DWORD bytes_transferred = 0;
-  DWORD recv_flags = flags;
-  int result = error_wrapper(::WSARecv(s, bufs,
-        recv_buf_count, &bytes_transferred, &recv_flags, 0, 0), ec);
-  if (ec.value() == ERROR_NETNAME_DELETED)
-    ec = asio::error::connection_reset;
-  else if (ec.value() == ERROR_PORT_UNREACHABLE)
-    ec = asio::error::connection_refused;
-  if (result != 0)
-    return socket_error_retval;
-  ec = asio::error_code();
-  return bytes_transferred;
-#else // defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-  msghdr msg = msghdr();
-  msg.msg_iov = bufs;
-  msg.msg_iovlen = static_cast<int>(count);
-  signed_size_type result = error_wrapper(::recvmsg(s, &msg, flags), ec);
-  if (result >= 0)
-    ec = asio::error_code();
-  return result;
-#endif // defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-}
-
-size_t sync_recv(socket_type s, state_type state, buf* bufs,
-    size_t count, int flags, bool all_empty, asio::error_code& ec)
-{
-  if (s == invalid_socket)
-  {
-    ec = asio::error::bad_descriptor;
-    return 0;
-  }
-
-  // A request to read 0 bytes on a stream is a no-op.
-  if (all_empty && (state & stream_oriented))
-  {
-    ec = asio::error_code();
-    return 0;
-  }
-
-  // Read some data.
-  for (;;)
-  {
-    // Try to complete the operation without blocking.
-    signed_size_type bytes = socket_ops::recv(s, bufs, count, flags, ec);
-
-    // Check if operation succeeded.
-    if (bytes > 0)
-      return bytes;
-
-    // Check for EOF.
-    if ((state & stream_oriented) && bytes == 0)
-    {
-      ec = asio::error::eof;
-      return 0;
-    }
-
-    // Operation failed.
-    if ((state & user_set_non_blocking)
-        || (ec != asio::error::would_block
-          && ec != asio::error::try_again))
-      return 0;
-
-    // Wait for socket to become ready.
-    if (socket_ops::poll_read(s, 0, ec) < 0)
-      return 0;
-  }
-}
-
-#if defined(ASIO_HAS_IOCP)
-
-void complete_iocp_recv(state_type state,
-    const weak_cancel_token_type& cancel_token, bool all_empty,
-    asio::error_code& ec, size_t bytes_transferred)
-{
-  // Map non-portable errors to their portable counterparts.
-  if (ec.value() == ERROR_NETNAME_DELETED)
-  {
-    if (cancel_token.expired())
-      ec = asio::error::operation_aborted;
-    else
-      ec = asio::error::connection_reset;
-  }
-  else if (ec.value() == ERROR_PORT_UNREACHABLE)
-  {
-    ec = asio::error::connection_refused;
-  }
-
-  // Check for connection closed.
-  else if (!ec && bytes_transferred == 0
-      && (state & stream_oriented) != 0
-      && !all_empty)
-  {
-    ec = asio::error::eof;
-  }
-}
-
-#else // defined(ASIO_HAS_IOCP)
-
-bool non_blocking_recv(socket_type s,
-    buf* bufs, size_t count, int flags, bool is_stream,
-    asio::error_code& ec, size_t& bytes_transferred)
-{
-  for (;;)
-  {
-    // Read some data.
-    signed_size_type bytes = socket_ops::recv(s, bufs, count, flags, ec);
-
-    // Check for end of stream.
-    if (is_stream && bytes == 0)
-    {
-      ec = asio::error::eof;
-      return true;
-    }
-
-    // Retry operation if interrupted by signal.
-    if (ec == asio::error::interrupted)
-      continue;
-
-    // Check if we need to run the operation again.
-    if (ec == asio::error::would_block
-        || ec == asio::error::try_again)
-      return false;
-
-    // Operation is complete.
-    if (bytes >= 0)
-    {
-      ec = asio::error_code();
-      bytes_transferred = bytes;
-    }
-    else
-      bytes_transferred = 0;
-
-    return true;
-  }
-}
-
-#endif // defined(ASIO_HAS_IOCP)
-
-signed_size_type recvfrom(socket_type s, buf* bufs, size_t count,
-    int flags, socket_addr_type* addr, std::size_t* addrlen,
-    asio::error_code& ec)
-{
-  clear_last_error();
-#if defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-  // Receive some data.
-  DWORD recv_buf_count = static_cast<DWORD>(count);
-  DWORD bytes_transferred = 0;
-  DWORD recv_flags = flags;
-  int tmp_addrlen = (int)*addrlen;
-  int result = error_wrapper(::WSARecvFrom(s, bufs, recv_buf_count,
-        &bytes_transferred, &recv_flags, addr, &tmp_addrlen, 0, 0), ec);
-  *addrlen = (std::size_t)tmp_addrlen;
-  if (ec.value() == ERROR_NETNAME_DELETED)
-    ec = asio::error::connection_reset;
-  else if (ec.value() == ERROR_PORT_UNREACHABLE)
-    ec = asio::error::connection_refused;
-  if (result != 0)
-    return socket_error_retval;
-  ec = asio::error_code();
-  return bytes_transferred;
-#else // defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-  msghdr msg = msghdr();
-  init_msghdr_msg_name(msg.msg_name, addr);
-  msg.msg_namelen = static_cast<int>(*addrlen);
-  msg.msg_iov = bufs;
-  msg.msg_iovlen = static_cast<int>(count);
-  signed_size_type result = error_wrapper(::recvmsg(s, &msg, flags), ec);
-  *addrlen = msg.msg_namelen;
-  if (result >= 0)
-    ec = asio::error_code();
-  return result;
-#endif // defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-}
-
-size_t sync_recvfrom(socket_type s, state_type state, buf* bufs,
-    size_t count, int flags, socket_addr_type* addr,
-    std::size_t* addrlen, asio::error_code& ec)
-{
-  if (s == invalid_socket)
-  {
-    ec = asio::error::bad_descriptor;
-    return 0;
-  }
-
-  // Read some data.
-  for (;;)
-  {
-    // Try to complete the operation without blocking.
-    signed_size_type bytes = socket_ops::recvfrom(
-        s, bufs, count, flags, addr, addrlen, ec);
-
-    // Check if operation succeeded.
-    if (bytes >= 0)
-      return bytes;
-
-    // Operation failed.
-    if ((state & user_set_non_blocking)
-        || (ec != asio::error::would_block
-          && ec != asio::error::try_again))
-      return 0;
-
-    // Wait for socket to become ready.
-    if (socket_ops::poll_read(s, 0, ec) < 0)
-      return 0;
-  }
-}
-
-#if defined(ASIO_HAS_IOCP)
-
-void complete_iocp_recvfrom(
-    const weak_cancel_token_type& cancel_token,
-    asio::error_code& ec)
-{
-  // Map non-portable errors to their portable counterparts.
-  if (ec.value() == ERROR_NETNAME_DELETED)
-  {
-    if (cancel_token.expired())
-      ec = asio::error::operation_aborted;
-    else
-      ec = asio::error::connection_reset;
-  }
-  else if (ec.value() == ERROR_PORT_UNREACHABLE)
-  {
-    ec = asio::error::connection_refused;
-  }
-}
-
-#else // defined(ASIO_HAS_IOCP)
-
-bool non_blocking_recvfrom(socket_type s,
-    buf* bufs, size_t count, int flags,
-    socket_addr_type* addr, std::size_t* addrlen,
-    asio::error_code& ec, size_t& bytes_transferred)
-{
-  for (;;)
-  {
-    // Read some data.
-    signed_size_type bytes = socket_ops::recvfrom(
-        s, bufs, count, flags, addr, addrlen, ec);
-
-    // Retry operation if interrupted by signal.
-    if (ec == asio::error::interrupted)
-      continue;
-
-    // Check if we need to run the operation again.
-    if (ec == asio::error::would_block
-        || ec == asio::error::try_again)
-      return false;
-
-    // Operation is complete.
-    if (bytes >= 0)
-    {
-      ec = asio::error_code();
-      bytes_transferred = bytes;
-    }
-    else
-      bytes_transferred = 0;
-
-    return true;
-  }
-}
-
-#endif // defined(ASIO_HAS_IOCP)
-
-signed_size_type recvmsg(socket_type s, buf* bufs, size_t count,
-    int in_flags, int& out_flags, asio::error_code& ec)
-{
-  clear_last_error();
-#if defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-  out_flags = 0;
-  return socket_ops::recv(s, bufs, count, in_flags, ec);
-#else // defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-  msghdr msg = msghdr();
-  msg.msg_iov = bufs;
-  msg.msg_iovlen = static_cast<int>(count);
-  signed_size_type result = error_wrapper(::recvmsg(s, &msg, in_flags), ec);
-  if (result >= 0)
-  {
-    ec = asio::error_code();
-    out_flags = msg.msg_flags;
-  }
-  else
-    out_flags = 0;
-  return result;
-#endif // defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-}
-
-size_t sync_recvmsg(socket_type s, state_type state,
-    buf* bufs, size_t count, int in_flags, int& out_flags,
-    asio::error_code& ec)
-{
-  if (s == invalid_socket)
-  {
-    ec = asio::error::bad_descriptor;
-    return 0;
-  }
-
-  // Read some data.
-  for (;;)
-  {
-    // Try to complete the operation without blocking.
-    signed_size_type bytes = socket_ops::recvmsg(
-        s, bufs, count, in_flags, out_flags, ec);
-
-    // Check if operation succeeded.
-    if (bytes >= 0)
-      return bytes;
-
-    // Operation failed.
-    if ((state & user_set_non_blocking)
-        || (ec != asio::error::would_block
-          && ec != asio::error::try_again))
-      return 0;
-
-    // Wait for socket to become ready.
-    if (socket_ops::poll_read(s, 0, ec) < 0)
-      return 0;
-  }
-}
-
-#if defined(ASIO_HAS_IOCP)
-
-void complete_iocp_recvmsg(
-    const weak_cancel_token_type& cancel_token,
-    asio::error_code& ec)
-{
-  // Map non-portable errors to their portable counterparts.
-  if (ec.value() == ERROR_NETNAME_DELETED)
-  {
-    if (cancel_token.expired())
-      ec = asio::error::operation_aborted;
-    else
-      ec = asio::error::connection_reset;
-  }
-  else if (ec.value() == ERROR_PORT_UNREACHABLE)
-  {
-    ec = asio::error::connection_refused;
-  }
-}
-
-#else // defined(ASIO_HAS_IOCP)
-
-bool non_blocking_recvmsg(socket_type s,
-    buf* bufs, size_t count, int in_flags, int& out_flags,
-    asio::error_code& ec, size_t& bytes_transferred)
-{
-  for (;;)
-  {
-    // Read some data.
-    signed_size_type bytes = socket_ops::recvmsg(
-        s, bufs, count, in_flags, out_flags, ec);
-
-    // Retry operation if interrupted by signal.
-    if (ec == asio::error::interrupted)
-      continue;
-
-    // Check if we need to run the operation again.
-    if (ec == asio::error::would_block
-        || ec == asio::error::try_again)
-      return false;
-
-    // Operation is complete.
-    if (bytes >= 0)
-    {
-      ec = asio::error_code();
-      bytes_transferred = bytes;
-    }
-    else
-      bytes_transferred = 0;
-
-    return true;
-  }
-}
-
-#endif // defined(ASIO_HAS_IOCP)
-
-signed_size_type send(socket_type s, const buf* bufs, size_t count,
-    int flags, asio::error_code& ec)
-{
-  clear_last_error();
-#if defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-  // Send the data.
-  DWORD send_buf_count = static_cast<DWORD>(count);
-  DWORD bytes_transferred = 0;
-  DWORD send_flags = flags;
-  int result = error_wrapper(::WSASend(s, const_cast<buf*>(bufs),
-        send_buf_count, &bytes_transferred, send_flags, 0, 0), ec);
-  if (ec.value() == ERROR_NETNAME_DELETED)
-    ec = asio::error::connection_reset;
-  else if (ec.value() == ERROR_PORT_UNREACHABLE)
-    ec = asio::error::connection_refused;
-  if (result != 0)
-    return socket_error_retval;
-  ec = asio::error_code();
-  return bytes_transferred;
-#else // defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-  msghdr msg = msghdr();
-  msg.msg_iov = const_cast<buf*>(bufs);
-  msg.msg_iovlen = static_cast<int>(count);
-#if defined(__linux__)
-  flags |= MSG_NOSIGNAL;
-#endif // defined(__linux__)
-  signed_size_type result = error_wrapper(::sendmsg(s, &msg, flags), ec);
-  if (result >= 0)
-    ec = asio::error_code();
-  return result;
-#endif // defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-}
-
-size_t sync_send(socket_type s, state_type state, const buf* bufs,
-    size_t count, int flags, bool all_empty, asio::error_code& ec)
-{
-  if (s == invalid_socket)
-  {
-    ec = asio::error::bad_descriptor;
-    return 0;
-  }
-
-  // A request to write 0 bytes to a stream is a no-op.
-  if (all_empty && (state & stream_oriented))
-  {
-    ec = asio::error_code();
-    return 0;
-  }
-
-  // Read some data.
-  for (;;)
-  {
-    // Try to complete the operation without blocking.
-    signed_size_type bytes = socket_ops::send(s, bufs, count, flags, ec);
-
-    // Check if operation succeeded.
-    if (bytes >= 0)
-      return bytes;
-
-    // Operation failed.
-    if ((state & user_set_non_blocking)
-        || (ec != asio::error::would_block
-          && ec != asio::error::try_again))
-      return 0;
-
-    // Wait for socket to become ready.
-    if (socket_ops::poll_write(s, 0, ec) < 0)
-      return 0;
-  }
-}
-
-#if defined(ASIO_HAS_IOCP)
-
-void complete_iocp_send(
-    const weak_cancel_token_type& cancel_token,
-    asio::error_code& ec)
-{
-  // Map non-portable errors to their portable counterparts.
-  if (ec.value() == ERROR_NETNAME_DELETED)
-  {
-    if (cancel_token.expired())
-      ec = asio::error::operation_aborted;
-    else
-      ec = asio::error::connection_reset;
-  }
-  else if (ec.value() == ERROR_PORT_UNREACHABLE)
-  {
-    ec = asio::error::connection_refused;
-  }
-}
-
-#else // defined(ASIO_HAS_IOCP)
-
-bool non_blocking_send(socket_type s,
-    const buf* bufs, size_t count, int flags,
-    asio::error_code& ec, size_t& bytes_transferred)
-{
-  for (;;)
-  {
-    // Write some data.
-    signed_size_type bytes = socket_ops::send(s, bufs, count, flags, ec);
-
-    // Retry operation if interrupted by signal.
-    if (ec == asio::error::interrupted)
-      continue;
-
-    // Check if we need to run the operation again.
-    if (ec == asio::error::would_block
-        || ec == asio::error::try_again)
-      return false;
-
-    // Operation is complete.
-    if (bytes >= 0)
-    {
-      ec = asio::error_code();
-      bytes_transferred = bytes;
-    }
-    else
-      bytes_transferred = 0;
-
-    return true;
-  }
-}
-
-#endif // defined(ASIO_HAS_IOCP)
-
-signed_size_type sendto(socket_type s, const buf* bufs, size_t count,
-    int flags, const socket_addr_type* addr, std::size_t addrlen,
-    asio::error_code& ec)
-{
-  clear_last_error();
-#if defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-  // Send the data.
-  DWORD send_buf_count = static_cast<DWORD>(count);
-  DWORD bytes_transferred = 0;
-  int result = error_wrapper(::WSASendTo(s, const_cast<buf*>(bufs),
-        send_buf_count, &bytes_transferred, flags, addr,
-        static_cast<int>(addrlen), 0, 0), ec);
-  if (ec.value() == ERROR_NETNAME_DELETED)
-    ec = asio::error::connection_reset;
-  else if (ec.value() == ERROR_PORT_UNREACHABLE)
-    ec = asio::error::connection_refused;
-  if (result != 0)
-    return socket_error_retval;
-  ec = asio::error_code();
-  return bytes_transferred;
-#else // defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-  msghdr msg = msghdr();
-  init_msghdr_msg_name(msg.msg_name, addr);
-  msg.msg_namelen = static_cast<int>(addrlen);
-  msg.msg_iov = const_cast<buf*>(bufs);
-  msg.msg_iovlen = static_cast<int>(count);
-#if defined(__linux__)
-  flags |= MSG_NOSIGNAL;
-#endif // defined(__linux__)
-  signed_size_type result = error_wrapper(::sendmsg(s, &msg, flags), ec);
-  if (result >= 0)
-    ec = asio::error_code();
-  return result;
-#endif // defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-}
-
-size_t sync_sendto(socket_type s, state_type state, const buf* bufs,
-    size_t count, int flags, const socket_addr_type* addr,
-    std::size_t addrlen, asio::error_code& ec)
-{
-  if (s == invalid_socket)
-  {
-    ec = asio::error::bad_descriptor;
-    return 0;
-  }
-
-  // Write some data.
-  for (;;)
-  {
-    // Try to complete the operation without blocking.
-    signed_size_type bytes = socket_ops::sendto(
-        s, bufs, count, flags, addr, addrlen, ec);
-
-    // Check if operation succeeded.
-    if (bytes >= 0)
-      return bytes;
-
-    // Operation failed.
-    if ((state & user_set_non_blocking)
-        || (ec != asio::error::would_block
-          && ec != asio::error::try_again))
-      return 0;
-
-    // Wait for socket to become ready.
-    if (socket_ops::poll_write(s, 0, ec) < 0)
-      return 0;
-  }
-}
-
-#if !defined(ASIO_HAS_IOCP)
-
-bool non_blocking_sendto(socket_type s,
-    const buf* bufs, size_t count, int flags,
-    const socket_addr_type* addr, std::size_t addrlen,
-    asio::error_code& ec, size_t& bytes_transferred)
-{
-  for (;;)
-  {
-    // Write some data.
-    signed_size_type bytes = socket_ops::sendto(
-        s, bufs, count, flags, addr, addrlen, ec);
-
-    // Retry operation if interrupted by signal.
-    if (ec == asio::error::interrupted)
-      continue;
-
-    // Check if we need to run the operation again.
-    if (ec == asio::error::would_block
-        || ec == asio::error::try_again)
-      return false;
-
-    // Operation is complete.
-    if (bytes >= 0)
-    {
-      ec = asio::error_code();
-      bytes_transferred = bytes;
-    }
-    else
-      bytes_transferred = 0;
-
-    return true;
-  }
-}
-
-#endif // !defined(ASIO_HAS_IOCP)
-
-socket_type socket(int af, int type, int protocol,
-    asio::error_code& ec)
-{
-  clear_last_error();
-#if defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-  socket_type s = error_wrapper(::WSASocket(af, type, protocol, 0, 0,
-        WSA_FLAG_OVERLAPPED), ec);
-  if (s == invalid_socket)
-    return s;
-
-  if (af == ASIO_OS_DEF(AF_INET6))
-  {
-    // Try to enable the POSIX default behaviour of having IPV6_V6ONLY set to
-    // false. This will only succeed on Windows Vista and later versions of
-    // Windows, where a dual-stack IPv4/v6 implementation is available.
-    DWORD optval = 0;
-    ::setsockopt(s, IPPROTO_IPV6, IPV6_V6ONLY,
-        reinterpret_cast<const char*>(&optval), sizeof(optval));
-  }
-
-  ec = asio::error_code();
-
-  return s;
-#elif defined(__MACH__) && defined(__APPLE__) || defined(__FreeBSD__)
-  socket_type s = error_wrapper(::socket(af, type, protocol), ec);
-  if (s == invalid_socket)
-    return s;
-
-  int optval = 1;
-  int result = error_wrapper(::setsockopt(s,
-        SOL_SOCKET, SO_NOSIGPIPE, &optval, sizeof(optval)), ec);
-  if (result != 0)
-  {
-    ::close(s);
-    return invalid_socket;
-  }
-
-  return s;
-#else
-  int s = error_wrapper(::socket(af, type, protocol), ec);
-  if (s >= 0)
-    ec = asio::error_code();
-  return s;
-#endif
-}
-
-template <typename SockLenType>
-inline int call_setsockopt(SockLenType msghdr::*,
-    socket_type s, int level, int optname,
-    const void* optval, std::size_t optlen)
-{
-  return ::setsockopt(s, level, optname,
-      (const char*)optval, (SockLenType)optlen);
-}
-
-int setsockopt(socket_type s, state_type& state, int level, int optname,
-    const void* optval, std::size_t optlen, asio::error_code& ec)
-{
-  if (s == invalid_socket)
-  {
-    ec = asio::error::bad_descriptor;
-    return socket_error_retval;
-  }
-
-  if (level == custom_socket_option_level && optname == always_fail_option)
-  {
-    ec = asio::error::invalid_argument;
-    return socket_error_retval;
-  }
-
-  if (level == custom_socket_option_level
-      && optname == enable_connection_aborted_option)
-  {
-    if (optlen != sizeof(int))
-    {
-      ec = asio::error::invalid_argument;
-      return socket_error_retval;
-    }
-
-    if (*static_cast<const int*>(optval))
-      state |= enable_connection_aborted;
-    else
-      state &= ~enable_connection_aborted;
-    ec = asio::error_code();
-    return 0;
-  }
-
-  if (level == SOL_SOCKET && optname == SO_LINGER)
-    state |= user_set_linger;
-
-#if defined(__BORLANDC__)
-  // Mysteriously, using the getsockopt and setsockopt functions directly with
-  // Borland C++ results in incorrect values being set and read. The bug can be
-  // worked around by using function addresses resolved with GetProcAddress.
-  if (HMODULE winsock_module = ::GetModuleHandleA("ws2_32"))
-  {
-    typedef int (WSAAPI *sso_t)(SOCKET, int, int, const char*, int);
-    if (sso_t sso = (sso_t)::GetProcAddress(winsock_module, "setsockopt"))
-    {
-      clear_last_error();
-      return error_wrapper(sso(s, level, optname,
-            reinterpret_cast<const char*>(optval),
-            static_cast<int>(optlen)), ec);
-    }
-  }
-  ec = asio::error::fault;
-  return socket_error_retval;
-#else // defined(__BORLANDC__)
-  clear_last_error();
-  int result = error_wrapper(call_setsockopt(&msghdr::msg_namelen,
-        s, level, optname, optval, optlen), ec);
-  if (result == 0)
-  {
-    ec = asio::error_code();
-
-#if defined(__MACH__) && defined(__APPLE__) \
-  || defined(__NetBSD__) || defined(__FreeBSD__) || defined(__OpenBSD__)
-    // To implement portable behaviour for SO_REUSEADDR with UDP sockets we
-    // need to also set SO_REUSEPORT on BSD-based platforms.
-    if ((state & datagram_oriented)
-        && level == SOL_SOCKET && optname == SO_REUSEADDR)
-    {
-      call_setsockopt(&msghdr::msg_namelen, s,
-          SOL_SOCKET, SO_REUSEPORT, optval, optlen);
-    }
-#endif
-  }
-
-  return result;
-#endif // defined(__BORLANDC__)
-}
-
-template <typename SockLenType>
-inline int call_getsockopt(SockLenType msghdr::*,
-    socket_type s, int level, int optname,
-    void* optval, std::size_t* optlen)
-{
-  SockLenType tmp_optlen = (SockLenType)*optlen;
-  int result = ::getsockopt(s, level, optname, (char*)optval, &tmp_optlen);
-  *optlen = (std::size_t)tmp_optlen;
-  return result;
-}
-
-int getsockopt(socket_type s, state_type state, int level, int optname,
-    void* optval, size_t* optlen, asio::error_code& ec)
-{
-  if (s == invalid_socket)
-  {
-    ec = asio::error::bad_descriptor;
-    return socket_error_retval;
-  }
-
-  if (level == custom_socket_option_level && optname == always_fail_option)
-  {
-    ec = asio::error::invalid_argument;
-    return socket_error_retval;
-  }
-
-  if (level == custom_socket_option_level
-      && optname == enable_connection_aborted_option)
-  {
-    if (*optlen != sizeof(int))
-    {
-      ec = asio::error::invalid_argument;
-      return socket_error_retval;
-    }
-
-    *static_cast<int*>(optval) = (state & enable_connection_aborted) ? 1 : 0;
-    ec = asio::error_code();
-    return 0;
-  }
-
-#if defined(__BORLANDC__)
-  // Mysteriously, using the getsockopt and setsockopt functions directly with
-  // Borland C++ results in incorrect values being set and read. The bug can be
-  // worked around by using function addresses resolved with GetProcAddress.
-  if (HMODULE winsock_module = ::GetModuleHandleA("ws2_32"))
-  {
-    typedef int (WSAAPI *gso_t)(SOCKET, int, int, char*, int*);
-    if (gso_t gso = (gso_t)::GetProcAddress(winsock_module, "getsockopt"))
-    {
-      clear_last_error();
-      int tmp_optlen = static_cast<int>(*optlen);
-      int result = error_wrapper(gso(s, level, optname,
-            reinterpret_cast<char*>(optval), &tmp_optlen), ec);
-      *optlen = static_cast<size_t>(tmp_optlen);
-      if (result != 0 && level == IPPROTO_IPV6 && optname == IPV6_V6ONLY
-          && ec.value() == WSAENOPROTOOPT && *optlen == sizeof(DWORD))
-      {
-        // Dual-stack IPv4/v6 sockets, and the IPV6_V6ONLY socket option, are
-        // only supported on Windows Vista and later. To simplify program logic
-        // we will fake success of getting this option and specify that the
-        // value is non-zero (i.e. true). This corresponds to the behavior of
-        // IPv6 sockets on Windows platforms pre-Vista.
-        *static_cast<DWORD*>(optval) = 1;
-        ec = asio::error_code();
-      }
-      return result;
-    }
-  }
-  ec = asio::error::fault;
-  return socket_error_retval;
-#elif defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-  clear_last_error();
-  int result = error_wrapper(call_getsockopt(&msghdr::msg_namelen,
-        s, level, optname, optval, optlen), ec);
-  if (result != 0 && level == IPPROTO_IPV6 && optname == IPV6_V6ONLY
-      && ec.value() == WSAENOPROTOOPT && *optlen == sizeof(DWORD))
-  {
-    // Dual-stack IPv4/v6 sockets, and the IPV6_V6ONLY socket option, are only
-    // supported on Windows Vista and later. To simplify program logic we will
-    // fake success of getting this option and specify that the value is
-    // non-zero (i.e. true). This corresponds to the behavior of IPv6 sockets
-    // on Windows platforms pre-Vista.
-    *static_cast<DWORD*>(optval) = 1;
-    ec = asio::error_code();
-  }
-  if (result == 0)
-    ec = asio::error_code();
-  return result;
-#else // defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-  clear_last_error();
-  int result = error_wrapper(call_getsockopt(&msghdr::msg_namelen,
-        s, level, optname, optval, optlen), ec);
-#if defined(__linux__)
-  if (result == 0 && level == SOL_SOCKET && *optlen == sizeof(int)
-      && (optname == SO_SNDBUF || optname == SO_RCVBUF))
-  {
-    // On Linux, setting SO_SNDBUF or SO_RCVBUF to N actually causes the kernel
-    // to set the buffer size to N*2. Linux puts additional stuff into the
-    // buffers so that only about half is actually available to the application.
-    // The retrieved value is divided by 2 here to make it appear as though the
-    // correct value has been set.
-    *static_cast<int*>(optval) /= 2;
-  }
-#endif // defined(__linux__)
-  if (result == 0)
-    ec = asio::error_code();
-  return result;
-#endif // defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-}
-
-template <typename SockLenType>
-inline int call_getpeername(SockLenType msghdr::*,
-    socket_type s, socket_addr_type* addr, std::size_t* addrlen)
-{
-  SockLenType tmp_addrlen = (SockLenType)*addrlen;
-  int result = ::getpeername(s, addr, &tmp_addrlen);
-  *addrlen = (std::size_t)tmp_addrlen;
-  return result;
-}
-
-int getpeername(socket_type s, socket_addr_type* addr,
-    std::size_t* addrlen, bool cached, asio::error_code& ec)
-{
-  if (s == invalid_socket)
-  {
-    ec = asio::error::bad_descriptor;
-    return socket_error_retval;
-  }
-
-#if defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-  if (cached)
-  {
-    // Check if socket is still connected.
-    DWORD connect_time = 0;
-    size_t connect_time_len = sizeof(connect_time);
-    if (socket_ops::getsockopt(s, 0, SOL_SOCKET, SO_CONNECT_TIME,
-          &connect_time, &connect_time_len, ec) == socket_error_retval)
-    {
-      return socket_error_retval;
-    }
-    if (connect_time == 0xFFFFFFFF)
-    {
-      ec = asio::error::not_connected;
-      return socket_error_retval;
-    }
-
-    // The cached value is still valid.
-    ec = asio::error_code();
-    return 0;
-  }
-#else // defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-  (void)cached;
-#endif // defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-
-  clear_last_error();
-  int result = error_wrapper(call_getpeername(
-        &msghdr::msg_namelen, s, addr, addrlen), ec);
-  if (result == 0)
-    ec = asio::error_code();
-  return result;
-}
-
-template <typename SockLenType>
-inline int call_getsockname(SockLenType msghdr::*,
-    socket_type s, socket_addr_type* addr, std::size_t* addrlen)
-{
-  SockLenType tmp_addrlen = (SockLenType)*addrlen;
-  int result = ::getsockname(s, addr, &tmp_addrlen);
-  *addrlen = (std::size_t)tmp_addrlen;
-  return result;
-}
-
-int getsockname(socket_type s, socket_addr_type* addr,
-    std::size_t* addrlen, asio::error_code& ec)
-{
-  if (s == invalid_socket)
-  {
-    ec = asio::error::bad_descriptor;
-    return socket_error_retval;
-  }
-
-  clear_last_error();
-  int result = error_wrapper(call_getsockname(
-        &msghdr::msg_namelen, s, addr, addrlen), ec);
-  if (result == 0)
-    ec = asio::error_code();
-  return result;
-}
-
-int ioctl(socket_type s, state_type& state, int cmd,
-    ioctl_arg_type* arg, asio::error_code& ec)
-{
-  if (s == invalid_socket)
-  {
-    ec = asio::error::bad_descriptor;
-    return socket_error_retval;
-  }
-
-  clear_last_error();
-#if defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-  int result = error_wrapper(::ioctlsocket(s, cmd, arg), ec);
-#elif defined(__MACH__) && defined(__APPLE__) \
-  || defined(__NetBSD__) || defined(__FreeBSD__) || defined(__OpenBSD__)
-  int result = error_wrapper(::ioctl(s,
-        static_cast<unsigned int>(cmd), arg), ec);
-#else
-  int result = error_wrapper(::ioctl(s, cmd, arg), ec);
-#endif
-  if (result >= 0)
-  {
-    ec = asio::error_code();
-
-    // When updating the non-blocking mode we always perform the ioctl syscall,
-    // even if the flags would otherwise indicate that the socket is already in
-    // the correct state. This ensures that the underlying socket is put into
-    // the state that has been requested by the user. If the ioctl syscall was
-    // successful then we need to update the flags to match.
-    if (cmd == static_cast<int>(FIONBIO))
-    {
-      if (*arg)
-      {
-        state |= user_set_non_blocking;
-      }
-      else
-      {
-        // Clearing the non-blocking mode always overrides any internally-set
-        // non-blocking flag. Any subsequent asynchronous operations will need
-        // to re-enable non-blocking I/O.
-        state &= ~(user_set_non_blocking | internal_non_blocking);
-      }
-    }
-  }
-
-  return result;
-}
-
-int select(int nfds, fd_set* readfds, fd_set* writefds,
-    fd_set* exceptfds, timeval* timeout, asio::error_code& ec)
-{
-  clear_last_error();
-#if defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-  if (!readfds && !writefds && !exceptfds && timeout)
-  {
-    DWORD milliseconds = timeout->tv_sec * 1000 + timeout->tv_usec / 1000;
-    if (milliseconds == 0)
-      milliseconds = 1; // Force context switch.
-    ::Sleep(milliseconds);
-    ec = asio::error_code();
-    return 0;
-  }
-
-  // The select() call allows timeout values measured in microseconds, but the
-  // system clock (as wrapped by boost::posix_time::microsec_clock) typically
-  // has a resolution of 10 milliseconds. This can lead to a spinning select
-  // reactor, meaning increased CPU usage, when waiting for the earliest
-  // scheduled timeout if it's less than 10 milliseconds away. To avoid a tight
-  // spin we'll use a minimum timeout of 1 millisecond.
-  if (timeout && timeout->tv_sec == 0
-      && timeout->tv_usec > 0 && timeout->tv_usec < 1000)
-    timeout->tv_usec = 1000;
-#endif // defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-
-#if defined(__hpux) && defined(__SELECT)
-  timespec ts;
-  ts.tv_sec = timeout ? timeout->tv_sec : 0;
-  ts.tv_nsec = timeout ? timeout->tv_usec * 1000 : 0;
-  return error_wrapper(::pselect(nfds, readfds,
-        writefds, exceptfds, timeout ? &ts : 0, 0), ec);
-#else
-  int result = error_wrapper(::select(nfds, readfds,
-        writefds, exceptfds, timeout), ec);
-  if (result >= 0)
-    ec = asio::error_code();
-  return result;
-#endif
-}
-
-int poll_read(socket_type s, state_type state, asio::error_code& ec)
-{
-  if (s == invalid_socket)
-  {
-    ec = asio::error::bad_descriptor;
-    return socket_error_retval;
-  }
-
-#if defined(ASIO_WINDOWS) \
-  || defined(__CYGWIN__) \
-  || defined(__SYMBIAN32__)
-  fd_set fds;
-  FD_ZERO(&fds);
-  FD_SET(s, &fds);
-  timeval zero_timeout;
-  zero_timeout.tv_sec = 0;
-  zero_timeout.tv_usec = 0;
-  timeval* timeout = (state & user_set_non_blocking) ? &zero_timeout : 0;
-  clear_last_error();
-  int result = error_wrapper(::select(s + 1, &fds, 0, 0, timeout), ec);
-#else // defined(ASIO_WINDOWS)
-      // || defined(__CYGWIN__)
-      // || defined(__SYMBIAN32__)
-  pollfd fds;
-  fds.fd = s;
-  fds.events = POLLIN;
-  fds.revents = 0;
-  int timeout = (state & user_set_non_blocking) ? 0 : -1;
-  clear_last_error();
-  int result = error_wrapper(::poll(&fds, 1, timeout), ec);
-#endif // defined(ASIO_WINDOWS)
-       // || defined(__CYGWIN__)
-       // || defined(__SYMBIAN32__)
-  if (result == 0)
-    ec = (state & user_set_non_blocking)
-      ? asio::error::would_block : asio::error_code();
-  else if (result > 0)
-    ec = asio::error_code();
-  return result;
-}
-
-int poll_write(socket_type s, state_type state, asio::error_code& ec)
-{
-  if (s == invalid_socket)
-  {
-    ec = asio::error::bad_descriptor;
-    return socket_error_retval;
-  }
-
-#if defined(ASIO_WINDOWS) \
-  || defined(__CYGWIN__) \
-  || defined(__SYMBIAN32__)
-  fd_set fds;
-  FD_ZERO(&fds);
-  FD_SET(s, &fds);
-  timeval zero_timeout;
-  zero_timeout.tv_sec = 0;
-  zero_timeout.tv_usec = 0;
-  timeval* timeout = (state & user_set_non_blocking) ? &zero_timeout : 0;
-  clear_last_error();
-  int result = error_wrapper(::select(s + 1, 0, &fds, 0, timeout), ec);
-#else // defined(ASIO_WINDOWS)
-      // || defined(__CYGWIN__)
-      // || defined(__SYMBIAN32__)
-  pollfd fds;
-  fds.fd = s;
-  fds.events = POLLOUT;
-  fds.revents = 0;
-  int timeout = (state & user_set_non_blocking) ? 0 : -1;
-  clear_last_error();
-  int result = error_wrapper(::poll(&fds, 1, timeout), ec);
-#endif // defined(ASIO_WINDOWS)
-       // || defined(__CYGWIN__)
-       // || defined(__SYMBIAN32__)
-  if (result == 0)
-    ec = (state & user_set_non_blocking)
-      ? asio::error::would_block : asio::error_code();
-  else if (result > 0)
-    ec = asio::error_code();
-  return result;
-}
-
-int poll_connect(socket_type s, asio::error_code& ec)
-{
-  if (s == invalid_socket)
-  {
-    ec = asio::error::bad_descriptor;
-    return socket_error_retval;
-  }
-
-#if defined(ASIO_WINDOWS) \
-  || defined(__CYGWIN__) \
-  || defined(__SYMBIAN32__)
-  fd_set write_fds;
-  FD_ZERO(&write_fds);
-  FD_SET(s, &write_fds);
-  fd_set except_fds;
-  FD_ZERO(&except_fds);
-  FD_SET(s, &except_fds);
-  clear_last_error();
-  int result = error_wrapper(::select(
-        s + 1, 0, &write_fds, &except_fds, 0), ec);
-  if (result >= 0)
-    ec = asio::error_code();
-  return result;
-#else // defined(ASIO_WINDOWS)
-      // || defined(__CYGWIN__)
-      // || defined(__SYMBIAN32__)
-  pollfd fds;
-  fds.fd = s;
-  fds.events = POLLOUT;
-  fds.revents = 0;
-  clear_last_error();
-  int result = error_wrapper(::poll(&fds, 1, -1), ec);
-  if (result >= 0)
-    ec = asio::error_code();
-  return result;
-#endif // defined(ASIO_WINDOWS)
-       // || defined(__CYGWIN__)
-       // || defined(__SYMBIAN32__)
-}
-
-#endif // !defined(ASIO_WINDOWS_RUNTIME)
-
-const char* inet_ntop(int af, const void* src, char* dest, size_t length,
-    unsigned long scope_id, asio::error_code& ec)
-{
-  clear_last_error();
-#if defined(ASIO_WINDOWS_RUNTIME)
-  using namespace std; // For sprintf.
-  const unsigned char* bytes = static_cast<const unsigned char*>(src);
-  if (af == ASIO_OS_DEF(AF_INET))
-  {
-    sprintf_s(dest, length, "%u.%u.%u.%u",
-        bytes[0], bytes[1], bytes[2], bytes[3]);
-    return dest;
-  }
-  else if (af == ASIO_OS_DEF(AF_INET6))
-  {
-    size_t n = 0, b = 0, z = 0;
-    while (n < length && b < 16)
-    {
-      if (bytes[b] == 0 && bytes[b + 1] == 0 && z == 0)
-      {
-        do b += 2; while (b < 16 && bytes[b] == 0 && bytes[b + 1] == 0);
-        n += sprintf_s(dest + n, length - n, ":%s", b < 16 ? "" : ":"), ++z;
-      }
-      else
-      {
-        n += sprintf_s(dest + n, length - n, "%s%x", b ? ":" : "",
-            (static_cast<u_long_type>(bytes[b]) << 8) | bytes[b + 1]);
-        b += 2;
-      }
-    }
-    if (scope_id)
-      n += sprintf_s(dest + n, length - n, "%%%lu", scope_id);
-    return dest;
-  }
-  else
-  {
-    ec = asio::error::address_family_not_supported;
-    return 0;
-  }
-#elif defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-  using namespace std; // For memcpy.
-
-  if (af != ASIO_OS_DEF(AF_INET) && af != ASIO_OS_DEF(AF_INET6))
-  {
-    ec = asio::error::address_family_not_supported;
-    return 0;
-  }
-
-  union
-  {
-    socket_addr_type base;
-    sockaddr_storage_type storage;
-    sockaddr_in4_type v4;
-    sockaddr_in6_type v6;
-  } address;
-  DWORD address_length;
-  if (af == ASIO_OS_DEF(AF_INET))
-  {
-    address_length = sizeof(sockaddr_in4_type);
-    address.v4.sin_family = ASIO_OS_DEF(AF_INET);
-    address.v4.sin_port = 0;
-    memcpy(&address.v4.sin_addr, src, sizeof(in4_addr_type));
-  }
-  else // AF_INET6
-  {
-    address_length = sizeof(sockaddr_in6_type);
-    address.v6.sin6_family = ASIO_OS_DEF(AF_INET6);
-    address.v6.sin6_port = 0;
-    address.v6.sin6_flowinfo = 0;
-    address.v6.sin6_scope_id = scope_id;
-    memcpy(&address.v6.sin6_addr, src, sizeof(in6_addr_type));
-  }
-
-  DWORD string_length = static_cast<DWORD>(length);
-#if defined(BOOST_NO_ANSI_APIS)
-  LPWSTR string_buffer = (LPWSTR)_alloca(length * sizeof(WCHAR));
-  int result = error_wrapper(::WSAAddressToStringW(&address.base,
-        address_length, 0, string_buffer, &string_length), ec);
-  ::WideCharToMultiByte(CP_ACP, 0, string_buffer, -1, dest, length, 0, 0);
-#else
-  int result = error_wrapper(::WSAAddressToStringA(
-        &address.base, address_length, 0, dest, &string_length), ec);
-#endif
-
-  // Windows may set error code on success.
-  if (result != socket_error_retval)
-    ec = asio::error_code();
-
-  // Windows may not set an error code on failure.
-  else if (result == socket_error_retval && !ec)
-    ec = asio::error::invalid_argument;
-
-  return result == socket_error_retval ? 0 : dest;
-#else // defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-  const char* result = error_wrapper(::inet_ntop(
-        af, src, dest, static_cast<int>(length)), ec);
-  if (result == 0 && !ec)
-    ec = asio::error::invalid_argument;
-  if (result != 0 && af == ASIO_OS_DEF(AF_INET6) && scope_id != 0)
-  {
-    using namespace std; // For strcat and sprintf.
-    char if_name[IF_NAMESIZE + 1] = "%";
-    const in6_addr_type* ipv6_address = static_cast<const in6_addr_type*>(src);
-    bool is_link_local = ((ipv6_address->s6_addr[0] == 0xfe)
-        && ((ipv6_address->s6_addr[1] & 0xc0) == 0x80));
-    bool is_multicast_link_local = ((ipv6_address->s6_addr[0] == 0xff)
-        && ((ipv6_address->s6_addr[1] & 0x0f) == 0x02));
-    if ((!is_link_local && !is_multicast_link_local)
-        || if_indextoname(static_cast<unsigned>(scope_id), if_name + 1) == 0)
-      sprintf(if_name + 1, "%lu", scope_id);
-    strcat(dest, if_name);
-  }
-  return result;
-#endif // defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-}
-
-int inet_pton(int af, const char* src, void* dest,
-    unsigned long* scope_id, asio::error_code& ec)
-{
-  clear_last_error();
-#if defined(ASIO_WINDOWS_RUNTIME)
-  using namespace std; // For sscanf.
-  unsigned char* bytes = static_cast<unsigned char*>(dest);
-  if (af == ASIO_OS_DEF(AF_INET))
-  {
-    unsigned int b0, b1, b2, b3;
-    if (sscanf_s(src, "%u.%u.%u.%u", &b0, &b1, &b2, &b3) != 4)
-    {
-      ec = asio::error::invalid_argument;
-      return -1;
-    }
-    if (b0 > 255 || b1 > 255 || b2 > 255 || b3 > 255)
-    {
-      ec = asio::error::invalid_argument;
-      return -1;
-    }
-    bytes[0] = static_cast<unsigned char>(b0);
-    bytes[1] = static_cast<unsigned char>(b1);
-    bytes[2] = static_cast<unsigned char>(b2);
-    bytes[3] = static_cast<unsigned char>(b3);
-    ec = asio::error_code();
-    return 1;
-  }
-  else if (af == ASIO_OS_DEF(AF_INET6))
-  {
-    unsigned char* bytes = static_cast<unsigned char*>(dest);
-    std::memset(bytes, 0, 16);
-    unsigned char back_bytes[16] = { 0 };
-    int num_front_bytes = 0, num_back_bytes = 0;
-    const char* p = src;
-
-    enum { fword, fcolon, bword, scope, done } state = fword;
-    unsigned long current_word = 0;
-    while (state != done)
-    {
-      if (current_word > 0xFFFF)
-      {
-        ec = asio::error::invalid_argument;
-        return -1;
-      }
-
-      switch (state)
-      {
-      case fword:
-        if (*p >= '0' && *p <= '9')
-          current_word = current_word * 16 + *p++ - '0';
-        else if (*p >= 'a' && *p <= 'f')
-          current_word = current_word * 16 + *p++ - 'a' + 10;
-        else if (*p >= 'A' && *p <= 'F')
-          current_word = current_word * 16 + *p++ - 'A' + 10;
-        else
-        {
-          if (num_front_bytes == 16)
-          {
-            ec = asio::error::invalid_argument;
-            return -1;
-          }
-
-          bytes[num_front_bytes++] = (current_word >> 8) & 0xFF;
-          bytes[num_front_bytes++] = current_word & 0xFF;
-          current_word = 0;
-
-          if (*p == ':')
-            state = fcolon, ++p;
-          else if (*p == '%')
-            state = scope, ++p;
-          else if (*p == 0)
-            state = done;
-          else
-          {
-            ec = asio::error::invalid_argument;
-            return -1;
-          }
-        }
-        break;
-
-      case fcolon:
-        if (*p == ':')
-          state = bword, ++p;
-        else
-          state = fword;
-        break;
-
-      case bword:
-        if (*p >= '0' && *p <= '9')
-          current_word = current_word * 16 + *p++ - '0';
-        else if (*p >= 'a' && *p <= 'f')
-          current_word = current_word * 16 + *p++ - 'a' + 10;
-        else if (*p >= 'A' && *p <= 'F')
-          current_word = current_word * 16 + *p++ - 'A' + 10;
-        else
-        {
-          if (num_front_bytes + num_back_bytes == 16)
-          {
-            ec = asio::error::invalid_argument;
-            return -1;
-          }
-
-          back_bytes[num_back_bytes++] = (current_word >> 8) & 0xFF;
-          back_bytes[num_back_bytes++] = current_word & 0xFF;
-          current_word = 0;
-
-          if (*p == ':')
-            state = bword, ++p;
-          else if (*p == '%')
-            state = scope, ++p;
-          else if (*p == 0)
-            state = done;
-          else
-          {
-            ec = asio::error::invalid_argument;
-            return -1;
-          }
-        }
-        break;
-
-      case scope:
-        if (*p >= '0' && *p <= '9')
-          current_word = current_word * 10 + *p++ - '0';
-        else if (*p == 0)
-          *scope_id = current_word, state = done;
-        else
-        {
-          ec = asio::error::invalid_argument;
-          return -1;
-        }
-        break;
-
-      default:
-        break;
-      }
-    }
-
-    for (int i = 0; i < num_back_bytes; ++i)
-      bytes[16 - num_back_bytes + i] = back_bytes[i];
-
-    ec = asio::error_code();
-    return 1;
-  }
-  else
-  {
-    ec = asio::error::address_family_not_supported;
-    return -1;
-  }
-#elif defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-  using namespace std; // For memcpy and strcmp.
-
-  if (af != ASIO_OS_DEF(AF_INET) && af != ASIO_OS_DEF(AF_INET6))
-  {
-    ec = asio::error::address_family_not_supported;
-    return -1;
-  }
-
-  union
-  {
-    socket_addr_type base;
-    sockaddr_storage_type storage;
-    sockaddr_in4_type v4;
-    sockaddr_in6_type v6;
-  } address;
-  int address_length = sizeof(sockaddr_storage_type);
-#if defined(BOOST_NO_ANSI_APIS)
-  int num_wide_chars = strlen(src) + 1;
-  LPWSTR wide_buffer = (LPWSTR)_alloca(num_wide_chars * sizeof(WCHAR));
-  ::MultiByteToWideChar(CP_ACP, 0, src, -1, wide_buffer, num_wide_chars);
-  int result = error_wrapper(::WSAStringToAddressW(
-        wide_buffer, af, 0, &address.base, &address_length), ec);
-#else
-  int result = error_wrapper(::WSAStringToAddressA(
-        const_cast<char*>(src), af, 0, &address.base, &address_length), ec);
-#endif
-
-  if (af == ASIO_OS_DEF(AF_INET))
-  {
-    if (result != socket_error_retval)
-    {
-      memcpy(dest, &address.v4.sin_addr, sizeof(in4_addr_type));
-      ec = asio::error_code();
-    }
-    else if (strcmp(src, "255.255.255.255") == 0)
-    {
-      static_cast<in4_addr_type*>(dest)->s_addr = INADDR_NONE;
-      ec = asio::error_code();
-    }
-  }
-  else // AF_INET6
-  {
-    if (result != socket_error_retval)
-    {
-      memcpy(dest, &address.v6.sin6_addr, sizeof(in6_addr_type));
-      if (scope_id)
-        *scope_id = address.v6.sin6_scope_id;
-      ec = asio::error_code();
-    }
-  }
-
-  // Windows may not set an error code on failure.
-  if (result == socket_error_retval && !ec)
-    ec = asio::error::invalid_argument;
-
-  if (result != socket_error_retval)
-    ec = asio::error_code();
-
-  return result == socket_error_retval ? -1 : 1;
-#else // defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-  int result = error_wrapper(::inet_pton(af, src, dest), ec);
-  if (result <= 0 && !ec)
-    ec = asio::error::invalid_argument;
-  if (result > 0 && af == ASIO_OS_DEF(AF_INET6) && scope_id)
-  {
-    using namespace std; // For strchr and atoi.
-    *scope_id = 0;
-    if (const char* if_name = strchr(src, '%'))
-    {
-      in6_addr_type* ipv6_address = static_cast<in6_addr_type*>(dest);
-      bool is_link_local = ((ipv6_address->s6_addr[0] == 0xfe)
-          && ((ipv6_address->s6_addr[1] & 0xc0) == 0x80));
-      bool is_multicast_link_local = ((ipv6_address->s6_addr[0] == 0xff)
-          && ((ipv6_address->s6_addr[1] & 0x0f) == 0x02));
-      if (is_link_local || is_multicast_link_local)
-        *scope_id = if_nametoindex(if_name + 1);
-      if (*scope_id == 0)
-        *scope_id = atoi(if_name + 1);
-    }
-  }
-  return result;
-#endif // defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-}
-
-int gethostname(char* name, int namelen, asio::error_code& ec)
-{
-  clear_last_error();
-#if defined(ASIO_WINDOWS_RUNTIME)
-  try
-  {
-    using namespace Windows::Foundation::Collections;
-    using namespace Windows::Networking;
-    using namespace Windows::Networking::Connectivity;
-    IVectorView<HostName^>^ hostnames = NetworkInformation::GetHostNames();
-    for (unsigned i = 0; i < hostnames->Size; ++i)
-    {
-      HostName^ hostname = hostnames->GetAt(i);
-      if (hostname->Type == HostNameType::DomainName)
-      {
-        std::wstring_convert<std::codecvt_utf8<wchar_t>> converter;
-        std::string raw_name = converter.to_bytes(hostname->RawName->Data());
-        if (namelen > 0 && raw_name.size() < static_cast<std::size_t>(namelen))
-        {
-          strcpy_s(name, namelen, raw_name.c_str());
-          return 0;
-        }
-      }
-    }
-    return -1;
-  }
-  catch (Platform::Exception^ e)
-  {
-    ec = asio::error_code(e->HResult,
-        asio::system_category());
-    return -1;
-  }
-#else // defined(ASIO_WINDOWS_RUNTIME)
-  int result = error_wrapper(::gethostname(name, namelen), ec);
-# if defined(ASIO_WINDOWS)
-  if (result == 0)
-    ec = asio::error_code();
-# endif // defined(ASIO_WINDOWS)
-  return result;
-#endif // defined(ASIO_WINDOWS_RUNTIME)
-}
-
-#if !defined(ASIO_WINDOWS_RUNTIME)
-
-#if defined(ASIO_WINDOWS) || defined(__CYGWIN__) \
-  || defined(__MACH__) && defined(__APPLE__)
-
-// The following functions are only needed for emulation of getaddrinfo and
-// getnameinfo.
-
-inline asio::error_code translate_netdb_error(int error)
-{
-  switch (error)
-  {
-  case 0:
-    return asio::error_code();
-  case HOST_NOT_FOUND:
-    return asio::error::host_not_found;
-  case TRY_AGAIN:
-    return asio::error::host_not_found_try_again;
-  case NO_RECOVERY:
-    return asio::error::no_recovery;
-  case NO_DATA:
-    return asio::error::no_data;
-  default:
-    ASIO_ASSERT(false);
-    return asio::error::invalid_argument;
-  }
-}
-
-inline hostent* gethostbyaddr(const char* addr, int length, int af,
-    hostent* result, char* buffer, int buflength, asio::error_code& ec)
-{
-  clear_last_error();
-#if defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-  (void)(buffer);
-  (void)(buflength);
-  hostent* retval = error_wrapper(::gethostbyaddr(addr, length, af), ec);
-  if (!retval)
-    return 0;
-  ec = asio::error_code();
-  *result = *retval;
-  return retval;
-#elif defined(__sun) || defined(__QNX__)
-  int error = 0;
-  hostent* retval = error_wrapper(::gethostbyaddr_r(addr, length, af, result,
-        buffer, buflength, &error), ec);
-  if (error)
-    ec = translate_netdb_error(error);
-  return retval;
-#elif defined(__MACH__) && defined(__APPLE__)
-  (void)(buffer);
-  (void)(buflength);
-  int error = 0;
-  hostent* retval = error_wrapper(::getipnodebyaddr(
-        addr, length, af, &error), ec);
-  if (error)
-    ec = translate_netdb_error(error);
-  if (!retval)
-    return 0;
-  *result = *retval;
-  return retval;
-#else
-  hostent* retval = 0;
-  int error = 0;
-  error_wrapper(::gethostbyaddr_r(addr, length, af, result, buffer,
-        buflength, &retval, &error), ec);
-  if (error)
-    ec = translate_netdb_error(error);
-  return retval;
-#endif
-}
-
-inline hostent* gethostbyname(const char* name, int af, struct hostent* result,
-    char* buffer, int buflength, int ai_flags, asio::error_code& ec)
-{
-  clear_last_error();
-#if defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-  (void)(buffer);
-  (void)(buflength);
-  (void)(ai_flags);
-  if (af != ASIO_OS_DEF(AF_INET))
-  {
-    ec = asio::error::address_family_not_supported;
-    return 0;
-  }
-  hostent* retval = error_wrapper(::gethostbyname(name), ec);
-  if (!retval)
-    return 0;
-  ec = asio::error_code();
-  *result = *retval;
-  return result;
-#elif defined(__sun) || defined(__QNX__)
-  (void)(ai_flags);
-  if (af != ASIO_OS_DEF(AF_INET))
-  {
-    ec = asio::error::address_family_not_supported;
-    return 0;
-  }
-  int error = 0;
-  hostent* retval = error_wrapper(::gethostbyname_r(name, result, buffer,
-        buflength, &error), ec);
-  if (error)
-    ec = translate_netdb_error(error);
-  return retval;
-#elif defined(__MACH__) && defined(__APPLE__)
-  (void)(buffer);
-  (void)(buflength);
-  int error = 0;
-  hostent* retval = error_wrapper(::getipnodebyname(
-        name, af, ai_flags, &error), ec);
-  if (error)
-    ec = translate_netdb_error(error);
-  if (!retval)
-    return 0;
-  *result = *retval;
-  return retval;
-#else
-  (void)(ai_flags);
-  if (af != ASIO_OS_DEF(AF_INET))
-  {
-    ec = asio::error::address_family_not_supported;
-    return 0;
-  }
-  hostent* retval = 0;
-  int error = 0;
-  error_wrapper(::gethostbyname_r(name, result,
-        buffer, buflength, &retval, &error), ec);
-  if (error)
-    ec = translate_netdb_error(error);
-  return retval;
-#endif
-}
-
-inline void freehostent(hostent* h)
-{
-#if defined(__MACH__) && defined(__APPLE__)
-  if (h)
-    ::freehostent(h);
-#else
-  (void)(h);
-#endif
-}
-
-// Emulation of getaddrinfo based on implementation in:
-// Stevens, W. R., UNIX Network Programming Vol. 1, 2nd Ed., Prentice-Hall 1998.
-
-struct gai_search
-{
-  const char* host;
-  int family;
-};
-
-inline int gai_nsearch(const char* host,
-    const addrinfo_type* hints, gai_search (&search)[2])
-{
-  int search_count = 0;
-  if (host == 0 || host[0] == '\0')
-  {
-    if (hints->ai_flags & AI_PASSIVE)
-    {
-      // No host and AI_PASSIVE implies wildcard bind.
-      switch (hints->ai_family)
-      {
-      case ASIO_OS_DEF(AF_INET):
-        search[search_count].host = "0.0.0.0";
-        search[search_count].family = ASIO_OS_DEF(AF_INET);
-        ++search_count;
-        break;
-      case ASIO_OS_DEF(AF_INET6):
-        search[search_count].host = "0::0";
-        search[search_count].family = ASIO_OS_DEF(AF_INET6);
-        ++search_count;
-        break;
-      case ASIO_OS_DEF(AF_UNSPEC):
-        search[search_count].host = "0::0";
-        search[search_count].family = ASIO_OS_DEF(AF_INET6);
-        ++search_count;
-        search[search_count].host = "0.0.0.0";
-        search[search_count].family = ASIO_OS_DEF(AF_INET);
-        ++search_count;
-        break;
-      default:
-        break;
-      }
-    }
-    else
-    {
-      // No host and not AI_PASSIVE means connect to local host.
-      switch (hints->ai_family)
-      {
-      case ASIO_OS_DEF(AF_INET):
-        search[search_count].host = "localhost";
-        search[search_count].family = ASIO_OS_DEF(AF_INET);
-        ++search_count;
-        break;
-      case ASIO_OS_DEF(AF_INET6):
-        search[search_count].host = "localhost";
-        search[search_count].family = ASIO_OS_DEF(AF_INET6);
-        ++search_count;
-        break;
-      case ASIO_OS_DEF(AF_UNSPEC):
-        search[search_count].host = "localhost";
-        search[search_count].family = ASIO_OS_DEF(AF_INET6);
-        ++search_count;
-        search[search_count].host = "localhost";
-        search[search_count].family = ASIO_OS_DEF(AF_INET);
-        ++search_count;
-        break;
-      default:
-        break;
-      }
-    }
-  }
-  else
-  {
-    // Host is specified.
-    switch (hints->ai_family)
-    {
-    case ASIO_OS_DEF(AF_INET):
-      search[search_count].host = host;
-      search[search_count].family = ASIO_OS_DEF(AF_INET);
-      ++search_count;
-      break;
-    case ASIO_OS_DEF(AF_INET6):
-      search[search_count].host = host;
-      search[search_count].family = ASIO_OS_DEF(AF_INET6);
-      ++search_count;
-      break;
-    case ASIO_OS_DEF(AF_UNSPEC):
-      search[search_count].host = host;
-      search[search_count].family = ASIO_OS_DEF(AF_INET6);
-      ++search_count;
-      search[search_count].host = host;
-      search[search_count].family = ASIO_OS_DEF(AF_INET);
-      ++search_count;
-      break;
-    default:
-      break;
-    }
-  }
-  return search_count;
-}
-
-template <typename T>
-inline T* gai_alloc(std::size_t size = sizeof(T))
-{
-  using namespace std;
-  T* p = static_cast<T*>(::operator new(size, std::nothrow));
-  if (p)
-    memset(p, 0, size);
-  return p;
-}
-
-inline void gai_free(void* p)
-{
-  ::operator delete(p);
-}
-
-inline void gai_strcpy(char* target, const char* source, std::size_t max_size)
-{
-  using namespace std;
-#if defined(ASIO_HAS_SECURE_RTL)
-  strcpy_s(target, max_size, source);
-#else // defined(ASIO_HAS_SECURE_RTL)
-  *target = 0;
-  strncat(target, source, max_size);
-#endif // defined(ASIO_HAS_SECURE_RTL)
-}
-
-enum { gai_clone_flag = 1 << 30 };
-
-inline int gai_aistruct(addrinfo_type*** next, const addrinfo_type* hints,
-    const void* addr, int family)
-{
-  using namespace std;
-
-  addrinfo_type* ai = gai_alloc<addrinfo_type>();
-  if (ai == 0)
-    return EAI_MEMORY;
-
-  ai->ai_next = 0;
-  **next = ai;
-  *next = &ai->ai_next;
-
-  ai->ai_canonname = 0;
-  ai->ai_socktype = hints->ai_socktype;
-  if (ai->ai_socktype == 0)
-    ai->ai_flags |= gai_clone_flag;
-  ai->ai_protocol = hints->ai_protocol;
-  ai->ai_family = family;
-
-  switch (ai->ai_family)
-  {
-  case ASIO_OS_DEF(AF_INET):
-    {
-      sockaddr_in4_type* sinptr = gai_alloc<sockaddr_in4_type>();
-      if (sinptr == 0)
-        return EAI_MEMORY;
-      sinptr->sin_family = ASIO_OS_DEF(AF_INET);
-      memcpy(&sinptr->sin_addr, addr, sizeof(in4_addr_type));
-      ai->ai_addr = reinterpret_cast<sockaddr*>(sinptr);
-      ai->ai_addrlen = sizeof(sockaddr_in4_type);
-      break;
-    }
-  case ASIO_OS_DEF(AF_INET6):
-    {
-      sockaddr_in6_type* sin6ptr = gai_alloc<sockaddr_in6_type>();
-      if (sin6ptr == 0)
-        return EAI_MEMORY;
-      sin6ptr->sin6_family = ASIO_OS_DEF(AF_INET6);
-      memcpy(&sin6ptr->sin6_addr, addr, sizeof(in6_addr_type));
-      ai->ai_addr = reinterpret_cast<sockaddr*>(sin6ptr);
-      ai->ai_addrlen = sizeof(sockaddr_in6_type);
-      break;
-    }
-  default:
-    break;
-  }
-
-  return 0;
-}
-
-inline addrinfo_type* gai_clone(addrinfo_type* ai)
-{
-  using namespace std;
-
-  addrinfo_type* new_ai = gai_alloc<addrinfo_type>();
-  if (new_ai == 0)
-    return new_ai;
-
-  new_ai->ai_next = ai->ai_next;
-  ai->ai_next = new_ai;
-
-  new_ai->ai_flags = 0;
-  new_ai->ai_family = ai->ai_family;
-  new_ai->ai_socktype = ai->ai_socktype;
-  new_ai->ai_protocol = ai->ai_protocol;
-  new_ai->ai_canonname = 0;
-  new_ai->ai_addrlen = ai->ai_addrlen;
-  new_ai->ai_addr = gai_alloc<sockaddr>(ai->ai_addrlen);
-  memcpy(new_ai->ai_addr, ai->ai_addr, ai->ai_addrlen);
-
-  return new_ai;
-}
-
-inline int gai_port(addrinfo_type* aihead, int port, int socktype)
-{
-  int num_found = 0;
-
-  for (addrinfo_type* ai = aihead; ai; ai = ai->ai_next)
-  {
-    if (ai->ai_flags & gai_clone_flag)
-    {
-      if (ai->ai_socktype != 0)
-      {
-        ai = gai_clone(ai);
-        if (ai == 0)
-          return -1;
-        // ai now points to newly cloned entry.
-      }
-    }
-    else if (ai->ai_socktype != socktype)
-    {
-      // Ignore if mismatch on socket type.
-      continue;
-    }
-
-    ai->ai_socktype = socktype;
-
-    switch (ai->ai_family)
-    {
-    case ASIO_OS_DEF(AF_INET):
-      {
-        sockaddr_in4_type* sinptr =
-          reinterpret_cast<sockaddr_in4_type*>(ai->ai_addr);
-        sinptr->sin_port = port;
-        ++num_found;
-        break;
-      }
-    case ASIO_OS_DEF(AF_INET6):
-      {
-        sockaddr_in6_type* sin6ptr =
-          reinterpret_cast<sockaddr_in6_type*>(ai->ai_addr);
-        sin6ptr->sin6_port = port;
-        ++num_found;
-        break;
-      }
-    default:
-      break;
-    }
-  }
-
-  return num_found;
-}
-
-inline int gai_serv(addrinfo_type* aihead,
-    const addrinfo_type* hints, const char* serv)
-{
-  using namespace std;
-
-  int num_found = 0;
-
-  if (
-#if defined(AI_NUMERICSERV)
-      (hints->ai_flags & AI_NUMERICSERV) ||
-#endif
-      isdigit(static_cast<unsigned char>(serv[0])))
-  {
-    int port = htons(atoi(serv));
-    if (hints->ai_socktype)
-    {
-      // Caller specifies socket type.
-      int rc = gai_port(aihead, port, hints->ai_socktype);
-      if (rc < 0)
-        return EAI_MEMORY;
-      num_found += rc;
-    }
-    else
-    {
-      // Caller does not specify socket type.
-      int rc = gai_port(aihead, port, SOCK_STREAM);
-      if (rc < 0)
-        return EAI_MEMORY;
-      num_found += rc;
-      rc = gai_port(aihead, port, SOCK_DGRAM);
-      if (rc < 0)
-        return EAI_MEMORY;
-      num_found += rc;
-    }
-  }
-  else
-  {
-    // Try service name with TCP first, then UDP.
-    if (hints->ai_socktype == 0 || hints->ai_socktype == SOCK_STREAM)
-    {
-      servent* sptr = getservbyname(serv, "tcp");
-      if (sptr != 0)
-      {
-        int rc = gai_port(aihead, sptr->s_port, SOCK_STREAM);
-        if (rc < 0)
-          return EAI_MEMORY;
-        num_found += rc;
-      }
-    }
-    if (hints->ai_socktype == 0 || hints->ai_socktype == SOCK_DGRAM)
-    {
-      servent* sptr = getservbyname(serv, "udp");
-      if (sptr != 0)
-      {
-        int rc = gai_port(aihead, sptr->s_port, SOCK_DGRAM);
-        if (rc < 0)
-          return EAI_MEMORY;
-        num_found += rc;
-      }
-    }
-  }
-
-  if (num_found == 0)
-  {
-    if (hints->ai_socktype == 0)
-    {
-      // All calls to getservbyname() failed.
-      return EAI_NONAME;
-    }
-    else
-    {
-      // Service not supported for socket type.
-      return EAI_SERVICE;
-    }
-  }
-
-  return 0;
-}
-
-inline int gai_echeck(const char* host, const char* service,
-    int flags, int family, int socktype, int protocol)
-{
-  (void)(flags);
-  (void)(protocol);
-
-  // Host or service must be specified.
-  if (host == 0 || host[0] == '\0')
-    if (service == 0 || service[0] == '\0')
-      return EAI_NONAME;
-
-  // Check combination of family and socket type.
-  switch (family)
-  {
-  case ASIO_OS_DEF(AF_UNSPEC):
-    break;
-  case ASIO_OS_DEF(AF_INET):
-  case ASIO_OS_DEF(AF_INET6):
-    if (service != 0 && service[0] != '\0')
-      if (socktype != 0 && socktype != SOCK_STREAM && socktype != SOCK_DGRAM)
-        return EAI_SOCKTYPE;
-    break;
-  default:
-    return EAI_FAMILY;
-  }
-
-  return 0;
-}
-
-inline void freeaddrinfo_emulation(addrinfo_type* aihead)
-{
-  addrinfo_type* ai = aihead;
-  while (ai)
-  {
-    gai_free(ai->ai_addr);
-    gai_free(ai->ai_canonname);
-    addrinfo_type* ainext = ai->ai_next;
-    gai_free(ai);
-    ai = ainext;
-  }
-}
-
-inline int getaddrinfo_emulation(const char* host, const char* service,
-    const addrinfo_type* hintsp, addrinfo_type** result)
-{
-  // Set up linked list of addrinfo structures.
-  addrinfo_type* aihead = 0;
-  addrinfo_type** ainext = &aihead;
-  char* canon = 0;
-
-  // Supply default hints if not specified by caller.
-  addrinfo_type hints = addrinfo_type();
-  hints.ai_family = ASIO_OS_DEF(AF_UNSPEC);
-  if (hintsp)
-    hints = *hintsp;
-
-  // If the resolution is not specifically for AF_INET6, remove the AI_V4MAPPED
-  // and AI_ALL flags.
-#if defined(AI_V4MAPPED)
-  if (hints.ai_family != ASIO_OS_DEF(AF_INET6))
-    hints.ai_flags &= ~AI_V4MAPPED;
-#endif
-#if defined(AI_ALL)
-  if (hints.ai_family != ASIO_OS_DEF(AF_INET6))
-    hints.ai_flags &= ~AI_ALL;
-#endif
-
-  // Basic error checking.
-  int rc = gai_echeck(host, service, hints.ai_flags, hints.ai_family,
-      hints.ai_socktype, hints.ai_protocol);
-  if (rc != 0)
-  {
-    freeaddrinfo_emulation(aihead);
-    return rc;
-  }
-
-  gai_search search[2];
-  int search_count = gai_nsearch(host, &hints, search);
-  for (gai_search* sptr = search; sptr < search + search_count; ++sptr)
-  {
-    // Check for IPv4 dotted decimal string.
-    in4_addr_type inaddr;
-    asio::error_code ec;
-    if (socket_ops::inet_pton(ASIO_OS_DEF(AF_INET),
-          sptr->host, &inaddr, 0, ec) == 1)
-    {
-      if (hints.ai_family != ASIO_OS_DEF(AF_UNSPEC)
-          && hints.ai_family != ASIO_OS_DEF(AF_INET))
-      {
-        freeaddrinfo_emulation(aihead);
-        gai_free(canon);
-        return EAI_FAMILY;
-      }
-      if (sptr->family == ASIO_OS_DEF(AF_INET))
-      {
-        rc = gai_aistruct(&ainext, &hints, &inaddr, ASIO_OS_DEF(AF_INET));
-        if (rc != 0)
-        {
-          freeaddrinfo_emulation(aihead);
-          gai_free(canon);
-          return rc;
-        }
-      }
-      continue;
-    }
-
-    // Check for IPv6 hex string.
-    in6_addr_type in6addr;
-    if (socket_ops::inet_pton(ASIO_OS_DEF(AF_INET6),
-          sptr->host, &in6addr, 0, ec) == 1)
-    {
-      if (hints.ai_family != ASIO_OS_DEF(AF_UNSPEC)
-          && hints.ai_family != ASIO_OS_DEF(AF_INET6))
-      {
-        freeaddrinfo_emulation(aihead);
-        gai_free(canon);
-        return EAI_FAMILY;
-      }
-      if (sptr->family == ASIO_OS_DEF(AF_INET6))
-      {
-        rc = gai_aistruct(&ainext, &hints, &in6addr,
-            ASIO_OS_DEF(AF_INET6));
-        if (rc != 0)
-        {
-          freeaddrinfo_emulation(aihead);
-          gai_free(canon);
-          return rc;
-        }
-      }
-      continue;
-    }
-
-    // Look up hostname.
-    hostent hent;
-    char hbuf[8192] = "";
-    hostent* hptr = socket_ops::gethostbyname(sptr->host,
-        sptr->family, &hent, hbuf, sizeof(hbuf), hints.ai_flags, ec);
-    if (hptr == 0)
-    {
-      if (search_count == 2)
-      {
-        // Failure is OK if there are multiple searches.
-        continue;
-      }
-      freeaddrinfo_emulation(aihead);
-      gai_free(canon);
-      if (ec == asio::error::host_not_found)
-        return EAI_NONAME;
-      if (ec == asio::error::host_not_found_try_again)
-        return EAI_AGAIN;
-      if (ec == asio::error::no_recovery)
-        return EAI_FAIL;
-      if (ec == asio::error::no_data)
-        return EAI_NONAME;
-      return EAI_NONAME;
-    }
-
-    // Check for address family mismatch if one was specified.
-    if (hints.ai_family != ASIO_OS_DEF(AF_UNSPEC)
-        && hints.ai_family != hptr->h_addrtype)
-    {
-      freeaddrinfo_emulation(aihead);
-      gai_free(canon);
-      socket_ops::freehostent(hptr);
-      return EAI_FAMILY;
-    }
-
-    // Save canonical name first time.
-    if (host != 0 && host[0] != '\0' && hptr->h_name && hptr->h_name[0]
-        && (hints.ai_flags & AI_CANONNAME) && canon == 0)
-    {
-      std::size_t canon_len = strlen(hptr->h_name) + 1;
-      canon = gai_alloc<char>(canon_len);
-      if (canon == 0)
-      {
-        freeaddrinfo_emulation(aihead);
-        socket_ops::freehostent(hptr);
-        return EAI_MEMORY;
-      }
-      gai_strcpy(canon, hptr->h_name, canon_len);
-    }
-
-    // Create an addrinfo structure for each returned address.
-    for (char** ap = hptr->h_addr_list; *ap; ++ap)
-    {
-      rc = gai_aistruct(&ainext, &hints, *ap, hptr->h_addrtype);
-      if (rc != 0)
-      {
-        freeaddrinfo_emulation(aihead);
-        gai_free(canon);
-        socket_ops::freehostent(hptr);
-        return EAI_FAMILY;
-      }
-    }
-
-    socket_ops::freehostent(hptr);
-  }
-
-  // Check if we found anything.
-  if (aihead == 0)
-  {
-    gai_free(canon);
-    return EAI_NONAME;
-  }
-
-  // Return canonical name in first entry.
-  if (host != 0 && host[0] != '\0' && (hints.ai_flags & AI_CANONNAME))
-  {
-    if (canon)
-    {
-      aihead->ai_canonname = canon;
-      canon = 0;
-    }
-    else
-    {
-      std::size_t canonname_len = strlen(search[0].host) + 1;
-      aihead->ai_canonname = gai_alloc<char>(canonname_len);
-      if (aihead->ai_canonname == 0)
-      {
-        freeaddrinfo_emulation(aihead);
-        return EAI_MEMORY;
-      }
-      gai_strcpy(aihead->ai_canonname, search[0].host, canonname_len);
-    }
-  }
-  gai_free(canon);
-
-  // Process the service name.
-  if (service != 0 && service[0] != '\0')
-  {
-    rc = gai_serv(aihead, &hints, service);
-    if (rc != 0)
-    {
-      freeaddrinfo_emulation(aihead);
-      return rc;
-    }
-  }
-
-  // Return result to caller.
-  *result = aihead;
-  return 0;
-}
-
-inline asio::error_code getnameinfo_emulation(
-    const socket_addr_type* sa, std::size_t salen, char* host,
-    std::size_t hostlen, char* serv, std::size_t servlen, int flags,
-    asio::error_code& ec)
-{
-  using namespace std;
-
-  const char* addr;
-  size_t addr_len;
-  unsigned short port;
-  switch (sa->sa_family)
-  {
-  case ASIO_OS_DEF(AF_INET):
-    if (salen != sizeof(sockaddr_in4_type))
-    {
-      return ec = asio::error::invalid_argument;
-    }
-    addr = reinterpret_cast<const char*>(
-        &reinterpret_cast<const sockaddr_in4_type*>(sa)->sin_addr);
-    addr_len = sizeof(in4_addr_type);
-    port = reinterpret_cast<const sockaddr_in4_type*>(sa)->sin_port;
-    break;
-  case ASIO_OS_DEF(AF_INET6):
-    if (salen != sizeof(sockaddr_in6_type))
-    {
-      return ec = asio::error::invalid_argument;
-    }
-    addr = reinterpret_cast<const char*>(
-        &reinterpret_cast<const sockaddr_in6_type*>(sa)->sin6_addr);
-    addr_len = sizeof(in6_addr_type);
-    port = reinterpret_cast<const sockaddr_in6_type*>(sa)->sin6_port;
-    break;
-  default:
-    return ec = asio::error::address_family_not_supported;
-  }
-
-  if (host && hostlen > 0)
-  {
-    if (flags & NI_NUMERICHOST)
-    {
-      if (socket_ops::inet_ntop(sa->sa_family, addr, host, hostlen, 0, ec) == 0)
-      {
-        return ec;
-      }
-    }
-    else
-    {
-      hostent hent;
-      char hbuf[8192] = "";
-      hostent* hptr = socket_ops::gethostbyaddr(addr,
-          static_cast<int>(addr_len), sa->sa_family,
-          &hent, hbuf, sizeof(hbuf), ec);
-      if (hptr && hptr->h_name && hptr->h_name[0] != '\0')
-      {
-        if (flags & NI_NOFQDN)
-        {
-          char* dot = strchr(hptr->h_name, '.');
-          if (dot)
-          {
-            *dot = 0;
-          }
-        }
-        gai_strcpy(host, hptr->h_name, hostlen);
-        socket_ops::freehostent(hptr);
-      }
-      else
-      {
-        socket_ops::freehostent(hptr);
-        if (flags & NI_NAMEREQD)
-        {
-          return ec = asio::error::host_not_found;
-        }
-        if (socket_ops::inet_ntop(sa->sa_family,
-              addr, host, hostlen, 0, ec) == 0)
-        {
-          return ec;
-        }
-      }
-    }
-  }
-
-  if (serv && servlen > 0)
-  {
-    if (flags & NI_NUMERICSERV)
-    {
-      if (servlen < 6)
-      {
-        return ec = asio::error::no_buffer_space;
-      }
-#if defined(ASIO_HAS_SECURE_RTL)
-      sprintf_s(serv, servlen, "%u", ntohs(port));
-#else // defined(ASIO_HAS_SECURE_RTL)
-      sprintf(serv, "%u", ntohs(port));
-#endif // defined(ASIO_HAS_SECURE_RTL)
-    }
-    else
-    {
-#if defined(ASIO_HAS_PTHREADS)
-      static ::pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
-      ::pthread_mutex_lock(&mutex);
-#endif // defined(ASIO_HAS_PTHREADS)
-      servent* sptr = ::getservbyport(port, (flags & NI_DGRAM) ? "udp" : 0);
-      if (sptr && sptr->s_name && sptr->s_name[0] != '\0')
-      {
-        gai_strcpy(serv, sptr->s_name, servlen);
-      }
-      else
-      {
-        if (servlen < 6)
-        {
-          return ec = asio::error::no_buffer_space;
-        }
-#if defined(ASIO_HAS_SECURE_RTL)
-        sprintf_s(serv, servlen, "%u", ntohs(port));
-#else // defined(ASIO_HAS_SECURE_RTL)
-        sprintf(serv, "%u", ntohs(port));
-#endif // defined(ASIO_HAS_SECURE_RTL)
-      }
-#if defined(ASIO_HAS_PTHREADS)
-      ::pthread_mutex_unlock(&mutex);
-#endif // defined(ASIO_HAS_PTHREADS)
-    }
-  }
-
-  ec = asio::error_code();
-  return ec;
-}
-
-#endif // defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-       //   || defined(__MACH__) && defined(__APPLE__)
-
-inline asio::error_code translate_addrinfo_error(int error)
-{
-  switch (error)
-  {
-  case 0:
-    return asio::error_code();
-  case EAI_AGAIN:
-    return asio::error::host_not_found_try_again;
-  case EAI_BADFLAGS:
-    return asio::error::invalid_argument;
-  case EAI_FAIL:
-    return asio::error::no_recovery;
-  case EAI_FAMILY:
-    return asio::error::address_family_not_supported;
-  case EAI_MEMORY:
-    return asio::error::no_memory;
-  case EAI_NONAME:
-#if defined(EAI_ADDRFAMILY)
-  case EAI_ADDRFAMILY:
-#endif
-#if defined(EAI_NODATA) && (EAI_NODATA != EAI_NONAME)
-  case EAI_NODATA:
-#endif
-    return asio::error::host_not_found;
-  case EAI_SERVICE:
-    return asio::error::service_not_found;
-  case EAI_SOCKTYPE:
-    return asio::error::socket_type_not_supported;
-  default: // Possibly the non-portable EAI_SYSTEM.
-#if defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-    return asio::error_code(
-        WSAGetLastError(), asio::error::get_system_category());
-#else
-    return asio::error_code(
-        errno, asio::error::get_system_category());
-#endif
-  }
-}
-
-asio::error_code getaddrinfo(const char* host,
-    const char* service, const addrinfo_type& hints,
-    addrinfo_type** result, asio::error_code& ec)
-{
-  host = (host && *host) ? host : 0;
-  service = (service && *service) ? service : 0;
-  clear_last_error();
-#if defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-# if defined(_WIN32_WINNT) && (_WIN32_WINNT >= 0x0501) || defined(UNDER_CE)
-  // Building for Windows XP, Windows Server 2003, or later.
-  int error = ::getaddrinfo(host, service, &hints, result);
-  return ec = translate_addrinfo_error(error);
-# else
-  // Building for Windows 2000 or earlier.
-  typedef int (WSAAPI *gai_t)(const char*,
-      const char*, const addrinfo_type*, addrinfo_type**);
-  if (HMODULE winsock_module = ::GetModuleHandleA("ws2_32"))
-  {
-    if (gai_t gai = (gai_t)::GetProcAddress(winsock_module, "getaddrinfo"))
-    {
-      int error = gai(host, service, &hints, result);
-      return ec = translate_addrinfo_error(error);
-    }
-  }
-  int error = getaddrinfo_emulation(host, service, &hints, result);
-  return ec = translate_addrinfo_error(error);
-# endif
-#elif defined(__MACH__) && defined(__APPLE__)
-  int error = getaddrinfo_emulation(host, service, &hints, result);
-  return ec = translate_addrinfo_error(error);
-#else
-  int error = ::getaddrinfo(host, service, &hints, result);
-  return ec = translate_addrinfo_error(error);
-#endif
-}
-
-asio::error_code background_getaddrinfo(
-    const weak_cancel_token_type& cancel_token, const char* host,
-    const char* service, const addrinfo_type& hints,
-    addrinfo_type** result, asio::error_code& ec)
-{
-  if (cancel_token.expired())
-    ec = asio::error::operation_aborted;
-  else
-    socket_ops::getaddrinfo(host, service, hints, result, ec);
-  return ec;
-}
-
-void freeaddrinfo(addrinfo_type* ai)
-{
-#if defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-# if defined(_WIN32_WINNT) && (_WIN32_WINNT >= 0x0501) || defined(UNDER_CE)
-  // Building for Windows XP, Windows Server 2003, or later.
-  ::freeaddrinfo(ai);
-# else
-  // Building for Windows 2000 or earlier.
-  typedef int (WSAAPI *fai_t)(addrinfo_type*);
-  if (HMODULE winsock_module = ::GetModuleHandleA("ws2_32"))
-  {
-    if (fai_t fai = (fai_t)::GetProcAddress(winsock_module, "freeaddrinfo"))
-    {
-      fai(ai);
-      return;
-    }
-  }
-  freeaddrinfo_emulation(ai);
-# endif
-#elif defined(__MACH__) && defined(__APPLE__)
-  freeaddrinfo_emulation(ai);
-#else
-  ::freeaddrinfo(ai);
-#endif
-}
-
-asio::error_code getnameinfo(const socket_addr_type* addr,
-    std::size_t addrlen, char* host, std::size_t hostlen,
-    char* serv, std::size_t servlen, int flags, asio::error_code& ec)
-{
-#if defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-# if defined(_WIN32_WINNT) && (_WIN32_WINNT >= 0x0501) || defined(UNDER_CE)
-  // Building for Windows XP, Windows Server 2003, or later.
-  clear_last_error();
-  int error = ::getnameinfo(addr, static_cast<socklen_t>(addrlen),
-      host, static_cast<DWORD>(hostlen),
-      serv, static_cast<DWORD>(servlen), flags);
-  return ec = translate_addrinfo_error(error);
-# else
-  // Building for Windows 2000 or earlier.
-  typedef int (WSAAPI *gni_t)(const socket_addr_type*,
-      int, char*, DWORD, char*, DWORD, int);
-  if (HMODULE winsock_module = ::GetModuleHandleA("ws2_32"))
-  {
-    if (gni_t gni = (gni_t)::GetProcAddress(winsock_module, "getnameinfo"))
-    {
-      clear_last_error();
-      int error = gni(addr, static_cast<int>(addrlen),
-          host, static_cast<DWORD>(hostlen),
-          serv, static_cast<DWORD>(servlen), flags);
-      return ec = translate_addrinfo_error(error);
-    }
-  }
-  clear_last_error();
-  return getnameinfo_emulation(addr, addrlen,
-      host, hostlen, serv, servlen, flags, ec);
-# endif
-#elif defined(__MACH__) && defined(__APPLE__)
-  using namespace std; // For memcpy.
-  sockaddr_storage_type tmp_addr;
-  memcpy(&tmp_addr, addr, addrlen);
-  tmp_addr.ss_len = addrlen;
-  addr = reinterpret_cast<socket_addr_type*>(&tmp_addr);
-  clear_last_error();
-  return getnameinfo_emulation(addr, addrlen,
-      host, hostlen, serv, servlen, flags, ec);
-#else
-  clear_last_error();
-  int error = ::getnameinfo(addr, addrlen, host, hostlen, serv, servlen, flags);
-  return ec = translate_addrinfo_error(error);
-#endif
-}
-
-asio::error_code sync_getnameinfo(
-    const socket_addr_type* addr, std::size_t addrlen,
-    char* host, std::size_t hostlen, char* serv,
-    std::size_t servlen, int sock_type, asio::error_code& ec)
-{
-  // First try resolving with the service name. If that fails try resolving
-  // but allow the service to be returned as a number.
-  int flags = (sock_type == SOCK_DGRAM) ? NI_DGRAM : 0;
-  socket_ops::getnameinfo(addr, addrlen, host,
-      hostlen, serv, servlen, flags, ec);
-  if (ec)
-  {
-    socket_ops::getnameinfo(addr, addrlen, host, hostlen,
-        serv, servlen, flags | NI_NUMERICSERV, ec);
-  }
-
-  return ec;
-}
-
-asio::error_code background_getnameinfo(
-    const weak_cancel_token_type& cancel_token,
-    const socket_addr_type* addr, std::size_t addrlen,
-    char* host, std::size_t hostlen, char* serv,
-    std::size_t servlen, int sock_type, asio::error_code& ec)
-{
-  if (cancel_token.expired())
-  {
-    ec = asio::error::operation_aborted;
-  }
-  else
-  {
-    // First try resolving with the service name. If that fails try resolving
-    // but allow the service to be returned as a number.
-    int flags = (sock_type == SOCK_DGRAM) ? NI_DGRAM : 0;
-    socket_ops::getnameinfo(addr, addrlen, host,
-        hostlen, serv, servlen, flags, ec);
-    if (ec)
-    {
-      socket_ops::getnameinfo(addr, addrlen, host, hostlen,
-          serv, servlen, flags | NI_NUMERICSERV, ec);
-    }
-  }
-
-  return ec;
-}
-
-#endif // !defined(ASIO_WINDOWS_RUNTIME)
-
-u_long_type network_to_host_long(u_long_type value)
-{
-#if defined(ASIO_WINDOWS_RUNTIME)
-  unsigned char* value_p = reinterpret_cast<unsigned char*>(&value);
-  u_long_type result = (static_cast<u_long_type>(value_p[0]) << 24)
-    | (static_cast<u_long_type>(value_p[1]) << 16)
-    | (static_cast<u_long_type>(value_p[2]) << 8)
-    | static_cast<u_long_type>(value_p[3]);
-  return result;
-#else // defined(ASIO_WINDOWS_RUNTIME)
-  return ntohl(value);
-#endif // defined(ASIO_WINDOWS_RUNTIME)
-}
-
-u_long_type host_to_network_long(u_long_type value)
-{
-#if defined(ASIO_WINDOWS_RUNTIME)
-  u_long_type result;
-  unsigned char* result_p = reinterpret_cast<unsigned char*>(&result);
-  result_p[0] = static_cast<unsigned char>((value >> 24) & 0xFF);
-  result_p[1] = static_cast<unsigned char>((value >> 16) & 0xFF);
-  result_p[2] = static_cast<unsigned char>((value >> 8) & 0xFF);
-  result_p[3] = static_cast<unsigned char>(value & 0xFF);
-  return result;
-#else // defined(ASIO_WINDOWS_RUNTIME)
-  return htonl(value);
-#endif // defined(ASIO_WINDOWS_RUNTIME)
-}
-
-u_short_type network_to_host_short(u_short_type value)
-{
-#if defined(ASIO_WINDOWS_RUNTIME)
-  unsigned char* value_p = reinterpret_cast<unsigned char*>(&value);
-  u_short_type result = (static_cast<u_long_type>(value_p[0]) << 8)
-    | static_cast<u_long_type>(value_p[1]);
-  return result;
-#else // defined(ASIO_WINDOWS_RUNTIME)
-  return ntohs(value);
-#endif // defined(ASIO_WINDOWS_RUNTIME)
-}
-
-u_short_type host_to_network_short(u_short_type value)
-{
-#if defined(ASIO_WINDOWS_RUNTIME)
-  u_long_type result;
-  unsigned char* result_p = reinterpret_cast<unsigned char*>(&result);
-  result_p[0] = static_cast<unsigned char>((value >> 8) & 0xFF);
-  result_p[1] = static_cast<unsigned char>(value & 0xFF);
-  return result;
-#else // defined(ASIO_WINDOWS_RUNTIME)
-  return htons(value);
-#endif // defined(ASIO_WINDOWS_RUNTIME)
-}
-
-} // namespace socket_ops
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_DETAIL_SOCKET_OPS_IPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/socket_select_interrupter.ipp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/socket_select_interrupter.ipp
deleted file mode 100644
index bd6f3633ee28..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/socket_select_interrupter.ipp
+++ /dev/null
@@ -1,175 +0,0 @@
-//
-// detail/impl/socket_select_interrupter.ipp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_IMPL_SOCKET_SELECT_INTERRUPTER_IPP
-#define ASIO_DETAIL_IMPL_SOCKET_SELECT_INTERRUPTER_IPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if !defined(ASIO_WINDOWS_RUNTIME)
-
-#if defined(ASIO_WINDOWS) \
-  || defined(__CYGWIN__) \
-  || defined(__SYMBIAN32__)
-
-#include <cstdlib>
-#include "asio/detail/socket_holder.hpp"
-#include "asio/detail/socket_ops.hpp"
-#include "asio/detail/socket_select_interrupter.hpp"
-#include "asio/detail/throw_error.hpp"
-#include "asio/error.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-socket_select_interrupter::socket_select_interrupter()
-{
-  open_descriptors();
-}
-
-void socket_select_interrupter::open_descriptors()
-{
-  asio::error_code ec;
-  socket_holder acceptor(socket_ops::socket(
-        AF_INET, SOCK_STREAM, IPPROTO_TCP, ec));
-  if (acceptor.get() == invalid_socket)
-    asio::detail::throw_error(ec, "socket_select_interrupter");
-
-  int opt = 1;
-  socket_ops::state_type acceptor_state = 0;
-  socket_ops::setsockopt(acceptor.get(), acceptor_state,
-      SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt), ec);
-
-  using namespace std; // For memset.
-  sockaddr_in4_type addr;
-  std::size_t addr_len = sizeof(addr);
-  memset(&addr, 0, sizeof(addr));
-  addr.sin_family = AF_INET;
-  addr.sin_addr.s_addr = inet_addr("127.0.0.1");
-  addr.sin_port = 0;
-  if (socket_ops::bind(acceptor.get(), (const socket_addr_type*)&addr,
-        addr_len, ec) == socket_error_retval)
-    asio::detail::throw_error(ec, "socket_select_interrupter");
-
-  if (socket_ops::getsockname(acceptor.get(), (socket_addr_type*)&addr,
-        &addr_len, ec) == socket_error_retval)
-    asio::detail::throw_error(ec, "socket_select_interrupter");
-
-  // Some broken firewalls on Windows will intermittently cause getsockname to
-  // return 0.0.0.0 when the socket is actually bound to 127.0.0.1. We
-  // explicitly specify the target address here to work around this problem.
-  addr.sin_addr.s_addr = inet_addr("127.0.0.1");
-
-  if (socket_ops::listen(acceptor.get(),
-        SOMAXCONN, ec) == socket_error_retval)
-    asio::detail::throw_error(ec, "socket_select_interrupter");
-
-  socket_holder client(socket_ops::socket(
-        AF_INET, SOCK_STREAM, IPPROTO_TCP, ec));
-  if (client.get() == invalid_socket)
-    asio::detail::throw_error(ec, "socket_select_interrupter");
-
-  if (socket_ops::connect(client.get(), (const socket_addr_type*)&addr,
-        addr_len, ec) == socket_error_retval)
-    asio::detail::throw_error(ec, "socket_select_interrupter");
-
-  socket_holder server(socket_ops::accept(acceptor.get(), 0, 0, ec));
-  if (server.get() == invalid_socket)
-    asio::detail::throw_error(ec, "socket_select_interrupter");
-  
-  ioctl_arg_type non_blocking = 1;
-  socket_ops::state_type client_state = 0;
-  if (socket_ops::ioctl(client.get(), client_state,
-        FIONBIO, &non_blocking, ec))
-    asio::detail::throw_error(ec, "socket_select_interrupter");
-
-  opt = 1;
-  socket_ops::setsockopt(client.get(), client_state,
-      IPPROTO_TCP, TCP_NODELAY, &opt, sizeof(opt), ec);
-
-  non_blocking = 1;
-  socket_ops::state_type server_state = 0;
-  if (socket_ops::ioctl(server.get(), server_state,
-        FIONBIO, &non_blocking, ec))
-    asio::detail::throw_error(ec, "socket_select_interrupter");
-
-  opt = 1;
-  socket_ops::setsockopt(server.get(), server_state,
-      IPPROTO_TCP, TCP_NODELAY, &opt, sizeof(opt), ec);
-
-  read_descriptor_ = server.release();
-  write_descriptor_ = client.release();
-}
-
-socket_select_interrupter::~socket_select_interrupter()
-{
-  close_descriptors();
-}
-
-void socket_select_interrupter::close_descriptors()
-{
-  asio::error_code ec;
-  socket_ops::state_type state = socket_ops::internal_non_blocking;
-  if (read_descriptor_ != invalid_socket)
-    socket_ops::close(read_descriptor_, state, true, ec);
-  if (write_descriptor_ != invalid_socket)
-    socket_ops::close(write_descriptor_, state, true, ec);
-}
-
-void socket_select_interrupter::recreate()
-{
-  close_descriptors();
-
-  write_descriptor_ = invalid_socket;
-  read_descriptor_ = invalid_socket;
-
-  open_descriptors();
-}
-
-void socket_select_interrupter::interrupt()
-{
-  char byte = 0;
-  socket_ops::buf b;
-  socket_ops::init_buf(b, &byte, 1);
-  asio::error_code ec;
-  socket_ops::send(write_descriptor_, &b, 1, 0, ec);
-}
-
-bool socket_select_interrupter::reset()
-{
-  char data[1024];
-  socket_ops::buf b;
-  socket_ops::init_buf(b, data, sizeof(data));
-  asio::error_code ec;
-  int bytes_read = socket_ops::recv(read_descriptor_, &b, 1, 0, ec);
-  bool was_interrupted = (bytes_read > 0);
-  while (bytes_read == sizeof(data))
-    bytes_read = socket_ops::recv(read_descriptor_, &b, 1, 0, ec);
-  return was_interrupted;
-}
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // defined(ASIO_WINDOWS)
-       // || defined(__CYGWIN__)
-       // || defined(__SYMBIAN32__)
-
-#endif // !defined(ASIO_WINDOWS_RUNTIME)
-
-#endif // ASIO_DETAIL_IMPL_SOCKET_SELECT_INTERRUPTER_IPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/strand_service.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/strand_service.hpp
deleted file mode 100644
index bed0ecae87b9..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/strand_service.hpp
+++ /dev/null
@@ -1,118 +0,0 @@
-//
-// detail/impl/strand_service.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_IMPL_STRAND_SERVICE_HPP
-#define ASIO_DETAIL_IMPL_STRAND_SERVICE_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/addressof.hpp"
-#include "asio/detail/call_stack.hpp"
-#include "asio/detail/completion_handler.hpp"
-#include "asio/detail/fenced_block.hpp"
-#include "asio/detail/handler_alloc_helpers.hpp"
-#include "asio/detail/handler_invoke_helpers.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-inline strand_service::strand_impl::strand_impl()
-  : operation(&strand_service::do_complete),
-    locked_(false)
-{
-}
-
-struct strand_service::on_dispatch_exit
-{
-  io_service_impl* io_service_;
-  strand_impl* impl_;
-
-  ~on_dispatch_exit()
-  {
-    impl_->mutex_.lock();
-    impl_->ready_queue_.push(impl_->waiting_queue_);
-    bool more_handlers = impl_->locked_ = !impl_->ready_queue_.empty();
-    impl_->mutex_.unlock();
-
-    if (more_handlers)
-      io_service_->post_immediate_completion(impl_, false);
-  }
-};
-
-template <typename Handler>
-void strand_service::dispatch(strand_service::implementation_type& impl,
-    Handler& handler)
-{
-  // If we are already in the strand then the handler can run immediately.
-  if (call_stack<strand_impl>::contains(impl))
-  {
-    fenced_block b(fenced_block::full);
-    asio_handler_invoke_helpers::invoke(handler, handler);
-    return;
-  }
-
-  // Allocate and construct an operation to wrap the handler.
-  typedef completion_handler<Handler> op;
-  typename op::ptr p = { asio::detail::addressof(handler),
-    asio_handler_alloc_helpers::allocate(
-      sizeof(op), handler), 0 };
-  p.p = new (p.v) op(handler);
-
-  ASIO_HANDLER_CREATION((p.p, "strand", impl, "dispatch"));
-
-  bool dispatch_immediately = do_dispatch(impl, p.p);
-  operation* o = p.p;
-  p.v = p.p = 0;
-
-  if (dispatch_immediately)
-  {
-    // Indicate that this strand is executing on the current thread.
-    call_stack<strand_impl>::context ctx(impl);
-
-    // Ensure the next handler, if any, is scheduled on block exit.
-    on_dispatch_exit on_exit = { &io_service_, impl };
-    (void)on_exit;
-
-    completion_handler<Handler>::do_complete(
-        &io_service_, o, asio::error_code(), 0);
-  }
-}
-
-// Request the io_service to invoke the given handler and return immediately.
-template <typename Handler>
-void strand_service::post(strand_service::implementation_type& impl,
-    Handler& handler)
-{
-  bool is_continuation =
-    asio_handler_cont_helpers::is_continuation(handler);
-
-  // Allocate and construct an operation to wrap the handler.
-  typedef completion_handler<Handler> op;
-  typename op::ptr p = { asio::detail::addressof(handler),
-    asio_handler_alloc_helpers::allocate(
-      sizeof(op), handler), 0 };
-  p.p = new (p.v) op(handler);
-
-  ASIO_HANDLER_CREATION((p.p, "strand", impl, "post"));
-
-  do_post(impl, p.p, is_continuation);
-  p.v = p.p = 0;
-}
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_DETAIL_IMPL_STRAND_SERVICE_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/strand_service.ipp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/strand_service.ipp
deleted file mode 100644
index 0083e86d227d..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/strand_service.ipp
+++ /dev/null
@@ -1,176 +0,0 @@
-//
-// detail/impl/strand_service.ipp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_IMPL_STRAND_SERVICE_IPP
-#define ASIO_DETAIL_IMPL_STRAND_SERVICE_IPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include "asio/detail/call_stack.hpp"
-#include "asio/detail/strand_service.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-struct strand_service::on_do_complete_exit
-{
-  io_service_impl* owner_;
-  strand_impl* impl_;
-
-  ~on_do_complete_exit()
-  {
-    impl_->mutex_.lock();
-    impl_->ready_queue_.push(impl_->waiting_queue_);
-    bool more_handlers = impl_->locked_ = !impl_->ready_queue_.empty();
-    impl_->mutex_.unlock();
-
-    if (more_handlers)
-      owner_->post_immediate_completion(impl_, true);
-  }
-};
-
-strand_service::strand_service(asio::io_service& io_service)
-  : asio::detail::service_base<strand_service>(io_service),
-    io_service_(asio::use_service<io_service_impl>(io_service)),
-    mutex_(),
-    salt_(0)
-{
-}
-
-void strand_service::shutdown_service()
-{
-  op_queue<operation> ops;
-
-  asio::detail::mutex::scoped_lock lock(mutex_);
-
-  for (std::size_t i = 0; i < num_implementations; ++i)
-  {
-    if (strand_impl* impl = implementations_[i].get())
-    {
-      ops.push(impl->waiting_queue_);
-      ops.push(impl->ready_queue_);
-    }
-  }
-}
-
-void strand_service::construct(strand_service::implementation_type& impl)
-{
-  asio::detail::mutex::scoped_lock lock(mutex_);
-
-  std::size_t salt = salt_++;
-#if defined(ASIO_ENABLE_SEQUENTIAL_STRAND_ALLOCATION)
-  std::size_t index = salt;
-#else // defined(ASIO_ENABLE_SEQUENTIAL_STRAND_ALLOCATION)
-  std::size_t index = reinterpret_cast<std::size_t>(&impl);
-  index += (reinterpret_cast<std::size_t>(&impl) >> 3);
-  index ^= salt + 0x9e3779b9 + (index << 6) + (index >> 2);
-#endif // defined(ASIO_ENABLE_SEQUENTIAL_STRAND_ALLOCATION)
-  index = index % num_implementations;
-
-  if (!implementations_[index].get())
-    implementations_[index].reset(new strand_impl);
-  impl = implementations_[index].get();
-}
-
-bool strand_service::running_in_this_thread(
-    const implementation_type& impl) const
-{
-  return call_stack<strand_impl>::contains(impl) != 0;
-}
-
-bool strand_service::do_dispatch(implementation_type& impl, operation* op)
-{
-  // If we are running inside the io_service, and no other handler already
-  // holds the strand lock, then the handler can run immediately.
-  bool can_dispatch = io_service_.can_dispatch();
-  impl->mutex_.lock();
-  if (can_dispatch && !impl->locked_)
-  {
-    // Immediate invocation is allowed.
-    impl->locked_ = true;
-    impl->mutex_.unlock();
-    return true;
-  }
-
-  if (impl->locked_)
-  {
-    // Some other handler already holds the strand lock. Enqueue for later.
-    impl->waiting_queue_.push(op);
-    impl->mutex_.unlock();
-  }
-  else
-  {
-    // The handler is acquiring the strand lock and so is responsible for
-    // scheduling the strand.
-    impl->locked_ = true;
-    impl->mutex_.unlock();
-    impl->ready_queue_.push(op);
-    io_service_.post_immediate_completion(impl, false);
-  }
-
-  return false;
-}
-
-void strand_service::do_post(implementation_type& impl,
-    operation* op, bool is_continuation)
-{
-  impl->mutex_.lock();
-  if (impl->locked_)
-  {
-    // Some other handler already holds the strand lock. Enqueue for later.
-    impl->waiting_queue_.push(op);
-    impl->mutex_.unlock();
-  }
-  else
-  {
-    // The handler is acquiring the strand lock and so is responsible for
-    // scheduling the strand.
-    impl->locked_ = true;
-    impl->mutex_.unlock();
-    impl->ready_queue_.push(op);
-    io_service_.post_immediate_completion(impl, is_continuation);
-  }
-}
-
-void strand_service::do_complete(io_service_impl* owner, operation* base,
-    const asio::error_code& ec, std::size_t /*bytes_transferred*/)
-{
-  if (owner)
-  {
-    strand_impl* impl = static_cast<strand_impl*>(base);
-
-    // Indicate that this strand is executing on the current thread.
-    call_stack<strand_impl>::context ctx(impl);
-
-    // Ensure the next handler, if any, is scheduled on block exit.
-    on_do_complete_exit on_exit = { owner, impl };
-    (void)on_exit;
-
-    // Run all ready handlers. No lock is required since the ready queue is
-    // accessed only within the strand.
-    while (operation* o = impl->ready_queue_.front())
-    {
-      impl->ready_queue_.pop();
-      o->complete(*owner, ec, 0);
-    }
-  }
-}
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_DETAIL_IMPL_STRAND_SERVICE_IPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/task_io_service.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/task_io_service.hpp
deleted file mode 100644
index 9e8bc8fea0ad..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/task_io_service.hpp
+++ /dev/null
@@ -1,78 +0,0 @@
-//
-// detail/impl/task_io_service.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_IMPL_TASK_IO_SERVICE_HPP
-#define ASIO_DETAIL_IMPL_TASK_IO_SERVICE_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/addressof.hpp"
-#include "asio/detail/completion_handler.hpp"
-#include "asio/detail/fenced_block.hpp"
-#include "asio/detail/handler_alloc_helpers.hpp"
-#include "asio/detail/handler_cont_helpers.hpp"
-#include "asio/detail/handler_invoke_helpers.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-template <typename Handler>
-void task_io_service::dispatch(Handler& handler)
-{
-  if (thread_call_stack::contains(this))
-  {
-    fenced_block b(fenced_block::full);
-    asio_handler_invoke_helpers::invoke(handler, handler);
-  }
-  else
-  {
-    // Allocate and construct an operation to wrap the handler.
-    typedef completion_handler<Handler> op;
-    typename op::ptr p = { asio::detail::addressof(handler),
-      asio_handler_alloc_helpers::allocate(
-        sizeof(op), handler), 0 };
-    p.p = new (p.v) op(handler);
-
-    ASIO_HANDLER_CREATION((p.p, "io_service", this, "dispatch"));
-
-    do_dispatch(p.p);
-    p.v = p.p = 0;
-  }
-}
-
-template <typename Handler>
-void task_io_service::post(Handler& handler)
-{
-  bool is_continuation =
-    asio_handler_cont_helpers::is_continuation(handler);
-
-  // Allocate and construct an operation to wrap the handler.
-  typedef completion_handler<Handler> op;
-  typename op::ptr p = { asio::detail::addressof(handler),
-    asio_handler_alloc_helpers::allocate(
-      sizeof(op), handler), 0 };
-  p.p = new (p.v) op(handler);
-
-  ASIO_HANDLER_CREATION((p.p, "io_service", this, "post"));
-
-  post_immediate_completion(p.p, is_continuation);
-  p.v = p.p = 0;
-}
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_DETAIL_IMPL_TASK_IO_SERVICE_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/task_io_service.ipp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/task_io_service.ipp
deleted file mode 100644
index baf27c8cb3f8..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/task_io_service.ipp
+++ /dev/null
@@ -1,474 +0,0 @@
-//
-// detail/impl/task_io_service.ipp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_IMPL_TASK_IO_SERVICE_IPP
-#define ASIO_DETAIL_IMPL_TASK_IO_SERVICE_IPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if !defined(ASIO_HAS_IOCP)
-
-#include "asio/detail/event.hpp"
-#include "asio/detail/limits.hpp"
-#include "asio/detail/reactor.hpp"
-#include "asio/detail/task_io_service.hpp"
-#include "asio/detail/task_io_service_thread_info.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-struct task_io_service::task_cleanup
-{
-  ~task_cleanup()
-  {
-    if (this_thread_->private_outstanding_work > 0)
-    {
-      asio::detail::increment(
-          task_io_service_->outstanding_work_,
-          this_thread_->private_outstanding_work);
-    }
-    this_thread_->private_outstanding_work = 0;
-
-    // Enqueue the completed operations and reinsert the task at the end of
-    // the operation queue.
-    lock_->lock();
-    task_io_service_->task_interrupted_ = true;
-    task_io_service_->op_queue_.push(this_thread_->private_op_queue);
-    task_io_service_->op_queue_.push(&task_io_service_->task_operation_);
-  }
-
-  task_io_service* task_io_service_;
-  mutex::scoped_lock* lock_;
-  thread_info* this_thread_;
-};
-
-struct task_io_service::work_cleanup
-{
-  ~work_cleanup()
-  {
-    if (this_thread_->private_outstanding_work > 1)
-    {
-      asio::detail::increment(
-          task_io_service_->outstanding_work_,
-          this_thread_->private_outstanding_work - 1);
-    }
-    else if (this_thread_->private_outstanding_work < 1)
-    {
-      task_io_service_->work_finished();
-    }
-    this_thread_->private_outstanding_work = 0;
-
-#if defined(ASIO_HAS_THREADS)
-    if (!this_thread_->private_op_queue.empty())
-    {
-      lock_->lock();
-      task_io_service_->op_queue_.push(this_thread_->private_op_queue);
-    }
-#endif // defined(ASIO_HAS_THREADS)
-  }
-
-  task_io_service* task_io_service_;
-  mutex::scoped_lock* lock_;
-  thread_info* this_thread_;
-};
-
-task_io_service::task_io_service(
-    asio::io_service& io_service, std::size_t concurrency_hint)
-  : asio::detail::service_base<task_io_service>(io_service),
-    one_thread_(concurrency_hint == 1),
-    mutex_(),
-    task_(0),
-    task_interrupted_(true),
-    outstanding_work_(0),
-    stopped_(false),
-    shutdown_(false)
-{
-  ASIO_HANDLER_TRACKING_INIT;
-}
-
-void task_io_service::shutdown_service()
-{
-  mutex::scoped_lock lock(mutex_);
-  shutdown_ = true;
-  lock.unlock();
-
-  // Destroy handler objects.
-  while (!op_queue_.empty())
-  {
-    operation* o = op_queue_.front();
-    op_queue_.pop();
-    if (o != &task_operation_)
-      o->destroy();
-  }
-
-  // Reset to initial state.
-  task_ = 0;
-}
-
-void task_io_service::init_task()
-{
-  mutex::scoped_lock lock(mutex_);
-  if (!shutdown_ && !task_)
-  {
-    task_ = &use_service<reactor>(this->get_io_service());
-    op_queue_.push(&task_operation_);
-    wake_one_thread_and_unlock(lock);
-  }
-}
-
-std::size_t task_io_service::run(asio::error_code& ec)
-{
-  ec = asio::error_code();
-  if (outstanding_work_ == 0)
-  {
-    stop();
-    return 0;
-  }
-
-  thread_info this_thread;
-  this_thread.private_outstanding_work = 0;
-  thread_call_stack::context ctx(this, this_thread);
-
-  mutex::scoped_lock lock(mutex_);
-
-  std::size_t n = 0;
-  for (; do_run_one(lock, this_thread, ec); lock.lock())
-    if (n != (std::numeric_limits<std::size_t>::max)())
-      ++n;
-  return n;
-}
-
-std::size_t task_io_service::run_one(asio::error_code& ec)
-{
-  ec = asio::error_code();
-  if (outstanding_work_ == 0)
-  {
-    stop();
-    return 0;
-  }
-
-  thread_info this_thread;
-  this_thread.private_outstanding_work = 0;
-  thread_call_stack::context ctx(this, this_thread);
-
-  mutex::scoped_lock lock(mutex_);
-
-  return do_run_one(lock, this_thread, ec);
-}
-
-std::size_t task_io_service::poll(asio::error_code& ec)
-{
-  ec = asio::error_code();
-  if (outstanding_work_ == 0)
-  {
-    stop();
-    return 0;
-  }
-
-  thread_info this_thread;
-  this_thread.private_outstanding_work = 0;
-  thread_call_stack::context ctx(this, this_thread);
-
-  mutex::scoped_lock lock(mutex_);
-
-#if defined(ASIO_HAS_THREADS)
-  // We want to support nested calls to poll() and poll_one(), so any handlers
-  // that are already on a thread-private queue need to be put on to the main
-  // queue now.
-  if (one_thread_)
-    if (thread_info* outer_thread_info = ctx.next_by_key())
-      op_queue_.push(outer_thread_info->private_op_queue);
-#endif // defined(ASIO_HAS_THREADS)
-
-  std::size_t n = 0;
-  for (; do_poll_one(lock, this_thread, ec); lock.lock())
-    if (n != (std::numeric_limits<std::size_t>::max)())
-      ++n;
-  return n;
-}
-
-std::size_t task_io_service::poll_one(asio::error_code& ec)
-{
-  ec = asio::error_code();
-  if (outstanding_work_ == 0)
-  {
-    stop();
-    return 0;
-  }
-
-  thread_info this_thread;
-  this_thread.private_outstanding_work = 0;
-  thread_call_stack::context ctx(this, this_thread);
-
-  mutex::scoped_lock lock(mutex_);
-
-#if defined(ASIO_HAS_THREADS)
-  // We want to support nested calls to poll() and poll_one(), so any handlers
-  // that are already on a thread-private queue need to be put on to the main
-  // queue now.
-  if (one_thread_)
-    if (thread_info* outer_thread_info = ctx.next_by_key())
-      op_queue_.push(outer_thread_info->private_op_queue);
-#endif // defined(ASIO_HAS_THREADS)
-
-  return do_poll_one(lock, this_thread, ec);
-}
-
-void task_io_service::stop()
-{
-  mutex::scoped_lock lock(mutex_);
-  stop_all_threads(lock);
-}
-
-bool task_io_service::stopped() const
-{
-  mutex::scoped_lock lock(mutex_);
-  return stopped_;
-}
-
-void task_io_service::reset()
-{
-  mutex::scoped_lock lock(mutex_);
-  stopped_ = false;
-}
-
-void task_io_service::post_immediate_completion(
-    task_io_service::operation* op, bool is_continuation)
-{
-#if defined(ASIO_HAS_THREADS)
-  if (one_thread_ || is_continuation)
-  {
-    if (thread_info* this_thread = thread_call_stack::contains(this))
-    {
-      ++this_thread->private_outstanding_work;
-      this_thread->private_op_queue.push(op);
-      return;
-    }
-  }
-#else // defined(ASIO_HAS_THREADS)
-  (void)is_continuation;
-#endif // defined(ASIO_HAS_THREADS)
-
-  work_started();
-  mutex::scoped_lock lock(mutex_);
-  op_queue_.push(op);
-  wake_one_thread_and_unlock(lock);
-}
-
-void task_io_service::post_deferred_completion(task_io_service::operation* op)
-{
-#if defined(ASIO_HAS_THREADS)
-  if (one_thread_)
-  {
-    if (thread_info* this_thread = thread_call_stack::contains(this))
-    {
-      this_thread->private_op_queue.push(op);
-      return;
-    }
-  }
-#endif // defined(ASIO_HAS_THREADS)
-
-  mutex::scoped_lock lock(mutex_);
-  op_queue_.push(op);
-  wake_one_thread_and_unlock(lock);
-}
-
-void task_io_service::post_deferred_completions(
-    op_queue<task_io_service::operation>& ops)
-{
-  if (!ops.empty())
-  {
-#if defined(ASIO_HAS_THREADS)
-    if (one_thread_)
-    {
-      if (thread_info* this_thread = thread_call_stack::contains(this))
-      {
-        this_thread->private_op_queue.push(ops);
-        return;
-      }
-    }
-#endif // defined(ASIO_HAS_THREADS)
-
-    mutex::scoped_lock lock(mutex_);
-    op_queue_.push(ops);
-    wake_one_thread_and_unlock(lock);
-  }
-}
-
-void task_io_service::do_dispatch(
-    task_io_service::operation* op)
-{
-  work_started();
-  mutex::scoped_lock lock(mutex_);
-  op_queue_.push(op);
-  wake_one_thread_and_unlock(lock);
-}
-
-void task_io_service::abandon_operations(
-    op_queue<task_io_service::operation>& ops)
-{
-  op_queue<task_io_service::operation> ops2;
-  ops2.push(ops);
-}
-
-std::size_t task_io_service::do_run_one(mutex::scoped_lock& lock,
-    task_io_service::thread_info& this_thread,
-    const asio::error_code& ec)
-{
-  while (!stopped_)
-  {
-    if (!op_queue_.empty())
-    {
-      // Prepare to execute first handler from queue.
-      operation* o = op_queue_.front();
-      op_queue_.pop();
-      bool more_handlers = (!op_queue_.empty());
-
-      if (o == &task_operation_)
-      {
-        task_interrupted_ = more_handlers;
-
-        if (more_handlers && !one_thread_)
-          wakeup_event_.unlock_and_signal_one(lock);
-        else
-          lock.unlock();
-
-        task_cleanup on_exit = { this, &lock, &this_thread };
-        (void)on_exit;
-
-        // Run the task. May throw an exception. Only block if the operation
-        // queue is empty and we're not polling, otherwise we want to return
-        // as soon as possible.
-        task_->run(!more_handlers, this_thread.private_op_queue);
-      }
-      else
-      {
-        std::size_t task_result = o->task_result_;
-
-        if (more_handlers && !one_thread_)
-          wake_one_thread_and_unlock(lock);
-        else
-          lock.unlock();
-
-        // Ensure the count of outstanding work is decremented on block exit.
-        work_cleanup on_exit = { this, &lock, &this_thread };
-        (void)on_exit;
-
-        // Complete the operation. May throw an exception. Deletes the object.
-        o->complete(*this, ec, task_result);
-
-        return 1;
-      }
-    }
-    else
-    {
-      wakeup_event_.clear(lock);
-      wakeup_event_.wait(lock);
-    }
-  }
-
-  return 0;
-}
-
-std::size_t task_io_service::do_poll_one(mutex::scoped_lock& lock,
-    task_io_service::thread_info& this_thread,
-    const asio::error_code& ec)
-{
-  if (stopped_)
-    return 0;
-
-  operation* o = op_queue_.front();
-  if (o == &task_operation_)
-  {
-    op_queue_.pop();
-    lock.unlock();
-
-    {
-      task_cleanup c = { this, &lock, &this_thread };
-      (void)c;
-
-      // Run the task. May throw an exception. Only block if the operation
-      // queue is empty and we're not polling, otherwise we want to return
-      // as soon as possible.
-      task_->run(false, this_thread.private_op_queue);
-    }
-
-    o = op_queue_.front();
-    if (o == &task_operation_)
-    {
-      wakeup_event_.maybe_unlock_and_signal_one(lock);
-      return 0;
-    }
-  }
-
-  if (o == 0)
-    return 0;
-
-  op_queue_.pop();
-  bool more_handlers = (!op_queue_.empty());
-
-  std::size_t task_result = o->task_result_;
-
-  if (more_handlers && !one_thread_)
-    wake_one_thread_and_unlock(lock);
-  else
-    lock.unlock();
-
-  // Ensure the count of outstanding work is decremented on block exit.
-  work_cleanup on_exit = { this, &lock, &this_thread };
-  (void)on_exit;
-
-  // Complete the operation. May throw an exception. Deletes the object.
-  o->complete(*this, ec, task_result);
-
-  return 1;
-}
-
-void task_io_service::stop_all_threads(
-    mutex::scoped_lock& lock)
-{
-  stopped_ = true;
-  wakeup_event_.signal_all(lock);
-
-  if (!task_interrupted_ && task_)
-  {
-    task_interrupted_ = true;
-    task_->interrupt();
-  }
-}
-
-void task_io_service::wake_one_thread_and_unlock(
-    mutex::scoped_lock& lock)
-{
-  if (!wakeup_event_.maybe_unlock_and_signal_one(lock))
-  {
-    if (!task_interrupted_ && task_)
-    {
-      task_interrupted_ = true;
-      task_->interrupt();
-    }
-    lock.unlock();
-  }
-}
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // !defined(ASIO_HAS_IOCP)
-
-#endif // ASIO_DETAIL_IMPL_TASK_IO_SERVICE_IPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/throw_error.ipp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/throw_error.ipp
deleted file mode 100644
index 94b58537ac47..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/throw_error.ipp
+++ /dev/null
@@ -1,60 +0,0 @@
-//
-// detail/impl/throw_error.ipp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_IMPL_THROW_ERROR_IPP
-#define ASIO_DETAIL_IMPL_THROW_ERROR_IPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include "asio/detail/throw_error.hpp"
-#include "asio/detail/throw_exception.hpp"
-#include "asio/system_error.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-void do_throw_error(const asio::error_code& err)
-{
-  asio::system_error e(err);
-  asio::detail::throw_exception(e);
-}
-
-void do_throw_error(const asio::error_code& err, const char* location)
-{
-  // boostify: non-boost code starts here
-#if defined(ASIO_MSVC) && defined(ASIO_HAS_STD_SYSTEM_ERROR)
-  // Microsoft's implementation of std::system_error is non-conformant in that
-  // it ignores the error code's message when a "what" string is supplied. We'll
-  // work around this by explicitly formatting the "what" string.
-  std::string what_msg = location;
-  what_msg += ": ";
-  what_msg += err.message();
-  asio::system_error e(err, what_msg);
-  asio::detail::throw_exception(e);
-#else // defined(ASIO_MSVC) && defined(ASIO_HAS_STD_SYSTEM_ERROR)
-  // boostify: non-boost code ends here
-  asio::system_error e(err, location);
-  asio::detail::throw_exception(e);
-  // boostify: non-boost code starts here
-#endif // defined(ASIO_MSVC) && defined(ASIO_HAS_STD_SYSTEM_ERROR)
-  // boostify: non-boost code ends here
-}
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_DETAIL_IMPL_THROW_ERROR_IPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/timer_queue_ptime.ipp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/timer_queue_ptime.ipp
deleted file mode 100644
index 97c87b5eef06..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/timer_queue_ptime.ipp
+++ /dev/null
@@ -1,84 +0,0 @@
-//
-// detail/impl/timer_queue_ptime.ipp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_IMPL_TIMER_QUEUE_PTIME_IPP
-#define ASIO_DETAIL_IMPL_TIMER_QUEUE_PTIME_IPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include "asio/detail/timer_queue_ptime.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-#if defined(ASIO_HAS_BOOST_DATE_TIME)
-
-namespace asio {
-namespace detail {
-
-timer_queue<time_traits<boost::posix_time::ptime> >::timer_queue()
-{
-}
-
-timer_queue<time_traits<boost::posix_time::ptime> >::~timer_queue()
-{
-}
-
-bool timer_queue<time_traits<boost::posix_time::ptime> >::enqueue_timer(
-    const time_type& time, per_timer_data& timer, wait_op* op)
-{
-  return impl_.enqueue_timer(time, timer, op);
-}
-
-bool timer_queue<time_traits<boost::posix_time::ptime> >::empty() const
-{
-  return impl_.empty();
-}
-
-long timer_queue<time_traits<boost::posix_time::ptime> >::wait_duration_msec(
-    long max_duration) const
-{
-  return impl_.wait_duration_msec(max_duration);
-}
-
-long timer_queue<time_traits<boost::posix_time::ptime> >::wait_duration_usec(
-    long max_duration) const
-{
-  return impl_.wait_duration_usec(max_duration);
-}
-
-void timer_queue<time_traits<boost::posix_time::ptime> >::get_ready_timers(
-    op_queue<operation>& ops)
-{
-  impl_.get_ready_timers(ops);
-}
-
-void timer_queue<time_traits<boost::posix_time::ptime> >::get_all_timers(
-    op_queue<operation>& ops)
-{
-  impl_.get_all_timers(ops);
-}
-
-std::size_t timer_queue<time_traits<boost::posix_time::ptime> >::cancel_timer(
-    per_timer_data& timer, op_queue<operation>& ops, std::size_t max_cancelled)
-{
-  return impl_.cancel_timer(timer, ops, max_cancelled);
-}
-
-} // namespace detail
-} // namespace asio
-
-#endif // defined(ASIO_HAS_BOOST_DATE_TIME)
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_DETAIL_IMPL_TIMER_QUEUE_PTIME_IPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/timer_queue_set.ipp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/timer_queue_set.ipp
deleted file mode 100644
index a8b59e5b8e52..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/timer_queue_set.ipp
+++ /dev/null
@@ -1,101 +0,0 @@
-//
-// detail/impl/timer_queue_set.ipp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_IMPL_TIMER_QUEUE_SET_IPP
-#define ASIO_DETAIL_IMPL_TIMER_QUEUE_SET_IPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include "asio/detail/timer_queue_set.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-timer_queue_set::timer_queue_set()
-  : first_(0)
-{
-}
-
-void timer_queue_set::insert(timer_queue_base* q)
-{
-  q->next_ = first_;
-  first_ = q;
-}
-
-void timer_queue_set::erase(timer_queue_base* q)
-{
-  if (first_)
-  {
-    if (q == first_)
-    {
-      first_ = q->next_;
-      q->next_ = 0;
-      return;
-    }
-
-    for (timer_queue_base* p = first_; p->next_; p = p->next_)
-    {
-      if (p->next_ == q)
-      {
-        p->next_ = q->next_;
-        q->next_ = 0;
-        return;
-      }
-    }
-  }
-}
-
-bool timer_queue_set::all_empty() const
-{
-  for (timer_queue_base* p = first_; p; p = p->next_)
-    if (!p->empty())
-      return false;
-  return true;
-}
-
-long timer_queue_set::wait_duration_msec(long max_duration) const
-{
-  long min_duration = max_duration;
-  for (timer_queue_base* p = first_; p; p = p->next_)
-    min_duration = p->wait_duration_msec(min_duration);
-  return min_duration;
-}
-
-long timer_queue_set::wait_duration_usec(long max_duration) const
-{
-  long min_duration = max_duration;
-  for (timer_queue_base* p = first_; p; p = p->next_)
-    min_duration = p->wait_duration_usec(min_duration);
-  return min_duration;
-}
-
-void timer_queue_set::get_ready_timers(op_queue<operation>& ops)
-{
-  for (timer_queue_base* p = first_; p; p = p->next_)
-    p->get_ready_timers(ops);
-}
-
-void timer_queue_set::get_all_timers(op_queue<operation>& ops)
-{
-  for (timer_queue_base* p = first_; p; p = p->next_)
-    p->get_all_timers(ops);
-}
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_DETAIL_IMPL_TIMER_QUEUE_SET_IPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/win_event.ipp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/win_event.ipp
deleted file mode 100644
index 29f9af914a0f..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/win_event.ipp
+++ /dev/null
@@ -1,67 +0,0 @@
-//
-// detail/win_event.ipp
-// ~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_IMPL_WIN_EVENT_IPP
-#define ASIO_DETAIL_IMPL_WIN_EVENT_IPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_WINDOWS)
-
-#include "asio/detail/throw_error.hpp"
-#include "asio/detail/win_event.hpp"
-#include "asio/error.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-win_event::win_event()
-  : state_(0)
-{
-  events_[0] = ::CreateEvent(0, true, false, 0);
-  if (!events_[0])
-  {
-    DWORD last_error = ::GetLastError();
-    asio::error_code ec(last_error,
-        asio::error::get_system_category());
-    asio::detail::throw_error(ec, "event");
-  }
-
-  events_[1] = ::CreateEvent(0, false, false, 0);
-  if (!events_[1])
-  {
-    DWORD last_error = ::GetLastError();
-    ::CloseHandle(events_[0]);
-    asio::error_code ec(last_error,
-        asio::error::get_system_category());
-    asio::detail::throw_error(ec, "event");
-  }
-}
-
-win_event::~win_event()
-{
-  ::CloseHandle(events_[0]);
-  ::CloseHandle(events_[1]);
-}
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // defined(ASIO_WINDOWS)
-
-#endif // ASIO_DETAIL_IMPL_WIN_EVENT_IPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/win_iocp_handle_service.ipp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/win_iocp_handle_service.ipp
deleted file mode 100644
index 1281050a0842..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/win_iocp_handle_service.ipp
+++ /dev/null
@@ -1,528 +0,0 @@
-//
-// detail/impl/win_iocp_handle_service.ipp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-// Copyright (c) 2008 Rep Invariant Systems, Inc. (info@repinvariant.com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_IMPL_WIN_IOCP_HANDLE_SERVICE_IPP
-#define ASIO_DETAIL_IMPL_WIN_IOCP_HANDLE_SERVICE_IPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_HAS_IOCP)
-
-#include "asio/detail/win_iocp_handle_service.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-class win_iocp_handle_service::overlapped_wrapper
-  : public OVERLAPPED
-{
-public:
-  explicit overlapped_wrapper(asio::error_code& ec)
-  {
-    Internal = 0;
-    InternalHigh = 0;
-    Offset = 0;
-    OffsetHigh = 0;
-
-    // Create a non-signalled manual-reset event, for GetOverlappedResult.
-    hEvent = ::CreateEvent(0, TRUE, FALSE, 0);
-    if (hEvent)
-    {
-      // As documented in GetQueuedCompletionStatus, setting the low order
-      // bit of this event prevents our synchronous writes from being treated
-      // as completion port events.
-      DWORD_PTR tmp = reinterpret_cast<DWORD_PTR>(hEvent);
-      hEvent = reinterpret_cast<HANDLE>(tmp | 1);
-    }
-    else
-    {
-      DWORD last_error = ::GetLastError();
-      ec = asio::error_code(last_error,
-          asio::error::get_system_category());
-    }
-  }
-
-  ~overlapped_wrapper()
-  {
-    if (hEvent)
-    {
-      ::CloseHandle(hEvent);
-    }
-  }
-};
-
-win_iocp_handle_service::win_iocp_handle_service(
-    asio::io_service& io_service)
-  : iocp_service_(asio::use_service<win_iocp_io_service>(io_service)),
-    mutex_(),
-    impl_list_(0)
-{
-}
-
-void win_iocp_handle_service::shutdown_service()
-{
-  // Close all implementations, causing all operations to complete.
-  asio::detail::mutex::scoped_lock lock(mutex_);
-  implementation_type* impl = impl_list_;
-  while (impl)
-  {
-    close_for_destruction(*impl);
-    impl = impl->next_;
-  }
-}
-
-void win_iocp_handle_service::construct(
-    win_iocp_handle_service::implementation_type& impl)
-{
-  impl.handle_ = INVALID_HANDLE_VALUE;
-  impl.safe_cancellation_thread_id_ = 0;
-
-  // Insert implementation into linked list of all implementations.
-  asio::detail::mutex::scoped_lock lock(mutex_);
-  impl.next_ = impl_list_;
-  impl.prev_ = 0;
-  if (impl_list_)
-    impl_list_->prev_ = &impl;
-  impl_list_ = &impl;
-}
-
-void win_iocp_handle_service::move_construct(
-    win_iocp_handle_service::implementation_type& impl,
-    win_iocp_handle_service::implementation_type& other_impl)
-{
-  impl.handle_ = other_impl.handle_;
-  other_impl.handle_ = INVALID_HANDLE_VALUE;
-
-  impl.safe_cancellation_thread_id_ = other_impl.safe_cancellation_thread_id_;
-  other_impl.safe_cancellation_thread_id_ = 0;
-
-  // Insert implementation into linked list of all implementations.
-  asio::detail::mutex::scoped_lock lock(mutex_);
-  impl.next_ = impl_list_;
-  impl.prev_ = 0;
-  if (impl_list_)
-    impl_list_->prev_ = &impl;
-  impl_list_ = &impl;
-}
-
-void win_iocp_handle_service::move_assign(
-    win_iocp_handle_service::implementation_type& impl,
-    win_iocp_handle_service& other_service,
-    win_iocp_handle_service::implementation_type& other_impl)
-{
-  close_for_destruction(impl);
-
-  if (this != &other_service)
-  {
-    // Remove implementation from linked list of all implementations.
-    asio::detail::mutex::scoped_lock lock(mutex_);
-    if (impl_list_ == &impl)
-      impl_list_ = impl.next_;
-    if (impl.prev_)
-      impl.prev_->next_ = impl.next_;
-    if (impl.next_)
-      impl.next_->prev_= impl.prev_;
-    impl.next_ = 0;
-    impl.prev_ = 0;
-  }
-
-  impl.handle_ = other_impl.handle_;
-  other_impl.handle_ = INVALID_HANDLE_VALUE;
-
-  impl.safe_cancellation_thread_id_ = other_impl.safe_cancellation_thread_id_;
-  other_impl.safe_cancellation_thread_id_ = 0;
-
-  if (this != &other_service)
-  {
-    // Insert implementation into linked list of all implementations.
-    asio::detail::mutex::scoped_lock lock(other_service.mutex_);
-    impl.next_ = other_service.impl_list_;
-    impl.prev_ = 0;
-    if (other_service.impl_list_)
-      other_service.impl_list_->prev_ = &impl;
-    other_service.impl_list_ = &impl;
-  }
-}
-
-void win_iocp_handle_service::destroy(
-    win_iocp_handle_service::implementation_type& impl)
-{
-  close_for_destruction(impl);
-  
-  // Remove implementation from linked list of all implementations.
-  asio::detail::mutex::scoped_lock lock(mutex_);
-  if (impl_list_ == &impl)
-    impl_list_ = impl.next_;
-  if (impl.prev_)
-    impl.prev_->next_ = impl.next_;
-  if (impl.next_)
-    impl.next_->prev_= impl.prev_;
-  impl.next_ = 0;
-  impl.prev_ = 0;
-}
-
-asio::error_code win_iocp_handle_service::assign(
-    win_iocp_handle_service::implementation_type& impl,
-    const native_handle_type& handle, asio::error_code& ec)
-{
-  if (is_open(impl))
-  {
-    ec = asio::error::already_open;
-    return ec;
-  }
-
-  if (iocp_service_.register_handle(handle, ec))
-    return ec;
-
-  impl.handle_ = handle;
-  ec = asio::error_code();
-  return ec;
-}
-
-asio::error_code win_iocp_handle_service::close(
-    win_iocp_handle_service::implementation_type& impl,
-    asio::error_code& ec)
-{
-  if (is_open(impl))
-  {
-    ASIO_HANDLER_OPERATION(("handle", &impl, "close"));
-
-    if (!::CloseHandle(impl.handle_))
-    {
-      DWORD last_error = ::GetLastError();
-      ec = asio::error_code(last_error,
-          asio::error::get_system_category());
-    }
-    else
-    {
-      ec = asio::error_code();
-    }
-
-    impl.handle_ = INVALID_HANDLE_VALUE;
-    impl.safe_cancellation_thread_id_ = 0;
-  }
-  else
-  {
-    ec = asio::error_code();
-  }
-
-  return ec;
-}
-
-asio::error_code win_iocp_handle_service::cancel(
-    win_iocp_handle_service::implementation_type& impl,
-    asio::error_code& ec)
-{
-  if (!is_open(impl))
-  {
-    ec = asio::error::bad_descriptor;
-    return ec;
-  }
-
-  ASIO_HANDLER_OPERATION(("handle", &impl, "cancel"));
-
-  if (FARPROC cancel_io_ex_ptr = ::GetProcAddress(
-        ::GetModuleHandleA("KERNEL32"), "CancelIoEx"))
-  {
-    // The version of Windows supports cancellation from any thread.
-    typedef BOOL (WINAPI* cancel_io_ex_t)(HANDLE, LPOVERLAPPED);
-    cancel_io_ex_t cancel_io_ex = (cancel_io_ex_t)cancel_io_ex_ptr;
-    if (!cancel_io_ex(impl.handle_, 0))
-    {
-      DWORD last_error = ::GetLastError();
-      if (last_error == ERROR_NOT_FOUND)
-      {
-        // ERROR_NOT_FOUND means that there were no operations to be
-        // cancelled. We swallow this error to match the behaviour on other
-        // platforms.
-        ec = asio::error_code();
-      }
-      else
-      {
-        ec = asio::error_code(last_error,
-            asio::error::get_system_category());
-      }
-    }
-    else
-    {
-      ec = asio::error_code();
-    }
-  }
-  else if (impl.safe_cancellation_thread_id_ == 0)
-  {
-    // No operations have been started, so there's nothing to cancel.
-    ec = asio::error_code();
-  }
-  else if (impl.safe_cancellation_thread_id_ == ::GetCurrentThreadId())
-  {
-    // Asynchronous operations have been started from the current thread only,
-    // so it is safe to try to cancel them using CancelIo.
-    if (!::CancelIo(impl.handle_))
-    {
-      DWORD last_error = ::GetLastError();
-      ec = asio::error_code(last_error,
-          asio::error::get_system_category());
-    }
-    else
-    {
-      ec = asio::error_code();
-    }
-  }
-  else
-  {
-    // Asynchronous operations have been started from more than one thread,
-    // so cancellation is not safe.
-    ec = asio::error::operation_not_supported;
-  }
-
-  return ec;
-}
-
-size_t win_iocp_handle_service::do_write(
-    win_iocp_handle_service::implementation_type& impl, uint64_t offset,
-    const asio::const_buffer& buffer, asio::error_code& ec)
-{
-  if (!is_open(impl))
-  {
-    ec = asio::error::bad_descriptor;
-    return 0;
-  }
-
-  // A request to write 0 bytes on a handle is a no-op.
-  if (asio::buffer_size(buffer) == 0)
-  {
-    ec = asio::error_code();
-    return 0;
-  }
-
-  overlapped_wrapper overlapped(ec);
-  if (ec)
-  {
-    return 0;
-  }
-
-  // Write the data. 
-  overlapped.Offset = offset & 0xFFFFFFFF;
-  overlapped.OffsetHigh = (offset >> 32) & 0xFFFFFFFF;
-  BOOL ok = ::WriteFile(impl.handle_,
-      asio::buffer_cast<LPCVOID>(buffer),
-      static_cast<DWORD>(asio::buffer_size(buffer)), 0, &overlapped);
-  if (!ok) 
-  {
-    DWORD last_error = ::GetLastError();
-    if (last_error != ERROR_IO_PENDING)
-    {
-      ec = asio::error_code(last_error,
-          asio::error::get_system_category());
-      return 0;
-    }
-  }
-
-  // Wait for the operation to complete.
-  DWORD bytes_transferred = 0;
-  ok = ::GetOverlappedResult(impl.handle_,
-      &overlapped, &bytes_transferred, TRUE);
-  if (!ok)
-  {
-    DWORD last_error = ::GetLastError();
-    ec = asio::error_code(last_error,
-        asio::error::get_system_category());
-    return 0;
-  }
-
-  ec = asio::error_code();
-  return bytes_transferred;
-}
-
-void win_iocp_handle_service::start_write_op(
-    win_iocp_handle_service::implementation_type& impl, uint64_t offset,
-    const asio::const_buffer& buffer, operation* op)
-{
-  update_cancellation_thread_id(impl);
-  iocp_service_.work_started();
-
-  if (!is_open(impl))
-  {
-    iocp_service_.on_completion(op, asio::error::bad_descriptor);
-  }
-  else if (asio::buffer_size(buffer) == 0)
-  {
-    // A request to write 0 bytes on a handle is a no-op.
-    iocp_service_.on_completion(op);
-  }
-  else
-  {
-    DWORD bytes_transferred = 0;
-    op->Offset = offset & 0xFFFFFFFF;
-    op->OffsetHigh = (offset >> 32) & 0xFFFFFFFF;
-    BOOL ok = ::WriteFile(impl.handle_,
-        asio::buffer_cast<LPCVOID>(buffer),
-        static_cast<DWORD>(asio::buffer_size(buffer)),
-        &bytes_transferred, op);
-    DWORD last_error = ::GetLastError();
-    if (!ok && last_error != ERROR_IO_PENDING
-        && last_error != ERROR_MORE_DATA)
-    {
-      iocp_service_.on_completion(op, last_error, bytes_transferred);
-    }
-    else
-    {
-      iocp_service_.on_pending(op);
-    }
-  }
-}
-
-size_t win_iocp_handle_service::do_read(
-    win_iocp_handle_service::implementation_type& impl, uint64_t offset,
-    const asio::mutable_buffer& buffer, asio::error_code& ec)
-{
-  if (!is_open(impl))
-  {
-    ec = asio::error::bad_descriptor;
-    return 0;
-  }
-  
-  // A request to read 0 bytes on a stream handle is a no-op.
-  if (asio::buffer_size(buffer) == 0)
-  {
-    ec = asio::error_code();
-    return 0;
-  }
-
-  overlapped_wrapper overlapped(ec);
-  if (ec)
-  {
-    return 0;
-  }
-
-  // Read some data.
-  overlapped.Offset = offset & 0xFFFFFFFF;
-  overlapped.OffsetHigh = (offset >> 32) & 0xFFFFFFFF;
-  BOOL ok = ::ReadFile(impl.handle_,
-      asio::buffer_cast<LPVOID>(buffer),
-      static_cast<DWORD>(asio::buffer_size(buffer)), 0, &overlapped);
-  if (!ok) 
-  {
-    DWORD last_error = ::GetLastError();
-    if (last_error != ERROR_IO_PENDING && last_error != ERROR_MORE_DATA)
-    {
-      if (last_error == ERROR_HANDLE_EOF)
-      {
-        ec = asio::error::eof;
-      }
-      else
-      {
-        ec = asio::error_code(last_error,
-            asio::error::get_system_category());
-      }
-      return 0;
-    }
-  }
-
-  // Wait for the operation to complete.
-  DWORD bytes_transferred = 0;
-  ok = ::GetOverlappedResult(impl.handle_,
-      &overlapped, &bytes_transferred, TRUE);
-  if (!ok)
-  {
-    DWORD last_error = ::GetLastError();
-    if (last_error != ERROR_MORE_DATA)
-    {
-      if (last_error == ERROR_HANDLE_EOF)
-      {
-        ec = asio::error::eof;
-      }
-      else
-      {
-        ec = asio::error_code(last_error,
-            asio::error::get_system_category());
-      }
-    }
-    return 0;
-  }
-
-  ec = asio::error_code();
-  return bytes_transferred;
-}
-
-void win_iocp_handle_service::start_read_op(
-    win_iocp_handle_service::implementation_type& impl, uint64_t offset,
-    const asio::mutable_buffer& buffer, operation* op)
-{
-  update_cancellation_thread_id(impl);
-  iocp_service_.work_started();
-
-  if (!is_open(impl))
-  {
-    iocp_service_.on_completion(op, asio::error::bad_descriptor);
-  }
-  else if (asio::buffer_size(buffer) == 0)
-  {
-    // A request to read 0 bytes on a handle is a no-op.
-    iocp_service_.on_completion(op);
-  }
-  else
-  {
-    DWORD bytes_transferred = 0;
-    op->Offset = offset & 0xFFFFFFFF;
-    op->OffsetHigh = (offset >> 32) & 0xFFFFFFFF;
-    BOOL ok = ::ReadFile(impl.handle_,
-        asio::buffer_cast<LPVOID>(buffer),
-        static_cast<DWORD>(asio::buffer_size(buffer)),
-        &bytes_transferred, op);
-    DWORD last_error = ::GetLastError();
-    if (!ok && last_error != ERROR_IO_PENDING
-        && last_error != ERROR_MORE_DATA)
-    {
-      iocp_service_.on_completion(op, last_error, bytes_transferred);
-    }
-    else
-    {
-      iocp_service_.on_pending(op);
-    }
-  }
-}
-
-void win_iocp_handle_service::update_cancellation_thread_id(
-    win_iocp_handle_service::implementation_type& impl)
-{
-  if (impl.safe_cancellation_thread_id_ == 0)
-    impl.safe_cancellation_thread_id_ = ::GetCurrentThreadId();
-  else if (impl.safe_cancellation_thread_id_ != ::GetCurrentThreadId())
-    impl.safe_cancellation_thread_id_ = ~DWORD(0);
-}
-
-void win_iocp_handle_service::close_for_destruction(implementation_type& impl)
-{
-  if (is_open(impl))
-  {
-    ASIO_HANDLER_OPERATION(("handle", &impl, "close"));
-
-    ::CloseHandle(impl.handle_);
-    impl.handle_ = INVALID_HANDLE_VALUE;
-    impl.safe_cancellation_thread_id_ = 0;
-  }
-}
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // defined(ASIO_HAS_IOCP)
-
-#endif // ASIO_DETAIL_IMPL_WIN_IOCP_HANDLE_SERVICE_IPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/win_iocp_io_service.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/win_iocp_io_service.hpp
deleted file mode 100644
index 02d346d4442d..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/win_iocp_io_service.hpp
+++ /dev/null
@@ -1,130 +0,0 @@
-//
-// detail/impl/win_iocp_io_service.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_IMPL_WIN_IOCP_IO_SERVICE_HPP
-#define ASIO_DETAIL_IMPL_WIN_IOCP_IO_SERVICE_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_HAS_IOCP)
-
-#include "asio/detail/addressof.hpp"
-#include "asio/detail/completion_handler.hpp"
-#include "asio/detail/fenced_block.hpp"
-#include "asio/detail/handler_alloc_helpers.hpp"
-#include "asio/detail/handler_invoke_helpers.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-template <typename Handler>
-void win_iocp_io_service::dispatch(Handler& handler)
-{
-  if (thread_call_stack::contains(this))
-  {
-    fenced_block b(fenced_block::full);
-    asio_handler_invoke_helpers::invoke(handler, handler);
-  }
-  else
-  {
-    // Allocate and construct an operation to wrap the handler.
-    typedef completion_handler<Handler> op;
-    typename op::ptr p = { asio::detail::addressof(handler),
-      asio_handler_alloc_helpers::allocate(
-        sizeof(op), handler), 0 };
-    p.p = new (p.v) op(handler);
-
-    ASIO_HANDLER_CREATION((p.p, "io_service", this, "dispatch"));
-
-    post_immediate_completion(p.p, false);
-    p.v = p.p = 0;
-  }
-}
-
-template <typename Handler>
-void win_iocp_io_service::post(Handler& handler)
-{
-  // Allocate and construct an operation to wrap the handler.
-  typedef completion_handler<Handler> op;
-  typename op::ptr p = { asio::detail::addressof(handler),
-    asio_handler_alloc_helpers::allocate(
-      sizeof(op), handler), 0 };
-  p.p = new (p.v) op(handler);
-
-  ASIO_HANDLER_CREATION((p.p, "io_service", this, "post"));
-
-  post_immediate_completion(p.p, false);
-  p.v = p.p = 0;
-}
-
-template <typename Time_Traits>
-void win_iocp_io_service::add_timer_queue(
-    timer_queue<Time_Traits>& queue)
-{
-  do_add_timer_queue(queue);
-}
-
-template <typename Time_Traits>
-void win_iocp_io_service::remove_timer_queue(
-    timer_queue<Time_Traits>& queue)
-{
-  do_remove_timer_queue(queue);
-}
-
-template <typename Time_Traits>
-void win_iocp_io_service::schedule_timer(timer_queue<Time_Traits>& queue,
-    const typename Time_Traits::time_type& time,
-    typename timer_queue<Time_Traits>::per_timer_data& timer, wait_op* op)
-{
-  // If the service has been shut down we silently discard the timer.
-  if (::InterlockedExchangeAdd(&shutdown_, 0) != 0)
-  {
-    post_immediate_completion(op, false);
-    return;
-  }
-
-  mutex::scoped_lock lock(dispatch_mutex_);
-
-  bool earliest = queue.enqueue_timer(time, timer, op);
-  work_started();
-  if (earliest)
-    update_timeout();
-}
-
-template <typename Time_Traits>
-std::size_t win_iocp_io_service::cancel_timer(timer_queue<Time_Traits>& queue,
-    typename timer_queue<Time_Traits>::per_timer_data& timer,
-    std::size_t max_cancelled)
-{
-  // If the service has been shut down we silently ignore the cancellation.
-  if (::InterlockedExchangeAdd(&shutdown_, 0) != 0)
-    return 0;
-
-  mutex::scoped_lock lock(dispatch_mutex_);
-  op_queue<win_iocp_operation> ops;
-  std::size_t n = queue.cancel_timer(timer, ops, max_cancelled);
-  post_deferred_completions(ops);
-  return n;
-}
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // defined(ASIO_HAS_IOCP)
-
-#endif // ASIO_DETAIL_IMPL_WIN_IOCP_IO_SERVICE_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/win_iocp_io_service.ipp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/win_iocp_io_service.ipp
deleted file mode 100644
index a4f56dc4bc56..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/win_iocp_io_service.ipp
+++ /dev/null
@@ -1,531 +0,0 @@
-//
-// detail/impl/win_iocp_io_service.ipp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_IMPL_WIN_IOCP_IO_SERVICE_IPP
-#define ASIO_DETAIL_IMPL_WIN_IOCP_IO_SERVICE_IPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_HAS_IOCP)
-
-#include "asio/error.hpp"
-#include "asio/io_service.hpp"
-#include "asio/detail/handler_alloc_helpers.hpp"
-#include "asio/detail/handler_invoke_helpers.hpp"
-#include "asio/detail/limits.hpp"
-#include "asio/detail/throw_error.hpp"
-#include "asio/detail/win_iocp_io_service.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-struct win_iocp_io_service::work_finished_on_block_exit
-{
-  ~work_finished_on_block_exit()
-  {
-    io_service_->work_finished();
-  }
-
-  win_iocp_io_service* io_service_;
-};
-
-struct win_iocp_io_service::timer_thread_function
-{
-  void operator()()
-  {
-    while (::InterlockedExchangeAdd(&io_service_->shutdown_, 0) == 0)
-    {
-      if (::WaitForSingleObject(io_service_->waitable_timer_.handle,
-            INFINITE) == WAIT_OBJECT_0)
-      {
-        ::InterlockedExchange(&io_service_->dispatch_required_, 1);
-        ::PostQueuedCompletionStatus(io_service_->iocp_.handle,
-            0, wake_for_dispatch, 0);
-      }
-    }
-  }
-
-  win_iocp_io_service* io_service_;
-};
-
-win_iocp_io_service::win_iocp_io_service(
-    asio::io_service& io_service, size_t concurrency_hint)
-  : asio::detail::service_base<win_iocp_io_service>(io_service),
-    iocp_(),
-    outstanding_work_(0),
-    stopped_(0),
-    stop_event_posted_(0),
-    shutdown_(0),
-    gqcs_timeout_(get_gqcs_timeout()),
-    dispatch_required_(0)
-{
-  ASIO_HANDLER_TRACKING_INIT;
-
-  iocp_.handle = ::CreateIoCompletionPort(INVALID_HANDLE_VALUE, 0, 0,
-      static_cast<DWORD>(concurrency_hint < DWORD(~0)
-        ? concurrency_hint : DWORD(~0)));
-  if (!iocp_.handle)
-  {
-    DWORD last_error = ::GetLastError();
-    asio::error_code ec(last_error,
-        asio::error::get_system_category());
-    asio::detail::throw_error(ec, "iocp");
-  }
-}
-
-void win_iocp_io_service::shutdown_service()
-{
-  ::InterlockedExchange(&shutdown_, 1);
-
-  if (timer_thread_.get())
-  {
-    LARGE_INTEGER timeout;
-    timeout.QuadPart = 1;
-    ::SetWaitableTimer(waitable_timer_.handle, &timeout, 1, 0, 0, FALSE);
-  }
-
-  while (::InterlockedExchangeAdd(&outstanding_work_, 0) > 0)
-  {
-    op_queue<win_iocp_operation> ops;
-    timer_queues_.get_all_timers(ops);
-    ops.push(completed_ops_);
-    if (!ops.empty())
-    {
-      while (win_iocp_operation* op = ops.front())
-      {
-        ops.pop();
-        ::InterlockedDecrement(&outstanding_work_);
-        op->destroy();
-      }
-    }
-    else
-    {
-      DWORD bytes_transferred = 0;
-      dword_ptr_t completion_key = 0;
-      LPOVERLAPPED overlapped = 0;
-      ::GetQueuedCompletionStatus(iocp_.handle, &bytes_transferred,
-          &completion_key, &overlapped, gqcs_timeout_);
-      if (overlapped)
-      {
-        ::InterlockedDecrement(&outstanding_work_);
-        static_cast<win_iocp_operation*>(overlapped)->destroy();
-      }
-    }
-  }
-
-  if (timer_thread_.get())
-    timer_thread_->join();
-}
-
-asio::error_code win_iocp_io_service::register_handle(
-    HANDLE handle, asio::error_code& ec)
-{
-  if (::CreateIoCompletionPort(handle, iocp_.handle, 0, 0) == 0)
-  {
-    DWORD last_error = ::GetLastError();
-    ec = asio::error_code(last_error,
-        asio::error::get_system_category());
-  }
-  else
-  {
-    ec = asio::error_code();
-  }
-  return ec;
-}
-
-size_t win_iocp_io_service::run(asio::error_code& ec)
-{
-  if (::InterlockedExchangeAdd(&outstanding_work_, 0) == 0)
-  {
-    stop();
-    ec = asio::error_code();
-    return 0;
-  }
-
-  win_iocp_thread_info this_thread;
-  thread_call_stack::context ctx(this, this_thread);
-
-  size_t n = 0;
-  while (do_one(true, ec))
-    if (n != (std::numeric_limits<size_t>::max)())
-      ++n;
-  return n;
-}
-
-size_t win_iocp_io_service::run_one(asio::error_code& ec)
-{
-  if (::InterlockedExchangeAdd(&outstanding_work_, 0) == 0)
-  {
-    stop();
-    ec = asio::error_code();
-    return 0;
-  }
-
-  win_iocp_thread_info this_thread;
-  thread_call_stack::context ctx(this, this_thread);
-
-  return do_one(true, ec);
-}
-
-size_t win_iocp_io_service::poll(asio::error_code& ec)
-{
-  if (::InterlockedExchangeAdd(&outstanding_work_, 0) == 0)
-  {
-    stop();
-    ec = asio::error_code();
-    return 0;
-  }
-
-  win_iocp_thread_info this_thread;
-  thread_call_stack::context ctx(this, this_thread);
-
-  size_t n = 0;
-  while (do_one(false, ec))
-    if (n != (std::numeric_limits<size_t>::max)())
-      ++n;
-  return n;
-}
-
-size_t win_iocp_io_service::poll_one(asio::error_code& ec)
-{
-  if (::InterlockedExchangeAdd(&outstanding_work_, 0) == 0)
-  {
-    stop();
-    ec = asio::error_code();
-    return 0;
-  }
-
-  win_iocp_thread_info this_thread;
-  thread_call_stack::context ctx(this, this_thread);
-
-  return do_one(false, ec);
-}
-
-void win_iocp_io_service::stop()
-{
-  if (::InterlockedExchange(&stopped_, 1) == 0)
-  {
-    if (::InterlockedExchange(&stop_event_posted_, 1) == 0)
-    {
-      if (!::PostQueuedCompletionStatus(iocp_.handle, 0, 0, 0))
-      {
-        DWORD last_error = ::GetLastError();
-        asio::error_code ec(last_error,
-            asio::error::get_system_category());
-        asio::detail::throw_error(ec, "pqcs");
-      }
-    }
-  }
-}
-
-void win_iocp_io_service::post_deferred_completion(win_iocp_operation* op)
-{
-  // Flag the operation as ready.
-  op->ready_ = 1;
-
-  // Enqueue the operation on the I/O completion port.
-  if (!::PostQueuedCompletionStatus(iocp_.handle, 0, 0, op))
-  {
-    // Out of resources. Put on completed queue instead.
-    mutex::scoped_lock lock(dispatch_mutex_);
-    completed_ops_.push(op);
-    ::InterlockedExchange(&dispatch_required_, 1);
-  }
-}
-
-void win_iocp_io_service::post_deferred_completions(
-    op_queue<win_iocp_operation>& ops)
-{
-  while (win_iocp_operation* op = ops.front())
-  {
-    ops.pop();
-
-    // Flag the operation as ready.
-    op->ready_ = 1;
-
-    // Enqueue the operation on the I/O completion port.
-    if (!::PostQueuedCompletionStatus(iocp_.handle, 0, 0, op))
-    {
-      // Out of resources. Put on completed queue instead.
-      mutex::scoped_lock lock(dispatch_mutex_);
-      completed_ops_.push(op);
-      completed_ops_.push(ops);
-      ::InterlockedExchange(&dispatch_required_, 1);
-    }
-  }
-}
-
-void win_iocp_io_service::abandon_operations(
-    op_queue<win_iocp_operation>& ops)
-{
-  while (win_iocp_operation* op = ops.front())
-  {
-    ops.pop();
-    ::InterlockedDecrement(&outstanding_work_);
-    op->destroy();
-  }
-}
-
-void win_iocp_io_service::on_pending(win_iocp_operation* op)
-{
-  if (::InterlockedCompareExchange(&op->ready_, 1, 0) == 1)
-  {
-    // Enqueue the operation on the I/O completion port.
-    if (!::PostQueuedCompletionStatus(iocp_.handle,
-          0, overlapped_contains_result, op))
-    {
-      // Out of resources. Put on completed queue instead.
-      mutex::scoped_lock lock(dispatch_mutex_);
-      completed_ops_.push(op);
-      ::InterlockedExchange(&dispatch_required_, 1);
-    }
-  }
-}
-
-void win_iocp_io_service::on_completion(win_iocp_operation* op,
-    DWORD last_error, DWORD bytes_transferred)
-{
-  // Flag that the operation is ready for invocation.
-  op->ready_ = 1;
-
-  // Store results in the OVERLAPPED structure.
-  op->Internal = reinterpret_cast<ulong_ptr_t>(
-      &asio::error::get_system_category());
-  op->Offset = last_error;
-  op->OffsetHigh = bytes_transferred;
-
-  // Enqueue the operation on the I/O completion port.
-  if (!::PostQueuedCompletionStatus(iocp_.handle,
-        0, overlapped_contains_result, op))
-  {
-    // Out of resources. Put on completed queue instead.
-    mutex::scoped_lock lock(dispatch_mutex_);
-    completed_ops_.push(op);
-    ::InterlockedExchange(&dispatch_required_, 1);
-  }
-}
-
-void win_iocp_io_service::on_completion(win_iocp_operation* op,
-    const asio::error_code& ec, DWORD bytes_transferred)
-{
-  // Flag that the operation is ready for invocation.
-  op->ready_ = 1;
-
-  // Store results in the OVERLAPPED structure.
-  op->Internal = reinterpret_cast<ulong_ptr_t>(&ec.category());
-  op->Offset = ec.value();
-  op->OffsetHigh = bytes_transferred;
-
-  // Enqueue the operation on the I/O completion port.
-  if (!::PostQueuedCompletionStatus(iocp_.handle,
-        0, overlapped_contains_result, op))
-  {
-    // Out of resources. Put on completed queue instead.
-    mutex::scoped_lock lock(dispatch_mutex_);
-    completed_ops_.push(op);
-    ::InterlockedExchange(&dispatch_required_, 1);
-  }
-}
-
-size_t win_iocp_io_service::do_one(bool block, asio::error_code& ec)
-{
-  for (;;)
-  {
-    // Try to acquire responsibility for dispatching timers and completed ops.
-    if (::InterlockedCompareExchange(&dispatch_required_, 0, 1) == 1)
-    {
-      mutex::scoped_lock lock(dispatch_mutex_);
-
-      // Dispatch pending timers and operations.
-      op_queue<win_iocp_operation> ops;
-      ops.push(completed_ops_);
-      timer_queues_.get_ready_timers(ops);
-      post_deferred_completions(ops);
-      update_timeout();
-    }
-
-    // Get the next operation from the queue.
-    DWORD bytes_transferred = 0;
-    dword_ptr_t completion_key = 0;
-    LPOVERLAPPED overlapped = 0;
-    ::SetLastError(0);
-    BOOL ok = ::GetQueuedCompletionStatus(iocp_.handle, &bytes_transferred,
-        &completion_key, &overlapped, block ? gqcs_timeout_ : 0);
-    DWORD last_error = ::GetLastError();
-
-    if (overlapped)
-    {
-      win_iocp_operation* op = static_cast<win_iocp_operation*>(overlapped);
-      asio::error_code result_ec(last_error,
-          asio::error::get_system_category());
-
-      // We may have been passed the last_error and bytes_transferred in the
-      // OVERLAPPED structure itself.
-      if (completion_key == overlapped_contains_result)
-      {
-        result_ec = asio::error_code(static_cast<int>(op->Offset),
-            *reinterpret_cast<asio::error_category*>(op->Internal));
-        bytes_transferred = op->OffsetHigh;
-      }
-
-      // Otherwise ensure any result has been saved into the OVERLAPPED
-      // structure.
-      else
-      {
-        op->Internal = reinterpret_cast<ulong_ptr_t>(&result_ec.category());
-        op->Offset = result_ec.value();
-        op->OffsetHigh = bytes_transferred;
-      }
-
-      // Dispatch the operation only if ready. The operation may not be ready
-      // if the initiating function (e.g. a call to WSARecv) has not yet
-      // returned. This is because the initiating function still wants access
-      // to the operation's OVERLAPPED structure.
-      if (::InterlockedCompareExchange(&op->ready_, 1, 0) == 1)
-      {
-        // Ensure the count of outstanding work is decremented on block exit.
-        work_finished_on_block_exit on_exit = { this };
-        (void)on_exit;
-
-        op->complete(*this, result_ec, bytes_transferred);
-        ec = asio::error_code();
-        return 1;
-      }
-    }
-    else if (!ok)
-    {
-      if (last_error != WAIT_TIMEOUT)
-      {
-        ec = asio::error_code(last_error,
-            asio::error::get_system_category());
-        return 0;
-      }
-
-      // If we're not polling we need to keep going until we get a real handler.
-      if (block)
-        continue;
-
-      ec = asio::error_code();
-      return 0;
-    }
-    else if (completion_key == wake_for_dispatch)
-    {
-      // We have been woken up to try to acquire responsibility for dispatching
-      // timers and completed operations.
-    }
-    else
-    {
-      // Indicate that there is no longer an in-flight stop event.
-      ::InterlockedExchange(&stop_event_posted_, 0);
-
-      // The stopped_ flag is always checked to ensure that any leftover
-      // stop events from a previous run invocation are ignored.
-      if (::InterlockedExchangeAdd(&stopped_, 0) != 0)
-      {
-        // Wake up next thread that is blocked on GetQueuedCompletionStatus.
-        if (::InterlockedExchange(&stop_event_posted_, 1) == 0)
-        {
-          if (!::PostQueuedCompletionStatus(iocp_.handle, 0, 0, 0))
-          {
-            last_error = ::GetLastError();
-            ec = asio::error_code(last_error,
-                asio::error::get_system_category());
-            return 0;
-          }
-        }
-
-        ec = asio::error_code();
-        return 0;
-      }
-    }
-  }
-}
-
-DWORD win_iocp_io_service::get_gqcs_timeout()
-{
-  OSVERSIONINFO version_info;
-  version_info.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
-  if (::GetVersionEx(&version_info))
-    if (version_info.dwMajorVersion >= 6)
-      return INFINITE;
-  return default_gqcs_timeout;
-}
-
-void win_iocp_io_service::do_add_timer_queue(timer_queue_base& queue)
-{
-  mutex::scoped_lock lock(dispatch_mutex_);
-
-  timer_queues_.insert(&queue);
-
-  if (!waitable_timer_.handle)
-  {
-    waitable_timer_.handle = ::CreateWaitableTimer(0, FALSE, 0);
-    if (waitable_timer_.handle == 0)
-    {
-      DWORD last_error = ::GetLastError();
-      asio::error_code ec(last_error,
-          asio::error::get_system_category());
-      asio::detail::throw_error(ec, "timer");
-    }
-
-    LARGE_INTEGER timeout;
-    timeout.QuadPart = -max_timeout_usec;
-    timeout.QuadPart *= 10;
-    ::SetWaitableTimer(waitable_timer_.handle,
-        &timeout, max_timeout_msec, 0, 0, FALSE);
-  }
-
-  if (!timer_thread_.get())
-  {
-    timer_thread_function thread_function = { this };
-    timer_thread_.reset(new thread(thread_function, 65536));
-  }
-}
-
-void win_iocp_io_service::do_remove_timer_queue(timer_queue_base& queue)
-{
-  mutex::scoped_lock lock(dispatch_mutex_);
-
-  timer_queues_.erase(&queue);
-}
-
-void win_iocp_io_service::update_timeout()
-{
-  if (timer_thread_.get())
-  {
-    // There's no point updating the waitable timer if the new timeout period
-    // exceeds the maximum timeout. In that case, we might as well wait for the
-    // existing period of the timer to expire.
-    long timeout_usec = timer_queues_.wait_duration_usec(max_timeout_usec);
-    if (timeout_usec < max_timeout_usec)
-    {
-      LARGE_INTEGER timeout;
-      timeout.QuadPart = -timeout_usec;
-      timeout.QuadPart *= 10;
-      ::SetWaitableTimer(waitable_timer_.handle,
-          &timeout, max_timeout_msec, 0, 0, FALSE);
-    }
-  }
-}
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // defined(ASIO_HAS_IOCP)
-
-#endif // ASIO_DETAIL_IMPL_WIN_IOCP_IO_SERVICE_IPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/win_iocp_serial_port_service.ipp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/win_iocp_serial_port_service.ipp
deleted file mode 100644
index 4b2b671a0a12..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/win_iocp_serial_port_service.ipp
+++ /dev/null
@@ -1,180 +0,0 @@
-//
-// detail/impl/win_iocp_serial_port_service.ipp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-// Copyright (c) 2008 Rep Invariant Systems, Inc. (info@repinvariant.com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_IMPL_WIN_IOCP_SERIAL_PORT_SERVICE_IPP
-#define ASIO_DETAIL_IMPL_WIN_IOCP_SERIAL_PORT_SERVICE_IPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_HAS_IOCP) && defined(ASIO_HAS_SERIAL_PORT)
-
-#include <cstring>
-#include "asio/detail/win_iocp_serial_port_service.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-win_iocp_serial_port_service::win_iocp_serial_port_service(
-    asio::io_service& io_service)
-  : handle_service_(io_service)
-{
-}
-
-void win_iocp_serial_port_service::shutdown_service()
-{
-}
-
-asio::error_code win_iocp_serial_port_service::open(
-    win_iocp_serial_port_service::implementation_type& impl,
-    const std::string& device, asio::error_code& ec)
-{
-  if (is_open(impl))
-  {
-    ec = asio::error::already_open;
-    return ec;
-  }
-
-  // For convenience, add a leading \\.\ sequence if not already present.
-  std::string name = (device[0] == '\\') ? device : "\\\\.\\" + device;
-
-  // Open a handle to the serial port.
-  ::HANDLE handle = ::CreateFileA(name.c_str(),
-      GENERIC_READ | GENERIC_WRITE, 0, 0,
-      OPEN_EXISTING, FILE_FLAG_OVERLAPPED, 0);
-  if (handle == INVALID_HANDLE_VALUE)
-  {
-    DWORD last_error = ::GetLastError();
-    ec = asio::error_code(last_error,
-        asio::error::get_system_category());
-    return ec;
-  }
-
-  // Determine the initial serial port parameters.
-  using namespace std; // For memset.
-  ::DCB dcb;
-  memset(&dcb, 0, sizeof(DCB));
-  dcb.DCBlength = sizeof(DCB);
-  if (!::GetCommState(handle, &dcb))
-  {
-    DWORD last_error = ::GetLastError();
-    ::CloseHandle(handle);
-    ec = asio::error_code(last_error,
-        asio::error::get_system_category());
-    return ec;
-  }
-
-  // Set some default serial port parameters. This implementation does not
-  // support changing these, so they might as well be in a known state.
-  dcb.fBinary = TRUE; // Win32 only supports binary mode.
-  dcb.fDsrSensitivity = FALSE;
-  dcb.fNull = FALSE; // Do not ignore NULL characters.
-  dcb.fAbortOnError = FALSE; // Ignore serial framing errors.
-  if (!::SetCommState(handle, &dcb))
-  {
-    DWORD last_error = ::GetLastError();
-    ::CloseHandle(handle);
-    ec = asio::error_code(last_error,
-        asio::error::get_system_category());
-    return ec;
-  }
-
-  // Set up timeouts so that the serial port will behave similarly to a
-  // network socket. Reads wait for at least one byte, then return with
-  // whatever they have. Writes return once everything is out the door.
-  ::COMMTIMEOUTS timeouts;
-  timeouts.ReadIntervalTimeout = 1;
-  timeouts.ReadTotalTimeoutMultiplier = 0;
-  timeouts.ReadTotalTimeoutConstant = 0;
-  timeouts.WriteTotalTimeoutMultiplier = 0;
-  timeouts.WriteTotalTimeoutConstant = 0;
-  if (!::SetCommTimeouts(handle, &timeouts))
-  {
-    DWORD last_error = ::GetLastError();
-    ::CloseHandle(handle);
-    ec = asio::error_code(last_error,
-        asio::error::get_system_category());
-    return ec;
-  }
-
-  // We're done. Take ownership of the serial port handle.
-  if (handle_service_.assign(impl, handle, ec))
-    ::CloseHandle(handle);
-  return ec;
-}
-
-asio::error_code win_iocp_serial_port_service::do_set_option(
-    win_iocp_serial_port_service::implementation_type& impl,
-    win_iocp_serial_port_service::store_function_type store,
-    const void* option, asio::error_code& ec)
-{
-  using namespace std; // For memcpy.
-
-  ::DCB dcb;
-  memset(&dcb, 0, sizeof(DCB));
-  dcb.DCBlength = sizeof(DCB);
-  if (!::GetCommState(handle_service_.native_handle(impl), &dcb))
-  {
-    DWORD last_error = ::GetLastError();
-    ec = asio::error_code(last_error,
-        asio::error::get_system_category());
-    return ec;
-  }
-
-  if (store(option, dcb, ec))
-    return ec;
-
-  if (!::SetCommState(handle_service_.native_handle(impl), &dcb))
-  {
-    DWORD last_error = ::GetLastError();
-    ec = asio::error_code(last_error,
-        asio::error::get_system_category());
-    return ec;
-  }
-
-  ec = asio::error_code();
-  return ec;
-}
-
-asio::error_code win_iocp_serial_port_service::do_get_option(
-    const win_iocp_serial_port_service::implementation_type& impl,
-    win_iocp_serial_port_service::load_function_type load,
-    void* option, asio::error_code& ec) const
-{
-  using namespace std; // For memset.
-
-  ::DCB dcb;
-  memset(&dcb, 0, sizeof(DCB));
-  dcb.DCBlength = sizeof(DCB);
-  if (!::GetCommState(handle_service_.native_handle(impl), &dcb))
-  {
-    DWORD last_error = ::GetLastError();
-    ec = asio::error_code(last_error,
-        asio::error::get_system_category());
-    return ec;
-  }
-
-  return load(option, dcb, ec);
-}
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // defined(ASIO_HAS_IOCP) && defined(ASIO_HAS_SERIAL_PORT)
-
-#endif // ASIO_DETAIL_IMPL_WIN_IOCP_SERIAL_PORT_SERVICE_IPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/win_iocp_socket_service_base.ipp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/win_iocp_socket_service_base.ipp
deleted file mode 100644
index 85d7545cbd95..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/win_iocp_socket_service_base.ipp
+++ /dev/null
@@ -1,728 +0,0 @@
-//
-// detail/impl/win_iocp_socket_service_base.ipp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_IMPL_WIN_IOCP_SOCKET_SERVICE_BASE_IPP
-#define ASIO_DETAIL_IMPL_WIN_IOCP_SOCKET_SERVICE_BASE_IPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_HAS_IOCP)
-
-#include "asio/detail/win_iocp_socket_service_base.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-win_iocp_socket_service_base::win_iocp_socket_service_base(
-    asio::io_service& io_service)
-  : io_service_(io_service),
-    iocp_service_(use_service<win_iocp_io_service>(io_service)),
-    reactor_(0),
-    connect_ex_(0),
-    mutex_(),
-    impl_list_(0)
-{
-}
-
-void win_iocp_socket_service_base::shutdown_service()
-{
-  // Close all implementations, causing all operations to complete.
-  asio::detail::mutex::scoped_lock lock(mutex_);
-  base_implementation_type* impl = impl_list_;
-  while (impl)
-  {
-    asio::error_code ignored_ec;
-    close_for_destruction(*impl);
-    impl = impl->next_;
-  }
-}
-
-void win_iocp_socket_service_base::construct(
-    win_iocp_socket_service_base::base_implementation_type& impl)
-{
-  impl.socket_ = invalid_socket;
-  impl.state_ = 0;
-  impl.cancel_token_.reset();
-#if defined(ASIO_ENABLE_CANCELIO)
-  impl.safe_cancellation_thread_id_ = 0;
-#endif // defined(ASIO_ENABLE_CANCELIO)
-
-  // Insert implementation into linked list of all implementations.
-  asio::detail::mutex::scoped_lock lock(mutex_);
-  impl.next_ = impl_list_;
-  impl.prev_ = 0;
-  if (impl_list_)
-    impl_list_->prev_ = &impl;
-  impl_list_ = &impl;
-}
-
-void win_iocp_socket_service_base::base_move_construct(
-    win_iocp_socket_service_base::base_implementation_type& impl,
-    win_iocp_socket_service_base::base_implementation_type& other_impl)
-{
-  impl.socket_ = other_impl.socket_;
-  other_impl.socket_ = invalid_socket;
-
-  impl.state_ = other_impl.state_;
-  other_impl.state_ = 0;
-
-  impl.cancel_token_ = other_impl.cancel_token_;
-  other_impl.cancel_token_.reset();
-
-#if defined(ASIO_ENABLE_CANCELIO)
-  impl.safe_cancellation_thread_id_ = other_impl.safe_cancellation_thread_id_;
-  other_impl.safe_cancellation_thread_id_ = 0;
-#endif // defined(ASIO_ENABLE_CANCELIO)
-
-  // Insert implementation into linked list of all implementations.
-  asio::detail::mutex::scoped_lock lock(mutex_);
-  impl.next_ = impl_list_;
-  impl.prev_ = 0;
-  if (impl_list_)
-    impl_list_->prev_ = &impl;
-  impl_list_ = &impl;
-}
-
-void win_iocp_socket_service_base::base_move_assign(
-    win_iocp_socket_service_base::base_implementation_type& impl,
-    win_iocp_socket_service_base& other_service,
-    win_iocp_socket_service_base::base_implementation_type& other_impl)
-{
-  close_for_destruction(impl);
-
-  if (this != &other_service)
-  {
-    // Remove implementation from linked list of all implementations.
-    asio::detail::mutex::scoped_lock lock(mutex_);
-    if (impl_list_ == &impl)
-      impl_list_ = impl.next_;
-    if (impl.prev_)
-      impl.prev_->next_ = impl.next_;
-    if (impl.next_)
-      impl.next_->prev_= impl.prev_;
-    impl.next_ = 0;
-    impl.prev_ = 0;
-  }
-
-  impl.socket_ = other_impl.socket_;
-  other_impl.socket_ = invalid_socket;
-
-  impl.state_ = other_impl.state_;
-  other_impl.state_ = 0;
-
-  impl.cancel_token_ = other_impl.cancel_token_;
-  other_impl.cancel_token_.reset();
-
-#if defined(ASIO_ENABLE_CANCELIO)
-  impl.safe_cancellation_thread_id_ = other_impl.safe_cancellation_thread_id_;
-  other_impl.safe_cancellation_thread_id_ = 0;
-#endif // defined(ASIO_ENABLE_CANCELIO)
-
-  if (this != &other_service)
-  {
-    // Insert implementation into linked list of all implementations.
-    asio::detail::mutex::scoped_lock lock(other_service.mutex_);
-    impl.next_ = other_service.impl_list_;
-    impl.prev_ = 0;
-    if (other_service.impl_list_)
-      other_service.impl_list_->prev_ = &impl;
-    other_service.impl_list_ = &impl;
-  }
-}
-
-void win_iocp_socket_service_base::destroy(
-    win_iocp_socket_service_base::base_implementation_type& impl)
-{
-  close_for_destruction(impl);
-
-  // Remove implementation from linked list of all implementations.
-  asio::detail::mutex::scoped_lock lock(mutex_);
-  if (impl_list_ == &impl)
-    impl_list_ = impl.next_;
-  if (impl.prev_)
-    impl.prev_->next_ = impl.next_;
-  if (impl.next_)
-    impl.next_->prev_= impl.prev_;
-  impl.next_ = 0;
-  impl.prev_ = 0;
-}
-
-asio::error_code win_iocp_socket_service_base::close(
-    win_iocp_socket_service_base::base_implementation_type& impl,
-    asio::error_code& ec)
-{
-  if (is_open(impl))
-  {
-    ASIO_HANDLER_OPERATION(("socket", &impl, "close"));
-
-    // Check if the reactor was created, in which case we need to close the
-    // socket on the reactor as well to cancel any operations that might be
-    // running there.
-    reactor* r = static_cast<reactor*>(
-          interlocked_compare_exchange_pointer(
-            reinterpret_cast<void**>(&reactor_), 0, 0));
-    if (r)
-      r->deregister_descriptor(impl.socket_, impl.reactor_data_, true);
-  }
-
-  socket_ops::close(impl.socket_, impl.state_, false, ec);
-
-  impl.socket_ = invalid_socket;
-  impl.state_ = 0;
-  impl.cancel_token_.reset();
-#if defined(ASIO_ENABLE_CANCELIO)
-  impl.safe_cancellation_thread_id_ = 0;
-#endif // defined(ASIO_ENABLE_CANCELIO)
-
-  return ec;
-}
-
-asio::error_code win_iocp_socket_service_base::cancel(
-    win_iocp_socket_service_base::base_implementation_type& impl,
-    asio::error_code& ec)
-{
-  if (!is_open(impl))
-  {
-    ec = asio::error::bad_descriptor;
-    return ec;
-  }
-
-  ASIO_HANDLER_OPERATION(("socket", &impl, "cancel"));
-
-  if (FARPROC cancel_io_ex_ptr = ::GetProcAddress(
-        ::GetModuleHandleA("KERNEL32"), "CancelIoEx"))
-  {
-    // The version of Windows supports cancellation from any thread.
-    typedef BOOL (WINAPI* cancel_io_ex_t)(HANDLE, LPOVERLAPPED);
-    cancel_io_ex_t cancel_io_ex = (cancel_io_ex_t)cancel_io_ex_ptr;
-    socket_type sock = impl.socket_;
-    HANDLE sock_as_handle = reinterpret_cast<HANDLE>(sock);
-    if (!cancel_io_ex(sock_as_handle, 0))
-    {
-      DWORD last_error = ::GetLastError();
-      if (last_error == ERROR_NOT_FOUND)
-      {
-        // ERROR_NOT_FOUND means that there were no operations to be
-        // cancelled. We swallow this error to match the behaviour on other
-        // platforms.
-        ec = asio::error_code();
-      }
-      else
-      {
-        ec = asio::error_code(last_error,
-            asio::error::get_system_category());
-      }
-    }
-    else
-    {
-      ec = asio::error_code();
-    }
-  }
-#if defined(ASIO_ENABLE_CANCELIO)
-  else if (impl.safe_cancellation_thread_id_ == 0)
-  {
-    // No operations have been started, so there's nothing to cancel.
-    ec = asio::error_code();
-  }
-  else if (impl.safe_cancellation_thread_id_ == ::GetCurrentThreadId())
-  {
-    // Asynchronous operations have been started from the current thread only,
-    // so it is safe to try to cancel them using CancelIo.
-    socket_type sock = impl.socket_;
-    HANDLE sock_as_handle = reinterpret_cast<HANDLE>(sock);
-    if (!::CancelIo(sock_as_handle))
-    {
-      DWORD last_error = ::GetLastError();
-      ec = asio::error_code(last_error,
-          asio::error::get_system_category());
-    }
-    else
-    {
-      ec = asio::error_code();
-    }
-  }
-  else
-  {
-    // Asynchronous operations have been started from more than one thread,
-    // so cancellation is not safe.
-    ec = asio::error::operation_not_supported;
-  }
-#else // defined(ASIO_ENABLE_CANCELIO)
-  else
-  {
-    // Cancellation is not supported as CancelIo may not be used.
-    ec = asio::error::operation_not_supported;
-  }
-#endif // defined(ASIO_ENABLE_CANCELIO)
-
-  // Cancel any operations started via the reactor.
-  if (!ec)
-  {
-    reactor* r = static_cast<reactor*>(
-          interlocked_compare_exchange_pointer(
-            reinterpret_cast<void**>(&reactor_), 0, 0));
-    if (r)
-      r->cancel_ops(impl.socket_, impl.reactor_data_);
-  }
-
-  return ec;
-}
-
-asio::error_code win_iocp_socket_service_base::do_open(
-    win_iocp_socket_service_base::base_implementation_type& impl,
-    int family, int type, int protocol, asio::error_code& ec)
-{
-  if (is_open(impl))
-  {
-    ec = asio::error::already_open;
-    return ec;
-  }
-
-  socket_holder sock(socket_ops::socket(family, type, protocol, ec));
-  if (sock.get() == invalid_socket)
-    return ec;
-
-  HANDLE sock_as_handle = reinterpret_cast<HANDLE>(sock.get());
-  if (iocp_service_.register_handle(sock_as_handle, ec))
-    return ec;
-
-  impl.socket_ = sock.release();
-  switch (type)
-  {
-  case SOCK_STREAM: impl.state_ = socket_ops::stream_oriented; break;
-  case SOCK_DGRAM: impl.state_ = socket_ops::datagram_oriented; break;
-  default: impl.state_ = 0; break;
-  }
-  impl.cancel_token_.reset(static_cast<void*>(0), socket_ops::noop_deleter());
-  ec = asio::error_code();
-  return ec;
-}
-
-asio::error_code win_iocp_socket_service_base::do_assign(
-    win_iocp_socket_service_base::base_implementation_type& impl,
-    int type, socket_type native_socket, asio::error_code& ec)
-{
-  if (is_open(impl))
-  {
-    ec = asio::error::already_open;
-    return ec;
-  }
-
-  HANDLE sock_as_handle = reinterpret_cast<HANDLE>(native_socket);
-  if (iocp_service_.register_handle(sock_as_handle, ec))
-    return ec;
-
-  impl.socket_ = native_socket;
-  switch (type)
-  {
-  case SOCK_STREAM: impl.state_ = socket_ops::stream_oriented; break;
-  case SOCK_DGRAM: impl.state_ = socket_ops::datagram_oriented; break;
-  default: impl.state_ = 0; break;
-  }
-  impl.cancel_token_.reset(static_cast<void*>(0), socket_ops::noop_deleter());
-  ec = asio::error_code();
-  return ec;
-}
-
-void win_iocp_socket_service_base::start_send_op(
-    win_iocp_socket_service_base::base_implementation_type& impl,
-    WSABUF* buffers, std::size_t buffer_count,
-    socket_base::message_flags flags, bool noop, operation* op)
-{
-  update_cancellation_thread_id(impl);
-  iocp_service_.work_started();
-
-  if (noop)
-    iocp_service_.on_completion(op);
-  else if (!is_open(impl))
-    iocp_service_.on_completion(op, asio::error::bad_descriptor);
-  else
-  {
-    DWORD bytes_transferred = 0;
-    int result = ::WSASend(impl.socket_, buffers,
-        static_cast<DWORD>(buffer_count), &bytes_transferred, flags, op, 0);
-    DWORD last_error = ::WSAGetLastError();
-    if (last_error == ERROR_PORT_UNREACHABLE)
-      last_error = WSAECONNREFUSED;
-    if (result != 0 && last_error != WSA_IO_PENDING)
-      iocp_service_.on_completion(op, last_error, bytes_transferred);
-    else
-      iocp_service_.on_pending(op);
-  }
-}
-
-void win_iocp_socket_service_base::start_send_to_op(
-    win_iocp_socket_service_base::base_implementation_type& impl,
-    WSABUF* buffers, std::size_t buffer_count,
-    const socket_addr_type* addr, int addrlen,
-    socket_base::message_flags flags, operation* op)
-{
-  update_cancellation_thread_id(impl);
-  iocp_service_.work_started();
-
-  if (!is_open(impl))
-    iocp_service_.on_completion(op, asio::error::bad_descriptor);
-  else
-  {
-    DWORD bytes_transferred = 0;
-    int result = ::WSASendTo(impl.socket_, buffers,
-        static_cast<DWORD>(buffer_count),
-        &bytes_transferred, flags, addr, addrlen, op, 0);
-    DWORD last_error = ::WSAGetLastError();
-    if (last_error == ERROR_PORT_UNREACHABLE)
-      last_error = WSAECONNREFUSED;
-    if (result != 0 && last_error != WSA_IO_PENDING)
-      iocp_service_.on_completion(op, last_error, bytes_transferred);
-    else
-      iocp_service_.on_pending(op);
-  }
-}
-
-void win_iocp_socket_service_base::start_receive_op(
-    win_iocp_socket_service_base::base_implementation_type& impl,
-    WSABUF* buffers, std::size_t buffer_count,
-    socket_base::message_flags flags, bool noop, operation* op)
-{
-  update_cancellation_thread_id(impl);
-  iocp_service_.work_started();
-
-  if (noop)
-    iocp_service_.on_completion(op);
-  else if (!is_open(impl))
-    iocp_service_.on_completion(op, asio::error::bad_descriptor);
-  else
-  {
-    DWORD bytes_transferred = 0;
-    DWORD recv_flags = flags;
-    int result = ::WSARecv(impl.socket_, buffers,
-        static_cast<DWORD>(buffer_count),
-        &bytes_transferred, &recv_flags, op, 0);
-    DWORD last_error = ::WSAGetLastError();
-    if (last_error == ERROR_NETNAME_DELETED)
-      last_error = WSAECONNRESET;
-    else if (last_error == ERROR_PORT_UNREACHABLE)
-      last_error = WSAECONNREFUSED;
-    if (result != 0 && last_error != WSA_IO_PENDING)
-      iocp_service_.on_completion(op, last_error, bytes_transferred);
-    else
-      iocp_service_.on_pending(op);
-  }
-}
-
-void win_iocp_socket_service_base::start_null_buffers_receive_op(
-    win_iocp_socket_service_base::base_implementation_type& impl,
-    socket_base::message_flags flags, reactor_op* op)
-{
-  if ((impl.state_ & socket_ops::stream_oriented) != 0)
-  {
-    // For stream sockets on Windows, we may issue a 0-byte overlapped
-    // WSARecv to wait until there is data available on the socket.
-    ::WSABUF buf = { 0, 0 };
-    start_receive_op(impl, &buf, 1, flags, false, op);
-  }
-  else
-  {
-    start_reactor_op(impl,
-        (flags & socket_base::message_out_of_band)
-          ? reactor::except_op : reactor::read_op,
-        op);
-  }
-}
-
-void win_iocp_socket_service_base::start_receive_from_op(
-    win_iocp_socket_service_base::base_implementation_type& impl,
-    WSABUF* buffers, std::size_t buffer_count, socket_addr_type* addr,
-    socket_base::message_flags flags, int* addrlen, operation* op)
-{
-  update_cancellation_thread_id(impl);
-  iocp_service_.work_started();
-
-  if (!is_open(impl))
-    iocp_service_.on_completion(op, asio::error::bad_descriptor);
-  else
-  {
-    DWORD bytes_transferred = 0;
-    DWORD recv_flags = flags;
-    int result = ::WSARecvFrom(impl.socket_, buffers,
-        static_cast<DWORD>(buffer_count),
-        &bytes_transferred, &recv_flags, addr, addrlen, op, 0);
-    DWORD last_error = ::WSAGetLastError();
-    if (last_error == ERROR_PORT_UNREACHABLE)
-      last_error = WSAECONNREFUSED;
-    if (result != 0 && last_error != WSA_IO_PENDING)
-      iocp_service_.on_completion(op, last_error, bytes_transferred);
-    else
-      iocp_service_.on_pending(op);
-  }
-}
-
-void win_iocp_socket_service_base::start_accept_op(
-    win_iocp_socket_service_base::base_implementation_type& impl,
-    bool peer_is_open, socket_holder& new_socket, int family, int type,
-    int protocol, void* output_buffer, DWORD address_length, operation* op)
-{
-  update_cancellation_thread_id(impl);
-  iocp_service_.work_started();
-
-  if (!is_open(impl))
-    iocp_service_.on_completion(op, asio::error::bad_descriptor);
-  else if (peer_is_open)
-    iocp_service_.on_completion(op, asio::error::already_open);
-  else
-  {
-    asio::error_code ec;
-    new_socket.reset(socket_ops::socket(family, type, protocol, ec));
-    if (new_socket.get() == invalid_socket)
-      iocp_service_.on_completion(op, ec);
-    else
-    {
-      DWORD bytes_read = 0;
-      BOOL result = ::AcceptEx(impl.socket_, new_socket.get(), output_buffer,
-          0, address_length, address_length, &bytes_read, op);
-      DWORD last_error = ::WSAGetLastError();
-      if (!result && last_error != WSA_IO_PENDING)
-        iocp_service_.on_completion(op, last_error);
-      else
-        iocp_service_.on_pending(op);
-    }
-  }
-}
-
-void win_iocp_socket_service_base::restart_accept_op(
-    socket_type s, socket_holder& new_socket, int family, int type,
-    int protocol, void* output_buffer, DWORD address_length, operation* op)
-{
-  new_socket.reset();
-  iocp_service_.work_started();
-
-  asio::error_code ec;
-  new_socket.reset(socket_ops::socket(family, type, protocol, ec));
-  if (new_socket.get() == invalid_socket)
-    iocp_service_.on_completion(op, ec);
-  else
-  {
-    DWORD bytes_read = 0;
-    BOOL result = ::AcceptEx(s, new_socket.get(), output_buffer,
-        0, address_length, address_length, &bytes_read, op);
-    DWORD last_error = ::WSAGetLastError();
-    if (!result && last_error != WSA_IO_PENDING)
-      iocp_service_.on_completion(op, last_error);
-    else
-      iocp_service_.on_pending(op);
-  }
-}
-
-void win_iocp_socket_service_base::start_reactor_op(
-    win_iocp_socket_service_base::base_implementation_type& impl,
-    int op_type, reactor_op* op)
-{
-  reactor& r = get_reactor();
-  update_cancellation_thread_id(impl);
-
-  if (is_open(impl))
-  {
-    r.start_op(op_type, impl.socket_, impl.reactor_data_, op, false, false);
-    return;
-  }
-  else
-    op->ec_ = asio::error::bad_descriptor;
-
-  iocp_service_.post_immediate_completion(op, false);
-}
-
-void win_iocp_socket_service_base::start_connect_op(
-    win_iocp_socket_service_base::base_implementation_type& impl,
-    int family, int type, const socket_addr_type* addr,
-    std::size_t addrlen, win_iocp_socket_connect_op_base* op)
-{
-  // If ConnectEx is available, use that.
-  if (family == ASIO_OS_DEF(AF_INET)
-      || family == ASIO_OS_DEF(AF_INET6))
-  {
-    if (connect_ex_fn connect_ex = get_connect_ex(impl, type))
-    {
-      union address_union
-      {
-        socket_addr_type base;
-        sockaddr_in4_type v4;
-        sockaddr_in6_type v6;
-      } a;
-
-      using namespace std; // For memset.
-      memset(&a, 0, sizeof(a));
-      a.base.sa_family = family;
-
-      socket_ops::bind(impl.socket_, &a.base,
-          family == ASIO_OS_DEF(AF_INET)
-          ? sizeof(a.v4) : sizeof(a.v6), op->ec_);
-      if (op->ec_ && op->ec_ != asio::error::invalid_argument)
-      {
-        iocp_service_.post_immediate_completion(op, false);
-        return;
-      }
-
-      op->connect_ex_ = true;
-      update_cancellation_thread_id(impl);
-      iocp_service_.work_started();
-
-      BOOL result = connect_ex(impl.socket_,
-          addr, static_cast<int>(addrlen), 0, 0, 0, op);
-      DWORD last_error = ::WSAGetLastError();
-      if (!result && last_error != WSA_IO_PENDING)
-        iocp_service_.on_completion(op, last_error);
-      else
-        iocp_service_.on_pending(op);
-      return;
-    }
-  }
-
-  // Otherwise, fall back to a reactor-based implementation.
-  reactor& r = get_reactor();
-  update_cancellation_thread_id(impl);
-
-  if ((impl.state_ & socket_ops::non_blocking) != 0
-      || socket_ops::set_internal_non_blocking(
-        impl.socket_, impl.state_, true, op->ec_))
-  {
-    if (socket_ops::connect(impl.socket_, addr, addrlen, op->ec_) != 0)
-    {
-      if (op->ec_ == asio::error::in_progress
-          || op->ec_ == asio::error::would_block)
-      {
-        op->ec_ = asio::error_code();
-        r.start_op(reactor::connect_op, impl.socket_,
-            impl.reactor_data_, op, false, false);
-        return;
-      }
-    }
-  }
-
-  r.post_immediate_completion(op, false);
-}
-
-void win_iocp_socket_service_base::close_for_destruction(
-    win_iocp_socket_service_base::base_implementation_type& impl)
-{
-  if (is_open(impl))
-  {
-    ASIO_HANDLER_OPERATION(("socket", &impl, "close"));
-
-    // Check if the reactor was created, in which case we need to close the
-    // socket on the reactor as well to cancel any operations that might be
-    // running there.
-    reactor* r = static_cast<reactor*>(
-          interlocked_compare_exchange_pointer(
-            reinterpret_cast<void**>(&reactor_), 0, 0));
-    if (r)
-      r->deregister_descriptor(impl.socket_, impl.reactor_data_, true);
-  }
-
-  asio::error_code ignored_ec;
-  socket_ops::close(impl.socket_, impl.state_, true, ignored_ec);
-  impl.socket_ = invalid_socket;
-  impl.state_ = 0;
-  impl.cancel_token_.reset();
-#if defined(ASIO_ENABLE_CANCELIO)
-  impl.safe_cancellation_thread_id_ = 0;
-#endif // defined(ASIO_ENABLE_CANCELIO)
-}
-
-void win_iocp_socket_service_base::update_cancellation_thread_id(
-    win_iocp_socket_service_base::base_implementation_type& impl)
-{
-#if defined(ASIO_ENABLE_CANCELIO)
-  if (impl.safe_cancellation_thread_id_ == 0)
-    impl.safe_cancellation_thread_id_ = ::GetCurrentThreadId();
-  else if (impl.safe_cancellation_thread_id_ != ::GetCurrentThreadId())
-    impl.safe_cancellation_thread_id_ = ~DWORD(0);
-#else // defined(ASIO_ENABLE_CANCELIO)
-  (void)impl;
-#endif // defined(ASIO_ENABLE_CANCELIO)
-}
-
-reactor& win_iocp_socket_service_base::get_reactor()
-{
-  reactor* r = static_cast<reactor*>(
-        interlocked_compare_exchange_pointer(
-          reinterpret_cast<void**>(&reactor_), 0, 0));
-  if (!r)
-  {
-    r = &(use_service<reactor>(io_service_));
-    interlocked_exchange_pointer(reinterpret_cast<void**>(&reactor_), r);
-  }
-  return *r;
-}
-
-win_iocp_socket_service_base::connect_ex_fn
-win_iocp_socket_service_base::get_connect_ex(
-    win_iocp_socket_service_base::base_implementation_type& impl, int type)
-{
-  if (type != ASIO_OS_DEF(SOCK_STREAM)
-      && type != ASIO_OS_DEF(SOCK_SEQPACKET))
-    return 0;
-
-  void* ptr = interlocked_compare_exchange_pointer(&connect_ex_, 0, 0);
-  if (!ptr)
-  {
-    GUID guid = { 0x25a207b9, 0xddf3, 0x4660,
-      { 0x8e, 0xe9, 0x76, 0xe5, 0x8c, 0x74, 0x06, 0x3e } };
-
-    DWORD bytes = 0;
-    if (::WSAIoctl(impl.socket_, SIO_GET_EXTENSION_FUNCTION_POINTER,
-          &guid, sizeof(guid), &ptr, sizeof(ptr), &bytes, 0, 0) != 0)
-    {
-      // Set connect_ex_ to a special value to indicate that ConnectEx is
-      // unavailable. That way we won't bother trying to look it up again.
-      ptr = this;
-    }
-
-    interlocked_exchange_pointer(&connect_ex_, ptr);
-  }
-
-  return reinterpret_cast<connect_ex_fn>(ptr == this ? 0 : ptr);
-}
-
-void* win_iocp_socket_service_base::interlocked_compare_exchange_pointer(
-    void** dest, void* exch, void* cmp)
-{
-#if defined(_M_IX86)
-  return reinterpret_cast<void*>(InterlockedCompareExchange(
-        reinterpret_cast<PLONG>(dest), reinterpret_cast<LONG>(exch),
-        reinterpret_cast<LONG>(cmp)));
-#else
-  return InterlockedCompareExchangePointer(dest, exch, cmp);
-#endif
-}
-
-void* win_iocp_socket_service_base::interlocked_exchange_pointer(
-    void** dest, void* val)
-{
-#if defined(_M_IX86)
-  return reinterpret_cast<void*>(InterlockedExchange(
-        reinterpret_cast<PLONG>(dest), reinterpret_cast<LONG>(val)));
-#else
-  return InterlockedExchangePointer(dest, val);
-#endif
-}
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // defined(ASIO_HAS_IOCP)
-
-#endif // ASIO_DETAIL_IMPL_WIN_IOCP_SOCKET_SERVICE_BASE_IPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/win_mutex.ipp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/win_mutex.ipp
deleted file mode 100644
index 18ce17d3139c..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/win_mutex.ipp
+++ /dev/null
@@ -1,78 +0,0 @@
-//
-// detail/impl/win_mutex.ipp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_IMPL_WIN_MUTEX_IPP
-#define ASIO_DETAIL_IMPL_WIN_MUTEX_IPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_WINDOWS)
-
-#include "asio/detail/throw_error.hpp"
-#include "asio/detail/win_mutex.hpp"
-#include "asio/error.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-win_mutex::win_mutex()
-{
-  int error = do_init();
-  asio::error_code ec(error,
-      asio::error::get_system_category());
-  asio::detail::throw_error(ec, "mutex");
-}
-
-int win_mutex::do_init()
-{
-#if defined(__MINGW32__)
-  // Not sure if MinGW supports structured exception handling, so for now
-  // we'll just call the Windows API and hope.
-# if defined(UNDER_CE)
-  ::InitializeCriticalSection(&crit_section_);
-# else
-  if (!::InitializeCriticalSectionAndSpinCount(&crit_section_, 0x80000000))
-    return ::GetLastError();
-# endif
-  return 0;
-#else
-  __try
-  {
-# if defined(UNDER_CE)
-    ::InitializeCriticalSection(&crit_section_);
-# else
-    if (!::InitializeCriticalSectionAndSpinCount(&crit_section_, 0x80000000))
-      return ::GetLastError();
-# endif
-  }
-  __except(GetExceptionCode() == STATUS_NO_MEMORY
-      ? EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)
-  {
-    return ERROR_OUTOFMEMORY;
-  }
-
-  return 0;
-#endif
-}
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // defined(ASIO_WINDOWS)
-
-#endif // ASIO_DETAIL_IMPL_WIN_MUTEX_IPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/win_object_handle_service.ipp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/win_object_handle_service.ipp
deleted file mode 100644
index 7a7d4307d443..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/win_object_handle_service.ipp
+++ /dev/null
@@ -1,444 +0,0 @@
-//
-// detail/impl/win_object_handle_service.ipp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-// Copyright (c) 2011 Boris Schaeling (boris@highscore.de)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_IMPL_WIN_OBJECT_HANDLE_SERVICE_IPP
-#define ASIO_DETAIL_IMPL_WIN_OBJECT_HANDLE_SERVICE_IPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_HAS_WINDOWS_OBJECT_HANDLE)
-
-#include "asio/detail/win_object_handle_service.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-win_object_handle_service::win_object_handle_service(
-    asio::io_service& io_service)
-  : io_service_(asio::use_service<io_service_impl>(io_service)),
-    mutex_(),
-    impl_list_(0),
-    shutdown_(false)
-{
-}
-
-void win_object_handle_service::shutdown_service()
-{
-  mutex::scoped_lock lock(mutex_);
-
-  // Setting this flag to true prevents new objects from being registered, and
-  // new asynchronous wait operations from being started. We only need to worry
-  // about cleaning up the operations that are currently in progress.
-  shutdown_ = true;
-
-  op_queue<operation> ops;
-  for (implementation_type* impl = impl_list_; impl; impl = impl->next_)
-    ops.push(impl->op_queue_);
-
-  lock.unlock();
-
-  io_service_.abandon_operations(ops);
-}
-
-void win_object_handle_service::construct(
-    win_object_handle_service::implementation_type& impl)
-{
-  impl.handle_ = INVALID_HANDLE_VALUE;
-  impl.wait_handle_ = INVALID_HANDLE_VALUE;
-  impl.owner_ = this;
-
-  // Insert implementation into linked list of all implementations.
-  mutex::scoped_lock lock(mutex_);
-  if (!shutdown_)
-  {
-    impl.next_ = impl_list_;
-    impl.prev_ = 0;
-    if (impl_list_)
-      impl_list_->prev_ = &impl;
-    impl_list_ = &impl;
-  }
-}
-
-void win_object_handle_service::move_construct(
-    win_object_handle_service::implementation_type& impl,
-    win_object_handle_service::implementation_type& other_impl)
-{
-  mutex::scoped_lock lock(mutex_);
-
-  // Insert implementation into linked list of all implementations.
-  if (!shutdown_)
-  {
-    impl.next_ = impl_list_;
-    impl.prev_ = 0;
-    if (impl_list_)
-      impl_list_->prev_ = &impl;
-    impl_list_ = &impl;
-  }
-
-  impl.handle_ = other_impl.handle_;
-  other_impl.handle_ = INVALID_HANDLE_VALUE;
-  impl.wait_handle_ = other_impl.wait_handle_;
-  other_impl.wait_handle_ = INVALID_HANDLE_VALUE;
-  impl.op_queue_.push(other_impl.op_queue_);
-  impl.owner_ = this;
-
-  // We must not hold the lock while calling UnregisterWaitEx. This is because
-  // the registered callback function might be invoked while we are waiting for
-  // UnregisterWaitEx to complete.
-  lock.unlock();
-
-  if (impl.wait_handle_ != INVALID_HANDLE_VALUE)
-    ::UnregisterWaitEx(impl.wait_handle_, INVALID_HANDLE_VALUE);
-
-  if (!impl.op_queue_.empty())
-    register_wait_callback(impl, lock);
-}
-
-void win_object_handle_service::move_assign(
-    win_object_handle_service::implementation_type& impl,
-    win_object_handle_service& other_service,
-    win_object_handle_service::implementation_type& other_impl)
-{
-  asio::error_code ignored_ec;
-  close(impl, ignored_ec);
-
-  mutex::scoped_lock lock(mutex_);
-
-  if (this != &other_service)
-  {
-    // Remove implementation from linked list of all implementations.
-    if (impl_list_ == &impl)
-      impl_list_ = impl.next_;
-    if (impl.prev_)
-      impl.prev_->next_ = impl.next_;
-    if (impl.next_)
-      impl.next_->prev_= impl.prev_;
-    impl.next_ = 0;
-    impl.prev_ = 0;
-  }
-
-  impl.handle_ = other_impl.handle_;
-  other_impl.handle_ = INVALID_HANDLE_VALUE;
-  impl.wait_handle_ = other_impl.wait_handle_;
-  other_impl.wait_handle_ = INVALID_HANDLE_VALUE;
-  impl.op_queue_.push(other_impl.op_queue_);
-  impl.owner_ = this;
-
-  if (this != &other_service)
-  {
-    // Insert implementation into linked list of all implementations.
-    impl.next_ = other_service.impl_list_;
-    impl.prev_ = 0;
-    if (other_service.impl_list_)
-      other_service.impl_list_->prev_ = &impl;
-    other_service.impl_list_ = &impl;
-  }
-
-  // We must not hold the lock while calling UnregisterWaitEx. This is because
-  // the registered callback function might be invoked while we are waiting for
-  // UnregisterWaitEx to complete.
-  lock.unlock();
-
-  if (impl.wait_handle_ != INVALID_HANDLE_VALUE)
-    ::UnregisterWaitEx(impl.wait_handle_, INVALID_HANDLE_VALUE);
-
-  if (!impl.op_queue_.empty())
-    register_wait_callback(impl, lock);
-}
-
-void win_object_handle_service::destroy(
-    win_object_handle_service::implementation_type& impl)
-{
-  mutex::scoped_lock lock(mutex_);
-
-  // Remove implementation from linked list of all implementations.
-  if (impl_list_ == &impl)
-    impl_list_ = impl.next_;
-  if (impl.prev_)
-    impl.prev_->next_ = impl.next_;
-  if (impl.next_)
-    impl.next_->prev_= impl.prev_;
-  impl.next_ = 0;
-  impl.prev_ = 0;
-
-  if (is_open(impl))
-  {
-    ASIO_HANDLER_OPERATION(("object_handle", &impl, "close"));
-
-    HANDLE wait_handle = impl.wait_handle_;
-    impl.wait_handle_ = INVALID_HANDLE_VALUE;
-
-    op_queue<operation> ops;
-    while (wait_op* op = impl.op_queue_.front())
-    {
-      op->ec_ = asio::error::operation_aborted;
-      impl.op_queue_.pop();
-      ops.push(op);
-    }
-
-    // We must not hold the lock while calling UnregisterWaitEx. This is
-    // because the registered callback function might be invoked while we are
-    // waiting for UnregisterWaitEx to complete.
-    lock.unlock();
-
-    if (wait_handle != INVALID_HANDLE_VALUE)
-      ::UnregisterWaitEx(wait_handle, INVALID_HANDLE_VALUE);
-
-    ::CloseHandle(impl.handle_);
-    impl.handle_ = INVALID_HANDLE_VALUE;
-
-    io_service_.post_deferred_completions(ops);
-  }
-}
-
-asio::error_code win_object_handle_service::assign(
-    win_object_handle_service::implementation_type& impl,
-    const native_handle_type& handle, asio::error_code& ec)
-{
-  if (is_open(impl))
-  {
-    ec = asio::error::already_open;
-    return ec;
-  }
-
-  impl.handle_ = handle;
-  ec = asio::error_code();
-  return ec;
-}
-
-asio::error_code win_object_handle_service::close(
-    win_object_handle_service::implementation_type& impl,
-    asio::error_code& ec)
-{
-  if (is_open(impl))
-  {
-    ASIO_HANDLER_OPERATION(("object_handle", &impl, "close"));
-
-    mutex::scoped_lock lock(mutex_);
-
-    HANDLE wait_handle = impl.wait_handle_;
-    impl.wait_handle_ = INVALID_HANDLE_VALUE;
-
-    op_queue<operation> completed_ops;
-    while (wait_op* op = impl.op_queue_.front())
-    {
-      impl.op_queue_.pop();
-      op->ec_ = asio::error::operation_aborted;
-      completed_ops.push(op);
-    }
-
-    // We must not hold the lock while calling UnregisterWaitEx. This is
-    // because the registered callback function might be invoked while we are
-    // waiting for UnregisterWaitEx to complete.
-    lock.unlock();
-
-    if (wait_handle != INVALID_HANDLE_VALUE)
-      ::UnregisterWaitEx(wait_handle, INVALID_HANDLE_VALUE);
-
-    if (::CloseHandle(impl.handle_))
-    {
-      impl.handle_ = INVALID_HANDLE_VALUE;
-      ec = asio::error_code();
-    }
-    else
-    {
-      DWORD last_error = ::GetLastError();
-      ec = asio::error_code(last_error,
-          asio::error::get_system_category());
-    }
-
-    io_service_.post_deferred_completions(completed_ops);
-  }
-  else
-  {
-    ec = asio::error_code();
-  }
-
-  return ec;
-}
-
-asio::error_code win_object_handle_service::cancel(
-    win_object_handle_service::implementation_type& impl,
-    asio::error_code& ec)
-{
-  if (is_open(impl))
-  {
-    ASIO_HANDLER_OPERATION(("object_handle", &impl, "cancel"));
-
-    mutex::scoped_lock lock(mutex_);
-
-    HANDLE wait_handle = impl.wait_handle_;
-    impl.wait_handle_ = INVALID_HANDLE_VALUE;
-
-    op_queue<operation> completed_ops;
-    while (wait_op* op = impl.op_queue_.front())
-    {
-      op->ec_ = asio::error::operation_aborted;
-      impl.op_queue_.pop();
-      completed_ops.push(op);
-    }
-
-    // We must not hold the lock while calling UnregisterWaitEx. This is
-    // because the registered callback function might be invoked while we are
-    // waiting for UnregisterWaitEx to complete.
-    lock.unlock();
-
-    if (wait_handle != INVALID_HANDLE_VALUE)
-      ::UnregisterWaitEx(wait_handle, INVALID_HANDLE_VALUE);
-
-    ec = asio::error_code();
-
-    io_service_.post_deferred_completions(completed_ops);
-  }
-  else
-  {
-    ec = asio::error::bad_descriptor;
-  }
-
-  return ec;
-}
-
-void win_object_handle_service::wait(
-    win_object_handle_service::implementation_type& impl,
-    asio::error_code& ec)
-{
-  switch (::WaitForSingleObject(impl.handle_, INFINITE))
-  {
-  case WAIT_FAILED:
-    {
-      DWORD last_error = ::GetLastError();
-      ec = asio::error_code(last_error,
-          asio::error::get_system_category());
-      break;
-    }
-  case WAIT_OBJECT_0:
-  case WAIT_ABANDONED:
-  default:
-    ec = asio::error_code();
-    break;
-  }
-}
-
-void win_object_handle_service::start_wait_op(
-    win_object_handle_service::implementation_type& impl, wait_op* op)
-{
-  io_service_.work_started();
-
-  if (is_open(impl))
-  {
-    mutex::scoped_lock lock(mutex_);
-
-    if (!shutdown_)
-    {
-      impl.op_queue_.push(op);
-
-      // Only the first operation to be queued gets to register a wait callback.
-      // Subsequent operations have to wait for the first to finish.
-      if (impl.op_queue_.front() == op)
-        register_wait_callback(impl, lock);
-    }
-    else
-    {
-      lock.unlock();
-      io_service_.post_deferred_completion(op);
-    }
-  }
-  else
-  {
-    op->ec_ = asio::error::bad_descriptor;
-    io_service_.post_deferred_completion(op);
-  }
-}
-
-void win_object_handle_service::register_wait_callback(
-    win_object_handle_service::implementation_type& impl,
-    mutex::scoped_lock& lock)
-{
-  lock.lock();
-
-  if (!RegisterWaitForSingleObject(&impl.wait_handle_,
-        impl.handle_, &win_object_handle_service::wait_callback,
-        &impl, INFINITE, WT_EXECUTEONLYONCE))
-  {
-    DWORD last_error = ::GetLastError();
-    asio::error_code ec(last_error,
-        asio::error::get_system_category());
-
-    op_queue<operation> completed_ops;
-    while (wait_op* op = impl.op_queue_.front())
-    {
-      op->ec_ = ec;
-      impl.op_queue_.pop();
-      completed_ops.push(op);
-    }
-
-    lock.unlock();
-    io_service_.post_deferred_completions(completed_ops);
-  }
-}
-
-void win_object_handle_service::wait_callback(PVOID param, BOOLEAN)
-{
-  implementation_type* impl = static_cast<implementation_type*>(param);
-  mutex::scoped_lock lock(impl->owner_->mutex_);
-
-  if (impl->wait_handle_ != INVALID_HANDLE_VALUE)
-  {
-    ::UnregisterWaitEx(impl->wait_handle_, NULL);
-    impl->wait_handle_ = INVALID_HANDLE_VALUE;
-  }
-
-  if (wait_op* op = impl->op_queue_.front())
-  {
-    op_queue<operation> completed_ops;
-
-    op->ec_ = asio::error_code();
-    impl->op_queue_.pop();
-    completed_ops.push(op);
-
-    if (!impl->op_queue_.empty())
-    {
-      if (!RegisterWaitForSingleObject(&impl->wait_handle_,
-            impl->handle_, &win_object_handle_service::wait_callback,
-            param, INFINITE, WT_EXECUTEONLYONCE))
-      {
-        DWORD last_error = ::GetLastError();
-        asio::error_code ec(last_error,
-            asio::error::get_system_category());
-
-        while (wait_op* op = impl->op_queue_.front())
-        {
-          op->ec_ = ec;
-          impl->op_queue_.pop();
-          completed_ops.push(op);
-        }
-      }
-    }
-
-    lock.unlock();
-    impl->owner_->io_service_.post_deferred_completions(completed_ops);
-  }
-}
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // defined(ASIO_HAS_WINDOWS_OBJECT_HANDLE)
-
-#endif // ASIO_DETAIL_IMPL_WIN_OBJECT_HANDLE_SERVICE_IPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/win_static_mutex.ipp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/win_static_mutex.ipp
deleted file mode 100644
index 366d7cf605bb..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/win_static_mutex.ipp
+++ /dev/null
@@ -1,118 +0,0 @@
-//
-// detail/impl/win_static_mutex.ipp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_IMPL_WIN_STATIC_MUTEX_IPP
-#define ASIO_DETAIL_IMPL_WIN_STATIC_MUTEX_IPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_WINDOWS)
-
-#include <cstdio>
-#include "asio/detail/throw_error.hpp"
-#include "asio/detail/win_static_mutex.hpp"
-#include "asio/error.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-void win_static_mutex::init()
-{
-  int error = do_init();
-  asio::error_code ec(error,
-      asio::error::get_system_category());
-  asio::detail::throw_error(ec, "static_mutex");
-}
-
-int win_static_mutex::do_init()
-{
-  using namespace std; // For sprintf.
-  wchar_t mutex_name[128];
-#if defined(ASIO_HAS_SECURE_RTL)
-  swprintf_s(
-#else // defined(ASIO_HAS_SECURE_RTL)
-  _snwprintf(
-#endif // defined(ASIO_HAS_SECURE_RTL)
-      mutex_name, 128, L"asio-58CCDC44-6264-4842-90C2-F3C545CB8AA7-%u-%p",
-      static_cast<unsigned int>(::GetCurrentProcessId()), this);
-
-  HANDLE mutex = ::CreateMutexW(0, TRUE, mutex_name);
-  DWORD last_error = ::GetLastError();
-  if (mutex == 0)
-    return ::GetLastError();
-
-  if (last_error == ERROR_ALREADY_EXISTS)
-    ::WaitForSingleObject(mutex, INFINITE);
-
-  if (initialised_)
-  {
-    ::ReleaseMutex(mutex);
-    ::CloseHandle(mutex);
-    return 0;
-  }
-
-#if defined(__MINGW32__)
-  // Not sure if MinGW supports structured exception handling, so for now
-  // we'll just call the Windows API and hope.
-# if defined(UNDER_CE)
-  ::InitializeCriticalSection(&crit_section_);
-# else
-  if (!::InitializeCriticalSectionAndSpinCount(&crit_section_, 0x80000000))
-  {
-    last_error = ::GetLastError();
-    ::ReleaseMutex(mutex);
-    ::CloseHandle(mutex);
-    return last_error;
-  }
-# endif
-#else
-  __try
-  {
-# if defined(UNDER_CE)
-    ::InitializeCriticalSection(&crit_section_);
-# else
-    if (!::InitializeCriticalSectionAndSpinCount(&crit_section_, 0x80000000))
-    {
-      last_error = ::GetLastError();
-      ::ReleaseMutex(mutex);
-      ::CloseHandle(mutex);
-      return last_error;
-    }
-# endif
-  }
-  __except(GetExceptionCode() == STATUS_NO_MEMORY
-      ? EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)
-  {
-    ::ReleaseMutex(mutex);
-    ::CloseHandle(mutex);
-    return ERROR_OUTOFMEMORY;
-  }
-#endif
-
-  initialised_ = true;
-  ::ReleaseMutex(mutex);
-  ::CloseHandle(mutex);
-  return 0;
-}
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // defined(ASIO_WINDOWS)
-
-#endif // ASIO_DETAIL_IMPL_WIN_STATIC_MUTEX_IPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/win_thread.ipp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/win_thread.ipp
deleted file mode 100644
index 554f9f68edbd..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/win_thread.ipp
+++ /dev/null
@@ -1,139 +0,0 @@
-//
-// detail/impl/win_thread.ipp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_IMPL_WIN_THREAD_IPP
-#define ASIO_DETAIL_IMPL_WIN_THREAD_IPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_WINDOWS) && !defined(UNDER_CE)
-
-#include <process.h>
-#include "asio/detail/throw_error.hpp"
-#include "asio/detail/win_thread.hpp"
-#include "asio/error.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-win_thread::~win_thread()
-{
-  ::CloseHandle(thread_);
-
-  // The exit_event_ handle is deliberately allowed to leak here since it
-  // is an error for the owner of an internal thread not to join() it.
-}
-
-void win_thread::join()
-{
-  HANDLE handles[2] = { exit_event_, thread_ };
-  ::WaitForMultipleObjects(2, handles, FALSE, INFINITE);
-  ::CloseHandle(exit_event_);
-  if (terminate_threads())
-  {
-    ::TerminateThread(thread_, 0);
-  }
-  else
-  {
-    ::QueueUserAPC(apc_function, thread_, 0);
-    ::WaitForSingleObject(thread_, INFINITE);
-  }
-}
-
-void win_thread::start_thread(func_base* arg, unsigned int stack_size)
-{
-  ::HANDLE entry_event = 0;
-  arg->entry_event_ = entry_event = ::CreateEvent(0, true, false, 0);
-  if (!entry_event)
-  {
-    DWORD last_error = ::GetLastError();
-    delete arg;
-    asio::error_code ec(last_error,
-        asio::error::get_system_category());
-    asio::detail::throw_error(ec, "thread.entry_event");
-  }
-
-  arg->exit_event_ = exit_event_ = ::CreateEvent(0, true, false, 0);
-  if (!exit_event_)
-  {
-    DWORD last_error = ::GetLastError();
-    delete arg;
-    asio::error_code ec(last_error,
-        asio::error::get_system_category());
-    asio::detail::throw_error(ec, "thread.exit_event");
-  }
-
-  unsigned int thread_id = 0;
-  thread_ = reinterpret_cast<HANDLE>(::_beginthreadex(0,
-        stack_size, win_thread_function, arg, 0, &thread_id));
-  if (!thread_)
-  {
-    DWORD last_error = ::GetLastError();
-    delete arg;
-    if (entry_event)
-      ::CloseHandle(entry_event);
-    if (exit_event_)
-      ::CloseHandle(exit_event_);
-    asio::error_code ec(last_error,
-        asio::error::get_system_category());
-    asio::detail::throw_error(ec, "thread");
-  }
-
-  if (entry_event)
-  {
-    ::WaitForSingleObject(entry_event, INFINITE);
-    ::CloseHandle(entry_event);
-  }
-}
-
-unsigned int __stdcall win_thread_function(void* arg)
-{
-  win_thread::auto_func_base_ptr func = {
-      static_cast<win_thread::func_base*>(arg) };
-
-  ::SetEvent(func.ptr->entry_event_);
-
-  func.ptr->run();
-
-  // Signal that the thread has finished its work, but rather than returning go
-  // to sleep to put the thread into a well known state. If the thread is being
-  // joined during global object destruction then it may be killed using
-  // TerminateThread (to avoid a deadlock in DllMain). Otherwise, the SleepEx
-  // call will be interrupted using QueueUserAPC and the thread will shut down
-  // cleanly.
-  HANDLE exit_event = func.ptr->exit_event_;
-  delete func.ptr;
-  func.ptr = 0;
-  ::SetEvent(exit_event);
-  ::SleepEx(INFINITE, TRUE);
-
-  return 0;
-}
-
-#if defined(WINVER) && (WINVER < 0x0500)
-void __stdcall apc_function(ULONG) {}
-#else
-void __stdcall apc_function(ULONG_PTR) {}
-#endif
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // defined(ASIO_WINDOWS) && !defined(UNDER_CE)
-
-#endif // ASIO_DETAIL_IMPL_WIN_THREAD_IPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/win_tss_ptr.ipp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/win_tss_ptr.ipp
deleted file mode 100644
index 7fa4c2688f4f..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/win_tss_ptr.ipp
+++ /dev/null
@@ -1,57 +0,0 @@
-//
-// detail/impl/win_tss_ptr.ipp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_IMPL_WIN_TSS_PTR_IPP
-#define ASIO_DETAIL_IMPL_WIN_TSS_PTR_IPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_WINDOWS)
-
-#include "asio/detail/throw_error.hpp"
-#include "asio/detail/win_tss_ptr.hpp"
-#include "asio/error.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-DWORD win_tss_ptr_create()
-{
-#if defined(UNDER_CE)
-  enum { out_of_indexes = 0xFFFFFFFF };
-#else
-  enum { out_of_indexes = TLS_OUT_OF_INDEXES };
-#endif
-
-  DWORD tss_key = ::TlsAlloc();
-  if (tss_key == out_of_indexes)
-  {
-    DWORD last_error = ::GetLastError();
-    asio::error_code ec(last_error,
-        asio::error::get_system_category());
-    asio::detail::throw_error(ec, "tss");
-  }
-  return tss_key;
-}
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // defined(ASIO_WINDOWS)
-
-#endif // ASIO_DETAIL_IMPL_WIN_TSS_PTR_IPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/winrt_ssocket_service_base.ipp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/winrt_ssocket_service_base.ipp
deleted file mode 100644
index c5aa3f4049f5..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/winrt_ssocket_service_base.ipp
+++ /dev/null
@@ -1,612 +0,0 @@
-//
-// detail/impl/winrt_ssocket_service_base.ipp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_IMPL_WINRT_SSOCKET_SERVICE_BASE_IPP
-#define ASIO_DETAIL_IMPL_WINRT_SSOCKET_SERVICE_BASE_IPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_WINDOWS_RUNTIME)
-
-#include <cstring>
-#include "asio/detail/winrt_ssocket_service_base.hpp"
-#include "asio/detail/winrt_async_op.hpp"
-#include "asio/detail/winrt_utils.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-winrt_ssocket_service_base::winrt_ssocket_service_base(
-    asio::io_service& io_service)
-  : io_service_(use_service<io_service_impl>(io_service)),
-    async_manager_(use_service<winrt_async_manager>(io_service)),
-    mutex_(),
-    impl_list_(0)
-{
-}
-
-void winrt_ssocket_service_base::shutdown_service()
-{
-  // Close all implementations, causing all operations to complete.
-  asio::detail::mutex::scoped_lock lock(mutex_);
-  base_implementation_type* impl = impl_list_;
-  while (impl)
-  {
-    asio::error_code ignored_ec;
-    close(*impl, ignored_ec);
-    impl = impl->next_;
-  }
-}
-
-void winrt_ssocket_service_base::construct(
-    winrt_ssocket_service_base::base_implementation_type& impl)
-{
-  // Insert implementation into linked list of all implementations.
-  asio::detail::mutex::scoped_lock lock(mutex_);
-  impl.next_ = impl_list_;
-  impl.prev_ = 0;
-  if (impl_list_)
-    impl_list_->prev_ = &impl;
-  impl_list_ = &impl;
-}
-
-void winrt_ssocket_service_base::base_move_construct(
-    winrt_ssocket_service_base::base_implementation_type& impl,
-    winrt_ssocket_service_base::base_implementation_type& other_impl)
-{
-  impl.socket_ = other_impl.socket_;
-  other_impl.socket_ = nullptr;
-
-  // Insert implementation into linked list of all implementations.
-  asio::detail::mutex::scoped_lock lock(mutex_);
-  impl.next_ = impl_list_;
-  impl.prev_ = 0;
-  if (impl_list_)
-    impl_list_->prev_ = &impl;
-  impl_list_ = &impl;
-}
-
-void winrt_ssocket_service_base::base_move_assign(
-    winrt_ssocket_service_base::base_implementation_type& impl,
-    winrt_ssocket_service_base& other_service,
-    winrt_ssocket_service_base::base_implementation_type& other_impl)
-{
-  asio::error_code ignored_ec;
-  close(impl, ignored_ec);
-
-  if (this != &other_service)
-  {
-    // Remove implementation from linked list of all implementations.
-    asio::detail::mutex::scoped_lock lock(mutex_);
-    if (impl_list_ == &impl)
-      impl_list_ = impl.next_;
-    if (impl.prev_)
-      impl.prev_->next_ = impl.next_;
-    if (impl.next_)
-      impl.next_->prev_= impl.prev_;
-    impl.next_ = 0;
-    impl.prev_ = 0;
-  }
-
-  impl.socket_ = other_impl.socket_;
-  other_impl.socket_ = nullptr;
-
-  if (this != &other_service)
-  {
-    // Insert implementation into linked list of all implementations.
-    asio::detail::mutex::scoped_lock lock(other_service.mutex_);
-    impl.next_ = other_service.impl_list_;
-    impl.prev_ = 0;
-    if (other_service.impl_list_)
-      other_service.impl_list_->prev_ = &impl;
-    other_service.impl_list_ = &impl;
-  }
-}
-
-void winrt_ssocket_service_base::destroy(
-    winrt_ssocket_service_base::base_implementation_type& impl)
-{
-  asio::error_code ignored_ec;
-  close(impl, ignored_ec);
-
-  // Remove implementation from linked list of all implementations.
-  asio::detail::mutex::scoped_lock lock(mutex_);
-  if (impl_list_ == &impl)
-    impl_list_ = impl.next_;
-  if (impl.prev_)
-    impl.prev_->next_ = impl.next_;
-  if (impl.next_)
-    impl.next_->prev_= impl.prev_;
-  impl.next_ = 0;
-  impl.prev_ = 0;
-}
-
-asio::error_code winrt_ssocket_service_base::close(
-    winrt_ssocket_service_base::base_implementation_type& impl,
-    asio::error_code& ec)
-{
-  if (impl.socket_)
-  {
-    delete impl.socket_;
-    impl.socket_ = nullptr;
-  }
-
-  ec = asio::error_code();
-  return ec;
-}
-
-std::size_t winrt_ssocket_service_base::do_get_endpoint(
-    const base_implementation_type& impl, bool local,
-    void* addr, std::size_t addr_len, asio::error_code& ec) const
-{
-  if (!is_open(impl))
-  {
-    ec = asio::error::bad_descriptor;
-    return addr_len;
-  }
-
-  try
-  {
-    std::string addr_string = winrt_utils::string(local
-        ? impl.socket_->Information->LocalAddress->CanonicalName
-        : impl.socket_->Information->RemoteAddress->CanonicalName);
-    unsigned short port = winrt_utils::integer(local
-        ? impl.socket_->Information->LocalPort
-        : impl.socket_->Information->RemotePort);
-    unsigned long scope = 0;
-
-    switch (reinterpret_cast<const socket_addr_type*>(addr)->sa_family)
-    {
-    case ASIO_OS_DEF(AF_INET):
-      if (addr_len < sizeof(sockaddr_in4_type))
-      {
-        ec = asio::error::invalid_argument;
-        return addr_len;
-      }
-      else
-      {
-        socket_ops::inet_pton(ASIO_OS_DEF(AF_INET), addr_string.c_str(),
-            &reinterpret_cast<sockaddr_in4_type*>(addr)->sin_addr, &scope, ec);
-        reinterpret_cast<sockaddr_in4_type*>(addr)->sin_port
-          = socket_ops::host_to_network_short(port);
-        ec = asio::error_code();
-        return sizeof(sockaddr_in4_type);
-      }
-    case ASIO_OS_DEF(AF_INET6):
-      if (addr_len < sizeof(sockaddr_in6_type))
-      {
-        ec = asio::error::invalid_argument;
-        return addr_len;
-      }
-      else
-      {
-        socket_ops::inet_pton(ASIO_OS_DEF(AF_INET6), addr_string.c_str(),
-            &reinterpret_cast<sockaddr_in6_type*>(addr)->sin6_addr, &scope, ec);
-        reinterpret_cast<sockaddr_in6_type*>(addr)->sin6_port
-          = socket_ops::host_to_network_short(port);
-        ec = asio::error_code();
-        return sizeof(sockaddr_in6_type);
-      }
-    default:
-      ec = asio::error::address_family_not_supported;
-      return addr_len;
-    }
-  }
-  catch (Platform::Exception^ e)
-  {
-    ec = asio::error_code(e->HResult,
-        asio::system_category());
-    return addr_len;
-  }
-}
-
-asio::error_code winrt_ssocket_service_base::do_set_option(
-    winrt_ssocket_service_base::base_implementation_type& impl,
-    int level, int optname, const void* optval,
-    std::size_t optlen, asio::error_code& ec)
-{
-  if (!is_open(impl))
-  {
-    ec = asio::error::bad_descriptor;
-    return ec;
-  }
-
-  try
-  {
-    if (level == ASIO_OS_DEF(SOL_SOCKET)
-        && optname == ASIO_OS_DEF(SO_KEEPALIVE))
-    {
-      if (optlen == sizeof(int))
-      {
-        int value = 0;
-        std::memcpy(&value, optval, optlen);
-        impl.socket_->Control->KeepAlive = !!value;
-        ec = asio::error_code();
-      }
-      else
-      {
-        ec = asio::error::invalid_argument;
-      }
-    }
-    else if (level == ASIO_OS_DEF(IPPROTO_TCP)
-        && optname == ASIO_OS_DEF(TCP_NODELAY))
-    {
-      if (optlen == sizeof(int))
-      {
-        int value = 0;
-        std::memcpy(&value, optval, optlen);
-        impl.socket_->Control->NoDelay = !!value;
-        ec = asio::error_code();
-      }
-      else
-      {
-        ec = asio::error::invalid_argument;
-      }
-    }
-    else
-    {
-      ec = asio::error::invalid_argument;
-    }
-  }
-  catch (Platform::Exception^ e)
-  {
-    ec = asio::error_code(e->HResult,
-        asio::system_category());
-  }
-
-  return ec;
-}
-
-void winrt_ssocket_service_base::do_get_option(
-    const winrt_ssocket_service_base::base_implementation_type& impl,
-    int level, int optname, void* optval,
-    std::size_t* optlen, asio::error_code& ec) const
-{
-  if (!is_open(impl))
-  {
-    ec = asio::error::bad_descriptor;
-    return;
-  }
-
-  try
-  {
-    if (level == ASIO_OS_DEF(SOL_SOCKET)
-        && optname == ASIO_OS_DEF(SO_KEEPALIVE))
-    {
-      if (*optlen >= sizeof(int))
-      {
-        int value = impl.socket_->Control->KeepAlive ? 1 : 0;
-        std::memcpy(optval, &value, sizeof(int));
-        *optlen = sizeof(int);
-        ec = asio::error_code();
-      }
-      else
-      {
-        ec = asio::error::invalid_argument;
-      }
-    }
-    else if (level == ASIO_OS_DEF(IPPROTO_TCP)
-        && optname == ASIO_OS_DEF(TCP_NODELAY))
-    {
-      if (*optlen >= sizeof(int))
-      {
-        int value = impl.socket_->Control->NoDelay ? 1 : 0;
-        std::memcpy(optval, &value, sizeof(int));
-        *optlen = sizeof(int);
-        ec = asio::error_code();
-      }
-      else
-      {
-        ec = asio::error::invalid_argument;
-      }
-    }
-    else
-    {
-      ec = asio::error::invalid_argument;
-    }
-  }
-  catch (Platform::Exception^ e)
-  {
-    ec = asio::error_code(e->HResult,
-        asio::system_category());
-  }
-}
-
-asio::error_code winrt_ssocket_service_base::do_connect(
-    winrt_ssocket_service_base::base_implementation_type& impl,
-    const void* addr, asio::error_code& ec)
-{
-  if (!is_open(impl))
-  {
-    ec = asio::error::bad_descriptor;
-    return ec;
-  }
-
-  char addr_string[max_addr_v6_str_len];
-  unsigned short port;
-  switch (reinterpret_cast<const socket_addr_type*>(addr)->sa_family)
-  {
-  case ASIO_OS_DEF(AF_INET):
-    socket_ops::inet_ntop(ASIO_OS_DEF(AF_INET),
-        &reinterpret_cast<const sockaddr_in4_type*>(addr)->sin_addr,
-        addr_string, sizeof(addr_string), 0, ec);
-    port = socket_ops::network_to_host_short(
-        reinterpret_cast<const sockaddr_in4_type*>(addr)->sin_port);
-    break;
-  case ASIO_OS_DEF(AF_INET6):
-    socket_ops::inet_ntop(ASIO_OS_DEF(AF_INET6),
-        &reinterpret_cast<const sockaddr_in6_type*>(addr)->sin6_addr,
-        addr_string, sizeof(addr_string), 0, ec);
-    port = socket_ops::network_to_host_short(
-        reinterpret_cast<const sockaddr_in6_type*>(addr)->sin6_port);
-    break;
-  default:
-    ec = asio::error::address_family_not_supported;
-    return ec;
-  }
-
-  if (!ec) try
-  {
-    async_manager_.sync(impl.socket_->ConnectAsync(
-          ref new Windows::Networking::HostName(
-            winrt_utils::string(addr_string)),
-          winrt_utils::string(port)), ec);
-  }
-  catch (Platform::Exception^ e)
-  {
-    ec = asio::error_code(e->HResult,
-        asio::system_category());
-  }
-
-  return ec;
-}
-
-void winrt_ssocket_service_base::start_connect_op(
-    winrt_ssocket_service_base::base_implementation_type& impl,
-    const void* addr, winrt_async_op<void>* op, bool is_continuation)
-{
-  if (!is_open(impl))
-  {
-    op->ec_ = asio::error::bad_descriptor;
-    io_service_.post_immediate_completion(op, is_continuation);
-    return;
-  }
-
-  char addr_string[max_addr_v6_str_len];
-  unsigned short port = 0;
-  switch (reinterpret_cast<const socket_addr_type*>(addr)->sa_family)
-  {
-  case ASIO_OS_DEF(AF_INET):
-    socket_ops::inet_ntop(ASIO_OS_DEF(AF_INET),
-        &reinterpret_cast<const sockaddr_in4_type*>(addr)->sin_addr,
-        addr_string, sizeof(addr_string), 0, op->ec_);
-    port = socket_ops::network_to_host_short(
-        reinterpret_cast<const sockaddr_in4_type*>(addr)->sin_port);
-    break;
-  case ASIO_OS_DEF(AF_INET6):
-    socket_ops::inet_ntop(ASIO_OS_DEF(AF_INET6),
-        &reinterpret_cast<const sockaddr_in6_type*>(addr)->sin6_addr,
-        addr_string, sizeof(addr_string), 0, op->ec_);
-    port = socket_ops::network_to_host_short(
-        reinterpret_cast<const sockaddr_in6_type*>(addr)->sin6_port);
-    break;
-  default:
-    op->ec_ = asio::error::address_family_not_supported;
-    break;
-  }
-
-  if (op->ec_)
-  {
-    io_service_.post_immediate_completion(op, is_continuation);
-    return;
-  }
-
-  try
-  {
-    async_manager_.async(impl.socket_->ConnectAsync(
-          ref new Windows::Networking::HostName(
-            winrt_utils::string(addr_string)),
-          winrt_utils::string(port)), op);
-  }
-  catch (Platform::Exception^ e)
-  {
-    op->ec_ = asio::error_code(
-        e->HResult, asio::system_category());
-    io_service_.post_immediate_completion(op, is_continuation);
-  }
-}
-
-std::size_t winrt_ssocket_service_base::do_send(
-    winrt_ssocket_service_base::base_implementation_type& impl,
-    const asio::const_buffer& data,
-    socket_base::message_flags flags, asio::error_code& ec)
-{
-  if (flags)
-  {
-    ec = asio::error::operation_not_supported;
-    return 0;
-  }
-
-  if (!is_open(impl))
-  {
-    ec = asio::error::bad_descriptor;
-    return 0;
-  }
-
-  try
-  {
-    buffer_sequence_adapter<asio::const_buffer,
-      asio::const_buffers_1> bufs(asio::buffer(data));
-
-    if (bufs.all_empty())
-    {
-      ec = asio::error_code();
-      return 0;
-    }
-
-    return async_manager_.sync(
-        impl.socket_->OutputStream->WriteAsync(bufs.buffers()[0]), ec);
-  }
-  catch (Platform::Exception^ e)
-  {
-    ec = asio::error_code(e->HResult,
-        asio::system_category());
-    return 0;
-  }
-}
-
-void winrt_ssocket_service_base::start_send_op(
-      winrt_ssocket_service_base::base_implementation_type& impl,
-      const asio::const_buffer& data, socket_base::message_flags flags,
-      winrt_async_op<unsigned int>* op, bool is_continuation)
-{
-  if (flags)
-  {
-    op->ec_ = asio::error::operation_not_supported;
-    io_service_.post_immediate_completion(op, is_continuation);
-    return;
-  }
-
-  if (!is_open(impl))
-  {
-    op->ec_ = asio::error::bad_descriptor;
-    io_service_.post_immediate_completion(op, is_continuation);
-    return;
-  }
-
-  try
-  {
-    buffer_sequence_adapter<asio::const_buffer,
-        asio::const_buffers_1> bufs(asio::buffer(data));
-
-    if (bufs.all_empty())
-    {
-      io_service_.post_immediate_completion(op, is_continuation);
-      return;
-    }
-
-    async_manager_.async(
-        impl.socket_->OutputStream->WriteAsync(bufs.buffers()[0]), op);
-  }
-  catch (Platform::Exception^ e)
-  {
-    op->ec_ = asio::error_code(e->HResult,
-        asio::system_category());
-    io_service_.post_immediate_completion(op, is_continuation);
-  }
-}
-
-std::size_t winrt_ssocket_service_base::do_receive(
-    winrt_ssocket_service_base::base_implementation_type& impl,
-    const asio::mutable_buffer& data,
-    socket_base::message_flags flags, asio::error_code& ec)
-{
-  if (flags)
-  {
-    ec = asio::error::operation_not_supported;
-    return 0;
-  }
-
-  if (!is_open(impl))
-  {
-    ec = asio::error::bad_descriptor;
-    return 0;
-  }
-
-  try
-  {
-    buffer_sequence_adapter<asio::mutable_buffer,
-        asio::mutable_buffers_1> bufs(asio::buffer(data));
-
-    if (bufs.all_empty())
-    {
-      ec = asio::error_code();
-      return 0;
-    }
-
-    async_manager_.sync(
-        impl.socket_->InputStream->ReadAsync(
-          bufs.buffers()[0], bufs.buffers()[0]->Capacity,
-          Windows::Storage::Streams::InputStreamOptions::Partial), ec);
-
-    std::size_t bytes_transferred = bufs.buffers()[0]->Length;
-    if (bytes_transferred == 0 && !ec)
-    {
-      ec = asio::error::eof;
-    }
-
-    return bytes_transferred;
-  }
-  catch (Platform::Exception^ e)
-  {
-    ec = asio::error_code(e->HResult,
-        asio::system_category());
-    return 0;
-  }
-}
-
-void winrt_ssocket_service_base::start_receive_op(
-      winrt_ssocket_service_base::base_implementation_type& impl,
-      const asio::mutable_buffer& data, socket_base::message_flags flags,
-      winrt_async_op<Windows::Storage::Streams::IBuffer^>* op,
-      bool is_continuation)
-{
-  if (flags)
-  {
-    op->ec_ = asio::error::operation_not_supported;
-    io_service_.post_immediate_completion(op, is_continuation);
-    return;
-  }
-
-  if (!is_open(impl))
-  {
-    op->ec_ = asio::error::bad_descriptor;
-    io_service_.post_immediate_completion(op, is_continuation);
-    return;
-  }
-
-  try
-  {
-    buffer_sequence_adapter<asio::mutable_buffer,
-        asio::mutable_buffers_1> bufs(asio::buffer(data));
-
-    if (bufs.all_empty())
-    {
-      io_service_.post_immediate_completion(op, is_continuation);
-      return;
-    }
-
-    async_manager_.async(
-        impl.socket_->InputStream->ReadAsync(
-          bufs.buffers()[0], bufs.buffers()[0]->Capacity,
-          Windows::Storage::Streams::InputStreamOptions::Partial), op);
-  }
-  catch (Platform::Exception^ e)
-  {
-    op->ec_ = asio::error_code(e->HResult,
-        asio::system_category());
-    io_service_.post_immediate_completion(op, is_continuation);
-  }
-}
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // defined(ASIO_WINDOWS_RUNTIME)
-
-#endif // ASIO_DETAIL_IMPL_WINRT_SSOCKET_SERVICE_BASE_IPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/winrt_timer_scheduler.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/winrt_timer_scheduler.hpp
deleted file mode 100644
index 544758dcc8ee..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/winrt_timer_scheduler.hpp
+++ /dev/null
@@ -1,79 +0,0 @@
-//
-// detail/impl/winrt_timer_scheduler.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_IMPL_WINRT_TIMER_SCHEDULER_HPP
-#define ASIO_DETAIL_IMPL_WINRT_TIMER_SCHEDULER_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_WINDOWS_RUNTIME)
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-template <typename Time_Traits>
-void winrt_timer_scheduler::add_timer_queue(timer_queue<Time_Traits>& queue)
-{
-  do_add_timer_queue(queue);
-}
-
-// Remove a timer queue from the reactor.
-template <typename Time_Traits>
-void winrt_timer_scheduler::remove_timer_queue(timer_queue<Time_Traits>& queue)
-{
-  do_remove_timer_queue(queue);
-}
-
-template <typename Time_Traits>
-void winrt_timer_scheduler::schedule_timer(timer_queue<Time_Traits>& queue,
-    const typename Time_Traits::time_type& time,
-    typename timer_queue<Time_Traits>::per_timer_data& timer, wait_op* op)
-{
-  asio::detail::mutex::scoped_lock lock(mutex_);
-
-  if (shutdown_)
-  {
-    io_service_.post_immediate_completion(op, false);
-    return;
-  }
-
-  bool earliest = queue.enqueue_timer(time, timer, op);
-  io_service_.work_started();
-  if (earliest)
-    event_.signal(lock);
-}
-
-template <typename Time_Traits>
-std::size_t winrt_timer_scheduler::cancel_timer(timer_queue<Time_Traits>& queue,
-    typename timer_queue<Time_Traits>::per_timer_data& timer,
-    std::size_t max_cancelled)
-{
-  asio::detail::mutex::scoped_lock lock(mutex_);
-  op_queue<operation> ops;
-  std::size_t n = queue.cancel_timer(timer, ops, max_cancelled);
-  lock.unlock();
-  io_service_.post_deferred_completions(ops);
-  return n;
-}
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // defined(ASIO_WINDOWS_RUNTIME)
-
-#endif // ASIO_DETAIL_IMPL_WINRT_TIMER_SCHEDULER_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/winrt_timer_scheduler.ipp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/winrt_timer_scheduler.ipp
deleted file mode 100644
index c7236c775bcb..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/winrt_timer_scheduler.ipp
+++ /dev/null
@@ -1,122 +0,0 @@
-//
-// detail/impl/winrt_timer_scheduler.ipp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_IMPL_WINRT_TIMER_SCHEDULER_IPP
-#define ASIO_DETAIL_IMPL_WINRT_TIMER_SCHEDULER_IPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_WINDOWS_RUNTIME)
-
-#include "asio/detail/bind_handler.hpp"
-#include "asio/detail/winrt_timer_scheduler.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-winrt_timer_scheduler::winrt_timer_scheduler(
-    asio::io_service& io_service)
-  : asio::detail::service_base<winrt_timer_scheduler>(io_service),
-    io_service_(use_service<io_service_impl>(io_service)),
-    mutex_(),
-    event_(),
-    timer_queues_(),
-    thread_(0),
-    stop_thread_(false),
-    shutdown_(false)
-{
-  thread_ = new asio::detail::thread(
-      bind_handler(&winrt_timer_scheduler::call_run_thread, this));
-}
-
-winrt_timer_scheduler::~winrt_timer_scheduler()
-{
-  shutdown_service();
-}
-
-void winrt_timer_scheduler::shutdown_service()
-{
-  asio::detail::mutex::scoped_lock lock(mutex_);
-  shutdown_ = true;
-  stop_thread_ = true;
-  event_.signal(lock);
-  lock.unlock();
-
-  if (thread_)
-  {
-    thread_->join();
-    delete thread_;
-    thread_ = 0;
-  }
-
-  op_queue<operation> ops;
-  timer_queues_.get_all_timers(ops);
-  io_service_.abandon_operations(ops);
-}
-
-void winrt_timer_scheduler::fork_service(asio::io_service::fork_event)
-{
-}
-
-void winrt_timer_scheduler::init_task()
-{
-}
-
-void winrt_timer_scheduler::run_thread()
-{
-  asio::detail::mutex::scoped_lock lock(mutex_);
-  while (!stop_thread_)
-  {
-    const long max_wait_duration = 5 * 60 * 1000000;
-    long wait_duration = timer_queues_.wait_duration_usec(max_wait_duration);
-    event_.wait_for_usec(lock, wait_duration);
-    event_.clear(lock);
-    op_queue<operation> ops;
-    timer_queues_.get_ready_timers(ops);
-    if (!ops.empty())
-    {
-      lock.unlock();
-      io_service_.post_deferred_completions(ops);
-      lock.lock();
-    }
-  }
-}
-
-void winrt_timer_scheduler::call_run_thread(winrt_timer_scheduler* scheduler)
-{
-  scheduler->run_thread();
-}
-
-void winrt_timer_scheduler::do_add_timer_queue(timer_queue_base& queue)
-{
-  mutex::scoped_lock lock(mutex_);
-  timer_queues_.insert(&queue);
-}
-
-void winrt_timer_scheduler::do_remove_timer_queue(timer_queue_base& queue)
-{
-  mutex::scoped_lock lock(mutex_);
-  timer_queues_.erase(&queue);
-}
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // defined(ASIO_WINDOWS_RUNTIME)
-
-#endif // ASIO_DETAIL_IMPL_WINRT_TIMER_SCHEDULER_IPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/winsock_init.ipp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/winsock_init.ipp
deleted file mode 100644
index 9f357f504804..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/impl/winsock_init.ipp
+++ /dev/null
@@ -1,82 +0,0 @@
-//
-// detail/impl/winsock_init.ipp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_IMPL_WINSOCK_INIT_IPP
-#define ASIO_DETAIL_IMPL_WINSOCK_INIT_IPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-
-#include "asio/detail/socket_types.hpp"
-#include "asio/detail/winsock_init.hpp"
-#include "asio/detail/throw_error.hpp"
-#include "asio/error.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-void winsock_init_base::startup(data& d,
-    unsigned char major, unsigned char minor)
-{
-  if (::InterlockedIncrement(&d.init_count_) == 1)
-  {
-    WSADATA wsa_data;
-    long result = ::WSAStartup(MAKEWORD(major, minor), &wsa_data);
-    ::InterlockedExchange(&d.result_, result);
-  }
-}
-
-void winsock_init_base::manual_startup(data& d)
-{
-  if (::InterlockedIncrement(&d.init_count_) == 1)
-  {
-    ::InterlockedExchange(&d.result_, 0);
-  }
-}
-
-void winsock_init_base::cleanup(data& d)
-{
-  if (::InterlockedDecrement(&d.init_count_) == 0)
-  {
-    ::WSACleanup();
-  }
-}
-
-void winsock_init_base::manual_cleanup(data& d)
-{
-  ::InterlockedDecrement(&d.init_count_);
-}
-
-void winsock_init_base::throw_on_error(data& d)
-{
-  long result = ::InterlockedExchangeAdd(&d.result_, 0);
-  if (result != 0)
-  {
-    asio::error_code ec(result,
-        asio::error::get_system_category());
-    asio::detail::throw_error(ec, "winsock");
-  }
-}
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-
-#endif // ASIO_DETAIL_IMPL_WINSOCK_INIT_IPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/io_control.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/io_control.hpp
deleted file mode 100644
index 3f84c35319b9..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/io_control.hpp
+++ /dev/null
@@ -1,134 +0,0 @@
-//
-// detail/io_control.hpp
-// ~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_IO_CONTROL_HPP
-#define ASIO_DETAIL_IO_CONTROL_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include <cstddef>
-#include "asio/detail/socket_types.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-namespace io_control {
-
-// IO control command for non-blocking I/O.
-class non_blocking_io
-{
-public:
-  // Default constructor.
-  non_blocking_io()
-    : value_(0)
-  {
-  }
-
-  // Construct with a specific command value.
-  non_blocking_io(bool value)
-    : value_(value ? 1 : 0)
-  {
-  }
-
-  // Get the name of the IO control command.
-  int name() const
-  {
-    return static_cast<int>(ASIO_OS_DEF(FIONBIO));
-  }
-
-  // Set the value of the I/O control command.
-  void set(bool value)
-  {
-    value_ = value ? 1 : 0;
-  }
-
-  // Get the current value of the I/O control command.
-  bool get() const
-  {
-    return value_ != 0;
-  }
-
-  // Get the address of the command data.
-  detail::ioctl_arg_type* data()
-  {
-    return &value_;
-  }
-
-  // Get the address of the command data.
-  const detail::ioctl_arg_type* data() const
-  {
-    return &value_;
-  }
-
-private:
-  detail::ioctl_arg_type value_;
-};
-
-// I/O control command for getting number of bytes available.
-class bytes_readable
-{
-public:
-  // Default constructor.
-  bytes_readable()
-    : value_(0)
-  {
-  }
-
-  // Construct with a specific command value.
-  bytes_readable(std::size_t value)
-    : value_(static_cast<detail::ioctl_arg_type>(value))
-  {
-  }
-
-  // Get the name of the IO control command.
-  int name() const
-  {
-    return static_cast<int>(ASIO_OS_DEF(FIONREAD));
-  }
-
-  // Set the value of the I/O control command.
-  void set(std::size_t value)
-  {
-    value_ = static_cast<detail::ioctl_arg_type>(value);
-  }
-
-  // Get the current value of the I/O control command.
-  std::size_t get() const
-  {
-    return static_cast<std::size_t>(value_);
-  }
-
-  // Get the address of the command data.
-  detail::ioctl_arg_type* data()
-  {
-    return &value_;
-  }
-
-  // Get the address of the command data.
-  const detail::ioctl_arg_type* data() const
-  {
-    return &value_;
-  }
-
-private:
-  detail::ioctl_arg_type value_;
-};
-
-} // namespace io_control
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_DETAIL_IO_CONTROL_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/keyword_tss_ptr.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/keyword_tss_ptr.hpp
deleted file mode 100644
index c544403c2ad5..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/keyword_tss_ptr.hpp
+++ /dev/null
@@ -1,70 +0,0 @@
-//
-// detail/keyword_tss_ptr.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_KEYWORD_TSS_PTR_HPP
-#define ASIO_DETAIL_KEYWORD_TSS_PTR_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_HAS_THREAD_KEYWORD_EXTENSION)
-
-#include "asio/detail/noncopyable.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-template <typename T>
-class keyword_tss_ptr
-  : private noncopyable
-{
-public:
-  // Constructor.
-  keyword_tss_ptr()
-  {
-  }
-
-  // Destructor.
-  ~keyword_tss_ptr()
-  {
-  }
-
-  // Get the value.
-  operator T*() const
-  {
-    return value_;
-  }
-
-  // Set the value.
-  void operator=(T* value)
-  {
-    value_ = value;
-  }
-
-private:
-  static ASIO_THREAD_KEYWORD T* value_;
-};
-
-template <typename T>
-ASIO_THREAD_KEYWORD T* keyword_tss_ptr<T>::value_;
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // defined(ASIO_HAS_THREAD_KEYWORD_EXTENSION)
-
-#endif // ASIO_DETAIL_KEYWORD_TSS_PTR_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/kqueue_reactor.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/kqueue_reactor.hpp
deleted file mode 100644
index ddd6c8a8f207..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/kqueue_reactor.hpp
+++ /dev/null
@@ -1,219 +0,0 @@
-//
-// detail/kqueue_reactor.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-// Copyright (c) 2005 Stefan Arentz (stefan at soze dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_KQUEUE_REACTOR_HPP
-#define ASIO_DETAIL_KQUEUE_REACTOR_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_HAS_KQUEUE)
-
-#include <cstddef>
-#include <sys/types.h>
-#include <sys/event.h>
-#include <sys/time.h>
-#include "asio/detail/limits.hpp"
-#include "asio/detail/mutex.hpp"
-#include "asio/detail/object_pool.hpp"
-#include "asio/detail/op_queue.hpp"
-#include "asio/detail/reactor_op.hpp"
-#include "asio/detail/select_interrupter.hpp"
-#include "asio/detail/socket_types.hpp"
-#include "asio/detail/timer_queue_base.hpp"
-#include "asio/detail/timer_queue_set.hpp"
-#include "asio/detail/wait_op.hpp"
-#include "asio/error.hpp"
-#include "asio/io_service.hpp"
-
-// Older versions of Mac OS X may not define EV_OOBAND.
-#if !defined(EV_OOBAND)
-# define EV_OOBAND EV_FLAG1
-#endif // !defined(EV_OOBAND)
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-class kqueue_reactor
-  : public asio::detail::service_base<kqueue_reactor>
-{
-public:
-  enum op_types { read_op = 0, write_op = 1,
-    connect_op = 1, except_op = 2, max_ops = 3 };
-
-  // Per-descriptor queues.
-  struct descriptor_state
-  {
-    friend class kqueue_reactor;
-    friend class object_pool_access;
-
-    descriptor_state* next_;
-    descriptor_state* prev_;
-
-    mutex mutex_;
-    int descriptor_;
-    op_queue<reactor_op> op_queue_[max_ops];
-    bool shutdown_;
-  };
-
-  // Per-descriptor data.
-  typedef descriptor_state* per_descriptor_data;
-
-  // Constructor.
-  ASIO_DECL kqueue_reactor(asio::io_service& io_service);
-
-  // Destructor.
-  ASIO_DECL ~kqueue_reactor();
-
-  // Destroy all user-defined handler objects owned by the service.
-  ASIO_DECL void shutdown_service();
-
-  // Recreate internal descriptors following a fork.
-  ASIO_DECL void fork_service(
-      asio::io_service::fork_event fork_ev);
-
-  // Initialise the task.
-  ASIO_DECL void init_task();
-
-  // Register a socket with the reactor. Returns 0 on success, system error
-  // code on failure.
-  ASIO_DECL int register_descriptor(socket_type descriptor,
-      per_descriptor_data& descriptor_data);
-
-  // Register a descriptor with an associated single operation. Returns 0 on
-  // success, system error code on failure.
-  ASIO_DECL int register_internal_descriptor(
-      int op_type, socket_type descriptor,
-      per_descriptor_data& descriptor_data, reactor_op* op);
-
-  // Move descriptor registration from one descriptor_data object to another.
-  ASIO_DECL void move_descriptor(socket_type descriptor,
-      per_descriptor_data& target_descriptor_data,
-      per_descriptor_data& source_descriptor_data);
-
-  // Post a reactor operation for immediate completion.
-  void post_immediate_completion(reactor_op* op, bool is_continuation)
-  {
-    io_service_.post_immediate_completion(op, is_continuation);
-  }
-
-  // Start a new operation. The reactor operation will be performed when the
-  // given descriptor is flagged as ready, or an error has occurred.
-  ASIO_DECL void start_op(int op_type, socket_type descriptor,
-      per_descriptor_data& descriptor_data, reactor_op* op,
-      bool is_continuation, bool allow_speculative);
-
-  // Cancel all operations associated with the given descriptor. The
-  // handlers associated with the descriptor will be invoked with the
-  // operation_aborted error.
-  ASIO_DECL void cancel_ops(socket_type descriptor,
-      per_descriptor_data& descriptor_data);
-
-  // Cancel any operations that are running against the descriptor and remove
-  // its registration from the reactor.
-  ASIO_DECL void deregister_descriptor(socket_type descriptor,
-      per_descriptor_data& descriptor_data, bool closing);
-
-  // Remote the descriptor's registration from the reactor.
-  ASIO_DECL void deregister_internal_descriptor(
-      socket_type descriptor, per_descriptor_data& descriptor_data);
-
-  // Add a new timer queue to the reactor.
-  template <typename Time_Traits>
-  void add_timer_queue(timer_queue<Time_Traits>& queue);
-
-  // Remove a timer queue from the reactor.
-  template <typename Time_Traits>
-  void remove_timer_queue(timer_queue<Time_Traits>& queue);
-
-  // Schedule a new operation in the given timer queue to expire at the
-  // specified absolute time.
-  template <typename Time_Traits>
-  void schedule_timer(timer_queue<Time_Traits>& queue,
-      const typename Time_Traits::time_type& time,
-      typename timer_queue<Time_Traits>::per_timer_data& timer, wait_op* op);
-
-  // Cancel the timer operations associated with the given token. Returns the
-  // number of operations that have been posted or dispatched.
-  template <typename Time_Traits>
-  std::size_t cancel_timer(timer_queue<Time_Traits>& queue,
-      typename timer_queue<Time_Traits>::per_timer_data& timer,
-      std::size_t max_cancelled = (std::numeric_limits<std::size_t>::max)());
-
-  // Run the kqueue loop.
-  ASIO_DECL void run(bool block, op_queue<operation>& ops);
-
-  // Interrupt the kqueue loop.
-  ASIO_DECL void interrupt();
-
-private:
-  // Create the kqueue file descriptor. Throws an exception if the descriptor
-  // cannot be created.
-  ASIO_DECL static int do_kqueue_create();
-
-  // Allocate a new descriptor state object.
-  ASIO_DECL descriptor_state* allocate_descriptor_state();
-
-  // Free an existing descriptor state object.
-  ASIO_DECL void free_descriptor_state(descriptor_state* s);
-
-  // Helper function to add a new timer queue.
-  ASIO_DECL void do_add_timer_queue(timer_queue_base& queue);
-
-  // Helper function to remove a timer queue.
-  ASIO_DECL void do_remove_timer_queue(timer_queue_base& queue);
-
-  // Get the timeout value for the kevent call.
-  ASIO_DECL timespec* get_timeout(timespec& ts);
-
-  // The io_service implementation used to post completions.
-  io_service_impl& io_service_;
-
-  // Mutex to protect access to internal data.
-  mutex mutex_;
-
-  // The kqueue file descriptor.
-  int kqueue_fd_;
-
-  // The interrupter is used to break a blocking kevent call.
-  select_interrupter interrupter_;
-
-  // The timer queues.
-  timer_queue_set timer_queues_;
-
-  // Whether the service has been shut down.
-  bool shutdown_;
-
-  // Mutex to protect access to the registered descriptors.
-  mutex registered_descriptors_mutex_;
-
-  // Keep track of all registered descriptors.
-  object_pool<descriptor_state> registered_descriptors_;
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#include "asio/detail/impl/kqueue_reactor.hpp"
-#if defined(ASIO_HEADER_ONLY)
-# include "asio/detail/impl/kqueue_reactor.ipp"
-#endif // defined(ASIO_HEADER_ONLY)
-
-#endif // defined(ASIO_HAS_KQUEUE)
-
-#endif // ASIO_DETAIL_KQUEUE_REACTOR_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/limits.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/limits.hpp
deleted file mode 100644
index d32470d2d350..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/limits.hpp
+++ /dev/null
@@ -1,26 +0,0 @@
-//
-// detail/limits.hpp
-// ~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2011 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_LIMITS_HPP
-#define ASIO_DETAIL_LIMITS_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_HAS_BOOST_LIMITS)
-# include <boost/limits.hpp>
-#else // defined(ASIO_HAS_BOOST_LIMITS)
-# include <limits>
-#endif // defined(ASIO_HAS_BOOST_LIMITS)
-
-#endif // ASIO_DETAIL_LIMITS_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/local_free_on_block_exit.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/local_free_on_block_exit.hpp
deleted file mode 100644
index e6e899a33cc3..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/local_free_on_block_exit.hpp
+++ /dev/null
@@ -1,57 +0,0 @@
-//
-// detail/local_free_on_block_exit.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_LOCAL_FREE_ON_BLOCK_EXIT_HPP
-#define ASIO_DETAIL_LOCAL_FREE_ON_BLOCK_EXIT_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-
-#include "asio/detail/noncopyable.hpp"
-#include "asio/detail/socket_types.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-class local_free_on_block_exit
-  : private noncopyable
-{
-public:
-  // Constructor blocks all signals for the calling thread.
-  explicit local_free_on_block_exit(void* p)
-    : p_(p)
-  {
-  }
-
-  // Destructor restores the previous signal mask.
-  ~local_free_on_block_exit()
-  {
-    ::LocalFree(p_);
-  }
-
-private:
-  void* p_;
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-
-#endif // ASIO_DETAIL_LOCAL_FREE_ON_BLOCK_EXIT_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/macos_fenced_block.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/macos_fenced_block.hpp
deleted file mode 100644
index 1614dd500022..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/macos_fenced_block.hpp
+++ /dev/null
@@ -1,61 +0,0 @@
-//
-// detail/macos_fenced_block.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_MACOS_FENCED_BLOCK_HPP
-#define ASIO_DETAIL_MACOS_FENCED_BLOCK_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(__MACH__) && defined(__APPLE__)
-
-#include <libkern/OSAtomic.h>
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-class macos_fenced_block
-  : private noncopyable
-{
-public:
-  enum half_t { half };
-  enum full_t { full };
-
-  // Constructor for a half fenced block.
-  explicit macos_fenced_block(half_t)
-  {
-  }
-
-  // Constructor for a full fenced block.
-  explicit macos_fenced_block(full_t)
-  {
-    OSMemoryBarrier();
-  }
-
-  // Destructor.
-  ~macos_fenced_block()
-  {
-    OSMemoryBarrier();
-  }
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // defined(__MACH__) && defined(__APPLE__)
-
-#endif // ASIO_DETAIL_MACOS_FENCED_BLOCK_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/mutex.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/mutex.hpp
deleted file mode 100644
index be10a88c6675..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/mutex.hpp
+++ /dev/null
@@ -1,48 +0,0 @@
-//
-// detail/mutex.hpp
-// ~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_MUTEX_HPP
-#define ASIO_DETAIL_MUTEX_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if !defined(ASIO_HAS_THREADS)
-# include "asio/detail/null_mutex.hpp"
-#elif defined(ASIO_WINDOWS)
-# include "asio/detail/win_mutex.hpp"
-#elif defined(ASIO_HAS_PTHREADS)
-# include "asio/detail/posix_mutex.hpp"
-#elif defined(ASIO_HAS_STD_MUTEX_AND_CONDVAR)
-# include "asio/detail/std_mutex.hpp"
-#else
-# error Only Windows, POSIX and std::mutex are supported!
-#endif
-
-namespace asio {
-namespace detail {
-
-#if !defined(ASIO_HAS_THREADS)
-typedef null_mutex mutex;
-#elif defined(ASIO_WINDOWS)
-typedef win_mutex mutex;
-#elif defined(ASIO_HAS_PTHREADS)
-typedef posix_mutex mutex;
-#elif defined(ASIO_HAS_STD_MUTEX_AND_CONDVAR)
-typedef std_mutex mutex;
-#endif
-
-} // namespace detail
-} // namespace asio
-
-#endif // ASIO_DETAIL_MUTEX_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/noncopyable.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/noncopyable.hpp
deleted file mode 100644
index 23e991fc97e4..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/noncopyable.hpp
+++ /dev/null
@@ -1,43 +0,0 @@
-//
-// detail/noncopyable.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_NONCOPYABLE_HPP
-#define ASIO_DETAIL_NONCOPYABLE_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-class noncopyable
-{
-protected:
-  noncopyable() {}
-  ~noncopyable() {}
-private:
-  noncopyable(const noncopyable&);
-  const noncopyable& operator=(const noncopyable&);
-};
-
-} // namespace detail
-
-using asio::detail::noncopyable;
-
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_DETAIL_NONCOPYABLE_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/null_event.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/null_event.hpp
deleted file mode 100644
index 4470a1f9c8a6..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/null_event.hpp
+++ /dev/null
@@ -1,88 +0,0 @@
-//
-// detail/null_event.hpp
-// ~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_NULL_EVENT_HPP
-#define ASIO_DETAIL_NULL_EVENT_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if !defined(ASIO_HAS_THREADS)
-
-#include "asio/detail/noncopyable.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-class null_event
-  : private noncopyable
-{
-public:
-  // Constructor.
-  null_event()
-  {
-  }
-
-  // Destructor.
-  ~null_event()
-  {
-  }
-
-  // Signal the event. (Retained for backward compatibility.)
-  template <typename Lock>
-  void signal(Lock&)
-  {
-  }
-
-  // Signal all waiters.
-  template <typename Lock>
-  void signal_all(Lock&)
-  {
-  }
-
-  // Unlock the mutex and signal one waiter.
-  template <typename Lock>
-  void unlock_and_signal_one(Lock&)
-  {
-  }
-
-  // If there's a waiter, unlock the mutex and signal it.
-  template <typename Lock>
-  bool maybe_unlock_and_signal_one(Lock&)
-  {
-    return false;
-  }
-
-  // Reset the event.
-  template <typename Lock>
-  void clear(Lock&)
-  {
-  }
-
-  // Wait for the event to become signalled.
-  template <typename Lock>
-  void wait(Lock&)
-  {
-  }
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // !defined(ASIO_HAS_THREADS)
-
-#endif // ASIO_DETAIL_NULL_EVENT_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/null_fenced_block.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/null_fenced_block.hpp
deleted file mode 100644
index c17b000c601e..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/null_fenced_block.hpp
+++ /dev/null
@@ -1,45 +0,0 @@
-//
-// detail/null_fenced_block.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_NULL_FENCED_BLOCK_HPP
-#define ASIO_DETAIL_NULL_FENCED_BLOCK_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-class null_fenced_block
-  : private noncopyable
-{
-public:
-  enum half_or_full_t { half, full };
-
-  // Constructor.
-  explicit null_fenced_block(half_or_full_t)
-  {
-  }
-
-  // Destructor.
-  ~null_fenced_block()
-  {
-  }
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_DETAIL_NULL_FENCED_BLOCK_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/null_mutex.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/null_mutex.hpp
deleted file mode 100644
index bd356d8ec902..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/null_mutex.hpp
+++ /dev/null
@@ -1,64 +0,0 @@
-//
-// detail/null_mutex.hpp
-// ~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_NULL_MUTEX_HPP
-#define ASIO_DETAIL_NULL_MUTEX_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if !defined(ASIO_HAS_THREADS)
-
-#include "asio/detail/noncopyable.hpp"
-#include "asio/detail/scoped_lock.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-class null_mutex
-  : private noncopyable
-{
-public:
-  typedef asio::detail::scoped_lock<null_mutex> scoped_lock;
-
-  // Constructor.
-  null_mutex()
-  {
-  }
-
-  // Destructor.
-  ~null_mutex()
-  {
-  }
-
-  // Lock the mutex.
-  void lock()
-  {
-  }
-
-  // Unlock the mutex.
-  void unlock()
-  {
-  }
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // !defined(ASIO_HAS_THREADS)
-
-#endif // ASIO_DETAIL_NULL_MUTEX_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/null_reactor.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/null_reactor.hpp
deleted file mode 100644
index fa6b62327024..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/null_reactor.hpp
+++ /dev/null
@@ -1,67 +0,0 @@
-//
-// detail/null_reactor.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_NULL_REACTOR_HPP
-#define ASIO_DETAIL_NULL_REACTOR_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_WINDOWS_RUNTIME)
-
-#include "asio/io_service.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-class null_reactor
-  : public asio::detail::service_base<null_reactor>
-{
-public:
-  // Constructor.
-  null_reactor(asio::io_service& io_service)
-    : asio::detail::service_base<null_reactor>(io_service)
-  {
-  }
-
-  // Destructor.
-  ~null_reactor()
-  {
-  }
-
-  // Destroy all user-defined handler objects owned by the service.
-  void shutdown_service()
-  {
-  }
-
-  // No-op because should never be called.
-  void run(bool /*block*/, op_queue<operation>& /*ops*/)
-  {
-  }
-
-  // No-op.
-  void interrupt()
-  {
-  }
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // defined(ASIO_WINDOWS_RUNTIME)
-
-#endif // ASIO_DETAIL_NULL_REACTOR_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/null_signal_blocker.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/null_signal_blocker.hpp
deleted file mode 100644
index cd813c8b7d5a..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/null_signal_blocker.hpp
+++ /dev/null
@@ -1,69 +0,0 @@
-//
-// detail/null_signal_blocker.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_NULL_SIGNAL_BLOCKER_HPP
-#define ASIO_DETAIL_NULL_SIGNAL_BLOCKER_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if !defined(ASIO_HAS_THREADS) \
-  || defined(ASIO_WINDOWS) \
-  || defined(ASIO_WINDOWS_RUNTIME) \
-  || defined(__CYGWIN__) \
-  || defined(__SYMBIAN32__)
-
-#include "asio/detail/noncopyable.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-class null_signal_blocker
-  : private noncopyable
-{
-public:
-  // Constructor blocks all signals for the calling thread.
-  null_signal_blocker()
-  {
-  }
-
-  // Destructor restores the previous signal mask.
-  ~null_signal_blocker()
-  {
-  }
-
-  // Block all signals for the calling thread.
-  void block()
-  {
-  }
-
-  // Restore the previous signal mask.
-  void unblock()
-  {
-  }
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // !defined(ASIO_HAS_THREADS)
-       // || defined(ASIO_WINDOWS)
-       // || defined(ASIO_WINDOWS_RUNTIME)
-       // || defined(__CYGWIN__)
-       // || defined(__SYMBIAN32__)
-
-#endif // ASIO_DETAIL_NULL_SIGNAL_BLOCKER_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/null_socket_service.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/null_socket_service.hpp
deleted file mode 100644
index 255a26d6d454..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/null_socket_service.hpp
+++ /dev/null
@@ -1,497 +0,0 @@
-//
-// detail/null_socket_service.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_NULL_SOCKET_SERVICE_HPP
-#define ASIO_DETAIL_NULL_SOCKET_SERVICE_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_WINDOWS_RUNTIME)
-
-#include "asio/buffer.hpp"
-#include "asio/error.hpp"
-#include "asio/io_service.hpp"
-#include "asio/socket_base.hpp"
-#include "asio/detail/bind_handler.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-template <typename Protocol>
-class null_socket_service
-{
-public:
-  // The protocol type.
-  typedef Protocol protocol_type;
-
-  // The endpoint type.
-  typedef typename Protocol::endpoint endpoint_type;
-
-  // The native type of a socket.
-  typedef int native_handle_type;
-
-  // The implementation type of the socket.
-  struct implementation_type
-  {
-  };
-
-  // Constructor.
-  null_socket_service(asio::io_service& io_service)
-    : io_service_(io_service)
-  {
-  }
-
-  // Destroy all user-defined handler objects owned by the service.
-  void shutdown_service()
-  {
-  }
-
-  // Construct a new socket implementation.
-  void construct(implementation_type&)
-  {
-  }
-
-  // Move-construct a new socket implementation.
-  void move_construct(implementation_type&, implementation_type&)
-  {
-  }
-
-  // Move-assign from another socket implementation.
-  void move_assign(implementation_type&,
-      null_socket_service&, implementation_type&)
-  {
-  }
-
-  // Move-construct a new socket implementation from another protocol type.
-  template <typename Protocol1>
-  void converting_move_construct(implementation_type&,
-      typename null_socket_service<Protocol1>::implementation_type&)
-  {
-  }
-
-  // Destroy a socket implementation.
-  void destroy(implementation_type&)
-  {
-  }
-
-  // Open a new socket implementation.
-  asio::error_code open(implementation_type&,
-      const protocol_type&, asio::error_code& ec)
-  {
-    ec = asio::error::operation_not_supported;
-    return ec;
-  }
-
-  // Assign a native socket to a socket implementation.
-  asio::error_code assign(implementation_type&, const protocol_type&,
-      const native_handle_type&, asio::error_code& ec)
-  {
-    ec = asio::error::operation_not_supported;
-    return ec;
-  }
-
-  // Determine whether the socket is open.
-  bool is_open(const implementation_type&) const
-  {
-    return false;
-  }
-
-  // Destroy a socket implementation.
-  asio::error_code close(implementation_type&,
-      asio::error_code& ec)
-  {
-    ec = asio::error::operation_not_supported;
-    return ec;
-  }
-
-  // Get the native socket representation.
-  native_handle_type native_handle(implementation_type&)
-  {
-    return 0;
-  }
-
-  // Cancel all operations associated with the socket.
-  asio::error_code cancel(implementation_type&,
-      asio::error_code& ec)
-  {
-    ec = asio::error::operation_not_supported;
-    return ec;
-  }
-
-  // Determine whether the socket is at the out-of-band data mark.
-  bool at_mark(const implementation_type&,
-      asio::error_code& ec) const
-  {
-    ec = asio::error::operation_not_supported;
-    return false;
-  }
-
-  // Determine the number of bytes available for reading.
-  std::size_t available(const implementation_type&,
-      asio::error_code& ec) const
-  {
-    ec = asio::error::operation_not_supported;
-    return 0;
-  }
-
-  // Place the socket into the state where it will listen for new connections.
-  asio::error_code listen(implementation_type&,
-      int, asio::error_code& ec)
-  {
-    ec = asio::error::operation_not_supported;
-    return ec;
-  }
-
-  // Perform an IO control command on the socket.
-  template <typename IO_Control_Command>
-  asio::error_code io_control(implementation_type&,
-      IO_Control_Command&, asio::error_code& ec)
-  {
-    ec = asio::error::operation_not_supported;
-    return ec;
-  }
-
-  // Gets the non-blocking mode of the socket.
-  bool non_blocking(const implementation_type&) const
-  {
-    return false;
-  }
-
-  // Sets the non-blocking mode of the socket.
-  asio::error_code non_blocking(implementation_type&,
-      bool, asio::error_code& ec)
-  {
-    ec = asio::error::operation_not_supported;
-    return ec;
-  }
-
-  // Gets the non-blocking mode of the native socket implementation.
-  bool native_non_blocking(const implementation_type&) const
-  {
-    return false;
-  }
-
-  // Sets the non-blocking mode of the native socket implementation.
-  asio::error_code native_non_blocking(implementation_type&,
-      bool, asio::error_code& ec)
-  {
-    ec = asio::error::operation_not_supported;
-    return ec;
-  }
-
-  // Disable sends or receives on the socket.
-  asio::error_code shutdown(implementation_type&,
-      socket_base::shutdown_type, asio::error_code& ec)
-  {
-    ec = asio::error::operation_not_supported;
-    return ec;
-  }
-
-  // Bind the socket to the specified local endpoint.
-  asio::error_code bind(implementation_type&,
-      const endpoint_type&, asio::error_code& ec)
-  {
-    ec = asio::error::operation_not_supported;
-    return ec;
-  }
-
-  // Set a socket option.
-  template <typename Option>
-  asio::error_code set_option(implementation_type&,
-      const Option&, asio::error_code& ec)
-  {
-    ec = asio::error::operation_not_supported;
-    return ec;
-  }
-
-  // Set a socket option.
-  template <typename Option>
-  asio::error_code get_option(const implementation_type&,
-      Option&, asio::error_code& ec) const
-  {
-    ec = asio::error::operation_not_supported;
-    return ec;
-  }
-
-  // Get the local endpoint.
-  endpoint_type local_endpoint(const implementation_type&,
-      asio::error_code& ec) const
-  {
-    ec = asio::error::operation_not_supported;
-    return endpoint_type();
-  }
-
-  // Get the remote endpoint.
-  endpoint_type remote_endpoint(const implementation_type&,
-      asio::error_code& ec) const
-  {
-    ec = asio::error::operation_not_supported;
-    return endpoint_type();
-  }
-
-  // Send the given data to the peer.
-  template <typename ConstBufferSequence>
-  std::size_t send(implementation_type&, const ConstBufferSequence&,
-      socket_base::message_flags, asio::error_code& ec)
-  {
-    ec = asio::error::operation_not_supported;
-    return 0;
-  }
-
-  // Wait until data can be sent without blocking.
-  std::size_t send(implementation_type&, const null_buffers&,
-      socket_base::message_flags, asio::error_code& ec)
-  {
-    ec = asio::error::operation_not_supported;
-    return 0;
-  }
-
-  // Start an asynchronous send. The data being sent must be valid for the
-  // lifetime of the asynchronous operation.
-  template <typename ConstBufferSequence, typename Handler>
-  void async_send(implementation_type&, const ConstBufferSequence&,
-      socket_base::message_flags, Handler& handler)
-  {
-    asio::error_code ec = asio::error::operation_not_supported;
-    const std::size_t bytes_transferred = 0;
-    io_service_.post(detail::bind_handler(handler, ec, bytes_transferred));
-  }
-
-  // Start an asynchronous wait until data can be sent without blocking.
-  template <typename Handler>
-  void async_send(implementation_type&, const null_buffers&,
-      socket_base::message_flags, Handler& handler)
-  {
-    asio::error_code ec = asio::error::operation_not_supported;
-    const std::size_t bytes_transferred = 0;
-    io_service_.post(detail::bind_handler(handler, ec, bytes_transferred));
-  }
-
-  // Receive some data from the peer. Returns the number of bytes received.
-  template <typename MutableBufferSequence>
-  std::size_t receive(implementation_type&, const MutableBufferSequence&,
-      socket_base::message_flags, asio::error_code& ec)
-  {
-    ec = asio::error::operation_not_supported;
-    return 0;
-  }
-
-  // Wait until data can be received without blocking.
-  std::size_t receive(implementation_type&, const null_buffers&,
-      socket_base::message_flags, asio::error_code& ec)
-  {
-    ec = asio::error::operation_not_supported;
-    return 0;
-  }
-
-  // Start an asynchronous receive. The buffer for the data being received
-  // must be valid for the lifetime of the asynchronous operation.
-  template <typename MutableBufferSequence, typename Handler>
-  void async_receive(implementation_type&, const MutableBufferSequence&,
-      socket_base::message_flags, Handler& handler)
-  {
-    asio::error_code ec = asio::error::operation_not_supported;
-    const std::size_t bytes_transferred = 0;
-    io_service_.post(detail::bind_handler(handler, ec, bytes_transferred));
-  }
-
-  // Wait until data can be received without blocking.
-  template <typename Handler>
-  void async_receive(implementation_type&, const null_buffers&,
-      socket_base::message_flags, Handler& handler)
-  {
-    asio::error_code ec = asio::error::operation_not_supported;
-    const std::size_t bytes_transferred = 0;
-    io_service_.post(detail::bind_handler(handler, ec, bytes_transferred));
-  }
-
-  // Receive some data with associated flags. Returns the number of bytes
-  // received.
-  template <typename MutableBufferSequence>
-  std::size_t receive_with_flags(implementation_type&,
-      const MutableBufferSequence&, socket_base::message_flags,
-      socket_base::message_flags&, asio::error_code& ec)
-  {
-    ec = asio::error::operation_not_supported;
-    return 0;
-  }
-
-  // Wait until data can be received without blocking.
-  std::size_t receive_with_flags(implementation_type&,
-      const null_buffers&, socket_base::message_flags,
-      socket_base::message_flags&, asio::error_code& ec)
-  {
-    ec = asio::error::operation_not_supported;
-    return 0;
-  }
-
-  // Start an asynchronous receive. The buffer for the data being received
-  // must be valid for the lifetime of the asynchronous operation.
-  template <typename MutableBufferSequence, typename Handler>
-  void async_receive_with_flags(implementation_type&,
-      const MutableBufferSequence&, socket_base::message_flags,
-      socket_base::message_flags&, Handler& handler)
-  {
-    asio::error_code ec = asio::error::operation_not_supported;
-    const std::size_t bytes_transferred = 0;
-    io_service_.post(detail::bind_handler(handler, ec, bytes_transferred));
-  }
-
-  // Wait until data can be received without blocking.
-  template <typename Handler>
-  void async_receive_with_flags(implementation_type&,
-      const null_buffers&, socket_base::message_flags,
-      socket_base::message_flags&, Handler& handler)
-  {
-    asio::error_code ec = asio::error::operation_not_supported;
-    const std::size_t bytes_transferred = 0;
-    io_service_.post(detail::bind_handler(handler, ec, bytes_transferred));
-  }
-
-  // Send a datagram to the specified endpoint. Returns the number of bytes
-  // sent.
-  template <typename ConstBufferSequence>
-  std::size_t send_to(implementation_type&, const ConstBufferSequence&,
-      const endpoint_type&, socket_base::message_flags,
-      asio::error_code& ec)
-  {
-    ec = asio::error::operation_not_supported;
-    return 0;
-  }
-
-  // Wait until data can be sent without blocking.
-  std::size_t send_to(implementation_type&, const null_buffers&,
-      const endpoint_type&, socket_base::message_flags,
-      asio::error_code& ec)
-  {
-    ec = asio::error::operation_not_supported;
-    return 0;
-  }
-
-  // Start an asynchronous send. The data being sent must be valid for the
-  // lifetime of the asynchronous operation.
-  template <typename ConstBufferSequence, typename Handler>
-  void async_send_to(implementation_type&, const ConstBufferSequence&,
-      const endpoint_type&, socket_base::message_flags,
-      Handler& handler)
-  {
-    asio::error_code ec = asio::error::operation_not_supported;
-    const std::size_t bytes_transferred = 0;
-    io_service_.post(detail::bind_handler(handler, ec, bytes_transferred));
-  }
-
-  // Start an asynchronous wait until data can be sent without blocking.
-  template <typename Handler>
-  void async_send_to(implementation_type&, const null_buffers&,
-      const endpoint_type&, socket_base::message_flags, Handler& handler)
-  {
-    asio::error_code ec = asio::error::operation_not_supported;
-    const std::size_t bytes_transferred = 0;
-    io_service_.post(detail::bind_handler(handler, ec, bytes_transferred));
-  }
-
-  // Receive a datagram with the endpoint of the sender. Returns the number of
-  // bytes received.
-  template <typename MutableBufferSequence>
-  std::size_t receive_from(implementation_type&, const MutableBufferSequence&,
-      endpoint_type&, socket_base::message_flags,
-      asio::error_code& ec)
-  {
-    ec = asio::error::operation_not_supported;
-    return 0;
-  }
-
-  // Wait until data can be received without blocking.
-  std::size_t receive_from(implementation_type&, const null_buffers&,
-      endpoint_type&, socket_base::message_flags,
-      asio::error_code& ec)
-  {
-    ec = asio::error::operation_not_supported;
-    return 0;
-  }
-
-  // Start an asynchronous receive. The buffer for the data being received and
-  // the sender_endpoint object must both be valid for the lifetime of the
-  // asynchronous operation.
-  template <typename MutableBufferSequence, typename Handler>
-  void async_receive_from(implementation_type&,
-      const MutableBufferSequence&, endpoint_type&,
-      socket_base::message_flags, Handler& handler)
-  {
-    asio::error_code ec = asio::error::operation_not_supported;
-    const std::size_t bytes_transferred = 0;
-    io_service_.post(detail::bind_handler(handler, ec, bytes_transferred));
-  }
-
-  // Wait until data can be received without blocking.
-  template <typename Handler>
-  void async_receive_from(implementation_type&,
-      const null_buffers&, endpoint_type&,
-      socket_base::message_flags, Handler& handler)
-  {
-    asio::error_code ec = asio::error::operation_not_supported;
-    const std::size_t bytes_transferred = 0;
-    io_service_.post(detail::bind_handler(handler, ec, bytes_transferred));
-  }
-
-  // Accept a new connection.
-  template <typename Socket>
-  asio::error_code accept(implementation_type&,
-      Socket&, endpoint_type*, asio::error_code& ec)
-  {
-    ec = asio::error::operation_not_supported;
-    return ec;
-  }
-
-  // Start an asynchronous accept. The peer and peer_endpoint objects
-  // must be valid until the accept's handler is invoked.
-  template <typename Socket, typename Handler>
-  void async_accept(implementation_type&, Socket&,
-      endpoint_type*, Handler& handler)
-  {
-    asio::error_code ec = asio::error::operation_not_supported;
-    io_service_.post(detail::bind_handler(handler, ec));
-  }
-
-  // Connect the socket to the specified endpoint.
-  asio::error_code connect(implementation_type&,
-      const endpoint_type&, asio::error_code& ec)
-  {
-    ec = asio::error::operation_not_supported;
-    return ec;
-  }
-
-  // Start an asynchronous connect.
-  template <typename Handler>
-  void async_connect(implementation_type&,
-      const endpoint_type&, Handler& handler)
-  {
-    asio::error_code ec = asio::error::operation_not_supported;
-    io_service_.post(detail::bind_handler(handler, ec));
-  }
-
-private:
-  asio::io_service& io_service_;
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // defined(ASIO_WINDOWS_RUNTIME)
-
-#endif // ASIO_DETAIL_NULL_SOCKET_SERVICE_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/null_static_mutex.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/null_static_mutex.hpp
deleted file mode 100644
index d777091f44ae..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/null_static_mutex.hpp
+++ /dev/null
@@ -1,60 +0,0 @@
-//
-// detail/null_static_mutex.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_NULL_STATIC_MUTEX_HPP
-#define ASIO_DETAIL_NULL_STATIC_MUTEX_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if !defined(ASIO_HAS_THREADS)
-
-#include "asio/detail/scoped_lock.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-struct null_static_mutex
-{
-  typedef asio::detail::scoped_lock<null_static_mutex> scoped_lock;
-
-  // Initialise the mutex.
-  void init()
-  {
-  }
-
-  // Lock the mutex.
-  void lock()
-  {
-  }
-
-  // Unlock the mutex.
-  void unlock()
-  {
-  }
-
-  int unused_;
-};
-
-#define ASIO_NULL_STATIC_MUTEX_INIT { 0 }
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // !defined(ASIO_HAS_THREADS)
-
-#endif // ASIO_DETAIL_NULL_STATIC_MUTEX_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/null_thread.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/null_thread.hpp
deleted file mode 100644
index 8c058ef0e51d..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/null_thread.hpp
+++ /dev/null
@@ -1,61 +0,0 @@
-//
-// detail/null_thread.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_NULL_THREAD_HPP
-#define ASIO_DETAIL_NULL_THREAD_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if !defined(ASIO_HAS_THREADS)
-
-#include "asio/detail/noncopyable.hpp"
-#include "asio/detail/throw_error.hpp"
-#include "asio/error.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-class null_thread
-  : private noncopyable
-{
-public:
-  // Constructor.
-  template <typename Function>
-  null_thread(Function, unsigned int = 0)
-  {
-    asio::detail::throw_error(
-        asio::error::operation_not_supported, "thread");
-  }
-
-  // Destructor.
-  ~null_thread()
-  {
-  }
-
-  // Wait for the thread to exit.
-  void join()
-  {
-  }
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // !defined(ASIO_HAS_THREADS)
-
-#endif // ASIO_DETAIL_NULL_THREAD_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/null_tss_ptr.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/null_tss_ptr.hpp
deleted file mode 100644
index 0c385cb70738..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/null_tss_ptr.hpp
+++ /dev/null
@@ -1,68 +0,0 @@
-//
-// detail/null_tss_ptr.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_NULL_TSS_PTR_HPP
-#define ASIO_DETAIL_NULL_TSS_PTR_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if !defined(ASIO_HAS_THREADS)
-
-#include "asio/detail/noncopyable.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-template <typename T>
-class null_tss_ptr
-  : private noncopyable
-{
-public:
-  // Constructor.
-  null_tss_ptr()
-    : value_(0)
-  {
-  }
-
-  // Destructor.
-  ~null_tss_ptr()
-  {
-  }
-
-  // Get the value.
-  operator T*() const
-  {
-    return value_;
-  }
-
-  // Set the value.
-  void operator=(T* value)
-  {
-    value_ = value;
-  }
-
-private:
-  T* value_;
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // !defined(ASIO_HAS_THREADS)
-
-#endif // ASIO_DETAIL_NULL_TSS_PTR_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/object_pool.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/object_pool.hpp
deleted file mode 100644
index c5bf8f737aaa..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/object_pool.hpp
+++ /dev/null
@@ -1,146 +0,0 @@
-//
-// detail/object_pool.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_OBJECT_POOL_HPP
-#define ASIO_DETAIL_OBJECT_POOL_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/noncopyable.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-template <typename Object>
-class object_pool;
-
-class object_pool_access
-{
-public:
-  template <typename Object>
-  static Object* create()
-  {
-    return new Object;
-  }
-
-  template <typename Object>
-  static void destroy(Object* o)
-  {
-    delete o;
-  }
-
-  template <typename Object>
-  static Object*& next(Object* o)
-  {
-    return o->next_;
-  }
-
-  template <typename Object>
-  static Object*& prev(Object* o)
-  {
-    return o->prev_;
-  }
-};
-
-template <typename Object>
-class object_pool
-  : private noncopyable
-{
-public:
-  // Constructor.
-  object_pool()
-    : live_list_(0),
-      free_list_(0)
-  {
-  }
-
-  // Destructor destroys all objects.
-  ~object_pool()
-  {
-    destroy_list(live_list_);
-    destroy_list(free_list_);
-  }
-
-  // Get the object at the start of the live list.
-  Object* first()
-  {
-    return live_list_;
-  }
-
-  // Allocate a new object.
-  Object* alloc()
-  {
-    Object* o = free_list_;
-    if (o)
-      free_list_ = object_pool_access::next(free_list_);
-    else
-      o = object_pool_access::create<Object>();
-
-    object_pool_access::next(o) = live_list_;
-    object_pool_access::prev(o) = 0;
-    if (live_list_)
-      object_pool_access::prev(live_list_) = o;
-    live_list_ = o;
-
-    return o;
-  }
-
-  // Free an object. Moves it to the free list. No destructors are run.
-  void free(Object* o)
-  {
-    if (live_list_ == o)
-      live_list_ = object_pool_access::next(o);
-
-    if (object_pool_access::prev(o))
-    {
-      object_pool_access::next(object_pool_access::prev(o))
-        = object_pool_access::next(o);
-    }
-
-    if (object_pool_access::next(o))
-    {
-      object_pool_access::prev(object_pool_access::next(o))
-        = object_pool_access::prev(o);
-    }
-
-    object_pool_access::next(o) = free_list_;
-    object_pool_access::prev(o) = 0;
-    free_list_ = o;
-  }
-
-private:
-  // Helper function to destroy all elements in a list.
-  void destroy_list(Object* list)
-  {
-    while (list)
-    {
-      Object* o = list;
-      list = object_pool_access::next(o);
-      object_pool_access::destroy(o);
-    }
-  }
-
-  // The list of live objects.
-  Object* live_list_;
-
-  // The free list.
-  Object* free_list_;
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_DETAIL_OBJECT_POOL_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/old_win_sdk_compat.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/old_win_sdk_compat.hpp
deleted file mode 100644
index af673ea1ff33..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/old_win_sdk_compat.hpp
+++ /dev/null
@@ -1,214 +0,0 @@
-//
-// detail/old_win_sdk_compat.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_OLD_WIN_SDK_COMPAT_HPP
-#define ASIO_DETAIL_OLD_WIN_SDK_COMPAT_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-
-// Guess whether we are building against on old Platform SDK.
-#if !defined(IN6ADDR_ANY_INIT)
-#define ASIO_HAS_OLD_WIN_SDK 1
-#endif // !defined(IN6ADDR_ANY_INIT)
-
-#if defined(ASIO_HAS_OLD_WIN_SDK)
-
-// Emulation of types that are missing from old Platform SDKs.
-//
-// N.B. this emulation is also used if building for a Windows 2000 target with
-// a recent (i.e. Vista or later) SDK, as the SDK does not provide IPv6 support
-// in that case.
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-enum
-{
-  sockaddr_storage_maxsize = 128, // Maximum size.
-  sockaddr_storage_alignsize = (sizeof(__int64)), // Desired alignment.
-  sockaddr_storage_pad1size = (sockaddr_storage_alignsize - sizeof(short)),
-  sockaddr_storage_pad2size = (sockaddr_storage_maxsize -
-      (sizeof(short) + sockaddr_storage_pad1size + sockaddr_storage_alignsize))
-};
-
-struct sockaddr_storage_emulation
-{
-  short ss_family;
-  char __ss_pad1[sockaddr_storage_pad1size];
-  __int64 __ss_align;
-  char __ss_pad2[sockaddr_storage_pad2size];
-};
-
-struct in6_addr_emulation
-{
-  union
-  {
-    u_char Byte[16];
-    u_short Word[8];
-  } u;
-};
-
-#if !defined(s6_addr)
-# define _S6_un u
-# define _S6_u8 Byte
-# define s6_addr _S6_un._S6_u8
-#endif // !defined(s6_addr)
-
-struct sockaddr_in6_emulation
-{
-  short sin6_family;
-  u_short sin6_port;
-  u_long sin6_flowinfo;
-  in6_addr_emulation sin6_addr;
-  u_long sin6_scope_id;
-};
-
-struct ipv6_mreq_emulation
-{
-  in6_addr_emulation ipv6mr_multiaddr;
-  unsigned int ipv6mr_interface;
-};
-
-struct addrinfo_emulation
-{
-  int ai_flags;
-  int ai_family;
-  int ai_socktype;
-  int ai_protocol;
-  size_t ai_addrlen;
-  char* ai_canonname;
-  sockaddr* ai_addr;
-  addrinfo_emulation* ai_next;
-};
-
-#if !defined(AI_PASSIVE)
-# define AI_PASSIVE 0x1
-#endif
-
-#if !defined(AI_CANONNAME)
-# define AI_CANONNAME 0x2
-#endif
-
-#if !defined(AI_NUMERICHOST)
-# define AI_NUMERICHOST 0x4
-#endif
-
-#if !defined(EAI_AGAIN)
-# define EAI_AGAIN WSATRY_AGAIN
-#endif
-
-#if !defined(EAI_BADFLAGS)
-# define EAI_BADFLAGS WSAEINVAL
-#endif
-
-#if !defined(EAI_FAIL)
-# define EAI_FAIL WSANO_RECOVERY
-#endif
-
-#if !defined(EAI_FAMILY)
-# define EAI_FAMILY WSAEAFNOSUPPORT
-#endif
-
-#if !defined(EAI_MEMORY)
-# define EAI_MEMORY WSA_NOT_ENOUGH_MEMORY
-#endif
-
-#if !defined(EAI_NODATA)
-# define EAI_NODATA WSANO_DATA
-#endif
-
-#if !defined(EAI_NONAME)
-# define EAI_NONAME WSAHOST_NOT_FOUND
-#endif
-
-#if !defined(EAI_SERVICE)
-# define EAI_SERVICE WSATYPE_NOT_FOUND
-#endif
-
-#if !defined(EAI_SOCKTYPE)
-# define EAI_SOCKTYPE WSAESOCKTNOSUPPORT
-#endif
-
-#if !defined(NI_NOFQDN)
-# define NI_NOFQDN 0x01
-#endif
-
-#if !defined(NI_NUMERICHOST)
-# define NI_NUMERICHOST 0x02
-#endif
-
-#if !defined(NI_NAMEREQD)
-# define NI_NAMEREQD 0x04
-#endif
-
-#if !defined(NI_NUMERICSERV)
-# define NI_NUMERICSERV 0x08
-#endif
-
-#if !defined(NI_DGRAM)
-# define NI_DGRAM 0x10
-#endif
-
-#if !defined(IPPROTO_IPV6)
-# define IPPROTO_IPV6 41
-#endif
-
-#if !defined(IPV6_UNICAST_HOPS)
-# define IPV6_UNICAST_HOPS 4
-#endif
-
-#if !defined(IPV6_MULTICAST_IF)
-# define IPV6_MULTICAST_IF 9
-#endif
-
-#if !defined(IPV6_MULTICAST_HOPS)
-# define IPV6_MULTICAST_HOPS 10
-#endif
-
-#if !defined(IPV6_MULTICAST_LOOP)
-# define IPV6_MULTICAST_LOOP 11
-#endif
-
-#if !defined(IPV6_JOIN_GROUP)
-# define IPV6_JOIN_GROUP 12
-#endif
-
-#if !defined(IPV6_LEAVE_GROUP)
-# define IPV6_LEAVE_GROUP 13
-#endif
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // defined(ASIO_HAS_OLD_WIN_SDK)
-
-// Even newer Platform SDKs that support IPv6 may not define IPV6_V6ONLY.
-#if !defined(IPV6_V6ONLY)
-# define IPV6_V6ONLY 27
-#endif
-
-// Some SDKs (e.g. Windows CE) don't define IPPROTO_ICMPV6.
-#if !defined(IPPROTO_ICMPV6)
-# define IPPROTO_ICMPV6 58
-#endif
-
-#endif // defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-
-#endif // ASIO_DETAIL_OLD_WIN_SDK_COMPAT_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/op_queue.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/op_queue.hpp
deleted file mode 100644
index a57789688efc..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/op_queue.hpp
+++ /dev/null
@@ -1,156 +0,0 @@
-//
-// detail/op_queue.hpp
-// ~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_OP_QUEUE_HPP
-#define ASIO_DETAIL_OP_QUEUE_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/noncopyable.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-template <typename Operation>
-class op_queue;
-
-class op_queue_access
-{
-public:
-  template <typename Operation>
-  static Operation* next(Operation* o)
-  {
-    return static_cast<Operation*>(o->next_);
-  }
-
-  template <typename Operation1, typename Operation2>
-  static void next(Operation1*& o1, Operation2* o2)
-  {
-    o1->next_ = o2;
-  }
-
-  template <typename Operation>
-  static void destroy(Operation* o)
-  {
-    o->destroy();
-  }
-
-  template <typename Operation>
-  static Operation*& front(op_queue<Operation>& q)
-  {
-    return q.front_;
-  }
-
-  template <typename Operation>
-  static Operation*& back(op_queue<Operation>& q)
-  {
-    return q.back_;
-  }
-};
-
-template <typename Operation>
-class op_queue
-  : private noncopyable
-{
-public:
-  // Constructor.
-  op_queue()
-    : front_(0),
-      back_(0)
-  {
-  }
-
-  // Destructor destroys all operations.
-  ~op_queue()
-  {
-    while (Operation* op = front_)
-    {
-      pop();
-      op_queue_access::destroy(op);
-    }
-  }
-
-  // Get the operation at the front of the queue.
-  Operation* front()
-  {
-    return front_;
-  }
-
-  // Pop an operation from the front of the queue.
-  void pop()
-  {
-    if (front_)
-    {
-      Operation* tmp = front_;
-      front_ = op_queue_access::next(front_);
-      if (front_ == 0)
-        back_ = 0;
-      op_queue_access::next(tmp, static_cast<Operation*>(0));
-    }
-  }
-
-  // Push an operation on to the back of the queue.
-  void push(Operation* h)
-  {
-    op_queue_access::next(h, static_cast<Operation*>(0));
-    if (back_)
-    {
-      op_queue_access::next(back_, h);
-      back_ = h;
-    }
-    else
-    {
-      front_ = back_ = h;
-    }
-  }
-
-  // Push all operations from another queue on to the back of the queue. The
-  // source queue may contain operations of a derived type.
-  template <typename OtherOperation>
-  void push(op_queue<OtherOperation>& q)
-  {
-    if (Operation* other_front = op_queue_access::front(q))
-    {
-      if (back_)
-        op_queue_access::next(back_, other_front);
-      else
-        front_ = other_front;
-      back_ = op_queue_access::back(q);
-      op_queue_access::front(q) = 0;
-      op_queue_access::back(q) = 0;
-    }
-  }
-
-  // Whether the queue is empty.
-  bool empty() const
-  {
-    return front_ == 0;
-  }
-
-private:
-  friend class op_queue_access;
-
-  // The front of the queue.
-  Operation* front_;
-
-  // The back of the queue.
-  Operation* back_;
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_DETAIL_OP_QUEUE_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/operation.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/operation.hpp
deleted file mode 100644
index ce0d6a61d315..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/operation.hpp
+++ /dev/null
@@ -1,38 +0,0 @@
-//
-// detail/operation.hpp
-// ~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_OPERATION_HPP
-#define ASIO_DETAIL_OPERATION_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_HAS_IOCP)
-# include "asio/detail/win_iocp_operation.hpp"
-#else
-# include "asio/detail/task_io_service_operation.hpp"
-#endif
-
-namespace asio {
-namespace detail {
-
-#if defined(ASIO_HAS_IOCP)
-typedef win_iocp_operation operation;
-#else
-typedef task_io_service_operation operation;
-#endif
-
-} // namespace detail
-} // namespace asio
-
-#endif // ASIO_DETAIL_OPERATION_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/pipe_select_interrupter.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/pipe_select_interrupter.hpp
deleted file mode 100644
index d9c224288c31..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/pipe_select_interrupter.hpp
+++ /dev/null
@@ -1,89 +0,0 @@
-//
-// detail/pipe_select_interrupter.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_PIPE_SELECT_INTERRUPTER_HPP
-#define ASIO_DETAIL_PIPE_SELECT_INTERRUPTER_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if !defined(ASIO_WINDOWS)
-#if !defined(ASIO_WINDOWS_RUNTIME)
-#if !defined(__CYGWIN__)
-#if !defined(__SYMBIAN32__)
-#if !defined(ASIO_HAS_EVENTFD)
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-class pipe_select_interrupter
-{
-public:
-  // Constructor.
-  ASIO_DECL pipe_select_interrupter();
-
-  // Destructor.
-  ASIO_DECL ~pipe_select_interrupter();
-
-  // Recreate the interrupter's descriptors. Used after a fork.
-  ASIO_DECL void recreate();
-
-  // Interrupt the select call.
-  ASIO_DECL void interrupt();
-
-  // Reset the select interrupt. Returns true if the call was interrupted.
-  ASIO_DECL bool reset();
-
-  // Get the read descriptor to be passed to select.
-  int read_descriptor() const
-  {
-    return read_descriptor_;
-  }
-
-private:
-  // Open the descriptors. Throws on error.
-  ASIO_DECL void open_descriptors();
-
-  // Close the descriptors.
-  ASIO_DECL void close_descriptors();
-
-  // The read end of a connection used to interrupt the select call. This file
-  // descriptor is passed to select such that when it is time to stop, a single
-  // byte will be written on the other end of the connection and this
-  // descriptor will become readable.
-  int read_descriptor_;
-
-  // The write end of a connection used to interrupt the select call. A single
-  // byte may be written to this to wake up the select which is waiting for the
-  // other end to become readable.
-  int write_descriptor_;
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#if defined(ASIO_HEADER_ONLY)
-# include "asio/detail/impl/pipe_select_interrupter.ipp"
-#endif // defined(ASIO_HEADER_ONLY)
-
-#endif // !defined(ASIO_HAS_EVENTFD)
-#endif // !defined(__SYMBIAN32__)
-#endif // !defined(__CYGWIN__)
-#endif // !defined(ASIO_WINDOWS_RUNTIME)
-#endif // !defined(ASIO_WINDOWS)
-
-#endif // ASIO_DETAIL_PIPE_SELECT_INTERRUPTER_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/pop_options.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/pop_options.hpp
deleted file mode 100644
index acc586364305..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/pop_options.hpp
+++ /dev/null
@@ -1,105 +0,0 @@
-//
-// detail/pop_options.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-// No header guard
-
-#if defined(__COMO__)
-
-// Comeau C++
-
-#elif defined(__DMC__)
-
-// Digital Mars C++
-
-#elif defined(__INTEL_COMPILER) || defined(__ICL) \
-  || defined(__ICC) || defined(__ECC)
-
-// Intel C++
-
-#elif defined(__GNUC__)
-
-// GNU C++
-
-# if defined(__MINGW32__) || defined(__CYGWIN__)
-#  pragma pack (pop)
-# endif
-
-# if defined(__OBJC__)
-#  if !defined(__APPLE_CC__) || (__APPLE_CC__ <= 1)
-#   if defined(ASIO_OBJC_WORKAROUND)
-#    undef Protocol
-#    undef id
-#    undef ASIO_OBJC_WORKAROUND
-#   endif
-#  endif
-# endif
-
-#elif defined(__KCC)
-
-// Kai C++
-
-#elif defined(__sgi)
-
-// SGI MIPSpro C++
-
-#elif defined(__DECCXX)
-
-// Compaq Tru64 Unix cxx
-
-#elif defined(__ghs)
-
-// Greenhills C++
-
-#elif defined(__BORLANDC__)
-
-// Borland C++
-
-# pragma option pop
-# pragma nopushoptwarn
-# pragma nopackwarning
-
-#elif defined(__MWERKS__)
-
-// Metrowerks CodeWarrior
-
-#elif defined(__SUNPRO_CC)
-
-// Sun Workshop Compiler C++
-
-#elif defined(__HP_aCC)
-
-// HP aCC
-
-#elif defined(__MRC__) || defined(__SC__)
-
-// MPW MrCpp or SCpp
-
-#elif defined(__IBMCPP__)
-
-// IBM Visual Age
-
-#elif defined(_MSC_VER)
-
-// Microsoft Visual C++
-//
-// Must remain the last #elif since some other vendors (Metrowerks, for example)
-// also #define _MSC_VER
-
-# pragma warning (pop)
-# pragma pack (pop)
-
-# if defined(__cplusplus_cli) || defined(__cplusplus_winrt)
-#  if defined(ASIO_CLR_WORKAROUND)
-#   undef generic
-#   undef ASIO_CLR_WORKAROUND
-#  endif
-# endif
-
-#endif
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/posix_event.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/posix_event.hpp
deleted file mode 100644
index 14ec89d7a410..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/posix_event.hpp
+++ /dev/null
@@ -1,126 +0,0 @@
-//
-// detail/posix_event.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_POSIX_EVENT_HPP
-#define ASIO_DETAIL_POSIX_EVENT_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_HAS_PTHREADS)
-
-#include <pthread.h>
-#include "asio/detail/assert.hpp"
-#include "asio/detail/noncopyable.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-class posix_event
-  : private noncopyable
-{
-public:
-  // Constructor.
-  ASIO_DECL posix_event();
-
-  // Destructor.
-  ~posix_event()
-  {
-    ::pthread_cond_destroy(&cond_);
-  }
-
-  // Signal the event. (Retained for backward compatibility.)
-  template <typename Lock>
-  void signal(Lock& lock)
-  {
-    this->signal_all(lock);
-  }
-
-  // Signal all waiters.
-  template <typename Lock>
-  void signal_all(Lock& lock)
-  {
-    ASIO_ASSERT(lock.locked());
-    (void)lock;
-    state_ |= 1;
-    ::pthread_cond_broadcast(&cond_); // Ignore EINVAL.
-  }
-
-  // Unlock the mutex and signal one waiter.
-  template <typename Lock>
-  void unlock_and_signal_one(Lock& lock)
-  {
-    ASIO_ASSERT(lock.locked());
-    state_ |= 1;
-    bool have_waiters = (state_ > 1);
-    lock.unlock();
-    if (have_waiters)
-      ::pthread_cond_signal(&cond_); // Ignore EINVAL.
-  }
-
-  // If there's a waiter, unlock the mutex and signal it.
-  template <typename Lock>
-  bool maybe_unlock_and_signal_one(Lock& lock)
-  {
-    ASIO_ASSERT(lock.locked());
-    state_ |= 1;
-    if (state_ > 1)
-    {
-      lock.unlock();
-      ::pthread_cond_signal(&cond_); // Ignore EINVAL.
-      return true;
-    }
-    return false;
-  }
-
-  // Reset the event.
-  template <typename Lock>
-  void clear(Lock& lock)
-  {
-    ASIO_ASSERT(lock.locked());
-    (void)lock;
-    state_ &= ~std::size_t(1);
-  }
-
-  // Wait for the event to become signalled.
-  template <typename Lock>
-  void wait(Lock& lock)
-  {
-    ASIO_ASSERT(lock.locked());
-    while ((state_ & 1) == 0)
-    {
-      state_ += 2;
-      ::pthread_cond_wait(&cond_, &lock.mutex().mutex_); // Ignore EINVAL.
-      state_ -= 2;
-    }
-  }
-
-private:
-  ::pthread_cond_t cond_;
-  std::size_t state_;
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#if defined(ASIO_HEADER_ONLY)
-# include "asio/detail/impl/posix_event.ipp"
-#endif // defined(ASIO_HEADER_ONLY)
-
-#endif // defined(ASIO_HAS_PTHREADS)
-
-#endif // ASIO_DETAIL_POSIX_EVENT_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/posix_fd_set_adapter.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/posix_fd_set_adapter.hpp
deleted file mode 100644
index e91c38df3ab0..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/posix_fd_set_adapter.hpp
+++ /dev/null
@@ -1,118 +0,0 @@
-//
-// detail/posix_fd_set_adapter.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_POSIX_FD_SET_ADAPTER_HPP
-#define ASIO_DETAIL_POSIX_FD_SET_ADAPTER_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if !defined(ASIO_WINDOWS) \
-  && !defined(__CYGWIN__) \
-  && !defined(ASIO_WINDOWS_RUNTIME)
-
-#include <cstring>
-#include "asio/detail/noncopyable.hpp"
-#include "asio/detail/reactor_op_queue.hpp"
-#include "asio/detail/socket_types.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-// Adapts the FD_SET type to meet the Descriptor_Set concept's requirements.
-class posix_fd_set_adapter : noncopyable
-{
-public:
-  posix_fd_set_adapter()
-    : max_descriptor_(invalid_socket)
-  {
-    using namespace std; // Needed for memset on Solaris.
-    FD_ZERO(&fd_set_);
-  }
-
-  void reset()
-  {
-    using namespace std; // Needed for memset on Solaris.
-    FD_ZERO(&fd_set_);
-  }
-
-  bool set(socket_type descriptor)
-  {
-    if (descriptor < (socket_type)FD_SETSIZE)
-    {
-      if (max_descriptor_ == invalid_socket || descriptor > max_descriptor_)
-        max_descriptor_ = descriptor;
-      FD_SET(descriptor, &fd_set_);
-      return true;
-    }
-    return false;
-  }
-
-  void set(reactor_op_queue<socket_type>& operations, op_queue<operation>& ops)
-  {
-    reactor_op_queue<socket_type>::iterator i = operations.begin();
-    while (i != operations.end())
-    {
-      reactor_op_queue<socket_type>::iterator op_iter = i++;
-      if (!set(op_iter->first))
-      {
-        asio::error_code ec(error::fd_set_failure);
-        operations.cancel_operations(op_iter, ops, ec);
-      }
-    }
-  }
-
-  bool is_set(socket_type descriptor) const
-  {
-    return FD_ISSET(descriptor, &fd_set_) != 0;
-  }
-
-  operator fd_set*()
-  {
-    return &fd_set_;
-  }
-
-  socket_type max_descriptor() const
-  {
-    return max_descriptor_;
-  }
-
-  void perform(reactor_op_queue<socket_type>& operations,
-      op_queue<operation>& ops) const
-  {
-    reactor_op_queue<socket_type>::iterator i = operations.begin();
-    while (i != operations.end())
-    {
-      reactor_op_queue<socket_type>::iterator op_iter = i++;
-      if (is_set(op_iter->first))
-        operations.perform_operations(op_iter, ops);
-    }
-  }
-
-private:
-  mutable fd_set fd_set_;
-  socket_type max_descriptor_;
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // !defined(ASIO_WINDOWS)
-       // && !defined(__CYGWIN__)
-       // && !defined(ASIO_WINDOWS_RUNTIME)
-
-#endif // ASIO_DETAIL_POSIX_FD_SET_ADAPTER_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/posix_mutex.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/posix_mutex.hpp
deleted file mode 100644
index 185a20738485..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/posix_mutex.hpp
+++ /dev/null
@@ -1,76 +0,0 @@
-//
-// detail/posix_mutex.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_POSIX_MUTEX_HPP
-#define ASIO_DETAIL_POSIX_MUTEX_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_HAS_PTHREADS)
-
-#include <pthread.h>
-#include "asio/detail/noncopyable.hpp"
-#include "asio/detail/scoped_lock.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-class posix_event;
-
-class posix_mutex
-  : private noncopyable
-{
-public:
-  typedef asio::detail::scoped_lock<posix_mutex> scoped_lock;
-
-  // Constructor.
-  ASIO_DECL posix_mutex();
-
-  // Destructor.
-  ~posix_mutex()
-  {
-    ::pthread_mutex_destroy(&mutex_); // Ignore EBUSY.
-  }
-
-  // Lock the mutex.
-  void lock()
-  {
-    (void)::pthread_mutex_lock(&mutex_); // Ignore EINVAL.
-  }
-
-  // Unlock the mutex.
-  void unlock()
-  {
-    (void)::pthread_mutex_unlock(&mutex_); // Ignore EINVAL.
-  }
-
-private:
-  friend class posix_event;
-  ::pthread_mutex_t mutex_;
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#if defined(ASIO_HEADER_ONLY)
-# include "asio/detail/impl/posix_mutex.ipp"
-#endif // defined(ASIO_HEADER_ONLY)
-
-#endif // defined(ASIO_HAS_PTHREADS)
-
-#endif // ASIO_DETAIL_POSIX_MUTEX_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/posix_signal_blocker.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/posix_signal_blocker.hpp
deleted file mode 100644
index 8556183f7bfc..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/posix_signal_blocker.hpp
+++ /dev/null
@@ -1,85 +0,0 @@
-//
-// detail/posix_signal_blocker.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_POSIX_SIGNAL_BLOCKER_HPP
-#define ASIO_DETAIL_POSIX_SIGNAL_BLOCKER_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_HAS_PTHREADS)
-
-#include <csignal>
-#include <pthread.h>
-#include <signal.h>
-#include "asio/detail/noncopyable.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-class posix_signal_blocker
-  : private noncopyable
-{
-public:
-  // Constructor blocks all signals for the calling thread.
-  posix_signal_blocker()
-    : blocked_(false)
-  {
-    sigset_t new_mask;
-    sigfillset(&new_mask);
-    blocked_ = (pthread_sigmask(SIG_BLOCK, &new_mask, &old_mask_) == 0);
-  }
-
-  // Destructor restores the previous signal mask.
-  ~posix_signal_blocker()
-  {
-    if (blocked_)
-      pthread_sigmask(SIG_SETMASK, &old_mask_, 0);
-  }
-
-  // Block all signals for the calling thread.
-  void block()
-  {
-    if (!blocked_)
-    {
-      sigset_t new_mask;
-      sigfillset(&new_mask);
-      blocked_ = (pthread_sigmask(SIG_BLOCK, &new_mask, &old_mask_) == 0);
-    }
-  }
-
-  // Restore the previous signal mask.
-  void unblock()
-  {
-    if (blocked_)
-      blocked_ = (pthread_sigmask(SIG_SETMASK, &old_mask_, 0) != 0);
-  }
-
-private:
-  // Have signals been blocked.
-  bool blocked_;
-
-  // The previous signal mask.
-  sigset_t old_mask_;
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // defined(ASIO_HAS_PTHREADS)
-
-#endif // ASIO_DETAIL_POSIX_SIGNAL_BLOCKER_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/posix_static_mutex.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/posix_static_mutex.hpp
deleted file mode 100644
index cfb59cac1210..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/posix_static_mutex.hpp
+++ /dev/null
@@ -1,64 +0,0 @@
-//
-// detail/posix_static_mutex.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_POSIX_STATIC_MUTEX_HPP
-#define ASIO_DETAIL_POSIX_STATIC_MUTEX_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_HAS_PTHREADS)
-
-#include <pthread.h>
-#include "asio/detail/scoped_lock.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-struct posix_static_mutex
-{
-  typedef asio::detail::scoped_lock<posix_static_mutex> scoped_lock;
-
-  // Initialise the mutex.
-  void init()
-  {
-    // Nothing to do.
-  }
-
-  // Lock the mutex.
-  void lock()
-  {
-    (void)::pthread_mutex_lock(&mutex_); // Ignore EINVAL.
-  }
-
-  // Unlock the mutex.
-  void unlock()
-  {
-    (void)::pthread_mutex_unlock(&mutex_); // Ignore EINVAL.
-  }
-
-  ::pthread_mutex_t mutex_;
-};
-
-#define ASIO_POSIX_STATIC_MUTEX_INIT { PTHREAD_MUTEX_INITIALIZER }
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // defined(ASIO_HAS_PTHREADS)
-
-#endif // ASIO_DETAIL_POSIX_STATIC_MUTEX_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/posix_thread.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/posix_thread.hpp
deleted file mode 100644
index d09a573cb9dc..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/posix_thread.hpp
+++ /dev/null
@@ -1,105 +0,0 @@
-//
-// detail/posix_thread.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_POSIX_THREAD_HPP
-#define ASIO_DETAIL_POSIX_THREAD_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_HAS_PTHREADS)
-
-#include <pthread.h>
-#include "asio/detail/noncopyable.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-extern "C"
-{
-  ASIO_DECL void* asio_detail_posix_thread_function(void* arg);
-}
-
-class posix_thread
-  : private noncopyable
-{
-public:
-  // Constructor.
-  template <typename Function>
-  posix_thread(Function f, unsigned int = 0)
-    : joined_(false)
-  {
-    start_thread(new func<Function>(f));
-  }
-
-  // Destructor.
-  ASIO_DECL ~posix_thread();
-
-  // Wait for the thread to exit.
-  ASIO_DECL void join();
-
-private:
-  friend void* asio_detail_posix_thread_function(void* arg);
-
-  class func_base
-  {
-  public:
-    virtual ~func_base() {}
-    virtual void run() = 0;
-  };
-
-  struct auto_func_base_ptr
-  {
-    func_base* ptr;
-    ~auto_func_base_ptr() { delete ptr; }
-  };
-
-  template <typename Function>
-  class func
-    : public func_base
-  {
-  public:
-    func(Function f)
-      : f_(f)
-    {
-    }
-
-    virtual void run()
-    {
-      f_();
-    }
-
-  private:
-    Function f_;
-  };
-
-  ASIO_DECL void start_thread(func_base* arg);
-
-  ::pthread_t thread_;
-  bool joined_;
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#if defined(ASIO_HEADER_ONLY)
-# include "asio/detail/impl/posix_thread.ipp"
-#endif // defined(ASIO_HEADER_ONLY)
-
-#endif // defined(ASIO_HAS_PTHREADS)
-
-#endif // ASIO_DETAIL_POSIX_THREAD_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/posix_tss_ptr.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/posix_tss_ptr.hpp
deleted file mode 100644
index 23f93ae1678b..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/posix_tss_ptr.hpp
+++ /dev/null
@@ -1,79 +0,0 @@
-//
-// detail/posix_tss_ptr.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_POSIX_TSS_PTR_HPP
-#define ASIO_DETAIL_POSIX_TSS_PTR_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_HAS_PTHREADS)
-
-#include <pthread.h>
-#include "asio/detail/noncopyable.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-// Helper function to create thread-specific storage.
-ASIO_DECL void posix_tss_ptr_create(pthread_key_t& key);
-
-template <typename T>
-class posix_tss_ptr
-  : private noncopyable
-{
-public:
-  // Constructor.
-  posix_tss_ptr()
-  {
-    posix_tss_ptr_create(tss_key_);
-  }
-
-  // Destructor.
-  ~posix_tss_ptr()
-  {
-    ::pthread_key_delete(tss_key_);
-  }
-
-  // Get the value.
-  operator T*() const
-  {
-    return static_cast<T*>(::pthread_getspecific(tss_key_));
-  }
-
-  // Set the value.
-  void operator=(T* value)
-  {
-    ::pthread_setspecific(tss_key_, value);
-  }
-
-private:
-  // Thread-specific storage to allow unlocked access to determine whether a
-  // thread is a member of the pool.
-  pthread_key_t tss_key_;
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#if defined(ASIO_HEADER_ONLY)
-# include "asio/detail/impl/posix_tss_ptr.ipp"
-#endif // defined(ASIO_HEADER_ONLY)
-
-#endif // defined(ASIO_HAS_PTHREADS)
-
-#endif // ASIO_DETAIL_POSIX_TSS_PTR_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/push_options.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/push_options.hpp
deleted file mode 100644
index c5ccd47dd652..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/push_options.hpp
+++ /dev/null
@@ -1,138 +0,0 @@
-//
-// detail/push_options.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-// No header guard
-
-#if defined(__COMO__)
-
-// Comeau C++
-
-#elif defined(__DMC__)
-
-// Digital Mars C++
-
-#elif defined(__INTEL_COMPILER) || defined(__ICL) \
-  || defined(__ICC) || defined(__ECC)
-
-// Intel C++
-
-#elif defined(__GNUC__)
-
-// GNU C++
-
-# if defined(__MINGW32__) || defined(__CYGWIN__)
-#  pragma pack (push, 8)
-# endif
-
-# if defined(__OBJC__)
-#  if !defined(__APPLE_CC__) || (__APPLE_CC__ <= 1)
-#   if !defined(ASIO_DISABLE_OBJC_WORKAROUND)
-#    if !defined(Protocol) && !defined(id)
-#     define Protocol cpp_Protocol
-#     define id cpp_id
-#     define ASIO_OBJC_WORKAROUND
-#    endif
-#   endif
-#  endif
-# endif
-
-#elif defined(__KCC)
-
-// Kai C++
-
-#elif defined(__sgi)
-
-// SGI MIPSpro C++
-
-#elif defined(__DECCXX)
-
-// Compaq Tru64 Unix cxx
-
-#elif defined(__ghs)
-
-// Greenhills C++
-
-#elif defined(__BORLANDC__)
-
-// Borland C++
-
-# pragma option push -a8 -b -Ve- -Vx- -w-inl -vi-
-# pragma nopushoptwarn
-# pragma nopackwarning
-# if !defined(__MT__)
-#  error Multithreaded RTL must be selected.
-# endif // !defined(__MT__)
-
-#elif defined(__MWERKS__)
-
-// Metrowerks CodeWarrior
-
-#elif defined(__SUNPRO_CC)
-
-// Sun Workshop Compiler C++
-
-#elif defined(__HP_aCC)
-
-// HP aCC
-
-#elif defined(__MRC__) || defined(__SC__)
-
-// MPW MrCpp or SCpp
-
-#elif defined(__IBMCPP__)
-
-// IBM Visual Age
-
-#elif defined(_MSC_VER)
-
-// Microsoft Visual C++
-//
-// Must remain the last #elif since some other vendors (Metrowerks, for example)
-// also #define _MSC_VER
-
-# pragma warning (disable:4103)
-# pragma warning (push)
-# pragma warning (disable:4127)
-# pragma warning (disable:4180)
-# pragma warning (disable:4244)
-# pragma warning (disable:4355)
-# pragma warning (disable:4510)
-# pragma warning (disable:4512)
-# pragma warning (disable:4610)
-# pragma warning (disable:4675)
-# if defined(_M_IX86) && defined(_Wp64)
-// The /Wp64 option is broken. If you want to check 64 bit portability, use a
-// 64 bit compiler!
-#  pragma warning (disable:4311)
-#  pragma warning (disable:4312)
-# endif // defined(_M_IX86) && defined(_Wp64)
-# pragma pack (push, 8)
-// Note that if the /Og optimisation flag is enabled with MSVC6, the compiler
-// has a tendency to incorrectly optimise away some calls to member template
-// functions, even though those functions contain code that should not be
-// optimised away! Therefore we will always disable this optimisation option
-// for the MSVC6 compiler.
-# if (_MSC_VER < 1300)
-#  pragma optimize ("g", off)
-# endif
-# if !defined(_MT)
-#  error Multithreaded RTL must be selected.
-# endif // !defined(_MT)
-
-# if defined(__cplusplus_cli) || defined(__cplusplus_winrt)
-#  if !defined(ASIO_DISABLE_CLR_WORKAROUND)
-#   if !defined(generic)
-#    define generic cpp_generic
-#    define ASIO_CLR_WORKAROUND
-#   endif
-#  endif
-# endif
-
-#endif
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/reactive_descriptor_service.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/reactive_descriptor_service.hpp
deleted file mode 100644
index d5c0ea9bbe4c..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/reactive_descriptor_service.hpp
+++ /dev/null
@@ -1,322 +0,0 @@
-//
-// detail/reactive_descriptor_service.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_REACTIVE_DESCRIPTOR_SERVICE_HPP
-#define ASIO_DETAIL_REACTIVE_DESCRIPTOR_SERVICE_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if !defined(ASIO_WINDOWS) \
-  && !defined(ASIO_WINDOWS_RUNTIME) \
-  && !defined(__CYGWIN__)
-
-#include "asio/buffer.hpp"
-#include "asio/io_service.hpp"
-#include "asio/detail/addressof.hpp"
-#include "asio/detail/bind_handler.hpp"
-#include "asio/detail/buffer_sequence_adapter.hpp"
-#include "asio/detail/descriptor_ops.hpp"
-#include "asio/detail/descriptor_read_op.hpp"
-#include "asio/detail/descriptor_write_op.hpp"
-#include "asio/detail/fenced_block.hpp"
-#include "asio/detail/noncopyable.hpp"
-#include "asio/detail/reactive_null_buffers_op.hpp"
-#include "asio/detail/reactor.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-class reactive_descriptor_service
-{
-public:
-  // The native type of a descriptor.
-  typedef int native_handle_type;
-
-  // The implementation type of the descriptor.
-  class implementation_type
-    : private asio::detail::noncopyable
-  {
-  public:
-    // Default constructor.
-    implementation_type()
-      : descriptor_(-1),
-        state_(0)
-    {
-    }
-
-  private:
-    // Only this service will have access to the internal values.
-    friend class reactive_descriptor_service;
-
-    // The native descriptor representation.
-    int descriptor_;
-
-    // The current state of the descriptor.
-    descriptor_ops::state_type state_;
-
-    // Per-descriptor data used by the reactor.
-    reactor::per_descriptor_data reactor_data_;
-  };
-
-  // Constructor.
-  ASIO_DECL reactive_descriptor_service(
-      asio::io_service& io_service);
-
-  // Destroy all user-defined handler objects owned by the service.
-  ASIO_DECL void shutdown_service();
-
-  // Construct a new descriptor implementation.
-  ASIO_DECL void construct(implementation_type& impl);
-
-  // Move-construct a new descriptor implementation.
-  ASIO_DECL void move_construct(implementation_type& impl,
-      implementation_type& other_impl);
-
-  // Move-assign from another descriptor implementation.
-  ASIO_DECL void move_assign(implementation_type& impl,
-      reactive_descriptor_service& other_service,
-      implementation_type& other_impl);
-
-  // Destroy a descriptor implementation.
-  ASIO_DECL void destroy(implementation_type& impl);
-
-  // Assign a native descriptor to a descriptor implementation.
-  ASIO_DECL asio::error_code assign(implementation_type& impl,
-      const native_handle_type& native_descriptor,
-      asio::error_code& ec);
-
-  // Determine whether the descriptor is open.
-  bool is_open(const implementation_type& impl) const
-  {
-    return impl.descriptor_ != -1;
-  }
-
-  // Destroy a descriptor implementation.
-  ASIO_DECL asio::error_code close(implementation_type& impl,
-      asio::error_code& ec);
-
-  // Get the native descriptor representation.
-  native_handle_type native_handle(const implementation_type& impl) const
-  {
-    return impl.descriptor_;
-  }
-
-  // Release ownership of the native descriptor representation.
-  ASIO_DECL native_handle_type release(implementation_type& impl);
-
-  // Cancel all operations associated with the descriptor.
-  ASIO_DECL asio::error_code cancel(implementation_type& impl,
-      asio::error_code& ec);
-
-  // Perform an IO control command on the descriptor.
-  template <typename IO_Control_Command>
-  asio::error_code io_control(implementation_type& impl,
-      IO_Control_Command& command, asio::error_code& ec)
-  {
-    descriptor_ops::ioctl(impl.descriptor_, impl.state_,
-        command.name(), static_cast<ioctl_arg_type*>(command.data()), ec);
-    return ec;
-  }
-
-  // Gets the non-blocking mode of the descriptor.
-  bool non_blocking(const implementation_type& impl) const
-  {
-    return (impl.state_ & descriptor_ops::user_set_non_blocking) != 0;
-  }
-
-  // Sets the non-blocking mode of the descriptor.
-  asio::error_code non_blocking(implementation_type& impl,
-      bool mode, asio::error_code& ec)
-  {
-    descriptor_ops::set_user_non_blocking(
-        impl.descriptor_, impl.state_, mode, ec);
-    return ec;
-  }
-
-  // Gets the non-blocking mode of the native descriptor implementation.
-  bool native_non_blocking(const implementation_type& impl) const
-  {
-    return (impl.state_ & descriptor_ops::internal_non_blocking) != 0;
-  }
-
-  // Sets the non-blocking mode of the native descriptor implementation.
-  asio::error_code native_non_blocking(implementation_type& impl,
-      bool mode, asio::error_code& ec)
-  {
-    descriptor_ops::set_internal_non_blocking(
-        impl.descriptor_, impl.state_, mode, ec);
-    return ec;
-  }
-
-  // Write some data to the descriptor.
-  template <typename ConstBufferSequence>
-  size_t write_some(implementation_type& impl,
-      const ConstBufferSequence& buffers, asio::error_code& ec)
-  {
-    buffer_sequence_adapter<asio::const_buffer,
-        ConstBufferSequence> bufs(buffers);
-
-    return descriptor_ops::sync_write(impl.descriptor_, impl.state_,
-        bufs.buffers(), bufs.count(), bufs.all_empty(), ec);
-  }
-
-  // Wait until data can be written without blocking.
-  size_t write_some(implementation_type& impl,
-      const null_buffers&, asio::error_code& ec)
-  {
-    // Wait for descriptor to become ready.
-    descriptor_ops::poll_write(impl.descriptor_, impl.state_, ec);
-
-    return 0;
-  }
-
-  // Start an asynchronous write. The data being sent must be valid for the
-  // lifetime of the asynchronous operation.
-  template <typename ConstBufferSequence, typename Handler>
-  void async_write_some(implementation_type& impl,
-      const ConstBufferSequence& buffers, Handler& handler)
-  {
-    bool is_continuation =
-      asio_handler_cont_helpers::is_continuation(handler);
-
-    // Allocate and construct an operation to wrap the handler.
-    typedef descriptor_write_op<ConstBufferSequence, Handler> op;
-    typename op::ptr p = { asio::detail::addressof(handler),
-      asio_handler_alloc_helpers::allocate(
-        sizeof(op), handler), 0 };
-    p.p = new (p.v) op(impl.descriptor_, buffers, handler);
-
-    ASIO_HANDLER_CREATION((p.p, "descriptor", &impl, "async_write_some"));
-
-    start_op(impl, reactor::write_op, p.p, is_continuation, true,
-        buffer_sequence_adapter<asio::const_buffer,
-          ConstBufferSequence>::all_empty(buffers));
-    p.v = p.p = 0;
-  }
-
-  // Start an asynchronous wait until data can be written without blocking.
-  template <typename Handler>
-  void async_write_some(implementation_type& impl,
-      const null_buffers&, Handler& handler)
-  {
-    bool is_continuation =
-      asio_handler_cont_helpers::is_continuation(handler);
-
-    // Allocate and construct an operation to wrap the handler.
-    typedef reactive_null_buffers_op<Handler> op;
-    typename op::ptr p = { asio::detail::addressof(handler),
-      asio_handler_alloc_helpers::allocate(
-        sizeof(op), handler), 0 };
-    p.p = new (p.v) op(handler);
-
-    ASIO_HANDLER_CREATION((p.p, "descriptor",
-          &impl, "async_write_some(null_buffers)"));
-
-    start_op(impl, reactor::write_op, p.p, is_continuation, false, false);
-    p.v = p.p = 0;
-  }
-
-  // Read some data from the stream. Returns the number of bytes read.
-  template <typename MutableBufferSequence>
-  size_t read_some(implementation_type& impl,
-      const MutableBufferSequence& buffers, asio::error_code& ec)
-  {
-    buffer_sequence_adapter<asio::mutable_buffer,
-        MutableBufferSequence> bufs(buffers);
-
-    return descriptor_ops::sync_read(impl.descriptor_, impl.state_,
-        bufs.buffers(), bufs.count(), bufs.all_empty(), ec);
-  }
-
-  // Wait until data can be read without blocking.
-  size_t read_some(implementation_type& impl,
-      const null_buffers&, asio::error_code& ec)
-  {
-    // Wait for descriptor to become ready.
-    descriptor_ops::poll_read(impl.descriptor_, impl.state_, ec);
-
-    return 0;
-  }
-
-  // Start an asynchronous read. The buffer for the data being read must be
-  // valid for the lifetime of the asynchronous operation.
-  template <typename MutableBufferSequence, typename Handler>
-  void async_read_some(implementation_type& impl,
-      const MutableBufferSequence& buffers, Handler& handler)
-  {
-    bool is_continuation =
-      asio_handler_cont_helpers::is_continuation(handler);
-
-    // Allocate and construct an operation to wrap the handler.
-    typedef descriptor_read_op<MutableBufferSequence, Handler> op;
-    typename op::ptr p = { asio::detail::addressof(handler),
-      asio_handler_alloc_helpers::allocate(
-        sizeof(op), handler), 0 };
-    p.p = new (p.v) op(impl.descriptor_, buffers, handler);
-
-    ASIO_HANDLER_CREATION((p.p, "descriptor", &impl, "async_read_some"));
-
-    start_op(impl, reactor::read_op, p.p, is_continuation, true,
-        buffer_sequence_adapter<asio::mutable_buffer,
-          MutableBufferSequence>::all_empty(buffers));
-    p.v = p.p = 0;
-  }
-
-  // Wait until data can be read without blocking.
-  template <typename Handler>
-  void async_read_some(implementation_type& impl,
-      const null_buffers&, Handler& handler)
-  {
-    bool is_continuation =
-      asio_handler_cont_helpers::is_continuation(handler);
-
-    // Allocate and construct an operation to wrap the handler.
-    typedef reactive_null_buffers_op<Handler> op;
-    typename op::ptr p = { asio::detail::addressof(handler),
-      asio_handler_alloc_helpers::allocate(
-        sizeof(op), handler), 0 };
-    p.p = new (p.v) op(handler);
-
-    ASIO_HANDLER_CREATION((p.p, "descriptor",
-          &impl, "async_read_some(null_buffers)"));
-
-    start_op(impl, reactor::read_op, p.p, is_continuation, false, false);
-    p.v = p.p = 0;
-  }
-
-private:
-  // Start the asynchronous operation.
-  ASIO_DECL void start_op(implementation_type& impl, int op_type,
-      reactor_op* op, bool is_continuation, bool is_non_blocking, bool noop);
-
-  // The selector that performs event demultiplexing for the service.
-  reactor& reactor_;
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#if defined(ASIO_HEADER_ONLY)
-# include "asio/detail/impl/reactive_descriptor_service.ipp"
-#endif // defined(ASIO_HEADER_ONLY)
-
-#endif // !defined(ASIO_WINDOWS)
-       //   && !defined(ASIO_WINDOWS_RUNTIME)
-       //   && !defined(__CYGWIN__)
-
-#endif // ASIO_DETAIL_REACTIVE_DESCRIPTOR_SERVICE_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/reactive_null_buffers_op.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/reactive_null_buffers_op.hpp
deleted file mode 100644
index c4c421369fd5..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/reactive_null_buffers_op.hpp
+++ /dev/null
@@ -1,88 +0,0 @@
-//
-// detail/reactive_null_buffers_op.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_REACTIVE_NULL_BUFFERS_OP_HPP
-#define ASIO_DETAIL_REACTIVE_NULL_BUFFERS_OP_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include "asio/detail/addressof.hpp"
-#include "asio/detail/fenced_block.hpp"
-#include "asio/detail/handler_alloc_helpers.hpp"
-#include "asio/detail/handler_invoke_helpers.hpp"
-#include "asio/detail/reactor_op.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-template <typename Handler>
-class reactive_null_buffers_op : public reactor_op
-{
-public:
-  ASIO_DEFINE_HANDLER_PTR(reactive_null_buffers_op);
-
-  reactive_null_buffers_op(Handler& handler)
-    : reactor_op(&reactive_null_buffers_op::do_perform,
-        &reactive_null_buffers_op::do_complete),
-      handler_(ASIO_MOVE_CAST(Handler)(handler))
-  {
-  }
-
-  static bool do_perform(reactor_op*)
-  {
-    return true;
-  }
-
-  static void do_complete(io_service_impl* owner, operation* base,
-      const asio::error_code& /*ec*/,
-      std::size_t /*bytes_transferred*/)
-  {
-    // Take ownership of the handler object.
-    reactive_null_buffers_op* o(static_cast<reactive_null_buffers_op*>(base));
-    ptr p = { asio::detail::addressof(o->handler_), o, o };
-
-    ASIO_HANDLER_COMPLETION((o));
-
-    // Make a copy of the handler so that the memory can be deallocated before
-    // the upcall is made. Even if we're not about to make an upcall, a
-    // sub-object of the handler may be the true owner of the memory associated
-    // with the handler. Consequently, a local copy of the handler is required
-    // to ensure that any owning sub-object remains valid until after we have
-    // deallocated the memory here.
-    detail::binder2<Handler, asio::error_code, std::size_t>
-      handler(o->handler_, o->ec_, o->bytes_transferred_);
-    p.h = asio::detail::addressof(handler.handler_);
-    p.reset();
-
-    // Make the upcall if required.
-    if (owner)
-    {
-      fenced_block b(fenced_block::half);
-      ASIO_HANDLER_INVOCATION_BEGIN((handler.arg1_, handler.arg2_));
-      asio_handler_invoke_helpers::invoke(handler, handler.handler_);
-      ASIO_HANDLER_INVOCATION_END;
-    }
-  }
-
-private:
-  Handler handler_;
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_DETAIL_REACTIVE_NULL_BUFFERS_OP_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/reactive_serial_port_service.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/reactive_serial_port_service.hpp
deleted file mode 100644
index 5361c48b3f7c..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/reactive_serial_port_service.hpp
+++ /dev/null
@@ -1,234 +0,0 @@
-//
-// detail/reactive_serial_port_service.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-// Copyright (c) 2008 Rep Invariant Systems, Inc. (info@repinvariant.com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_REACTIVE_SERIAL_PORT_SERVICE_HPP
-#define ASIO_DETAIL_REACTIVE_SERIAL_PORT_SERVICE_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_HAS_SERIAL_PORT)
-#if !defined(ASIO_WINDOWS) && !defined(__CYGWIN__)
-
-#include <string>
-#include "asio/error.hpp"
-#include "asio/io_service.hpp"
-#include "asio/serial_port_base.hpp"
-#include "asio/detail/descriptor_ops.hpp"
-#include "asio/detail/reactive_descriptor_service.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-// Extend reactive_descriptor_service to provide serial port support.
-class reactive_serial_port_service
-{
-public:
-  // The native type of a serial port.
-  typedef reactive_descriptor_service::native_handle_type native_handle_type;
-
-  // The implementation type of the serial port.
-  typedef reactive_descriptor_service::implementation_type implementation_type;
-
-  ASIO_DECL reactive_serial_port_service(
-      asio::io_service& io_service);
-
-  // Destroy all user-defined handler objects owned by the service.
-  ASIO_DECL void shutdown_service();
-
-  // Construct a new serial port implementation.
-  void construct(implementation_type& impl)
-  {
-    descriptor_service_.construct(impl);
-  }
-
-  // Move-construct a new serial port implementation.
-  void move_construct(implementation_type& impl,
-      implementation_type& other_impl)
-  {
-    descriptor_service_.move_construct(impl, other_impl);
-  }
-
-  // Move-assign from another serial port implementation.
-  void move_assign(implementation_type& impl,
-      reactive_serial_port_service& other_service,
-      implementation_type& other_impl)
-  {
-    descriptor_service_.move_assign(impl,
-        other_service.descriptor_service_, other_impl);
-  }
-
-  // Destroy a serial port implementation.
-  void destroy(implementation_type& impl)
-  {
-    descriptor_service_.destroy(impl);
-  }
-
-  // Open the serial port using the specified device name.
-  ASIO_DECL asio::error_code open(implementation_type& impl,
-      const std::string& device, asio::error_code& ec);
-
-  // Assign a native descriptor to a serial port implementation.
-  asio::error_code assign(implementation_type& impl,
-      const native_handle_type& native_descriptor,
-      asio::error_code& ec)
-  {
-    return descriptor_service_.assign(impl, native_descriptor, ec);
-  }
-
-  // Determine whether the serial port is open.
-  bool is_open(const implementation_type& impl) const
-  {
-    return descriptor_service_.is_open(impl);
-  }
-
-  // Destroy a serial port implementation.
-  asio::error_code close(implementation_type& impl,
-      asio::error_code& ec)
-  {
-    return descriptor_service_.close(impl, ec);
-  }
-
-  // Get the native serial port representation.
-  native_handle_type native_handle(implementation_type& impl)
-  {
-    return descriptor_service_.native_handle(impl);
-  }
-
-  // Cancel all operations associated with the serial port.
-  asio::error_code cancel(implementation_type& impl,
-      asio::error_code& ec)
-  {
-    return descriptor_service_.cancel(impl, ec);
-  }
-
-  // Set an option on the serial port.
-  template <typename SettableSerialPortOption>
-  asio::error_code set_option(implementation_type& impl,
-      const SettableSerialPortOption& option, asio::error_code& ec)
-  {
-    return do_set_option(impl,
-        &reactive_serial_port_service::store_option<SettableSerialPortOption>,
-        &option, ec);
-  }
-
-  // Get an option from the serial port.
-  template <typename GettableSerialPortOption>
-  asio::error_code get_option(const implementation_type& impl,
-      GettableSerialPortOption& option, asio::error_code& ec) const
-  {
-    return do_get_option(impl,
-        &reactive_serial_port_service::load_option<GettableSerialPortOption>,
-        &option, ec);
-  }
-
-  // Send a break sequence to the serial port.
-  asio::error_code send_break(implementation_type& impl,
-      asio::error_code& ec)
-  {
-    errno = 0;
-    descriptor_ops::error_wrapper(::tcsendbreak(
-          descriptor_service_.native_handle(impl), 0), ec);
-    return ec;
-  }
-
-  // Write the given data. Returns the number of bytes sent.
-  template <typename ConstBufferSequence>
-  size_t write_some(implementation_type& impl,
-      const ConstBufferSequence& buffers, asio::error_code& ec)
-  {
-    return descriptor_service_.write_some(impl, buffers, ec);
-  }
-
-  // Start an asynchronous write. The data being written must be valid for the
-  // lifetime of the asynchronous operation.
-  template <typename ConstBufferSequence, typename Handler>
-  void async_write_some(implementation_type& impl,
-      const ConstBufferSequence& buffers, Handler& handler)
-  {
-    descriptor_service_.async_write_some(impl, buffers, handler);
-  }
-
-  // Read some data. Returns the number of bytes received.
-  template <typename MutableBufferSequence>
-  size_t read_some(implementation_type& impl,
-      const MutableBufferSequence& buffers, asio::error_code& ec)
-  {
-    return descriptor_service_.read_some(impl, buffers, ec);
-  }
-
-  // Start an asynchronous read. The buffer for the data being received must be
-  // valid for the lifetime of the asynchronous operation.
-  template <typename MutableBufferSequence, typename Handler>
-  void async_read_some(implementation_type& impl,
-      const MutableBufferSequence& buffers, Handler& handler)
-  {
-    descriptor_service_.async_read_some(impl, buffers, handler);
-  }
-
-private:
-  // Function pointer type for storing a serial port option.
-  typedef asio::error_code (*store_function_type)(
-      const void*, termios&, asio::error_code&);
-
-  // Helper function template to store a serial port option.
-  template <typename SettableSerialPortOption>
-  static asio::error_code store_option(const void* option,
-      termios& storage, asio::error_code& ec)
-  {
-    return static_cast<const SettableSerialPortOption*>(option)->store(
-        storage, ec);
-  }
-
-  // Helper function to set a serial port option.
-  ASIO_DECL asio::error_code do_set_option(
-      implementation_type& impl, store_function_type store,
-      const void* option, asio::error_code& ec);
-
-  // Function pointer type for loading a serial port option.
-  typedef asio::error_code (*load_function_type)(
-      void*, const termios&, asio::error_code&);
-
-  // Helper function template to load a serial port option.
-  template <typename GettableSerialPortOption>
-  static asio::error_code load_option(void* option,
-      const termios& storage, asio::error_code& ec)
-  {
-    return static_cast<GettableSerialPortOption*>(option)->load(storage, ec);
-  }
-
-  // Helper function to get a serial port option.
-  ASIO_DECL asio::error_code do_get_option(
-      const implementation_type& impl, load_function_type load,
-      void* option, asio::error_code& ec) const;
-
-  // The implementation used for initiating asynchronous operations.
-  reactive_descriptor_service descriptor_service_;
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#if defined(ASIO_HEADER_ONLY)
-# include "asio/detail/impl/reactive_serial_port_service.ipp"
-#endif // defined(ASIO_HEADER_ONLY)
-
-#endif // !defined(ASIO_WINDOWS) && !defined(__CYGWIN__)
-#endif // defined(ASIO_HAS_SERIAL_PORT)
-
-#endif // ASIO_DETAIL_REACTIVE_SERIAL_PORT_SERVICE_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/reactive_socket_accept_op.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/reactive_socket_accept_op.hpp
deleted file mode 100644
index 35e83c628249..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/reactive_socket_accept_op.hpp
+++ /dev/null
@@ -1,136 +0,0 @@
-//
-// detail/reactive_socket_accept_op.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_REACTIVE_SOCKET_ACCEPT_OP_HPP
-#define ASIO_DETAIL_REACTIVE_SOCKET_ACCEPT_OP_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include "asio/detail/addressof.hpp"
-#include "asio/detail/bind_handler.hpp"
-#include "asio/detail/buffer_sequence_adapter.hpp"
-#include "asio/detail/fenced_block.hpp"
-#include "asio/detail/reactor_op.hpp"
-#include "asio/detail/socket_holder.hpp"
-#include "asio/detail/socket_ops.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-template <typename Socket, typename Protocol>
-class reactive_socket_accept_op_base : public reactor_op
-{
-public:
-  reactive_socket_accept_op_base(socket_type socket,
-      socket_ops::state_type state, Socket& peer, const Protocol& protocol,
-      typename Protocol::endpoint* peer_endpoint, func_type complete_func)
-    : reactor_op(&reactive_socket_accept_op_base::do_perform, complete_func),
-      socket_(socket),
-      state_(state),
-      peer_(peer),
-      protocol_(protocol),
-      peer_endpoint_(peer_endpoint)
-  {
-  }
-
-  static bool do_perform(reactor_op* base)
-  {
-    reactive_socket_accept_op_base* o(
-        static_cast<reactive_socket_accept_op_base*>(base));
-
-    std::size_t addrlen = o->peer_endpoint_ ? o->peer_endpoint_->capacity() : 0;
-    socket_type new_socket = invalid_socket;
-    bool result = socket_ops::non_blocking_accept(o->socket_,
-          o->state_, o->peer_endpoint_ ? o->peer_endpoint_->data() : 0,
-          o->peer_endpoint_ ? &addrlen : 0, o->ec_, new_socket);
-
-    // On success, assign new connection to peer socket object.
-    if (new_socket != invalid_socket)
-    {
-      socket_holder new_socket_holder(new_socket);
-      if (o->peer_endpoint_)
-        o->peer_endpoint_->resize(addrlen);
-      if (!o->peer_.assign(o->protocol_, new_socket, o->ec_))
-        new_socket_holder.release();
-    }
-
-    return result;
-  }
-
-private:
-  socket_type socket_;
-  socket_ops::state_type state_;
-  Socket& peer_;
-  Protocol protocol_;
-  typename Protocol::endpoint* peer_endpoint_;
-};
-
-template <typename Socket, typename Protocol, typename Handler>
-class reactive_socket_accept_op :
-  public reactive_socket_accept_op_base<Socket, Protocol>
-{
-public:
-  ASIO_DEFINE_HANDLER_PTR(reactive_socket_accept_op);
-
-  reactive_socket_accept_op(socket_type socket,
-      socket_ops::state_type state, Socket& peer, const Protocol& protocol,
-      typename Protocol::endpoint* peer_endpoint, Handler& handler)
-    : reactive_socket_accept_op_base<Socket, Protocol>(socket, state, peer,
-        protocol, peer_endpoint, &reactive_socket_accept_op::do_complete),
-      handler_(ASIO_MOVE_CAST(Handler)(handler))
-  {
-  }
-
-  static void do_complete(io_service_impl* owner, operation* base,
-      const asio::error_code& /*ec*/,
-      std::size_t /*bytes_transferred*/)
-  {
-    // Take ownership of the handler object.
-    reactive_socket_accept_op* o(static_cast<reactive_socket_accept_op*>(base));
-    ptr p = { asio::detail::addressof(o->handler_), o, o };
-
-    ASIO_HANDLER_COMPLETION((o));
-
-    // Make a copy of the handler so that the memory can be deallocated before
-    // the upcall is made. Even if we're not about to make an upcall, a
-    // sub-object of the handler may be the true owner of the memory associated
-    // with the handler. Consequently, a local copy of the handler is required
-    // to ensure that any owning sub-object remains valid until after we have
-    // deallocated the memory here.
-    detail::binder1<Handler, asio::error_code>
-      handler(o->handler_, o->ec_);
-    p.h = asio::detail::addressof(handler.handler_);
-    p.reset();
-
-    // Make the upcall if required.
-    if (owner)
-    {
-      fenced_block b(fenced_block::half);
-      ASIO_HANDLER_INVOCATION_BEGIN((handler.arg1_));
-      asio_handler_invoke_helpers::invoke(handler, handler.handler_);
-      ASIO_HANDLER_INVOCATION_END;
-    }
-  }
-
-private:
-  Handler handler_;
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_DETAIL_REACTIVE_SOCKET_ACCEPT_OP_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/reactive_socket_connect_op.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/reactive_socket_connect_op.hpp
deleted file mode 100644
index 5f15221e6aca..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/reactive_socket_connect_op.hpp
+++ /dev/null
@@ -1,106 +0,0 @@
-//
-// detail/reactive_socket_connect_op.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_REACTIVE_SOCKET_CONNECT_OP_HPP
-#define ASIO_DETAIL_REACTIVE_SOCKET_CONNECT_OP_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include "asio/detail/addressof.hpp"
-#include "asio/detail/bind_handler.hpp"
-#include "asio/detail/buffer_sequence_adapter.hpp"
-#include "asio/detail/fenced_block.hpp"
-#include "asio/detail/reactor_op.hpp"
-#include "asio/detail/socket_ops.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-class reactive_socket_connect_op_base : public reactor_op
-{
-public:
-  reactive_socket_connect_op_base(socket_type socket, func_type complete_func)
-    : reactor_op(&reactive_socket_connect_op_base::do_perform, complete_func),
-      socket_(socket)
-  {
-  }
-
-  static bool do_perform(reactor_op* base)
-  {
-    reactive_socket_connect_op_base* o(
-        static_cast<reactive_socket_connect_op_base*>(base));
-
-    return socket_ops::non_blocking_connect(o->socket_, o->ec_);
-  }
-
-private:
-  socket_type socket_;
-};
-
-template <typename Handler>
-class reactive_socket_connect_op : public reactive_socket_connect_op_base
-{
-public:
-  ASIO_DEFINE_HANDLER_PTR(reactive_socket_connect_op);
-
-  reactive_socket_connect_op(socket_type socket, Handler& handler)
-    : reactive_socket_connect_op_base(socket,
-        &reactive_socket_connect_op::do_complete),
-      handler_(ASIO_MOVE_CAST(Handler)(handler))
-  {
-  }
-
-  static void do_complete(io_service_impl* owner, operation* base,
-      const asio::error_code& /*ec*/,
-      std::size_t /*bytes_transferred*/)
-  {
-    // Take ownership of the handler object.
-    reactive_socket_connect_op* o
-      (static_cast<reactive_socket_connect_op*>(base));
-    ptr p = { asio::detail::addressof(o->handler_), o, o };
-
-    ASIO_HANDLER_COMPLETION((o));
-
-    // Make a copy of the handler so that the memory can be deallocated before
-    // the upcall is made. Even if we're not about to make an upcall, a
-    // sub-object of the handler may be the true owner of the memory associated
-    // with the handler. Consequently, a local copy of the handler is required
-    // to ensure that any owning sub-object remains valid until after we have
-    // deallocated the memory here.
-    detail::binder1<Handler, asio::error_code>
-      handler(o->handler_, o->ec_);
-    p.h = asio::detail::addressof(handler.handler_);
-    p.reset();
-
-    // Make the upcall if required.
-    if (owner)
-    {
-      fenced_block b(fenced_block::half);
-      ASIO_HANDLER_INVOCATION_BEGIN((handler.arg1_));
-      asio_handler_invoke_helpers::invoke(handler, handler);
-      ASIO_HANDLER_INVOCATION_END;
-    }
-  }
-
-private:
-  Handler handler_;
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_DETAIL_REACTIVE_SOCKET_CONNECT_OP_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/reactive_socket_recv_op.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/reactive_socket_recv_op.hpp
deleted file mode 100644
index 1e8b8d067332..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/reactive_socket_recv_op.hpp
+++ /dev/null
@@ -1,123 +0,0 @@
-//
-// detail/reactive_socket_recv_op.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_REACTIVE_SOCKET_RECV_OP_HPP
-#define ASIO_DETAIL_REACTIVE_SOCKET_RECV_OP_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include "asio/detail/addressof.hpp"
-#include "asio/detail/bind_handler.hpp"
-#include "asio/detail/buffer_sequence_adapter.hpp"
-#include "asio/detail/fenced_block.hpp"
-#include "asio/detail/reactor_op.hpp"
-#include "asio/detail/socket_ops.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-template <typename MutableBufferSequence>
-class reactive_socket_recv_op_base : public reactor_op
-{
-public:
-  reactive_socket_recv_op_base(socket_type socket,
-      socket_ops::state_type state, const MutableBufferSequence& buffers,
-      socket_base::message_flags flags, func_type complete_func)
-    : reactor_op(&reactive_socket_recv_op_base::do_perform, complete_func),
-      socket_(socket),
-      state_(state),
-      buffers_(buffers),
-      flags_(flags)
-  {
-  }
-
-  static bool do_perform(reactor_op* base)
-  {
-    reactive_socket_recv_op_base* o(
-        static_cast<reactive_socket_recv_op_base*>(base));
-
-    buffer_sequence_adapter<asio::mutable_buffer,
-        MutableBufferSequence> bufs(o->buffers_);
-
-    return socket_ops::non_blocking_recv(o->socket_,
-        bufs.buffers(), bufs.count(), o->flags_,
-        (o->state_ & socket_ops::stream_oriented) != 0,
-        o->ec_, o->bytes_transferred_);
-  }
-
-private:
-  socket_type socket_;
-  socket_ops::state_type state_;
-  MutableBufferSequence buffers_;
-  socket_base::message_flags flags_;
-};
-
-template <typename MutableBufferSequence, typename Handler>
-class reactive_socket_recv_op :
-  public reactive_socket_recv_op_base<MutableBufferSequence>
-{
-public:
-  ASIO_DEFINE_HANDLER_PTR(reactive_socket_recv_op);
-
-  reactive_socket_recv_op(socket_type socket,
-      socket_ops::state_type state, const MutableBufferSequence& buffers,
-      socket_base::message_flags flags, Handler& handler)
-    : reactive_socket_recv_op_base<MutableBufferSequence>(socket, state,
-        buffers, flags, &reactive_socket_recv_op::do_complete),
-      handler_(ASIO_MOVE_CAST(Handler)(handler))
-  {
-  }
-
-  static void do_complete(io_service_impl* owner, operation* base,
-      const asio::error_code& /*ec*/,
-      std::size_t /*bytes_transferred*/)
-  {
-    // Take ownership of the handler object.
-    reactive_socket_recv_op* o(static_cast<reactive_socket_recv_op*>(base));
-    ptr p = { asio::detail::addressof(o->handler_), o, o };
-
-    ASIO_HANDLER_COMPLETION((o));
-
-    // Make a copy of the handler so that the memory can be deallocated before
-    // the upcall is made. Even if we're not about to make an upcall, a
-    // sub-object of the handler may be the true owner of the memory associated
-    // with the handler. Consequently, a local copy of the handler is required
-    // to ensure that any owning sub-object remains valid until after we have
-    // deallocated the memory here.
-    detail::binder2<Handler, asio::error_code, std::size_t>
-      handler(o->handler_, o->ec_, o->bytes_transferred_);
-    p.h = asio::detail::addressof(handler.handler_);
-    p.reset();
-
-    // Make the upcall if required.
-    if (owner)
-    {
-      fenced_block b(fenced_block::half);
-      ASIO_HANDLER_INVOCATION_BEGIN((handler.arg1_, handler.arg2_));
-      asio_handler_invoke_helpers::invoke(handler, handler.handler_);
-      ASIO_HANDLER_INVOCATION_END;
-    }
-  }
-
-private:
-  Handler handler_;
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_DETAIL_REACTIVE_SOCKET_RECV_OP_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/reactive_socket_recvfrom_op.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/reactive_socket_recvfrom_op.hpp
deleted file mode 100644
index 32da2b3aa62e..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/reactive_socket_recvfrom_op.hpp
+++ /dev/null
@@ -1,133 +0,0 @@
-//
-// detail/reactive_socket_recvfrom_op.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_REACTIVE_SOCKET_RECVFROM_OP_HPP
-#define ASIO_DETAIL_REACTIVE_SOCKET_RECVFROM_OP_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include "asio/detail/addressof.hpp"
-#include "asio/detail/bind_handler.hpp"
-#include "asio/detail/buffer_sequence_adapter.hpp"
-#include "asio/detail/fenced_block.hpp"
-#include "asio/detail/reactor_op.hpp"
-#include "asio/detail/socket_ops.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-template <typename MutableBufferSequence, typename Endpoint>
-class reactive_socket_recvfrom_op_base : public reactor_op
-{
-public:
-  reactive_socket_recvfrom_op_base(socket_type socket, int protocol_type,
-      const MutableBufferSequence& buffers, Endpoint& endpoint,
-      socket_base::message_flags flags, func_type complete_func)
-    : reactor_op(&reactive_socket_recvfrom_op_base::do_perform, complete_func),
-      socket_(socket),
-      protocol_type_(protocol_type),
-      buffers_(buffers),
-      sender_endpoint_(endpoint),
-      flags_(flags)
-  {
-  }
-
-  static bool do_perform(reactor_op* base)
-  {
-    reactive_socket_recvfrom_op_base* o(
-        static_cast<reactive_socket_recvfrom_op_base*>(base));
-
-    buffer_sequence_adapter<asio::mutable_buffer,
-        MutableBufferSequence> bufs(o->buffers_);
-
-    std::size_t addr_len = o->sender_endpoint_.capacity();
-    bool result = socket_ops::non_blocking_recvfrom(o->socket_,
-        bufs.buffers(), bufs.count(), o->flags_,
-        o->sender_endpoint_.data(), &addr_len,
-        o->ec_, o->bytes_transferred_);
-
-    if (result && !o->ec_)
-      o->sender_endpoint_.resize(addr_len);
-
-    return result;
-  }
-
-private:
-  socket_type socket_;
-  int protocol_type_;
-  MutableBufferSequence buffers_;
-  Endpoint& sender_endpoint_;
-  socket_base::message_flags flags_;
-};
-
-template <typename MutableBufferSequence, typename Endpoint, typename Handler>
-class reactive_socket_recvfrom_op :
-  public reactive_socket_recvfrom_op_base<MutableBufferSequence, Endpoint>
-{
-public:
-  ASIO_DEFINE_HANDLER_PTR(reactive_socket_recvfrom_op);
-
-  reactive_socket_recvfrom_op(socket_type socket, int protocol_type,
-      const MutableBufferSequence& buffers, Endpoint& endpoint,
-      socket_base::message_flags flags, Handler& handler)
-    : reactive_socket_recvfrom_op_base<MutableBufferSequence, Endpoint>(
-        socket, protocol_type, buffers, endpoint, flags,
-        &reactive_socket_recvfrom_op::do_complete),
-      handler_(ASIO_MOVE_CAST(Handler)(handler))
-  {
-  }
-
-  static void do_complete(io_service_impl* owner, operation* base,
-      const asio::error_code& /*ec*/,
-      std::size_t /*bytes_transferred*/)
-  {
-    // Take ownership of the handler object.
-    reactive_socket_recvfrom_op* o(
-        static_cast<reactive_socket_recvfrom_op*>(base));
-    ptr p = { asio::detail::addressof(o->handler_), o, o };
-
-    ASIO_HANDLER_COMPLETION((o));
-
-    // Make a copy of the handler so that the memory can be deallocated before
-    // the upcall is made. Even if we're not about to make an upcall, a
-    // sub-object of the handler may be the true owner of the memory associated
-    // with the handler. Consequently, a local copy of the handler is required
-    // to ensure that any owning sub-object remains valid until after we have
-    // deallocated the memory here.
-    detail::binder2<Handler, asio::error_code, std::size_t>
-      handler(o->handler_, o->ec_, o->bytes_transferred_);
-    p.h = asio::detail::addressof(handler.handler_);
-    p.reset();
-
-    // Make the upcall if required.
-    if (owner)
-    {
-      fenced_block b(fenced_block::half);
-      ASIO_HANDLER_INVOCATION_BEGIN((handler.arg1_, handler.arg2_));
-      asio_handler_invoke_helpers::invoke(handler, handler.handler_);
-      ASIO_HANDLER_INVOCATION_END;
-    }
-  }
-
-private:
-  Handler handler_;
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_DETAIL_REACTIVE_SOCKET_RECVFROM_OP_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/reactive_socket_recvmsg_op.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/reactive_socket_recvmsg_op.hpp
deleted file mode 100644
index 13f3f8c8e450..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/reactive_socket_recvmsg_op.hpp
+++ /dev/null
@@ -1,125 +0,0 @@
-//
-// detail/reactive_socket_recvmsg_op.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_REACTIVE_SOCKET_RECVMSG_OP_HPP
-#define ASIO_DETAIL_REACTIVE_SOCKET_RECVMSG_OP_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include "asio/detail/addressof.hpp"
-#include "asio/detail/bind_handler.hpp"
-#include "asio/detail/buffer_sequence_adapter.hpp"
-#include "asio/detail/fenced_block.hpp"
-#include "asio/detail/reactor_op.hpp"
-#include "asio/detail/socket_ops.hpp"
-#include "asio/socket_base.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-template <typename MutableBufferSequence>
-class reactive_socket_recvmsg_op_base : public reactor_op
-{
-public:
-  reactive_socket_recvmsg_op_base(socket_type socket,
-      const MutableBufferSequence& buffers, socket_base::message_flags in_flags,
-      socket_base::message_flags& out_flags, func_type complete_func)
-    : reactor_op(&reactive_socket_recvmsg_op_base::do_perform, complete_func),
-      socket_(socket),
-      buffers_(buffers),
-      in_flags_(in_flags),
-      out_flags_(out_flags)
-  {
-  }
-
-  static bool do_perform(reactor_op* base)
-  {
-    reactive_socket_recvmsg_op_base* o(
-        static_cast<reactive_socket_recvmsg_op_base*>(base));
-
-    buffer_sequence_adapter<asio::mutable_buffer,
-        MutableBufferSequence> bufs(o->buffers_);
-
-    return socket_ops::non_blocking_recvmsg(o->socket_,
-        bufs.buffers(), bufs.count(),
-        o->in_flags_, o->out_flags_,
-        o->ec_, o->bytes_transferred_);
-  }
-
-private:
-  socket_type socket_;
-  MutableBufferSequence buffers_;
-  socket_base::message_flags in_flags_;
-  socket_base::message_flags& out_flags_;
-};
-
-template <typename MutableBufferSequence, typename Handler>
-class reactive_socket_recvmsg_op :
-  public reactive_socket_recvmsg_op_base<MutableBufferSequence>
-{
-public:
-  ASIO_DEFINE_HANDLER_PTR(reactive_socket_recvmsg_op);
-
-  reactive_socket_recvmsg_op(socket_type socket,
-      const MutableBufferSequence& buffers, socket_base::message_flags in_flags,
-      socket_base::message_flags& out_flags, Handler& handler)
-    : reactive_socket_recvmsg_op_base<MutableBufferSequence>(socket, buffers,
-        in_flags, out_flags, &reactive_socket_recvmsg_op::do_complete),
-      handler_(ASIO_MOVE_CAST(Handler)(handler))
-  {
-  }
-
-  static void do_complete(io_service_impl* owner, operation* base,
-      const asio::error_code& /*ec*/,
-      std::size_t /*bytes_transferred*/)
-  {
-    // Take ownership of the handler object.
-    reactive_socket_recvmsg_op* o(
-        static_cast<reactive_socket_recvmsg_op*>(base));
-    ptr p = { asio::detail::addressof(o->handler_), o, o };
-
-    ASIO_HANDLER_COMPLETION((o));
-
-    // Make a copy of the handler so that the memory can be deallocated before
-    // the upcall is made. Even if we're not about to make an upcall, a
-    // sub-object of the handler may be the true owner of the memory associated
-    // with the handler. Consequently, a local copy of the handler is required
-    // to ensure that any owning sub-object remains valid until after we have
-    // deallocated the memory here.
-    detail::binder2<Handler, asio::error_code, std::size_t>
-      handler(o->handler_, o->ec_, o->bytes_transferred_);
-    p.h = asio::detail::addressof(handler.handler_);
-    p.reset();
-
-    // Make the upcall if required.
-    if (owner)
-    {
-      fenced_block b(fenced_block::half);
-      ASIO_HANDLER_INVOCATION_BEGIN((handler.arg1_, handler.arg2_));
-      asio_handler_invoke_helpers::invoke(handler, handler.handler_);
-      ASIO_HANDLER_INVOCATION_END;
-    }
-  }
-
-private:
-  Handler handler_;
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_DETAIL_REACTIVE_SOCKET_RECVMSG_OP_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/reactive_socket_send_op.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/reactive_socket_send_op.hpp
deleted file mode 100644
index 3862a7f7793d..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/reactive_socket_send_op.hpp
+++ /dev/null
@@ -1,120 +0,0 @@
-//
-// detail/reactive_socket_send_op.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_REACTIVE_SOCKET_SEND_OP_HPP
-#define ASIO_DETAIL_REACTIVE_SOCKET_SEND_OP_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include "asio/detail/addressof.hpp"
-#include "asio/detail/bind_handler.hpp"
-#include "asio/detail/buffer_sequence_adapter.hpp"
-#include "asio/detail/fenced_block.hpp"
-#include "asio/detail/reactor_op.hpp"
-#include "asio/detail/socket_ops.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-template <typename ConstBufferSequence>
-class reactive_socket_send_op_base : public reactor_op
-{
-public:
-  reactive_socket_send_op_base(socket_type socket,
-      const ConstBufferSequence& buffers,
-      socket_base::message_flags flags, func_type complete_func)
-    : reactor_op(&reactive_socket_send_op_base::do_perform, complete_func),
-      socket_(socket),
-      buffers_(buffers),
-      flags_(flags)
-  {
-  }
-
-  static bool do_perform(reactor_op* base)
-  {
-    reactive_socket_send_op_base* o(
-        static_cast<reactive_socket_send_op_base*>(base));
-
-    buffer_sequence_adapter<asio::const_buffer,
-        ConstBufferSequence> bufs(o->buffers_);
-
-    return socket_ops::non_blocking_send(o->socket_,
-          bufs.buffers(), bufs.count(), o->flags_,
-          o->ec_, o->bytes_transferred_);
-  }
-
-private:
-  socket_type socket_;
-  ConstBufferSequence buffers_;
-  socket_base::message_flags flags_;
-};
-
-template <typename ConstBufferSequence, typename Handler>
-class reactive_socket_send_op :
-  public reactive_socket_send_op_base<ConstBufferSequence>
-{
-public:
-  ASIO_DEFINE_HANDLER_PTR(reactive_socket_send_op);
-
-  reactive_socket_send_op(socket_type socket,
-      const ConstBufferSequence& buffers,
-      socket_base::message_flags flags, Handler& handler)
-    : reactive_socket_send_op_base<ConstBufferSequence>(socket,
-        buffers, flags, &reactive_socket_send_op::do_complete),
-      handler_(ASIO_MOVE_CAST(Handler)(handler))
-  {
-  }
-
-  static void do_complete(io_service_impl* owner, operation* base,
-      const asio::error_code& /*ec*/,
-      std::size_t /*bytes_transferred*/)
-  {
-    // Take ownership of the handler object.
-    reactive_socket_send_op* o(static_cast<reactive_socket_send_op*>(base));
-    ptr p = { asio::detail::addressof(o->handler_), o, o };
-
-    ASIO_HANDLER_COMPLETION((o));
-
-    // Make a copy of the handler so that the memory can be deallocated before
-    // the upcall is made. Even if we're not about to make an upcall, a
-    // sub-object of the handler may be the true owner of the memory associated
-    // with the handler. Consequently, a local copy of the handler is required
-    // to ensure that any owning sub-object remains valid until after we have
-    // deallocated the memory here.
-    detail::binder2<Handler, asio::error_code, std::size_t>
-      handler(o->handler_, o->ec_, o->bytes_transferred_);
-    p.h = asio::detail::addressof(handler.handler_);
-    p.reset();
-
-    // Make the upcall if required.
-    if (owner)
-    {
-      fenced_block b(fenced_block::half);
-      ASIO_HANDLER_INVOCATION_BEGIN((handler.arg1_, handler.arg2_));
-      asio_handler_invoke_helpers::invoke(handler, handler.handler_);
-      ASIO_HANDLER_INVOCATION_END;
-    }
-  }
-
-private:
-  Handler handler_;
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_DETAIL_REACTIVE_SOCKET_SEND_OP_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/reactive_socket_sendto_op.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/reactive_socket_sendto_op.hpp
deleted file mode 100644
index fa2ac4585576..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/reactive_socket_sendto_op.hpp
+++ /dev/null
@@ -1,123 +0,0 @@
-//
-// detail/reactive_socket_sendto_op.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_REACTIVE_SOCKET_SENDTO_OP_HPP
-#define ASIO_DETAIL_REACTIVE_SOCKET_SENDTO_OP_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include "asio/detail/addressof.hpp"
-#include "asio/detail/bind_handler.hpp"
-#include "asio/detail/buffer_sequence_adapter.hpp"
-#include "asio/detail/fenced_block.hpp"
-#include "asio/detail/reactor_op.hpp"
-#include "asio/detail/socket_ops.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-template <typename ConstBufferSequence, typename Endpoint>
-class reactive_socket_sendto_op_base : public reactor_op
-{
-public:
-  reactive_socket_sendto_op_base(socket_type socket,
-      const ConstBufferSequence& buffers, const Endpoint& endpoint,
-      socket_base::message_flags flags, func_type complete_func)
-    : reactor_op(&reactive_socket_sendto_op_base::do_perform, complete_func),
-      socket_(socket),
-      buffers_(buffers),
-      destination_(endpoint),
-      flags_(flags)
-  {
-  }
-
-  static bool do_perform(reactor_op* base)
-  {
-    reactive_socket_sendto_op_base* o(
-        static_cast<reactive_socket_sendto_op_base*>(base));
-
-    buffer_sequence_adapter<asio::const_buffer,
-        ConstBufferSequence> bufs(o->buffers_);
-
-    return socket_ops::non_blocking_sendto(o->socket_,
-          bufs.buffers(), bufs.count(), o->flags_,
-          o->destination_.data(), o->destination_.size(),
-          o->ec_, o->bytes_transferred_);
-  }
-
-private:
-  socket_type socket_;
-  ConstBufferSequence buffers_;
-  Endpoint destination_;
-  socket_base::message_flags flags_;
-};
-
-template <typename ConstBufferSequence, typename Endpoint, typename Handler>
-class reactive_socket_sendto_op :
-  public reactive_socket_sendto_op_base<ConstBufferSequence, Endpoint>
-{
-public:
-  ASIO_DEFINE_HANDLER_PTR(reactive_socket_sendto_op);
-
-  reactive_socket_sendto_op(socket_type socket,
-      const ConstBufferSequence& buffers, const Endpoint& endpoint,
-      socket_base::message_flags flags, Handler& handler)
-    : reactive_socket_sendto_op_base<ConstBufferSequence, Endpoint>(socket,
-        buffers, endpoint, flags, &reactive_socket_sendto_op::do_complete),
-      handler_(ASIO_MOVE_CAST(Handler)(handler))
-  {
-  }
-
-  static void do_complete(io_service_impl* owner, operation* base,
-      const asio::error_code& /*ec*/,
-      std::size_t /*bytes_transferred*/)
-  {
-    // Take ownership of the handler object.
-    reactive_socket_sendto_op* o(static_cast<reactive_socket_sendto_op*>(base));
-    ptr p = { asio::detail::addressof(o->handler_), o, o };
-
-    ASIO_HANDLER_COMPLETION((o));
-
-    // Make a copy of the handler so that the memory can be deallocated before
-    // the upcall is made. Even if we're not about to make an upcall, a
-    // sub-object of the handler may be the true owner of the memory associated
-    // with the handler. Consequently, a local copy of the handler is required
-    // to ensure that any owning sub-object remains valid until after we have
-    // deallocated the memory here.
-    detail::binder2<Handler, asio::error_code, std::size_t>
-      handler(o->handler_, o->ec_, o->bytes_transferred_);
-    p.h = asio::detail::addressof(handler.handler_);
-    p.reset();
-
-    // Make the upcall if required.
-    if (owner)
-    {
-      fenced_block b(fenced_block::half);
-      ASIO_HANDLER_INVOCATION_BEGIN((handler.arg1_, handler.arg2_));
-      asio_handler_invoke_helpers::invoke(handler, handler.handler_);
-      ASIO_HANDLER_INVOCATION_END;
-    }
-  }
-
-private:
-  Handler handler_;
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_DETAIL_REACTIVE_SOCKET_SENDTO_OP_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/reactive_socket_service.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/reactive_socket_service.hpp
deleted file mode 100644
index c7f77b154b67..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/reactive_socket_service.hpp
+++ /dev/null
@@ -1,457 +0,0 @@
-//
-// detail/reactive_socket_service.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_REACTIVE_SOCKET_SERVICE_HPP
-#define ASIO_DETAIL_REACTIVE_SOCKET_SERVICE_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if !defined(ASIO_HAS_IOCP)
-
-#include "asio/buffer.hpp"
-#include "asio/error.hpp"
-#include "asio/io_service.hpp"
-#include "asio/socket_base.hpp"
-#include "asio/detail/addressof.hpp"
-#include "asio/detail/buffer_sequence_adapter.hpp"
-#include "asio/detail/noncopyable.hpp"
-#include "asio/detail/reactive_null_buffers_op.hpp"
-#include "asio/detail/reactive_socket_accept_op.hpp"
-#include "asio/detail/reactive_socket_connect_op.hpp"
-#include "asio/detail/reactive_socket_recvfrom_op.hpp"
-#include "asio/detail/reactive_socket_sendto_op.hpp"
-#include "asio/detail/reactive_socket_service_base.hpp"
-#include "asio/detail/reactor.hpp"
-#include "asio/detail/reactor_op.hpp"
-#include "asio/detail/socket_holder.hpp"
-#include "asio/detail/socket_ops.hpp"
-#include "asio/detail/socket_types.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-template <typename Protocol>
-class reactive_socket_service :
-  public reactive_socket_service_base
-{
-public:
-  // The protocol type.
-  typedef Protocol protocol_type;
-
-  // The endpoint type.
-  typedef typename Protocol::endpoint endpoint_type;
-
-  // The native type of a socket.
-  typedef socket_type native_handle_type;
-
-  // The implementation type of the socket.
-  struct implementation_type :
-    reactive_socket_service_base::base_implementation_type
-  {
-    // Default constructor.
-    implementation_type()
-      : protocol_(endpoint_type().protocol())
-    {
-    }
-
-    // The protocol associated with the socket.
-    protocol_type protocol_;
-  };
-
-  // Constructor.
-  reactive_socket_service(asio::io_service& io_service)
-    : reactive_socket_service_base(io_service)
-  {
-  }
-
-  // Move-construct a new socket implementation.
-  void move_construct(implementation_type& impl,
-      implementation_type& other_impl)
-  {
-    this->base_move_construct(impl, other_impl);
-
-    impl.protocol_ = other_impl.protocol_;
-    other_impl.protocol_ = endpoint_type().protocol();
-  }
-
-  // Move-assign from another socket implementation.
-  void move_assign(implementation_type& impl,
-      reactive_socket_service_base& other_service,
-      implementation_type& other_impl)
-  {
-    this->base_move_assign(impl, other_service, other_impl);
-
-    impl.protocol_ = other_impl.protocol_;
-    other_impl.protocol_ = endpoint_type().protocol();
-  }
-
-  // Move-construct a new socket implementation from another protocol type.
-  template <typename Protocol1>
-  void converting_move_construct(implementation_type& impl,
-      typename reactive_socket_service<
-        Protocol1>::implementation_type& other_impl)
-  {
-    this->base_move_construct(impl, other_impl);
-
-    impl.protocol_ = protocol_type(other_impl.protocol_);
-    other_impl.protocol_ = typename Protocol1::endpoint().protocol();
-  }
-
-  // Open a new socket implementation.
-  asio::error_code open(implementation_type& impl,
-      const protocol_type& protocol, asio::error_code& ec)
-  {
-    if (!do_open(impl, protocol.family(),
-          protocol.type(), protocol.protocol(), ec))
-      impl.protocol_ = protocol;
-    return ec;
-  }
-
-  // Assign a native socket to a socket implementation.
-  asio::error_code assign(implementation_type& impl,
-      const protocol_type& protocol, const native_handle_type& native_socket,
-      asio::error_code& ec)
-  {
-    if (!do_assign(impl, protocol.type(), native_socket, ec))
-      impl.protocol_ = protocol;
-    return ec;
-  }
-
-  // Get the native socket representation.
-  native_handle_type native_handle(implementation_type& impl)
-  {
-    return impl.socket_;
-  }
-
-  // Bind the socket to the specified local endpoint.
-  asio::error_code bind(implementation_type& impl,
-      const endpoint_type& endpoint, asio::error_code& ec)
-  {
-    socket_ops::bind(impl.socket_, endpoint.data(), endpoint.size(), ec);
-    return ec;
-  }
-
-  // Set a socket option.
-  template <typename Option>
-  asio::error_code set_option(implementation_type& impl,
-      const Option& option, asio::error_code& ec)
-  {
-    socket_ops::setsockopt(impl.socket_, impl.state_,
-        option.level(impl.protocol_), option.name(impl.protocol_),
-        option.data(impl.protocol_), option.size(impl.protocol_), ec);
-    return ec;
-  }
-
-  // Set a socket option.
-  template <typename Option>
-  asio::error_code get_option(const implementation_type& impl,
-      Option& option, asio::error_code& ec) const
-  {
-    std::size_t size = option.size(impl.protocol_);
-    socket_ops::getsockopt(impl.socket_, impl.state_,
-        option.level(impl.protocol_), option.name(impl.protocol_),
-        option.data(impl.protocol_), &size, ec);
-    if (!ec)
-      option.resize(impl.protocol_, size);
-    return ec;
-  }
-
-  // Get the local endpoint.
-  endpoint_type local_endpoint(const implementation_type& impl,
-      asio::error_code& ec) const
-  {
-    endpoint_type endpoint;
-    std::size_t addr_len = endpoint.capacity();
-    if (socket_ops::getsockname(impl.socket_, endpoint.data(), &addr_len, ec))
-      return endpoint_type();
-    endpoint.resize(addr_len);
-    return endpoint;
-  }
-
-  // Get the remote endpoint.
-  endpoint_type remote_endpoint(const implementation_type& impl,
-      asio::error_code& ec) const
-  {
-    endpoint_type endpoint;
-    std::size_t addr_len = endpoint.capacity();
-    if (socket_ops::getpeername(impl.socket_,
-          endpoint.data(), &addr_len, false, ec))
-      return endpoint_type();
-    endpoint.resize(addr_len);
-    return endpoint;
-  }
-
-  // Send a datagram to the specified endpoint. Returns the number of bytes
-  // sent.
-  template <typename ConstBufferSequence>
-  size_t send_to(implementation_type& impl, const ConstBufferSequence& buffers,
-      const endpoint_type& destination, socket_base::message_flags flags,
-      asio::error_code& ec)
-  {
-    buffer_sequence_adapter<asio::const_buffer,
-        ConstBufferSequence> bufs(buffers);
-
-    return socket_ops::sync_sendto(impl.socket_, impl.state_,
-        bufs.buffers(), bufs.count(), flags,
-        destination.data(), destination.size(), ec);
-  }
-
-  // Wait until data can be sent without blocking.
-  size_t send_to(implementation_type& impl, const null_buffers&,
-      const endpoint_type&, socket_base::message_flags,
-      asio::error_code& ec)
-  {
-    // Wait for socket to become ready.
-    socket_ops::poll_write(impl.socket_, impl.state_, ec);
-
-    return 0;
-  }
-
-  // Start an asynchronous send. The data being sent must be valid for the
-  // lifetime of the asynchronous operation.
-  template <typename ConstBufferSequence, typename Handler>
-  void async_send_to(implementation_type& impl,
-      const ConstBufferSequence& buffers,
-      const endpoint_type& destination, socket_base::message_flags flags,
-      Handler& handler)
-  {
-    bool is_continuation =
-      asio_handler_cont_helpers::is_continuation(handler);
-
-    // Allocate and construct an operation to wrap the handler.
-    typedef reactive_socket_sendto_op<ConstBufferSequence,
-        endpoint_type, Handler> op;
-    typename op::ptr p = { asio::detail::addressof(handler),
-      asio_handler_alloc_helpers::allocate(
-        sizeof(op), handler), 0 };
-    p.p = new (p.v) op(impl.socket_, buffers, destination, flags, handler);
-
-    ASIO_HANDLER_CREATION((p.p, "socket", &impl, "async_send_to"));
-
-    start_op(impl, reactor::write_op, p.p, is_continuation, true, false);
-    p.v = p.p = 0;
-  }
-
-  // Start an asynchronous wait until data can be sent without blocking.
-  template <typename Handler>
-  void async_send_to(implementation_type& impl, const null_buffers&,
-      const endpoint_type&, socket_base::message_flags, Handler& handler)
-  {
-    bool is_continuation =
-      asio_handler_cont_helpers::is_continuation(handler);
-
-    // Allocate and construct an operation to wrap the handler.
-    typedef reactive_null_buffers_op<Handler> op;
-    typename op::ptr p = { asio::detail::addressof(handler),
-      asio_handler_alloc_helpers::allocate(
-        sizeof(op), handler), 0 };
-    p.p = new (p.v) op(handler);
-
-    ASIO_HANDLER_CREATION((p.p, "socket",
-          &impl, "async_send_to(null_buffers)"));
-
-    start_op(impl, reactor::write_op, p.p, is_continuation, false, false);
-    p.v = p.p = 0;
-  }
-
-  // Receive a datagram with the endpoint of the sender. Returns the number of
-  // bytes received.
-  template <typename MutableBufferSequence>
-  size_t receive_from(implementation_type& impl,
-      const MutableBufferSequence& buffers,
-      endpoint_type& sender_endpoint, socket_base::message_flags flags,
-      asio::error_code& ec)
-  {
-    buffer_sequence_adapter<asio::mutable_buffer,
-        MutableBufferSequence> bufs(buffers);
-
-    std::size_t addr_len = sender_endpoint.capacity();
-    std::size_t bytes_recvd = socket_ops::sync_recvfrom(
-        impl.socket_, impl.state_, bufs.buffers(), bufs.count(),
-        flags, sender_endpoint.data(), &addr_len, ec);
-
-    if (!ec)
-      sender_endpoint.resize(addr_len);
-
-    return bytes_recvd;
-  }
-
-  // Wait until data can be received without blocking.
-  size_t receive_from(implementation_type& impl, const null_buffers&,
-      endpoint_type& sender_endpoint, socket_base::message_flags,
-      asio::error_code& ec)
-  {
-    // Wait for socket to become ready.
-    socket_ops::poll_read(impl.socket_, impl.state_, ec);
-
-    // Reset endpoint since it can be given no sensible value at this time.
-    sender_endpoint = endpoint_type();
-
-    return 0;
-  }
-
-  // Start an asynchronous receive. The buffer for the data being received and
-  // the sender_endpoint object must both be valid for the lifetime of the
-  // asynchronous operation.
-  template <typename MutableBufferSequence, typename Handler>
-  void async_receive_from(implementation_type& impl,
-      const MutableBufferSequence& buffers, endpoint_type& sender_endpoint,
-      socket_base::message_flags flags, Handler& handler)
-  {
-    bool is_continuation =
-      asio_handler_cont_helpers::is_continuation(handler);
-
-    // Allocate and construct an operation to wrap the handler.
-    typedef reactive_socket_recvfrom_op<MutableBufferSequence,
-        endpoint_type, Handler> op;
-    typename op::ptr p = { asio::detail::addressof(handler),
-      asio_handler_alloc_helpers::allocate(
-        sizeof(op), handler), 0 };
-    int protocol = impl.protocol_.type();
-    p.p = new (p.v) op(impl.socket_, protocol,
-        buffers, sender_endpoint, flags, handler);
-
-    ASIO_HANDLER_CREATION((p.p, "socket",
-          &impl, "async_receive_from"));
-
-    start_op(impl,
-        (flags & socket_base::message_out_of_band)
-          ? reactor::except_op : reactor::read_op,
-        p.p, is_continuation, true, false);
-    p.v = p.p = 0;
-  }
-
-  // Wait until data can be received without blocking.
-  template <typename Handler>
-  void async_receive_from(implementation_type& impl,
-      const null_buffers&, endpoint_type& sender_endpoint,
-      socket_base::message_flags flags, Handler& handler)
-  {
-    bool is_continuation =
-      asio_handler_cont_helpers::is_continuation(handler);
-
-    // Allocate and construct an operation to wrap the handler.
-    typedef reactive_null_buffers_op<Handler> op;
-    typename op::ptr p = { asio::detail::addressof(handler),
-      asio_handler_alloc_helpers::allocate(
-        sizeof(op), handler), 0 };
-    p.p = new (p.v) op(handler);
-
-    ASIO_HANDLER_CREATION((p.p, "socket",
-          &impl, "async_receive_from(null_buffers)"));
-
-    // Reset endpoint since it can be given no sensible value at this time.
-    sender_endpoint = endpoint_type();
-
-    start_op(impl,
-        (flags & socket_base::message_out_of_band)
-          ? reactor::except_op : reactor::read_op,
-        p.p, is_continuation, false, false);
-    p.v = p.p = 0;
-  }
-
-  // Accept a new connection.
-  template <typename Socket>
-  asio::error_code accept(implementation_type& impl,
-      Socket& peer, endpoint_type* peer_endpoint, asio::error_code& ec)
-  {
-    // We cannot accept a socket that is already open.
-    if (peer.is_open())
-    {
-      ec = asio::error::already_open;
-      return ec;
-    }
-
-    std::size_t addr_len = peer_endpoint ? peer_endpoint->capacity() : 0;
-    socket_holder new_socket(socket_ops::sync_accept(impl.socket_,
-          impl.state_, peer_endpoint ? peer_endpoint->data() : 0,
-          peer_endpoint ? &addr_len : 0, ec));
-
-    // On success, assign new connection to peer socket object.
-    if (new_socket.get() != invalid_socket)
-    {
-      if (peer_endpoint)
-        peer_endpoint->resize(addr_len);
-      if (!peer.assign(impl.protocol_, new_socket.get(), ec))
-        new_socket.release();
-    }
-
-    return ec;
-  }
-
-  // Start an asynchronous accept. The peer and peer_endpoint objects
-  // must be valid until the accept's handler is invoked.
-  template <typename Socket, typename Handler>
-  void async_accept(implementation_type& impl, Socket& peer,
-      endpoint_type* peer_endpoint, Handler& handler)
-  {
-    bool is_continuation =
-      asio_handler_cont_helpers::is_continuation(handler);
-
-    // Allocate and construct an operation to wrap the handler.
-    typedef reactive_socket_accept_op<Socket, Protocol, Handler> op;
-    typename op::ptr p = { asio::detail::addressof(handler),
-      asio_handler_alloc_helpers::allocate(
-        sizeof(op), handler), 0 };
-    p.p = new (p.v) op(impl.socket_, impl.state_, peer,
-        impl.protocol_, peer_endpoint, handler);
-
-    ASIO_HANDLER_CREATION((p.p, "socket", &impl, "async_accept"));
-
-    start_accept_op(impl, p.p, is_continuation, peer.is_open());
-    p.v = p.p = 0;
-  }
-
-  // Connect the socket to the specified endpoint.
-  asio::error_code connect(implementation_type& impl,
-      const endpoint_type& peer_endpoint, asio::error_code& ec)
-  {
-    socket_ops::sync_connect(impl.socket_,
-        peer_endpoint.data(), peer_endpoint.size(), ec);
-    return ec;
-  }
-
-  // Start an asynchronous connect.
-  template <typename Handler>
-  void async_connect(implementation_type& impl,
-      const endpoint_type& peer_endpoint, Handler& handler)
-  {
-    bool is_continuation =
-      asio_handler_cont_helpers::is_continuation(handler);
-
-    // Allocate and construct an operation to wrap the handler.
-    typedef reactive_socket_connect_op<Handler> op;
-    typename op::ptr p = { asio::detail::addressof(handler),
-      asio_handler_alloc_helpers::allocate(
-        sizeof(op), handler), 0 };
-    p.p = new (p.v) op(impl.socket_, handler);
-
-    ASIO_HANDLER_CREATION((p.p, "socket", &impl, "async_connect"));
-
-    start_connect_op(impl, p.p, is_continuation,
-        peer_endpoint.data(), peer_endpoint.size());
-    p.v = p.p = 0;
-  }
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // !defined(ASIO_HAS_IOCP)
-
-#endif // ASIO_DETAIL_REACTIVE_SOCKET_SERVICE_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/reactive_socket_service_base.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/reactive_socket_service_base.hpp
deleted file mode 100644
index 28e52d71089d..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/reactive_socket_service_base.hpp
+++ /dev/null
@@ -1,450 +0,0 @@
-//
-// detail/reactive_socket_service_base.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_REACTIVE_SOCKET_SERVICE_BASE_HPP
-#define ASIO_DETAIL_REACTIVE_SOCKET_SERVICE_BASE_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if !defined(ASIO_HAS_IOCP) \
-  && !defined(ASIO_WINDOWS_RUNTIME)
-
-#include "asio/buffer.hpp"
-#include "asio/error.hpp"
-#include "asio/io_service.hpp"
-#include "asio/socket_base.hpp"
-#include "asio/detail/addressof.hpp"
-#include "asio/detail/buffer_sequence_adapter.hpp"
-#include "asio/detail/reactive_null_buffers_op.hpp"
-#include "asio/detail/reactive_socket_recv_op.hpp"
-#include "asio/detail/reactive_socket_recvmsg_op.hpp"
-#include "asio/detail/reactive_socket_send_op.hpp"
-#include "asio/detail/reactor.hpp"
-#include "asio/detail/reactor_op.hpp"
-#include "asio/detail/socket_holder.hpp"
-#include "asio/detail/socket_ops.hpp"
-#include "asio/detail/socket_types.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-class reactive_socket_service_base
-{
-public:
-  // The native type of a socket.
-  typedef socket_type native_handle_type;
-
-  // The implementation type of the socket.
-  struct base_implementation_type
-  {
-    // The native socket representation.
-    socket_type socket_;
-
-    // The current state of the socket.
-    socket_ops::state_type state_;
-
-    // Per-descriptor data used by the reactor.
-    reactor::per_descriptor_data reactor_data_;
-  };
-
-  // Constructor.
-  ASIO_DECL reactive_socket_service_base(
-      asio::io_service& io_service);
-
-  // Destroy all user-defined handler objects owned by the service.
-  ASIO_DECL void shutdown_service();
-
-  // Construct a new socket implementation.
-  ASIO_DECL void construct(base_implementation_type& impl);
-
-  // Move-construct a new socket implementation.
-  ASIO_DECL void base_move_construct(base_implementation_type& impl,
-      base_implementation_type& other_impl);
-
-  // Move-assign from another socket implementation.
-  ASIO_DECL void base_move_assign(base_implementation_type& impl,
-      reactive_socket_service_base& other_service,
-      base_implementation_type& other_impl);
-
-  // Destroy a socket implementation.
-  ASIO_DECL void destroy(base_implementation_type& impl);
-
-  // Determine whether the socket is open.
-  bool is_open(const base_implementation_type& impl) const
-  {
-    return impl.socket_ != invalid_socket;
-  }
-
-  // Destroy a socket implementation.
-  ASIO_DECL asio::error_code close(
-      base_implementation_type& impl, asio::error_code& ec);
-
-  // Get the native socket representation.
-  native_handle_type native_handle(base_implementation_type& impl)
-  {
-    return impl.socket_;
-  }
-
-  // Cancel all operations associated with the socket.
-  ASIO_DECL asio::error_code cancel(
-      base_implementation_type& impl, asio::error_code& ec);
-
-  // Determine whether the socket is at the out-of-band data mark.
-  bool at_mark(const base_implementation_type& impl,
-      asio::error_code& ec) const
-  {
-    return socket_ops::sockatmark(impl.socket_, ec);
-  }
-
-  // Determine the number of bytes available for reading.
-  std::size_t available(const base_implementation_type& impl,
-      asio::error_code& ec) const
-  {
-    return socket_ops::available(impl.socket_, ec);
-  }
-
-  // Place the socket into the state where it will listen for new connections.
-  asio::error_code listen(base_implementation_type& impl,
-      int backlog, asio::error_code& ec)
-  {
-    socket_ops::listen(impl.socket_, backlog, ec);
-    return ec;
-  }
-
-  // Perform an IO control command on the socket.
-  template <typename IO_Control_Command>
-  asio::error_code io_control(base_implementation_type& impl,
-      IO_Control_Command& command, asio::error_code& ec)
-  {
-    socket_ops::ioctl(impl.socket_, impl.state_, command.name(),
-        static_cast<ioctl_arg_type*>(command.data()), ec);
-    return ec;
-  }
-
-  // Gets the non-blocking mode of the socket.
-  bool non_blocking(const base_implementation_type& impl) const
-  {
-    return (impl.state_ & socket_ops::user_set_non_blocking) != 0;
-  }
-
-  // Sets the non-blocking mode of the socket.
-  asio::error_code non_blocking(base_implementation_type& impl,
-      bool mode, asio::error_code& ec)
-  {
-    socket_ops::set_user_non_blocking(impl.socket_, impl.state_, mode, ec);
-    return ec;
-  }
-
-  // Gets the non-blocking mode of the native socket implementation.
-  bool native_non_blocking(const base_implementation_type& impl) const
-  {
-    return (impl.state_ & socket_ops::internal_non_blocking) != 0;
-  }
-
-  // Sets the non-blocking mode of the native socket implementation.
-  asio::error_code native_non_blocking(base_implementation_type& impl,
-      bool mode, asio::error_code& ec)
-  {
-    socket_ops::set_internal_non_blocking(impl.socket_, impl.state_, mode, ec);
-    return ec;
-  }
-
-  // Disable sends or receives on the socket.
-  asio::error_code shutdown(base_implementation_type& impl,
-      socket_base::shutdown_type what, asio::error_code& ec)
-  {
-    socket_ops::shutdown(impl.socket_, what, ec);
-    return ec;
-  }
-
-  // Send the given data to the peer.
-  template <typename ConstBufferSequence>
-  size_t send(base_implementation_type& impl,
-      const ConstBufferSequence& buffers,
-      socket_base::message_flags flags, asio::error_code& ec)
-  {
-    buffer_sequence_adapter<asio::const_buffer,
-        ConstBufferSequence> bufs(buffers);
-
-    return socket_ops::sync_send(impl.socket_, impl.state_,
-        bufs.buffers(), bufs.count(), flags, bufs.all_empty(), ec);
-  }
-
-  // Wait until data can be sent without blocking.
-  size_t send(base_implementation_type& impl, const null_buffers&,
-      socket_base::message_flags, asio::error_code& ec)
-  {
-    // Wait for socket to become ready.
-    socket_ops::poll_write(impl.socket_, impl.state_, ec);
-
-    return 0;
-  }
-
-  // Start an asynchronous send. The data being sent must be valid for the
-  // lifetime of the asynchronous operation.
-  template <typename ConstBufferSequence, typename Handler>
-  void async_send(base_implementation_type& impl,
-      const ConstBufferSequence& buffers,
-      socket_base::message_flags flags, Handler& handler)
-  {
-    bool is_continuation =
-      asio_handler_cont_helpers::is_continuation(handler);
-
-    // Allocate and construct an operation to wrap the handler.
-    typedef reactive_socket_send_op<ConstBufferSequence, Handler> op;
-    typename op::ptr p = { asio::detail::addressof(handler),
-      asio_handler_alloc_helpers::allocate(
-        sizeof(op), handler), 0 };
-    p.p = new (p.v) op(impl.socket_, buffers, flags, handler);
-
-    ASIO_HANDLER_CREATION((p.p, "socket", &impl, "async_send"));
-
-    start_op(impl, reactor::write_op, p.p, is_continuation, true,
-        ((impl.state_ & socket_ops::stream_oriented)
-          && buffer_sequence_adapter<asio::const_buffer,
-            ConstBufferSequence>::all_empty(buffers)));
-    p.v = p.p = 0;
-  }
-
-  // Start an asynchronous wait until data can be sent without blocking.
-  template <typename Handler>
-  void async_send(base_implementation_type& impl, const null_buffers&,
-      socket_base::message_flags, Handler& handler)
-  {
-    bool is_continuation =
-      asio_handler_cont_helpers::is_continuation(handler);
-
-    // Allocate and construct an operation to wrap the handler.
-    typedef reactive_null_buffers_op<Handler> op;
-    typename op::ptr p = { asio::detail::addressof(handler),
-      asio_handler_alloc_helpers::allocate(
-        sizeof(op), handler), 0 };
-    p.p = new (p.v) op(handler);
-
-    ASIO_HANDLER_CREATION((p.p, "socket",
-          &impl, "async_send(null_buffers)"));
-
-    start_op(impl, reactor::write_op, p.p, is_continuation, false, false);
-    p.v = p.p = 0;
-  }
-
-  // Receive some data from the peer. Returns the number of bytes received.
-  template <typename MutableBufferSequence>
-  size_t receive(base_implementation_type& impl,
-      const MutableBufferSequence& buffers,
-      socket_base::message_flags flags, asio::error_code& ec)
-  {
-    buffer_sequence_adapter<asio::mutable_buffer,
-        MutableBufferSequence> bufs(buffers);
-
-    return socket_ops::sync_recv(impl.socket_, impl.state_,
-        bufs.buffers(), bufs.count(), flags, bufs.all_empty(), ec);
-  }
-
-  // Wait until data can be received without blocking.
-  size_t receive(base_implementation_type& impl, const null_buffers&,
-      socket_base::message_flags, asio::error_code& ec)
-  {
-    // Wait for socket to become ready.
-    socket_ops::poll_read(impl.socket_, impl.state_, ec);
-
-    return 0;
-  }
-
-  // Start an asynchronous receive. The buffer for the data being received
-  // must be valid for the lifetime of the asynchronous operation.
-  template <typename MutableBufferSequence, typename Handler>
-  void async_receive(base_implementation_type& impl,
-      const MutableBufferSequence& buffers,
-      socket_base::message_flags flags, Handler& handler)
-  {
-    bool is_continuation =
-      asio_handler_cont_helpers::is_continuation(handler);
-
-    // Allocate and construct an operation to wrap the handler.
-    typedef reactive_socket_recv_op<MutableBufferSequence, Handler> op;
-    typename op::ptr p = { asio::detail::addressof(handler),
-      asio_handler_alloc_helpers::allocate(
-        sizeof(op), handler), 0 };
-    p.p = new (p.v) op(impl.socket_, impl.state_, buffers, flags, handler);
-
-    ASIO_HANDLER_CREATION((p.p, "socket", &impl, "async_receive"));
-
-    start_op(impl,
-        (flags & socket_base::message_out_of_band)
-          ? reactor::except_op : reactor::read_op,
-        p.p, is_continuation,
-        (flags & socket_base::message_out_of_band) == 0,
-        ((impl.state_ & socket_ops::stream_oriented)
-          && buffer_sequence_adapter<asio::mutable_buffer,
-            MutableBufferSequence>::all_empty(buffers)));
-    p.v = p.p = 0;
-  }
-
-  // Wait until data can be received without blocking.
-  template <typename Handler>
-  void async_receive(base_implementation_type& impl, const null_buffers&,
-      socket_base::message_flags flags, Handler& handler)
-  {
-    bool is_continuation =
-      asio_handler_cont_helpers::is_continuation(handler);
-
-    // Allocate and construct an operation to wrap the handler.
-    typedef reactive_null_buffers_op<Handler> op;
-    typename op::ptr p = { asio::detail::addressof(handler),
-      asio_handler_alloc_helpers::allocate(
-        sizeof(op), handler), 0 };
-    p.p = new (p.v) op(handler);
-
-    ASIO_HANDLER_CREATION((p.p, "socket",
-          &impl, "async_receive(null_buffers)"));
-
-    start_op(impl,
-        (flags & socket_base::message_out_of_band)
-          ? reactor::except_op : reactor::read_op,
-        p.p, is_continuation, false, false);
-    p.v = p.p = 0;
-  }
-
-  // Receive some data with associated flags. Returns the number of bytes
-  // received.
-  template <typename MutableBufferSequence>
-  size_t receive_with_flags(base_implementation_type& impl,
-      const MutableBufferSequence& buffers,
-      socket_base::message_flags in_flags,
-      socket_base::message_flags& out_flags, asio::error_code& ec)
-  {
-    buffer_sequence_adapter<asio::mutable_buffer,
-        MutableBufferSequence> bufs(buffers);
-
-    return socket_ops::sync_recvmsg(impl.socket_, impl.state_,
-        bufs.buffers(), bufs.count(), in_flags, out_flags, ec);
-  }
-
-  // Wait until data can be received without blocking.
-  size_t receive_with_flags(base_implementation_type& impl,
-      const null_buffers&, socket_base::message_flags,
-      socket_base::message_flags& out_flags, asio::error_code& ec)
-  {
-    // Wait for socket to become ready.
-    socket_ops::poll_read(impl.socket_, impl.state_, ec);
-
-    // Clear out_flags, since we cannot give it any other sensible value when
-    // performing a null_buffers operation.
-    out_flags = 0;
-
-    return 0;
-  }
-
-  // Start an asynchronous receive. The buffer for the data being received
-  // must be valid for the lifetime of the asynchronous operation.
-  template <typename MutableBufferSequence, typename Handler>
-  void async_receive_with_flags(base_implementation_type& impl,
-      const MutableBufferSequence& buffers, socket_base::message_flags in_flags,
-      socket_base::message_flags& out_flags, Handler& handler)
-  {
-    bool is_continuation =
-      asio_handler_cont_helpers::is_continuation(handler);
-
-    // Allocate and construct an operation to wrap the handler.
-    typedef reactive_socket_recvmsg_op<MutableBufferSequence, Handler> op;
-    typename op::ptr p = { asio::detail::addressof(handler),
-      asio_handler_alloc_helpers::allocate(
-        sizeof(op), handler), 0 };
-    p.p = new (p.v) op(impl.socket_, buffers, in_flags, out_flags, handler);
-
-    ASIO_HANDLER_CREATION((p.p, "socket",
-          &impl, "async_receive_with_flags"));
-
-    start_op(impl,
-        (in_flags & socket_base::message_out_of_band)
-          ? reactor::except_op : reactor::read_op,
-        p.p, is_continuation,
-        (in_flags & socket_base::message_out_of_band) == 0, false);
-    p.v = p.p = 0;
-  }
-
-  // Wait until data can be received without blocking.
-  template <typename Handler>
-  void async_receive_with_flags(base_implementation_type& impl,
-      const null_buffers&, socket_base::message_flags in_flags,
-      socket_base::message_flags& out_flags, Handler& handler)
-  {
-    bool is_continuation =
-      asio_handler_cont_helpers::is_continuation(handler);
-
-    // Allocate and construct an operation to wrap the handler.
-    typedef reactive_null_buffers_op<Handler> op;
-    typename op::ptr p = { asio::detail::addressof(handler),
-      asio_handler_alloc_helpers::allocate(
-        sizeof(op), handler), 0 };
-    p.p = new (p.v) op(handler);
-
-    ASIO_HANDLER_CREATION((p.p, "socket", &impl,
-          "async_receive_with_flags(null_buffers)"));
-
-    // Clear out_flags, since we cannot give it any other sensible value when
-    // performing a null_buffers operation.
-    out_flags = 0;
-
-    start_op(impl,
-        (in_flags & socket_base::message_out_of_band)
-          ? reactor::except_op : reactor::read_op,
-        p.p, is_continuation, false, false);
-    p.v = p.p = 0;
-  }
-
-protected:
-  // Open a new socket implementation.
-  ASIO_DECL asio::error_code do_open(
-      base_implementation_type& impl, int af,
-      int type, int protocol, asio::error_code& ec);
-
-  // Assign a native socket to a socket implementation.
-  ASIO_DECL asio::error_code do_assign(
-      base_implementation_type& impl, int type,
-      const native_handle_type& native_socket, asio::error_code& ec);
-
-  // Start the asynchronous read or write operation.
-  ASIO_DECL void start_op(base_implementation_type& impl, int op_type,
-      reactor_op* op, bool is_continuation, bool is_non_blocking, bool noop);
-
-  // Start the asynchronous accept operation.
-  ASIO_DECL void start_accept_op(base_implementation_type& impl,
-      reactor_op* op, bool is_continuation, bool peer_is_open);
-
-  // Start the asynchronous connect operation.
-  ASIO_DECL void start_connect_op(base_implementation_type& impl,
-      reactor_op* op, bool is_continuation,
-      const socket_addr_type* addr, size_t addrlen);
-
-  // The selector that performs event demultiplexing for the service.
-  reactor& reactor_;
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#if defined(ASIO_HEADER_ONLY)
-# include "asio/detail/impl/reactive_socket_service_base.ipp"
-#endif // defined(ASIO_HEADER_ONLY)
-
-#endif // !defined(ASIO_HAS_IOCP)
-       //   && !defined(ASIO_WINDOWS_RUNTIME)
-
-#endif // ASIO_DETAIL_REACTIVE_SOCKET_SERVICE_BASE_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/reactor.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/reactor.hpp
deleted file mode 100644
index 7ee13680bcbc..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/reactor.hpp
+++ /dev/null
@@ -1,32 +0,0 @@
-//
-// detail/reactor.hpp
-// ~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_REACTOR_HPP
-#define ASIO_DETAIL_REACTOR_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/reactor_fwd.hpp"
-
-#if defined(ASIO_HAS_EPOLL)
-# include "asio/detail/epoll_reactor.hpp"
-#elif defined(ASIO_HAS_KQUEUE)
-# include "asio/detail/kqueue_reactor.hpp"
-#elif defined(ASIO_HAS_DEV_POLL)
-# include "asio/detail/dev_poll_reactor.hpp"
-#elif defined(ASIO_WINDOWS_RUNTIME)
-# include "asio/detail/null_reactor.hpp"
-#else
-# include "asio/detail/select_reactor.hpp"
-#endif
-
-#endif // ASIO_DETAIL_REACTOR_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/reactor_fwd.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/reactor_fwd.hpp
deleted file mode 100644
index cddedc795608..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/reactor_fwd.hpp
+++ /dev/null
@@ -1,40 +0,0 @@
-//
-// detail/reactor_fwd.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_REACTOR_FWD_HPP
-#define ASIO_DETAIL_REACTOR_FWD_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-namespace asio {
-namespace detail {
-
-#if defined(ASIO_WINDOWS_RUNTIME)
-typedef class null_reactor reactor;
-#elif defined(ASIO_HAS_IOCP)
-typedef class select_reactor reactor;
-#elif defined(ASIO_HAS_EPOLL)
-typedef class epoll_reactor reactor;
-#elif defined(ASIO_HAS_KQUEUE)
-typedef class kqueue_reactor reactor;
-#elif defined(ASIO_HAS_DEV_POLL)
-typedef class dev_poll_reactor reactor;
-#else
-typedef class select_reactor reactor;
-#endif
-
-} // namespace detail
-} // namespace asio
-
-#endif // ASIO_DETAIL_REACTOR_FWD_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/reactor_op.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/reactor_op.hpp
deleted file mode 100644
index 718356539c89..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/reactor_op.hpp
+++ /dev/null
@@ -1,61 +0,0 @@
-//
-// detail/reactor_op.hpp
-// ~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_REACTOR_OP_HPP
-#define ASIO_DETAIL_REACTOR_OP_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include "asio/detail/operation.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-class reactor_op
-  : public operation
-{
-public:
-  // The error code to be passed to the completion handler.
-  asio::error_code ec_;
-
-  // The number of bytes transferred, to be passed to the completion handler.
-  std::size_t bytes_transferred_;
-
-  // Perform the operation. Returns true if it is finished.
-  bool perform()
-  {
-    return perform_func_(this);
-  }
-
-protected:
-  typedef bool (*perform_func_type)(reactor_op*);
-
-  reactor_op(perform_func_type perform_func, func_type complete_func)
-    : operation(complete_func),
-      bytes_transferred_(0),
-      perform_func_(perform_func)
-  {
-  }
-
-private:
-  perform_func_type perform_func_;
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_DETAIL_REACTOR_OP_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/reactor_op_queue.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/reactor_op_queue.hpp
deleted file mode 100644
index 14f5fb04beef..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/reactor_op_queue.hpp
+++ /dev/null
@@ -1,168 +0,0 @@
-//
-// detail/reactor_op_queue.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_REACTOR_OP_QUEUE_HPP
-#define ASIO_DETAIL_REACTOR_OP_QUEUE_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include "asio/detail/hash_map.hpp"
-#include "asio/detail/noncopyable.hpp"
-#include "asio/detail/op_queue.hpp"
-#include "asio/detail/reactor_op.hpp"
-#include "asio/error.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-template <typename Descriptor>
-class reactor_op_queue
-  : private noncopyable
-{
-public:
-  typedef Descriptor key_type;
-
-  struct mapped_type : op_queue<reactor_op>
-  {
-    mapped_type() {}
-    mapped_type(const mapped_type&) {}
-    void operator=(const mapped_type&) {}
-  };
-
-  typedef typename hash_map<key_type, mapped_type>::value_type value_type;
-  typedef typename hash_map<key_type, mapped_type>::iterator iterator;
-
-  // Constructor.
-  reactor_op_queue()
-    : operations_()
-  {
-  }
-
-  // Obtain iterators to all registered descriptors.
-  iterator begin() { return operations_.begin(); }
-  iterator end() { return operations_.end(); }
-
-  // Add a new operation to the queue. Returns true if this is the only
-  // operation for the given descriptor, in which case the reactor's event
-  // demultiplexing function call may need to be interrupted and restarted.
-  bool enqueue_operation(Descriptor descriptor, reactor_op* op)
-  {
-    std::pair<iterator, bool> entry =
-      operations_.insert(value_type(descriptor, mapped_type()));
-    entry.first->second.push(op);
-    return entry.second;
-  }
-
-  // Cancel all operations associated with the descriptor identified by the
-  // supplied iterator. Any operations pending for the descriptor will be
-  // cancelled. Returns true if any operations were cancelled, in which case
-  // the reactor's event demultiplexing function may need to be interrupted and
-  // restarted.
-  bool cancel_operations(iterator i, op_queue<operation>& ops,
-      const asio::error_code& ec =
-        asio::error::operation_aborted)
-  {
-    if (i != operations_.end())
-    {
-      while (reactor_op* op = i->second.front())
-      {
-        op->ec_ = ec;
-        i->second.pop();
-        ops.push(op);
-      }
-      operations_.erase(i);
-      return true;
-    }
-
-    return false;
-  }
-
-  // Cancel all operations associated with the descriptor. Any operations
-  // pending for the descriptor will be cancelled. Returns true if any
-  // operations were cancelled, in which case the reactor's event
-  // demultiplexing function may need to be interrupted and restarted.
-  bool cancel_operations(Descriptor descriptor, op_queue<operation>& ops,
-      const asio::error_code& ec =
-        asio::error::operation_aborted)
-  {
-    return this->cancel_operations(operations_.find(descriptor), ops, ec);
-  }
-
-  // Whether there are no operations in the queue.
-  bool empty() const
-  {
-    return operations_.empty();
-  }
-
-  // Determine whether there are any operations associated with the descriptor.
-  bool has_operation(Descriptor descriptor) const
-  {
-    return operations_.find(descriptor) != operations_.end();
-  }
-
-  // Perform the operations corresponding to the descriptor identified by the
-  // supplied iterator. Returns true if there are still unfinished operations
-  // queued for the descriptor.
-  bool perform_operations(iterator i, op_queue<operation>& ops)
-  {
-    if (i != operations_.end())
-    {
-      while (reactor_op* op = i->second.front())
-      {
-        if (op->perform())
-        {
-          i->second.pop();
-          ops.push(op);
-        }
-        else
-        {
-          return true;
-        }
-      }
-      operations_.erase(i);
-    }
-    return false;
-  }
-
-  // Perform the operations corresponding to the descriptor. Returns true if
-  // there are still unfinished operations queued for the descriptor.
-  bool perform_operations(Descriptor descriptor, op_queue<operation>& ops)
-  {
-    return this->perform_operations(operations_.find(descriptor), ops);
-  }
-
-  // Get all operations owned by the queue.
-  void get_all_operations(op_queue<operation>& ops)
-  {
-    iterator i = operations_.begin();
-    while (i != operations_.end())
-    {
-      iterator op_iter = i++;
-      ops.push(op_iter->second);
-      operations_.erase(op_iter);
-    }
-  }
-
-private:
-  // The operations that are currently executing asynchronously.
-  hash_map<key_type, mapped_type> operations_;
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_DETAIL_REACTOR_OP_QUEUE_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/regex_fwd.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/regex_fwd.hpp
deleted file mode 100644
index c332ea0b896a..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/regex_fwd.hpp
+++ /dev/null
@@ -1,35 +0,0 @@
-//
-// detail/regex_fwd.hpp
-// ~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_REGEX_FWD_HPP
-#define ASIO_DETAIL_REGEX_FWD_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#if defined(ASIO_HAS_BOOST_REGEX)
-
-#include <boost/regex_fwd.hpp>
-#include <boost/regex/v4/match_flags.hpp>
-
-namespace boost {
-
-template <class BidiIterator>
-struct sub_match;
-
-template <class BidiIterator, class Allocator>
-class match_results;
-
-} // namespace boost
-
-#endif // defined(ASIO_HAS_BOOST_REGEX)
-
-#endif // ASIO_DETAIL_REGEX_FWD_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/resolve_endpoint_op.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/resolve_endpoint_op.hpp
deleted file mode 100644
index 7b6d2df2f96c..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/resolve_endpoint_op.hpp
+++ /dev/null
@@ -1,121 +0,0 @@
-//
-// detail/resolve_endpoint_op.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_RESOLVER_ENDPOINT_OP_HPP
-#define ASIO_DETAIL_RESOLVER_ENDPOINT_OP_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include "asio/error.hpp"
-#include "asio/io_service.hpp"
-#include "asio/ip/basic_resolver_iterator.hpp"
-#include "asio/detail/addressof.hpp"
-#include "asio/detail/bind_handler.hpp"
-#include "asio/detail/fenced_block.hpp"
-#include "asio/detail/handler_alloc_helpers.hpp"
-#include "asio/detail/handler_invoke_helpers.hpp"
-#include "asio/detail/operation.hpp"
-#include "asio/detail/socket_ops.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-template <typename Protocol, typename Handler>
-class resolve_endpoint_op : public operation
-{
-public:
-  ASIO_DEFINE_HANDLER_PTR(resolve_endpoint_op);
-
-  typedef typename Protocol::endpoint endpoint_type;
-  typedef asio::ip::basic_resolver_iterator<Protocol> iterator_type;
-
-  resolve_endpoint_op(socket_ops::weak_cancel_token_type cancel_token,
-      const endpoint_type& endpoint, io_service_impl& ios, Handler& handler)
-    : operation(&resolve_endpoint_op::do_complete),
-      cancel_token_(cancel_token),
-      endpoint_(endpoint),
-      io_service_impl_(ios),
-      handler_(ASIO_MOVE_CAST(Handler)(handler))
-  {
-  }
-
-  static void do_complete(io_service_impl* owner, operation* base,
-      const asio::error_code& /*ec*/,
-      std::size_t /*bytes_transferred*/)
-  {
-    // Take ownership of the operation object.
-    resolve_endpoint_op* o(static_cast<resolve_endpoint_op*>(base));
-    ptr p = { asio::detail::addressof(o->handler_), o, o };
-
-    if (owner && owner != &o->io_service_impl_)
-    {
-      // The operation is being run on the worker io_service. Time to perform
-      // the resolver operation.
-    
-      // Perform the blocking endpoint resolution operation.
-      char host_name[NI_MAXHOST];
-      char service_name[NI_MAXSERV];
-      socket_ops::background_getnameinfo(o->cancel_token_, o->endpoint_.data(),
-          o->endpoint_.size(), host_name, NI_MAXHOST, service_name, NI_MAXSERV,
-          o->endpoint_.protocol().type(), o->ec_);
-      o->iter_ = iterator_type::create(o->endpoint_, host_name, service_name);
-
-      // Pass operation back to main io_service for completion.
-      o->io_service_impl_.post_deferred_completion(o);
-      p.v = p.p = 0;
-    }
-    else
-    {
-      // The operation has been returned to the main io_service. The completion
-      // handler is ready to be delivered.
-
-      ASIO_HANDLER_COMPLETION((o));
-
-      // Make a copy of the handler so that the memory can be deallocated
-      // before the upcall is made. Even if we're not about to make an upcall,
-      // a sub-object of the handler may be the true owner of the memory
-      // associated with the handler. Consequently, a local copy of the handler
-      // is required to ensure that any owning sub-object remains valid until
-      // after we have deallocated the memory here.
-      detail::binder2<Handler, asio::error_code, iterator_type>
-        handler(o->handler_, o->ec_, o->iter_);
-      p.h = asio::detail::addressof(handler.handler_);
-      p.reset();
-
-      if (owner)
-      {
-        fenced_block b(fenced_block::half);
-        ASIO_HANDLER_INVOCATION_BEGIN((handler.arg1_, "..."));
-        asio_handler_invoke_helpers::invoke(handler, handler.handler_);
-        ASIO_HANDLER_INVOCATION_END;
-      }
-    }
-  }
-
-private:
-  socket_ops::weak_cancel_token_type cancel_token_;
-  endpoint_type endpoint_;
-  io_service_impl& io_service_impl_;
-  Handler handler_;
-  asio::error_code ec_;
-  iterator_type iter_;
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_DETAIL_RESOLVER_ENDPOINT_OP_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/resolve_op.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/resolve_op.hpp
deleted file mode 100644
index 93cc04b433c6..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/resolve_op.hpp
+++ /dev/null
@@ -1,131 +0,0 @@
-//
-// detail/resolve_op.hpp
-// ~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_RESOLVE_OP_HPP
-#define ASIO_DETAIL_RESOLVE_OP_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include "asio/error.hpp"
-#include "asio/io_service.hpp"
-#include "asio/ip/basic_resolver_iterator.hpp"
-#include "asio/ip/basic_resolver_query.hpp"
-#include "asio/detail/addressof.hpp"
-#include "asio/detail/bind_handler.hpp"
-#include "asio/detail/fenced_block.hpp"
-#include "asio/detail/handler_alloc_helpers.hpp"
-#include "asio/detail/handler_invoke_helpers.hpp"
-#include "asio/detail/operation.hpp"
-#include "asio/detail/socket_ops.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-template <typename Protocol, typename Handler>
-class resolve_op : public operation
-{
-public:
-  ASIO_DEFINE_HANDLER_PTR(resolve_op);
-
-  typedef asio::ip::basic_resolver_query<Protocol> query_type;
-  typedef asio::ip::basic_resolver_iterator<Protocol> iterator_type;
-
-  resolve_op(socket_ops::weak_cancel_token_type cancel_token,
-      const query_type& query, io_service_impl& ios, Handler& handler)
-    : operation(&resolve_op::do_complete),
-      cancel_token_(cancel_token),
-      query_(query),
-      io_service_impl_(ios),
-      handler_(ASIO_MOVE_CAST(Handler)(handler)),
-      addrinfo_(0)
-  {
-  }
-
-  ~resolve_op()
-  {
-    if (addrinfo_)
-      socket_ops::freeaddrinfo(addrinfo_);
-  }
-
-  static void do_complete(io_service_impl* owner, operation* base,
-      const asio::error_code& /*ec*/,
-      std::size_t /*bytes_transferred*/)
-  {
-    // Take ownership of the operation object.
-    resolve_op* o(static_cast<resolve_op*>(base));
-    ptr p = { asio::detail::addressof(o->handler_), o, o };
-
-    if (owner && owner != &o->io_service_impl_)
-    {
-      // The operation is being run on the worker io_service. Time to perform
-      // the resolver operation.
-    
-      // Perform the blocking host resolution operation.
-      socket_ops::background_getaddrinfo(o->cancel_token_,
-          o->query_.host_name().c_str(), o->query_.service_name().c_str(),
-          o->query_.hints(), &o->addrinfo_, o->ec_);
-
-      // Pass operation back to main io_service for completion.
-      o->io_service_impl_.post_deferred_completion(o);
-      p.v = p.p = 0;
-    }
-    else
-    {
-      // The operation has been returned to the main io_service. The completion
-      // handler is ready to be delivered.
-
-      ASIO_HANDLER_COMPLETION((o));
-
-      // Make a copy of the handler so that the memory can be deallocated
-      // before the upcall is made. Even if we're not about to make an upcall,
-      // a sub-object of the handler may be the true owner of the memory
-      // associated with the handler. Consequently, a local copy of the handler
-      // is required to ensure that any owning sub-object remains valid until
-      // after we have deallocated the memory here.
-      detail::binder2<Handler, asio::error_code, iterator_type>
-        handler(o->handler_, o->ec_, iterator_type());
-      p.h = asio::detail::addressof(handler.handler_);
-      if (o->addrinfo_)
-      {
-        handler.arg2_ = iterator_type::create(o->addrinfo_,
-            o->query_.host_name(), o->query_.service_name());
-      }
-      p.reset();
-
-      if (owner)
-      {
-        fenced_block b(fenced_block::half);
-        ASIO_HANDLER_INVOCATION_BEGIN((handler.arg1_, "..."));
-        asio_handler_invoke_helpers::invoke(handler, handler.handler_);
-        ASIO_HANDLER_INVOCATION_END;
-      }
-    }
-  }
-
-private:
-  socket_ops::weak_cancel_token_type cancel_token_;
-  query_type query_;
-  io_service_impl& io_service_impl_;
-  Handler handler_;
-  asio::error_code ec_;
-  asio::detail::addrinfo_type* addrinfo_;
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_DETAIL_RESOLVE_OP_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/resolver_service.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/resolver_service.hpp
deleted file mode 100644
index 5c0234b88d56..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/resolver_service.hpp
+++ /dev/null
@@ -1,129 +0,0 @@
-//
-// detail/resolver_service.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_RESOLVER_SERVICE_HPP
-#define ASIO_DETAIL_RESOLVER_SERVICE_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if !defined(ASIO_WINDOWS_RUNTIME)
-
-#include "asio/ip/basic_resolver_iterator.hpp"
-#include "asio/ip/basic_resolver_query.hpp"
-#include "asio/detail/addressof.hpp"
-#include "asio/detail/resolve_endpoint_op.hpp"
-#include "asio/detail/resolve_op.hpp"
-#include "asio/detail/resolver_service_base.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-template <typename Protocol>
-class resolver_service : public resolver_service_base
-{
-public:
-  // The implementation type of the resolver. A cancellation token is used to
-  // indicate to the background thread that the operation has been cancelled.
-  typedef socket_ops::shared_cancel_token_type implementation_type;
-
-  // The endpoint type.
-  typedef typename Protocol::endpoint endpoint_type;
-
-  // The query type.
-  typedef asio::ip::basic_resolver_query<Protocol> query_type;
-
-  // The iterator type.
-  typedef asio::ip::basic_resolver_iterator<Protocol> iterator_type;
-
-  // Constructor.
-  resolver_service(asio::io_service& io_service)
-    : resolver_service_base(io_service)
-  {
-  }
-
-  // Resolve a query to a list of entries.
-  iterator_type resolve(implementation_type&, const query_type& query,
-      asio::error_code& ec)
-  {
-    asio::detail::addrinfo_type* address_info = 0;
-
-    socket_ops::getaddrinfo(query.host_name().c_str(),
-        query.service_name().c_str(), query.hints(), &address_info, ec);
-    auto_addrinfo auto_address_info(address_info);
-
-    return ec ? iterator_type() : iterator_type::create(
-        address_info, query.host_name(), query.service_name());
-  }
-
-  // Asynchronously resolve a query to a list of entries.
-  template <typename Handler>
-  void async_resolve(implementation_type& impl,
-      const query_type& query, Handler& handler)
-  {
-    // Allocate and construct an operation to wrap the handler.
-    typedef resolve_op<Protocol, Handler> op;
-    typename op::ptr p = { asio::detail::addressof(handler),
-      asio_handler_alloc_helpers::allocate(
-        sizeof(op), handler), 0 };
-    p.p = new (p.v) op(impl, query, io_service_impl_, handler);
-
-    ASIO_HANDLER_CREATION((p.p, "resolver", &impl, "async_resolve"));
-
-    start_resolve_op(p.p);
-    p.v = p.p = 0;
-  }
-
-  // Resolve an endpoint to a list of entries.
-  iterator_type resolve(implementation_type&,
-      const endpoint_type& endpoint, asio::error_code& ec)
-  {
-    char host_name[NI_MAXHOST];
-    char service_name[NI_MAXSERV];
-    socket_ops::sync_getnameinfo(endpoint.data(), endpoint.size(),
-        host_name, NI_MAXHOST, service_name, NI_MAXSERV,
-        endpoint.protocol().type(), ec);
-
-    return ec ? iterator_type() : iterator_type::create(
-        endpoint, host_name, service_name);
-  }
-
-  // Asynchronously resolve an endpoint to a list of entries.
-  template <typename Handler>
-  void async_resolve(implementation_type& impl,
-      const endpoint_type& endpoint, Handler& handler)
-  {
-    // Allocate and construct an operation to wrap the handler.
-    typedef resolve_endpoint_op<Protocol, Handler> op;
-    typename op::ptr p = { asio::detail::addressof(handler),
-      asio_handler_alloc_helpers::allocate(
-        sizeof(op), handler), 0 };
-    p.p = new (p.v) op(impl, endpoint, io_service_impl_, handler);
-
-    ASIO_HANDLER_CREATION((p.p, "resolver", &impl, "async_resolve"));
-
-    start_resolve_op(p.p);
-    p.v = p.p = 0;
-  }
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // !defined(ASIO_WINDOWS_RUNTIME)
-
-#endif // ASIO_DETAIL_RESOLVER_SERVICE_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/resolver_service_base.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/resolver_service_base.hpp
deleted file mode 100644
index a8e6d122116a..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/resolver_service_base.hpp
+++ /dev/null
@@ -1,129 +0,0 @@
-//
-// detail/resolver_service_base.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_RESOLVER_SERVICE_BASE_HPP
-#define ASIO_DETAIL_RESOLVER_SERVICE_BASE_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include "asio/error.hpp"
-#include "asio/io_service.hpp"
-#include "asio/detail/mutex.hpp"
-#include "asio/detail/noncopyable.hpp"
-#include "asio/detail/operation.hpp"
-#include "asio/detail/socket_ops.hpp"
-#include "asio/detail/socket_types.hpp"
-#include "asio/detail/scoped_ptr.hpp"
-#include "asio/detail/thread.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-class resolver_service_base
-{
-public:
-  // The implementation type of the resolver. A cancellation token is used to
-  // indicate to the background thread that the operation has been cancelled.
-  typedef socket_ops::shared_cancel_token_type implementation_type;
-
-  // Constructor.
-  ASIO_DECL resolver_service_base(asio::io_service& io_service);
-
-  // Destructor.
-  ASIO_DECL ~resolver_service_base();
-
-  // Destroy all user-defined handler objects owned by the service.
-  ASIO_DECL void shutdown_service();
-
-  // Perform any fork-related housekeeping.
-  ASIO_DECL void fork_service(
-      asio::io_service::fork_event fork_ev);
-
-  // Construct a new resolver implementation.
-  ASIO_DECL void construct(implementation_type& impl);
-
-  // Destroy a resolver implementation.
-  ASIO_DECL void destroy(implementation_type&);
-
-  // Cancel pending asynchronous operations.
-  ASIO_DECL void cancel(implementation_type& impl);
-
-protected:
-  // Helper function to start an asynchronous resolve operation.
-  ASIO_DECL void start_resolve_op(operation* op);
-
-#if !defined(ASIO_WINDOWS_RUNTIME)
-  // Helper class to perform exception-safe cleanup of addrinfo objects.
-  class auto_addrinfo
-    : private asio::detail::noncopyable
-  {
-  public:
-    explicit auto_addrinfo(asio::detail::addrinfo_type* ai)
-      : ai_(ai)
-    {
-    }
-
-    ~auto_addrinfo()
-    {
-      if (ai_)
-        socket_ops::freeaddrinfo(ai_);
-    }
-
-    operator asio::detail::addrinfo_type*()
-    {
-      return ai_;
-    }
-
-  private:
-    asio::detail::addrinfo_type* ai_;
-  };
-#endif // !defined(ASIO_WINDOWS_RUNTIME)
-
-  // Helper class to run the work io_service in a thread.
-  class work_io_service_runner;
-
-  // Start the work thread if it's not already running.
-  ASIO_DECL void start_work_thread();
-
-  // The io_service implementation used to post completions.
-  io_service_impl& io_service_impl_;
-
-private:
-  // Mutex to protect access to internal data.
-  asio::detail::mutex mutex_;
-
-  // Private io_service used for performing asynchronous host resolution.
-  asio::detail::scoped_ptr<asio::io_service> work_io_service_;
-
-  // The work io_service implementation used to post completions.
-  io_service_impl& work_io_service_impl_;
-
-  // Work for the private io_service to perform.
-  asio::detail::scoped_ptr<asio::io_service::work> work_;
-
-  // Thread used for running the work io_service's run loop.
-  asio::detail::scoped_ptr<asio::detail::thread> work_thread_;
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#if defined(ASIO_HEADER_ONLY)
-# include "asio/detail/impl/resolver_service_base.ipp"
-#endif // defined(ASIO_HEADER_ONLY)
-
-#endif // ASIO_DETAIL_RESOLVER_SERVICE_BASE_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/scoped_lock.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/scoped_lock.hpp
deleted file mode 100644
index 643ed18d9cc2..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/scoped_lock.hpp
+++ /dev/null
@@ -1,101 +0,0 @@
-//
-// detail/scoped_lock.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_SCOPED_LOCK_HPP
-#define ASIO_DETAIL_SCOPED_LOCK_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/noncopyable.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-// Helper class to lock and unlock a mutex automatically.
-template <typename Mutex>
-class scoped_lock
-  : private noncopyable
-{
-public:
-  // Tag type used to distinguish constructors.
-  enum adopt_lock_t { adopt_lock };
-
-  // Constructor adopts a lock that is already held.
-  scoped_lock(Mutex& m, adopt_lock_t)
-    : mutex_(m),
-      locked_(true)
-  {
-  }
-
-  // Constructor acquires the lock.
-  explicit scoped_lock(Mutex& m)
-    : mutex_(m)
-  {
-    mutex_.lock();
-    locked_ = true;
-  }
-
-  // Destructor releases the lock.
-  ~scoped_lock()
-  {
-    if (locked_)
-      mutex_.unlock();
-  }
-
-  // Explicitly acquire the lock.
-  void lock()
-  {
-    if (!locked_)
-    {
-      mutex_.lock();
-      locked_ = true;
-    }
-  }
-
-  // Explicitly release the lock.
-  void unlock()
-  {
-    if (locked_)
-    {
-      mutex_.unlock();
-      locked_ = false;
-    }
-  }
-
-  // Test whether the lock is held.
-  bool locked() const
-  {
-    return locked_;
-  }
-
-  // Get the underlying mutex.
-  Mutex& mutex()
-  {
-    return mutex_;
-  }
-
-private:
-  // The underlying mutex.
-  Mutex& mutex_;
-
-  // Whether the mutex is currently locked or unlocked.
-  bool locked_;
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_DETAIL_SCOPED_LOCK_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/scoped_ptr.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/scoped_ptr.hpp
deleted file mode 100644
index 8d63c846139f..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/scoped_ptr.hpp
+++ /dev/null
@@ -1,79 +0,0 @@
-//
-// detail/scoped_ptr.hpp
-// ~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_SCOPED_PTR_HPP
-#define ASIO_DETAIL_SCOPED_PTR_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-template <typename T>
-class scoped_ptr
-{
-public:
-  // Constructor.
-  explicit scoped_ptr(T* p = 0)
-    : p_(p)
-  {
-  }
-
-  // Destructor.
-  ~scoped_ptr()
-  {
-    delete p_;
-  }
-
-  // Access.
-  T* get()
-  {
-    return p_;
-  }
-
-  // Access.
-  T* operator->()
-  {
-    return p_;
-  }
-
-  // Dereference.
-  T& operator*()
-  {
-    return *p_;
-  }
-
-  // Reset pointer.
-  void reset(T* p = 0)
-  {
-    delete p_;
-    p_ = p;
-  }
-
-private:
-  // Disallow copying and assignment.
-  scoped_ptr(const scoped_ptr&);
-  scoped_ptr& operator=(const scoped_ptr&);
-
-  T* p_;
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_DETAIL_SCOPED_PTR_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/select_interrupter.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/select_interrupter.hpp
deleted file mode 100644
index 5a0249941d9f..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/select_interrupter.hpp
+++ /dev/null
@@ -1,46 +0,0 @@
-//
-// detail/select_interrupter.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_SELECT_INTERRUPTER_HPP
-#define ASIO_DETAIL_SELECT_INTERRUPTER_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if !defined(ASIO_WINDOWS_RUNTIME)
-
-#if defined(ASIO_WINDOWS) || defined(__CYGWIN__) || defined(__SYMBIAN32__)
-# include "asio/detail/socket_select_interrupter.hpp"
-#elif defined(ASIO_HAS_EVENTFD)
-# include "asio/detail/eventfd_select_interrupter.hpp"
-#else
-# include "asio/detail/pipe_select_interrupter.hpp"
-#endif
-
-namespace asio {
-namespace detail {
-
-#if defined(ASIO_WINDOWS) || defined(__CYGWIN__) || defined(__SYMBIAN32__)
-typedef socket_select_interrupter select_interrupter;
-#elif defined(ASIO_HAS_EVENTFD)
-typedef eventfd_select_interrupter select_interrupter;
-#else
-typedef pipe_select_interrupter select_interrupter;
-#endif
-
-} // namespace detail
-} // namespace asio
-
-#endif // !defined(ASIO_WINDOWS_RUNTIME)
-
-#endif // ASIO_DETAIL_SELECT_INTERRUPTER_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/select_reactor.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/select_reactor.hpp
deleted file mode 100644
index 9f0e4a4878fd..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/select_reactor.hpp
+++ /dev/null
@@ -1,219 +0,0 @@
-//
-// detail/select_reactor.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_SELECT_REACTOR_HPP
-#define ASIO_DETAIL_SELECT_REACTOR_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_HAS_IOCP) \
-  || (!defined(ASIO_HAS_DEV_POLL) \
-      && !defined(ASIO_HAS_EPOLL) \
-      && !defined(ASIO_HAS_KQUEUE) \
-      && !defined(ASIO_WINDOWS_RUNTIME))
-
-#include <cstddef>
-#include "asio/detail/fd_set_adapter.hpp"
-#include "asio/detail/limits.hpp"
-#include "asio/detail/mutex.hpp"
-#include "asio/detail/op_queue.hpp"
-#include "asio/detail/reactor_op.hpp"
-#include "asio/detail/reactor_op_queue.hpp"
-#include "asio/detail/select_interrupter.hpp"
-#include "asio/detail/socket_types.hpp"
-#include "asio/detail/timer_queue_base.hpp"
-#include "asio/detail/timer_queue_set.hpp"
-#include "asio/detail/wait_op.hpp"
-#include "asio/io_service.hpp"
-
-#if defined(ASIO_HAS_IOCP)
-# include "asio/detail/thread.hpp"
-#endif // defined(ASIO_HAS_IOCP)
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-class select_reactor
-  : public asio::detail::service_base<select_reactor>
-{
-public:
-#if defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-  enum op_types { read_op = 0, write_op = 1, except_op = 2,
-    max_select_ops = 3, connect_op = 3, max_ops = 4 };
-#else // defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-  enum op_types { read_op = 0, write_op = 1, except_op = 2,
-    max_select_ops = 3, connect_op = 1, max_ops = 3 };
-#endif // defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-
-  // Per-descriptor data.
-  struct per_descriptor_data
-  {
-  };
-
-  // Constructor.
-  ASIO_DECL select_reactor(asio::io_service& io_service);
-
-  // Destructor.
-  ASIO_DECL ~select_reactor();
-
-  // Destroy all user-defined handler objects owned by the service.
-  ASIO_DECL void shutdown_service();
-
-  // Recreate internal descriptors following a fork.
-  ASIO_DECL void fork_service(
-      asio::io_service::fork_event fork_ev);
-
-  // Initialise the task, but only if the reactor is not in its own thread.
-  ASIO_DECL void init_task();
-
-  // Register a socket with the reactor. Returns 0 on success, system error
-  // code on failure.
-  ASIO_DECL int register_descriptor(socket_type, per_descriptor_data&);
-
-  // Register a descriptor with an associated single operation. Returns 0 on
-  // success, system error code on failure.
-  ASIO_DECL int register_internal_descriptor(
-      int op_type, socket_type descriptor,
-      per_descriptor_data& descriptor_data, reactor_op* op);
-
-  // Post a reactor operation for immediate completion.
-  void post_immediate_completion(reactor_op* op, bool is_continuation)
-  {
-    io_service_.post_immediate_completion(op, is_continuation);
-  }
-
-  // Start a new operation. The reactor operation will be performed when the
-  // given descriptor is flagged as ready, or an error has occurred.
-  ASIO_DECL void start_op(int op_type, socket_type descriptor,
-      per_descriptor_data&, reactor_op* op, bool is_continuation, bool);
-
-  // Cancel all operations associated with the given descriptor. The
-  // handlers associated with the descriptor will be invoked with the
-  // operation_aborted error.
-  ASIO_DECL void cancel_ops(socket_type descriptor, per_descriptor_data&);
-
-  // Cancel any operations that are running against the descriptor and remove
-  // its registration from the reactor.
-  ASIO_DECL void deregister_descriptor(socket_type descriptor,
-      per_descriptor_data&, bool closing);
-
-  // Remote the descriptor's registration from the reactor.
-  ASIO_DECL void deregister_internal_descriptor(
-      socket_type descriptor, per_descriptor_data& descriptor_data);
-
-  // Move descriptor registration from one descriptor_data object to another.
-  ASIO_DECL void move_descriptor(socket_type descriptor,
-      per_descriptor_data& target_descriptor_data,
-      per_descriptor_data& source_descriptor_data);
-
-  // Add a new timer queue to the reactor.
-  template <typename Time_Traits>
-  void add_timer_queue(timer_queue<Time_Traits>& queue);
-
-  // Remove a timer queue from the reactor.
-  template <typename Time_Traits>
-  void remove_timer_queue(timer_queue<Time_Traits>& queue);
-
-  // Schedule a new operation in the given timer queue to expire at the
-  // specified absolute time.
-  template <typename Time_Traits>
-  void schedule_timer(timer_queue<Time_Traits>& queue,
-      const typename Time_Traits::time_type& time,
-      typename timer_queue<Time_Traits>::per_timer_data& timer, wait_op* op);
-
-  // Cancel the timer operations associated with the given token. Returns the
-  // number of operations that have been posted or dispatched.
-  template <typename Time_Traits>
-  std::size_t cancel_timer(timer_queue<Time_Traits>& queue,
-      typename timer_queue<Time_Traits>::per_timer_data& timer,
-      std::size_t max_cancelled = (std::numeric_limits<std::size_t>::max)());
-
-  // Run select once until interrupted or events are ready to be dispatched.
-  ASIO_DECL void run(bool block, op_queue<operation>& ops);
-
-  // Interrupt the select loop.
-  ASIO_DECL void interrupt();
-
-private:
-#if defined(ASIO_HAS_IOCP)
-  // Run the select loop in the thread.
-  ASIO_DECL void run_thread();
-
-  // Entry point for the select loop thread.
-  ASIO_DECL static void call_run_thread(select_reactor* reactor);
-#endif // defined(ASIO_HAS_IOCP)
-
-  // Helper function to add a new timer queue.
-  ASIO_DECL void do_add_timer_queue(timer_queue_base& queue);
-
-  // Helper function to remove a timer queue.
-  ASIO_DECL void do_remove_timer_queue(timer_queue_base& queue);
-
-  // Get the timeout value for the select call.
-  ASIO_DECL timeval* get_timeout(timeval& tv);
-
-  // Cancel all operations associated with the given descriptor. This function
-  // does not acquire the select_reactor's mutex.
-  ASIO_DECL void cancel_ops_unlocked(socket_type descriptor,
-      const asio::error_code& ec);
-
-  // The io_service implementation used to post completions.
-  io_service_impl& io_service_;
-
-  // Mutex to protect access to internal data.
-  asio::detail::mutex mutex_;
-
-  // The interrupter is used to break a blocking select call.
-  select_interrupter interrupter_;
-
-  // The queues of read, write and except operations.
-  reactor_op_queue<socket_type> op_queue_[max_ops];
-
-  // The file descriptor sets to be passed to the select system call.
-  fd_set_adapter fd_sets_[max_select_ops];
-
-  // The timer queues.
-  timer_queue_set timer_queues_;
-
-#if defined(ASIO_HAS_IOCP)
-  // Does the reactor loop thread need to stop.
-  bool stop_thread_;
-
-  // The thread that is running the reactor loop.
-  asio::detail::thread* thread_;
-#endif // defined(ASIO_HAS_IOCP)
-
-  // Whether the service has been shut down.
-  bool shutdown_;
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#include "asio/detail/impl/select_reactor.hpp"
-#if defined(ASIO_HEADER_ONLY)
-# include "asio/detail/impl/select_reactor.ipp"
-#endif // defined(ASIO_HEADER_ONLY)
-
-#endif // defined(ASIO_HAS_IOCP)
-       //   || (!defined(ASIO_HAS_DEV_POLL)
-       //       && !defined(ASIO_HAS_EPOLL)
-       //       && !defined(ASIO_HAS_KQUEUE)
-       //       && !defined(ASIO_WINDOWS_RUNTIME))
-
-#endif // ASIO_DETAIL_SELECT_REACTOR_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/service_registry.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/service_registry.hpp
deleted file mode 100644
index 2a179bc4ce98..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/service_registry.hpp
+++ /dev/null
@@ -1,156 +0,0 @@
-//
-// detail/service_registry.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_SERVICE_REGISTRY_HPP
-#define ASIO_DETAIL_SERVICE_REGISTRY_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include <typeinfo>
-#include "asio/detail/mutex.hpp"
-#include "asio/detail/noncopyable.hpp"
-#include "asio/io_service.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-#if defined(__GNUC__)
-# if (__GNUC__ == 4 && __GNUC_MINOR__ >= 1) || (__GNUC__ > 4)
-#  pragma GCC visibility push (default)
-# endif // (__GNUC__ == 4 && __GNUC_MINOR__ >= 1) || (__GNUC__ > 4)
-#endif // defined(__GNUC__)
-
-template <typename T>
-class typeid_wrapper {};
-
-#if defined(__GNUC__)
-# if (__GNUC__ == 4 && __GNUC_MINOR__ >= 1) || (__GNUC__ > 4)
-#  pragma GCC visibility pop
-# endif // (__GNUC__ == 4 && __GNUC_MINOR__ >= 1) || (__GNUC__ > 4)
-#endif // defined(__GNUC__)
-
-class service_registry
-  : private noncopyable
-{
-public:
-  // Constructor. Adds the initial service.
-  template <typename Service, typename Arg>
-  service_registry(asio::io_service& o,
-      Service* initial_service, Arg arg);
-
-  // Destructor.
-  ASIO_DECL ~service_registry();
-
-  // Notify all services of a fork event.
-  ASIO_DECL void notify_fork(asio::io_service::fork_event fork_ev);
-
-  // Get the first service object cast to the specified type. Called during
-  // io_service construction and so performs no locking or type checking.
-  template <typename Service>
-  Service& first_service();
-
-  // Get the service object corresponding to the specified service type. Will
-  // create a new service object automatically if no such object already
-  // exists. Ownership of the service object is not transferred to the caller.
-  template <typename Service>
-  Service& use_service();
-
-  // Add a service object. Throws on error, in which case ownership of the
-  // object is retained by the caller.
-  template <typename Service>
-  void add_service(Service* new_service);
-
-  // Check whether a service object of the specified type already exists.
-  template <typename Service>
-  bool has_service() const;
-
-private:
-  // Initialise a service's key based on its id.
-  ASIO_DECL static void init_key(
-      asio::io_service::service::key& key,
-      const asio::io_service::id& id);
-
-#if !defined(ASIO_NO_TYPEID)
-  // Initialise a service's key based on its id.
-  template <typename Service>
-  static void init_key(asio::io_service::service::key& key,
-      const asio::detail::service_id<Service>& /*id*/);
-#endif // !defined(ASIO_NO_TYPEID)
-
-  // Check if a service matches the given id.
-  ASIO_DECL static bool keys_match(
-      const asio::io_service::service::key& key1,
-      const asio::io_service::service::key& key2);
-
-  // The type of a factory function used for creating a service instance.
-  typedef asio::io_service::service*
-    (*factory_type)(asio::io_service&);
-
-  // Factory function for creating a service instance.
-  template <typename Service>
-  static asio::io_service::service* create(
-      asio::io_service& owner);
-
-  // Destroy a service instance.
-  ASIO_DECL static void destroy(
-      asio::io_service::service* service);
-
-  // Helper class to manage service pointers.
-  struct auto_service_ptr;
-  friend struct auto_service_ptr;
-  struct auto_service_ptr
-  {
-    asio::io_service::service* ptr_;
-    ~auto_service_ptr() { destroy(ptr_); }
-  };
-
-  // Get the service object corresponding to the specified service key. Will
-  // create a new service object automatically if no such object already
-  // exists. Ownership of the service object is not transferred to the caller.
-  ASIO_DECL asio::io_service::service* do_use_service(
-      const asio::io_service::service::key& key,
-      factory_type factory);
-
-  // Add a service object. Throws on error, in which case ownership of the
-  // object is retained by the caller.
-  ASIO_DECL void do_add_service(
-      const asio::io_service::service::key& key,
-      asio::io_service::service* new_service);
-
-  // Check whether a service object with the specified key already exists.
-  ASIO_DECL bool do_has_service(
-      const asio::io_service::service::key& key) const;
-
-  // Mutex to protect access to internal data.
-  mutable asio::detail::mutex mutex_;
-
-  // The owner of this service registry and the services it contains.
-  asio::io_service& owner_;
-
-  // The first service in the list of contained services.
-  asio::io_service::service* first_service_;
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#include "asio/detail/impl/service_registry.hpp"
-#if defined(ASIO_HEADER_ONLY)
-# include "asio/detail/impl/service_registry.ipp"
-#endif // defined(ASIO_HEADER_ONLY)
-
-#endif // ASIO_DETAIL_SERVICE_REGISTRY_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/shared_ptr.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/shared_ptr.hpp
deleted file mode 100644
index 8d4894c1aa1a..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/shared_ptr.hpp
+++ /dev/null
@@ -1,38 +0,0 @@
-//
-// detail/shared_ptr.hpp
-// ~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_SHARED_PTR_HPP
-#define ASIO_DETAIL_SHARED_PTR_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_HAS_STD_SHARED_PTR)
-# include <memory>
-#else // defined(ASIO_HAS_STD_SHARED_PTR)
-# include <boost/shared_ptr.hpp>
-#endif // defined(ASIO_HAS_STD_SHARED_PTR)
-
-namespace asio {
-namespace detail {
-
-#if defined(ASIO_HAS_STD_SHARED_PTR)
-using std::shared_ptr;
-#else // defined(ASIO_HAS_STD_SHARED_PTR)
-using boost::shared_ptr;
-#endif // defined(ASIO_HAS_STD_SHARED_PTR)
-
-} // namespace detail
-} // namespace asio
-
-#endif // ASIO_DETAIL_SHARED_PTR_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/signal_blocker.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/signal_blocker.hpp
deleted file mode 100644
index 464e964c7756..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/signal_blocker.hpp
+++ /dev/null
@@ -1,44 +0,0 @@
-//
-// detail/signal_blocker.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_SIGNAL_BLOCKER_HPP
-#define ASIO_DETAIL_SIGNAL_BLOCKER_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if !defined(ASIO_HAS_THREADS) || defined(ASIO_WINDOWS) \
-  || defined(ASIO_WINDOWS_RUNTIME) \
-  || defined(__CYGWIN__) || defined(__SYMBIAN32__)
-# include "asio/detail/null_signal_blocker.hpp"
-#elif defined(ASIO_HAS_PTHREADS)
-# include "asio/detail/posix_signal_blocker.hpp"
-#else
-# error Only Windows and POSIX are supported!
-#endif
-
-namespace asio {
-namespace detail {
-
-#if !defined(ASIO_HAS_THREADS) || defined(ASIO_WINDOWS) \
-  || defined(ASIO_WINDOWS_RUNTIME) \
-  || defined(__CYGWIN__) || defined(__SYMBIAN32__)
-typedef null_signal_blocker signal_blocker;
-#elif defined(ASIO_HAS_PTHREADS)
-typedef posix_signal_blocker signal_blocker;
-#endif
-
-} // namespace detail
-} // namespace asio
-
-#endif // ASIO_DETAIL_SIGNAL_BLOCKER_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/signal_handler.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/signal_handler.hpp
deleted file mode 100644
index 394f2a445b1b..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/signal_handler.hpp
+++ /dev/null
@@ -1,82 +0,0 @@
-//
-// detail/signal_handler.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_SIGNAL_HANDLER_HPP
-#define ASIO_DETAIL_SIGNAL_HANDLER_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include "asio/detail/addressof.hpp"
-#include "asio/detail/fenced_block.hpp"
-#include "asio/detail/handler_alloc_helpers.hpp"
-#include "asio/detail/handler_invoke_helpers.hpp"
-#include "asio/detail/signal_op.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-template <typename Handler>
-class signal_handler : public signal_op
-{
-public:
-  ASIO_DEFINE_HANDLER_PTR(signal_handler);
-
-  signal_handler(Handler& h)
-    : signal_op(&signal_handler::do_complete),
-      handler_(ASIO_MOVE_CAST(Handler)(h))
-  {
-  }
-
-  static void do_complete(io_service_impl* owner, operation* base,
-      const asio::error_code& /*ec*/,
-      std::size_t /*bytes_transferred*/)
-  {
-    // Take ownership of the handler object.
-    signal_handler* h(static_cast<signal_handler*>(base));
-    ptr p = { asio::detail::addressof(h->handler_), h, h };
-
-    ASIO_HANDLER_COMPLETION((h));
-
-    // Make a copy of the handler so that the memory can be deallocated before
-    // the upcall is made. Even if we're not about to make an upcall, a
-    // sub-object of the handler may be the true owner of the memory associated
-    // with the handler. Consequently, a local copy of the handler is required
-    // to ensure that any owning sub-object remains valid until after we have
-    // deallocated the memory here.
-    detail::binder2<Handler, asio::error_code, int>
-      handler(h->handler_, h->ec_, h->signal_number_);
-    p.h = asio::detail::addressof(handler.handler_);
-    p.reset();
-
-    // Make the upcall if required.
-    if (owner)
-    {
-      fenced_block b(fenced_block::half);
-      ASIO_HANDLER_INVOCATION_BEGIN((handler.arg1_, handler.arg2_));
-      asio_handler_invoke_helpers::invoke(handler, handler.handler_);
-      ASIO_HANDLER_INVOCATION_END;
-    }
-  }
-
-private:
-  Handler handler_;
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_DETAIL_SIGNAL_HANDLER_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/signal_init.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/signal_init.hpp
deleted file mode 100644
index 08706ea0a4ac..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/signal_init.hpp
+++ /dev/null
@@ -1,47 +0,0 @@
-//
-// detail/signal_init.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_SIGNAL_INIT_HPP
-#define ASIO_DETAIL_SIGNAL_INIT_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if !defined(ASIO_WINDOWS) && !defined(__CYGWIN__)
-
-#include <csignal>
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-template <int Signal = SIGPIPE>
-class signal_init
-{
-public:
-  // Constructor.
-  signal_init()
-  {
-    std::signal(Signal, SIG_IGN);
-  }
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // !defined(ASIO_WINDOWS) && !defined(__CYGWIN__)
-
-#endif // ASIO_DETAIL_SIGNAL_INIT_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/signal_op.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/signal_op.hpp
deleted file mode 100644
index 4ebc65d48fb7..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/signal_op.hpp
+++ /dev/null
@@ -1,49 +0,0 @@
-//
-// detail/signal_op.hpp
-// ~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_SIGNAL_OP_HPP
-#define ASIO_DETAIL_SIGNAL_OP_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include "asio/detail/operation.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-class signal_op
-  : public operation
-{
-public:
-  // The error code to be passed to the completion handler.
-  asio::error_code ec_;
-
-  // The signal number to be passed to the completion handler.
-  int signal_number_;
-
-protected:
-  signal_op(func_type func)
-    : operation(func),
-      signal_number_(0)
-  {
-  }
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_DETAIL_SIGNAL_OP_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/signal_set_service.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/signal_set_service.hpp
deleted file mode 100644
index e409b9bbe063..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/signal_set_service.hpp
+++ /dev/null
@@ -1,216 +0,0 @@
-//
-// detail/signal_set_service.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_SIGNAL_SET_SERVICE_HPP
-#define ASIO_DETAIL_SIGNAL_SET_SERVICE_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#include <cstddef>
-#include <signal.h>
-#include "asio/error.hpp"
-#include "asio/io_service.hpp"
-#include "asio/detail/addressof.hpp"
-#include "asio/detail/handler_alloc_helpers.hpp"
-#include "asio/detail/op_queue.hpp"
-#include "asio/detail/signal_handler.hpp"
-#include "asio/detail/signal_op.hpp"
-#include "asio/detail/socket_types.hpp"
-
-#if !defined(ASIO_WINDOWS) && !defined(__CYGWIN__)
-# include "asio/detail/reactor.hpp"
-#endif // !defined(ASIO_WINDOWS) && !defined(__CYGWIN__)
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-#if defined(NSIG) && (NSIG > 0)
-enum { max_signal_number = NSIG };
-#else
-enum { max_signal_number = 128 };
-#endif
-
-extern ASIO_DECL struct signal_state* get_signal_state();
-
-extern "C" ASIO_DECL void asio_signal_handler(int signal_number);
-
-class signal_set_service
-{
-public:
-  // Type used for tracking an individual signal registration.
-  class registration
-  {
-  public:
-    // Default constructor.
-    registration()
-      : signal_number_(0),
-        queue_(0),
-        undelivered_(0),
-        next_in_table_(0),
-        prev_in_table_(0),
-        next_in_set_(0)
-    {
-    }
-
-  private:
-    // Only this service will have access to the internal values.
-    friend class signal_set_service;
-
-    // The signal number that is registered.
-    int signal_number_;
-
-    // The waiting signal handlers.
-    op_queue<signal_op>* queue_;
-
-    // The number of undelivered signals.
-    std::size_t undelivered_;
-
-    // Pointers to adjacent registrations in the registrations_ table.
-    registration* next_in_table_;
-    registration* prev_in_table_;
-
-    // Link to next registration in the signal set.
-    registration* next_in_set_;
-  };
-
-  // The implementation type of the signal_set.
-  class implementation_type
-  {
-  public:
-    // Default constructor.
-    implementation_type()
-      : signals_(0)
-    {
-    }
-
-  private:
-    // Only this service will have access to the internal values.
-    friend class signal_set_service;
-
-    // The pending signal handlers.
-    op_queue<signal_op> queue_;
-
-    // Linked list of registered signals.
-    registration* signals_;
-  };
-
-  // Constructor.
-  ASIO_DECL signal_set_service(asio::io_service& io_service);
-
-  // Destructor.
-  ASIO_DECL ~signal_set_service();
-
-  // Destroy all user-defined handler objects owned by the service.
-  ASIO_DECL void shutdown_service();
-
-  // Perform fork-related housekeeping.
-  ASIO_DECL void fork_service(
-      asio::io_service::fork_event fork_ev);
-
-  // Construct a new signal_set implementation.
-  ASIO_DECL void construct(implementation_type& impl);
-
-  // Destroy a signal_set implementation.
-  ASIO_DECL void destroy(implementation_type& impl);
-
-  // Add a signal to a signal_set.
-  ASIO_DECL asio::error_code add(implementation_type& impl,
-      int signal_number, asio::error_code& ec);
-
-  // Remove a signal to a signal_set.
-  ASIO_DECL asio::error_code remove(implementation_type& impl,
-      int signal_number, asio::error_code& ec);
-
-  // Remove all signals from a signal_set.
-  ASIO_DECL asio::error_code clear(implementation_type& impl,
-      asio::error_code& ec);
-
-  // Cancel all operations associated with the signal set.
-  ASIO_DECL asio::error_code cancel(implementation_type& impl,
-      asio::error_code& ec);
-
-  // Start an asynchronous operation to wait for a signal to be delivered.
-  template <typename Handler>
-  void async_wait(implementation_type& impl, Handler& handler)
-  {
-    // Allocate and construct an operation to wrap the handler.
-    typedef signal_handler<Handler> op;
-    typename op::ptr p = { asio::detail::addressof(handler),
-      asio_handler_alloc_helpers::allocate(
-        sizeof(op), handler), 0 };
-    p.p = new (p.v) op(handler);
-
-    ASIO_HANDLER_CREATION((p.p, "signal_set", &impl, "async_wait"));
-
-    start_wait_op(impl, p.p);
-    p.v = p.p = 0;
-  }
-
-  // Deliver notification that a particular signal occurred.
-  ASIO_DECL static void deliver_signal(int signal_number);
-
-private:
-  // Helper function to add a service to the global signal state.
-  ASIO_DECL static void add_service(signal_set_service* service);
-
-  // Helper function to remove a service from the global signal state.
-  ASIO_DECL static void remove_service(signal_set_service* service);
-
-  // Helper function to create the pipe descriptors.
-  ASIO_DECL static void open_descriptors();
-
-  // Helper function to close the pipe descriptors.
-  ASIO_DECL static void close_descriptors();
-
-  // Helper function to start a wait operation.
-  ASIO_DECL void start_wait_op(implementation_type& impl, signal_op* op);
-
-  // The io_service instance used for dispatching handlers.
-  io_service_impl& io_service_;
-
-#if !defined(ASIO_WINDOWS) \
-  && !defined(ASIO_WINDOWS_RUNTIME) \
-  && !defined(__CYGWIN__)
-  // The type used for registering for pipe reactor notifications.
-  class pipe_read_op;
-
-  // The reactor used for waiting for pipe readiness.
-  reactor& reactor_;
-
-  // The per-descriptor reactor data used for the pipe.
-  reactor::per_descriptor_data reactor_data_;
-#endif // !defined(ASIO_WINDOWS)
-       //   && !defined(ASIO_WINDOWS_RUNTIME)
-       //   && !defined(__CYGWIN__)
-
-  // A mapping from signal number to the registered signal sets.
-  registration* registrations_[max_signal_number];
-
-  // Pointers to adjacent services in linked list.
-  signal_set_service* next_;
-  signal_set_service* prev_;
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#if defined(ASIO_HEADER_ONLY)
-# include "asio/detail/impl/signal_set_service.ipp"
-#endif // defined(ASIO_HEADER_ONLY)
-
-#endif // ASIO_DETAIL_SIGNAL_SET_SERVICE_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/socket_holder.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/socket_holder.hpp
deleted file mode 100644
index 809cf1fdc416..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/socket_holder.hpp
+++ /dev/null
@@ -1,98 +0,0 @@
-//
-// detail/socket_holder.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_SOCKET_HOLDER_HPP
-#define ASIO_DETAIL_SOCKET_HOLDER_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include "asio/detail/noncopyable.hpp"
-#include "asio/detail/socket_ops.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-// Implement the resource acquisition is initialisation idiom for sockets.
-class socket_holder
-  : private noncopyable
-{
-public:
-  // Construct as an uninitialised socket.
-  socket_holder()
-    : socket_(invalid_socket)
-  {
-  }
-
-  // Construct to take ownership of the specified socket.
-  explicit socket_holder(socket_type s)
-    : socket_(s)
-  {
-  }
-
-  // Destructor.
-  ~socket_holder()
-  {
-    if (socket_ != invalid_socket)
-    {
-      asio::error_code ec;
-      socket_ops::state_type state = 0;
-      socket_ops::close(socket_, state, true, ec);
-    }
-  }
-
-  // Get the underlying socket.
-  socket_type get() const
-  {
-    return socket_;
-  }
-
-  // Reset to an uninitialised socket.
-  void reset()
-  {
-    if (socket_ != invalid_socket)
-    {
-      asio::error_code ec;
-      socket_ops::state_type state = 0;
-      socket_ops::close(socket_, state, true, ec);
-      socket_ = invalid_socket;
-    }
-  }
-
-  // Reset to take ownership of the specified socket.
-  void reset(socket_type s)
-  {
-    reset();
-    socket_ = s;
-  }
-
-  // Release ownership of the socket.
-  socket_type release()
-  {
-    socket_type tmp = socket_;
-    socket_ = invalid_socket;
-    return tmp;
-  }
-
-private:
-  // The underlying socket.
-  socket_type socket_;
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_DETAIL_SOCKET_HOLDER_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/socket_ops.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/socket_ops.hpp
deleted file mode 100644
index b976419fd59e..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/socket_ops.hpp
+++ /dev/null
@@ -1,334 +0,0 @@
-//
-// detail/socket_ops.hpp
-// ~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_SOCKET_OPS_HPP
-#define ASIO_DETAIL_SOCKET_OPS_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#include "asio/error_code.hpp"
-#include "asio/detail/shared_ptr.hpp"
-#include "asio/detail/socket_types.hpp"
-#include "asio/detail/weak_ptr.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-namespace socket_ops {
-
-// Socket state bits.
-enum
-{
-  // The user wants a non-blocking socket.
-  user_set_non_blocking = 1,
-
-  // The socket has been set non-blocking.
-  internal_non_blocking = 2,
-
-  // Helper "state" used to determine whether the socket is non-blocking.
-  non_blocking = user_set_non_blocking | internal_non_blocking,
-
-  // User wants connection_aborted errors, which are disabled by default.
-  enable_connection_aborted = 4,
-
-  // The user set the linger option. Needs to be checked when closing.
-  user_set_linger = 8,
-
-  // The socket is stream-oriented.
-  stream_oriented = 16,
-
-  // The socket is datagram-oriented.
-  datagram_oriented = 32,
-
-  // The socket may have been dup()-ed.
-  possible_dup = 64
-};
-
-typedef unsigned char state_type;
-
-struct noop_deleter { void operator()(void*) {} };
-typedef shared_ptr<void> shared_cancel_token_type;
-typedef weak_ptr<void> weak_cancel_token_type;
-
-#if !defined(ASIO_WINDOWS_RUNTIME)
-
-ASIO_DECL socket_type accept(socket_type s, socket_addr_type* addr,
-    std::size_t* addrlen, asio::error_code& ec);
-
-ASIO_DECL socket_type sync_accept(socket_type s,
-    state_type state, socket_addr_type* addr,
-    std::size_t* addrlen, asio::error_code& ec);
-
-#if defined(ASIO_HAS_IOCP)
-
-ASIO_DECL void complete_iocp_accept(socket_type s,
-    void* output_buffer, DWORD address_length,
-    socket_addr_type* addr, std::size_t* addrlen,
-    socket_type new_socket, asio::error_code& ec);
-
-#else // defined(ASIO_HAS_IOCP)
-
-ASIO_DECL bool non_blocking_accept(socket_type s,
-    state_type state, socket_addr_type* addr, std::size_t* addrlen,
-    asio::error_code& ec, socket_type& new_socket);
-
-#endif // defined(ASIO_HAS_IOCP)
-
-ASIO_DECL int bind(socket_type s, const socket_addr_type* addr,
-    std::size_t addrlen, asio::error_code& ec);
-
-ASIO_DECL int close(socket_type s, state_type& state,
-    bool destruction, asio::error_code& ec);
-
-ASIO_DECL bool set_user_non_blocking(socket_type s,
-    state_type& state, bool value, asio::error_code& ec);
-
-ASIO_DECL bool set_internal_non_blocking(socket_type s,
-    state_type& state, bool value, asio::error_code& ec);
-
-ASIO_DECL int shutdown(socket_type s,
-    int what, asio::error_code& ec);
-
-ASIO_DECL int connect(socket_type s, const socket_addr_type* addr,
-    std::size_t addrlen, asio::error_code& ec);
-
-ASIO_DECL void sync_connect(socket_type s, const socket_addr_type* addr,
-    std::size_t addrlen, asio::error_code& ec);
-
-#if defined(ASIO_HAS_IOCP)
-
-ASIO_DECL void complete_iocp_connect(socket_type s,
-    asio::error_code& ec);
-
-#endif // defined(ASIO_HAS_IOCP)
-
-ASIO_DECL bool non_blocking_connect(socket_type s,
-    asio::error_code& ec);
-
-ASIO_DECL int socketpair(int af, int type, int protocol,
-    socket_type sv[2], asio::error_code& ec);
-
-ASIO_DECL bool sockatmark(socket_type s, asio::error_code& ec);
-
-ASIO_DECL size_t available(socket_type s, asio::error_code& ec);
-
-ASIO_DECL int listen(socket_type s,
-    int backlog, asio::error_code& ec);
-
-#if defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-typedef WSABUF buf;
-#else // defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-typedef iovec buf;
-#endif // defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-
-ASIO_DECL void init_buf(buf& b, void* data, size_t size);
-
-ASIO_DECL void init_buf(buf& b, const void* data, size_t size);
-
-ASIO_DECL signed_size_type recv(socket_type s, buf* bufs,
-    size_t count, int flags, asio::error_code& ec);
-
-ASIO_DECL size_t sync_recv(socket_type s, state_type state, buf* bufs,
-    size_t count, int flags, bool all_empty, asio::error_code& ec);
-
-#if defined(ASIO_HAS_IOCP)
-
-ASIO_DECL void complete_iocp_recv(state_type state,
-    const weak_cancel_token_type& cancel_token, bool all_empty,
-    asio::error_code& ec, size_t bytes_transferred);
-
-#else // defined(ASIO_HAS_IOCP)
-
-ASIO_DECL bool non_blocking_recv(socket_type s,
-    buf* bufs, size_t count, int flags, bool is_stream,
-    asio::error_code& ec, size_t& bytes_transferred);
-
-#endif // defined(ASIO_HAS_IOCP)
-
-ASIO_DECL signed_size_type recvfrom(socket_type s, buf* bufs,
-    size_t count, int flags, socket_addr_type* addr,
-    std::size_t* addrlen, asio::error_code& ec);
-
-ASIO_DECL size_t sync_recvfrom(socket_type s, state_type state,
-    buf* bufs, size_t count, int flags, socket_addr_type* addr,
-    std::size_t* addrlen, asio::error_code& ec);
-
-#if defined(ASIO_HAS_IOCP)
-
-ASIO_DECL void complete_iocp_recvfrom(
-    const weak_cancel_token_type& cancel_token,
-    asio::error_code& ec);
-
-#else // defined(ASIO_HAS_IOCP)
-
-ASIO_DECL bool non_blocking_recvfrom(socket_type s,
-    buf* bufs, size_t count, int flags,
-    socket_addr_type* addr, std::size_t* addrlen,
-    asio::error_code& ec, size_t& bytes_transferred);
-
-#endif // defined(ASIO_HAS_IOCP)
-
-ASIO_DECL signed_size_type recvmsg(socket_type s, buf* bufs,
-    size_t count, int in_flags, int& out_flags,
-    asio::error_code& ec);
-
-ASIO_DECL size_t sync_recvmsg(socket_type s, state_type state,
-    buf* bufs, size_t count, int in_flags, int& out_flags,
-    asio::error_code& ec);
-
-#if defined(ASIO_HAS_IOCP)
-
-ASIO_DECL void complete_iocp_recvmsg(
-    const weak_cancel_token_type& cancel_token,
-    asio::error_code& ec);
-
-#else // defined(ASIO_HAS_IOCP)
-
-ASIO_DECL bool non_blocking_recvmsg(socket_type s,
-    buf* bufs, size_t count, int in_flags, int& out_flags,
-    asio::error_code& ec, size_t& bytes_transferred);
-
-#endif // defined(ASIO_HAS_IOCP)
-
-ASIO_DECL signed_size_type send(socket_type s, const buf* bufs,
-    size_t count, int flags, asio::error_code& ec);
-
-ASIO_DECL size_t sync_send(socket_type s, state_type state,
-    const buf* bufs, size_t count, int flags,
-    bool all_empty, asio::error_code& ec);
-
-#if defined(ASIO_HAS_IOCP)
-
-ASIO_DECL void complete_iocp_send(
-    const weak_cancel_token_type& cancel_token,
-    asio::error_code& ec);
-
-#else // defined(ASIO_HAS_IOCP)
-
-ASIO_DECL bool non_blocking_send(socket_type s,
-    const buf* bufs, size_t count, int flags,
-    asio::error_code& ec, size_t& bytes_transferred);
-
-#endif // defined(ASIO_HAS_IOCP)
-
-ASIO_DECL signed_size_type sendto(socket_type s, const buf* bufs,
-    size_t count, int flags, const socket_addr_type* addr,
-    std::size_t addrlen, asio::error_code& ec);
-
-ASIO_DECL size_t sync_sendto(socket_type s, state_type state,
-    const buf* bufs, size_t count, int flags, const socket_addr_type* addr,
-    std::size_t addrlen, asio::error_code& ec);
-
-#if !defined(ASIO_HAS_IOCP)
-
-ASIO_DECL bool non_blocking_sendto(socket_type s,
-    const buf* bufs, size_t count, int flags,
-    const socket_addr_type* addr, std::size_t addrlen,
-    asio::error_code& ec, size_t& bytes_transferred);
-
-#endif // !defined(ASIO_HAS_IOCP)
-
-ASIO_DECL socket_type socket(int af, int type, int protocol,
-    asio::error_code& ec);
-
-ASIO_DECL int setsockopt(socket_type s, state_type& state,
-    int level, int optname, const void* optval,
-    std::size_t optlen, asio::error_code& ec);
-
-ASIO_DECL int getsockopt(socket_type s, state_type state,
-    int level, int optname, void* optval,
-    size_t* optlen, asio::error_code& ec);
-
-ASIO_DECL int getpeername(socket_type s, socket_addr_type* addr,
-    std::size_t* addrlen, bool cached, asio::error_code& ec);
-
-ASIO_DECL int getsockname(socket_type s, socket_addr_type* addr,
-    std::size_t* addrlen, asio::error_code& ec);
-
-ASIO_DECL int ioctl(socket_type s, state_type& state,
-    int cmd, ioctl_arg_type* arg, asio::error_code& ec);
-
-ASIO_DECL int select(int nfds, fd_set* readfds, fd_set* writefds,
-    fd_set* exceptfds, timeval* timeout, asio::error_code& ec);
-
-ASIO_DECL int poll_read(socket_type s,
-    state_type state, asio::error_code& ec);
-
-ASIO_DECL int poll_write(socket_type s,
-    state_type state, asio::error_code& ec);
-
-ASIO_DECL int poll_connect(socket_type s, asio::error_code& ec);
-
-#endif // !defined(ASIO_WINDOWS_RUNTIME)
-
-ASIO_DECL const char* inet_ntop(int af, const void* src, char* dest,
-    size_t length, unsigned long scope_id, asio::error_code& ec);
-
-ASIO_DECL int inet_pton(int af, const char* src, void* dest,
-    unsigned long* scope_id, asio::error_code& ec);
-
-ASIO_DECL int gethostname(char* name,
-    int namelen, asio::error_code& ec);
-
-#if !defined(ASIO_WINDOWS_RUNTIME)
-
-ASIO_DECL asio::error_code getaddrinfo(const char* host,
-    const char* service, const addrinfo_type& hints,
-    addrinfo_type** result, asio::error_code& ec);
-
-ASIO_DECL asio::error_code background_getaddrinfo(
-    const weak_cancel_token_type& cancel_token, const char* host,
-    const char* service, const addrinfo_type& hints,
-    addrinfo_type** result, asio::error_code& ec);
-
-ASIO_DECL void freeaddrinfo(addrinfo_type* ai);
-
-ASIO_DECL asio::error_code getnameinfo(
-    const socket_addr_type* addr, std::size_t addrlen,
-    char* host, std::size_t hostlen, char* serv,
-    std::size_t servlen, int flags, asio::error_code& ec);
-
-ASIO_DECL asio::error_code sync_getnameinfo(
-    const socket_addr_type* addr, std::size_t addrlen,
-    char* host, std::size_t hostlen, char* serv,
-    std::size_t servlen, int sock_type, asio::error_code& ec);
-
-ASIO_DECL asio::error_code background_getnameinfo(
-    const weak_cancel_token_type& cancel_token,
-    const socket_addr_type* addr, std::size_t addrlen,
-    char* host, std::size_t hostlen, char* serv,
-    std::size_t servlen, int sock_type, asio::error_code& ec);
-
-#endif // !defined(ASIO_WINDOWS_RUNTIME)
-
-ASIO_DECL u_long_type network_to_host_long(u_long_type value);
-
-ASIO_DECL u_long_type host_to_network_long(u_long_type value);
-
-ASIO_DECL u_short_type network_to_host_short(u_short_type value);
-
-ASIO_DECL u_short_type host_to_network_short(u_short_type value);
-
-} // namespace socket_ops
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#if defined(ASIO_HEADER_ONLY)
-# include "asio/detail/impl/socket_ops.ipp"
-#endif // defined(ASIO_HEADER_ONLY)
-
-#endif // ASIO_DETAIL_SOCKET_OPS_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/socket_option.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/socket_option.hpp
deleted file mode 100644
index e363fdd64251..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/socket_option.hpp
+++ /dev/null
@@ -1,316 +0,0 @@
-//
-// detail/socket_option.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_SOCKET_OPTION_HPP
-#define ASIO_DETAIL_SOCKET_OPTION_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include <cstddef>
-#include <stdexcept>
-#include "asio/detail/socket_types.hpp"
-#include "asio/detail/throw_exception.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-namespace socket_option {
-
-// Helper template for implementing boolean-based options.
-template <int Level, int Name>
-class boolean
-{
-public:
-  // Default constructor.
-  boolean()
-    : value_(0)
-  {
-  }
-
-  // Construct with a specific option value.
-  explicit boolean(bool v)
-    : value_(v ? 1 : 0)
-  {
-  }
-
-  // Set the current value of the boolean.
-  boolean& operator=(bool v)
-  {
-    value_ = v ? 1 : 0;
-    return *this;
-  }
-
-  // Get the current value of the boolean.
-  bool value() const
-  {
-    return !!value_;
-  }
-
-  // Convert to bool.
-  operator bool() const
-  {
-    return !!value_;
-  }
-
-  // Test for false.
-  bool operator!() const
-  {
-    return !value_;
-  }
-
-  // Get the level of the socket option.
-  template <typename Protocol>
-  int level(const Protocol&) const
-  {
-    return Level;
-  }
-
-  // Get the name of the socket option.
-  template <typename Protocol>
-  int name(const Protocol&) const
-  {
-    return Name;
-  }
-
-  // Get the address of the boolean data.
-  template <typename Protocol>
-  int* data(const Protocol&)
-  {
-    return &value_;
-  }
-
-  // Get the address of the boolean data.
-  template <typename Protocol>
-  const int* data(const Protocol&) const
-  {
-    return &value_;
-  }
-
-  // Get the size of the boolean data.
-  template <typename Protocol>
-  std::size_t size(const Protocol&) const
-  {
-    return sizeof(value_);
-  }
-
-  // Set the size of the boolean data.
-  template <typename Protocol>
-  void resize(const Protocol&, std::size_t s)
-  {
-    // On some platforms (e.g. Windows Vista), the getsockopt function will
-    // return the size of a boolean socket option as one byte, even though a
-    // four byte integer was passed in.
-    switch (s)
-    {
-    case sizeof(char):
-      value_ = *reinterpret_cast<char*>(&value_) ? 1 : 0;
-      break;
-    case sizeof(value_):
-      break;
-    default:
-      {
-        std::length_error ex("boolean socket option resize");
-        asio::detail::throw_exception(ex);
-      }
-    }
-  }
-
-private:
-  int value_;
-};
-
-// Helper template for implementing integer options.
-template <int Level, int Name>
-class integer
-{
-public:
-  // Default constructor.
-  integer()
-    : value_(0)
-  {
-  }
-
-  // Construct with a specific option value.
-  explicit integer(int v)
-    : value_(v)
-  {
-  }
-
-  // Set the value of the int option.
-  integer& operator=(int v)
-  {
-    value_ = v;
-    return *this;
-  }
-
-  // Get the current value of the int option.
-  int value() const
-  {
-    return value_;
-  }
-
-  // Get the level of the socket option.
-  template <typename Protocol>
-  int level(const Protocol&) const
-  {
-    return Level;
-  }
-
-  // Get the name of the socket option.
-  template <typename Protocol>
-  int name(const Protocol&) const
-  {
-    return Name;
-  }
-
-  // Get the address of the int data.
-  template <typename Protocol>
-  int* data(const Protocol&)
-  {
-    return &value_;
-  }
-
-  // Get the address of the int data.
-  template <typename Protocol>
-  const int* data(const Protocol&) const
-  {
-    return &value_;
-  }
-
-  // Get the size of the int data.
-  template <typename Protocol>
-  std::size_t size(const Protocol&) const
-  {
-    return sizeof(value_);
-  }
-
-  // Set the size of the int data.
-  template <typename Protocol>
-  void resize(const Protocol&, std::size_t s)
-  {
-    if (s != sizeof(value_))
-    {
-      std::length_error ex("integer socket option resize");
-      asio::detail::throw_exception(ex);
-    }
-  }
-
-private:
-  int value_;
-};
-
-// Helper template for implementing linger options.
-template <int Level, int Name>
-class linger
-{
-public:
-  // Default constructor.
-  linger()
-  {
-    value_.l_onoff = 0;
-    value_.l_linger = 0;
-  }
-
-  // Construct with specific option values.
-  linger(bool e, int t)
-  {
-    enabled(e);
-    timeout ASIO_PREVENT_MACRO_SUBSTITUTION(t);
-  }
-
-  // Set the value for whether linger is enabled.
-  void enabled(bool value)
-  {
-    value_.l_onoff = value ? 1 : 0;
-  }
-
-  // Get the value for whether linger is enabled.
-  bool enabled() const
-  {
-    return value_.l_onoff != 0;
-  }
-
-  // Set the value for the linger timeout.
-  void timeout ASIO_PREVENT_MACRO_SUBSTITUTION(int value)
-  {
-#if defined(WIN32)
-    value_.l_linger = static_cast<u_short>(value);
-#else
-    value_.l_linger = value;
-#endif
-  }
-
-  // Get the value for the linger timeout.
-  int timeout ASIO_PREVENT_MACRO_SUBSTITUTION() const
-  {
-    return static_cast<int>(value_.l_linger);
-  }
-
-  // Get the level of the socket option.
-  template <typename Protocol>
-  int level(const Protocol&) const
-  {
-    return Level;
-  }
-
-  // Get the name of the socket option.
-  template <typename Protocol>
-  int name(const Protocol&) const
-  {
-    return Name;
-  }
-
-  // Get the address of the linger data.
-  template <typename Protocol>
-  detail::linger_type* data(const Protocol&)
-  {
-    return &value_;
-  }
-
-  // Get the address of the linger data.
-  template <typename Protocol>
-  const detail::linger_type* data(const Protocol&) const
-  {
-    return &value_;
-  }
-
-  // Get the size of the linger data.
-  template <typename Protocol>
-  std::size_t size(const Protocol&) const
-  {
-    return sizeof(value_);
-  }
-
-  // Set the size of the int data.
-  template <typename Protocol>
-  void resize(const Protocol&, std::size_t s)
-  {
-    if (s != sizeof(value_))
-    {
-      std::length_error ex("linger socket option resize");
-      asio::detail::throw_exception(ex);
-    }
-  }
-
-private:
-  detail::linger_type value_;
-};
-
-} // namespace socket_option
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_DETAIL_SOCKET_OPTION_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/socket_select_interrupter.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/socket_select_interrupter.hpp
deleted file mode 100644
index 4b52a28e719f..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/socket_select_interrupter.hpp
+++ /dev/null
@@ -1,91 +0,0 @@
-//
-// detail/socket_select_interrupter.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_SOCKET_SELECT_INTERRUPTER_HPP
-#define ASIO_DETAIL_SOCKET_SELECT_INTERRUPTER_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if !defined(ASIO_WINDOWS_RUNTIME)
-
-#if defined(ASIO_WINDOWS) \
-  || defined(__CYGWIN__) \
-  || defined(__SYMBIAN32__)
-
-#include "asio/detail/socket_types.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-class socket_select_interrupter
-{
-public:
-  // Constructor.
-  ASIO_DECL socket_select_interrupter();
-
-  // Destructor.
-  ASIO_DECL ~socket_select_interrupter();
-
-  // Recreate the interrupter's descriptors. Used after a fork.
-  ASIO_DECL void recreate();
-
-  // Interrupt the select call.
-  ASIO_DECL void interrupt();
-
-  // Reset the select interrupt. Returns true if the call was interrupted.
-  ASIO_DECL bool reset();
-
-  // Get the read descriptor to be passed to select.
-  socket_type read_descriptor() const
-  {
-    return read_descriptor_;
-  }
-
-private:
-  // Open the descriptors. Throws on error.
-  ASIO_DECL void open_descriptors();
-
-  // Close the descriptors.
-  ASIO_DECL void close_descriptors();
-
-  // The read end of a connection used to interrupt the select call. This file
-  // descriptor is passed to select such that when it is time to stop, a single
-  // byte will be written on the other end of the connection and this
-  // descriptor will become readable.
-  socket_type read_descriptor_;
-
-  // The write end of a connection used to interrupt the select call. A single
-  // byte may be written to this to wake up the select which is waiting for the
-  // other end to become readable.
-  socket_type write_descriptor_;
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#if defined(ASIO_HEADER_ONLY)
-# include "asio/detail/impl/socket_select_interrupter.ipp"
-#endif // defined(ASIO_HEADER_ONLY)
-
-#endif // defined(ASIO_WINDOWS)
-       // || defined(__CYGWIN__)
-       // || defined(__SYMBIAN32__)
-
-#endif // !defined(ASIO_WINDOWS_RUNTIME)
-
-#endif // ASIO_DETAIL_SOCKET_SELECT_INTERRUPTER_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/socket_types.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/socket_types.hpp
deleted file mode 100644
index f7be95754ce7..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/socket_types.hpp
+++ /dev/null
@@ -1,404 +0,0 @@
-//
-// detail/socket_types.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_SOCKET_TYPES_HPP
-#define ASIO_DETAIL_SOCKET_TYPES_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_WINDOWS_RUNTIME)
-// Empty.
-#elif defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-# if defined(_WINSOCKAPI_) && !defined(_WINSOCK2API_)
-#  error WinSock.h has already been included
-# endif // defined(_WINSOCKAPI_) && !defined(_WINSOCK2API_)
-# if defined(__BORLANDC__)
-#  include <stdlib.h> // Needed for __errno
-#  if !defined(_WSPIAPI_H_)
-#   define _WSPIAPI_H_
-#   define ASIO_WSPIAPI_H_DEFINED
-#  endif // !defined(_WSPIAPI_H_)
-# endif // defined(__BORLANDC__)
-# if defined(WINAPI_FAMILY)
-#  if ((WINAPI_FAMILY & WINAPI_PARTITION_DESKTOP) != 0)
-#   include <windows.h>
-#  endif // ((WINAPI_FAMILY & WINAPI_PARTITION_DESKTOP) != 0)
-# endif // defined(WINAPI_FAMILY)
-# include <winsock2.h>
-# include <ws2tcpip.h>
-# include <mswsock.h>
-# if defined(ASIO_WSPIAPI_H_DEFINED)
-#  undef _WSPIAPI_H_
-#  undef ASIO_WSPIAPI_H_DEFINED
-# endif // defined(ASIO_WSPIAPI_H_DEFINED)
-# if !defined(ASIO_NO_DEFAULT_LINKED_LIBS)
-#  if defined(UNDER_CE)
-#   pragma comment(lib, "ws2.lib")
-#  elif defined(_MSC_VER) || defined(__BORLANDC__)
-#   pragma comment(lib, "ws2_32.lib")
-#   pragma comment(lib, "mswsock.lib")
-#  endif // defined(_MSC_VER) || defined(__BORLANDC__)
-# endif // !defined(ASIO_NO_DEFAULT_LINKED_LIBS)
-# include "asio/detail/old_win_sdk_compat.hpp"
-#else
-# include <sys/ioctl.h>
-# if !defined(__SYMBIAN32__)
-#  include <sys/poll.h>
-# endif
-# include <sys/types.h>
-# include <sys/stat.h>
-# include <fcntl.h>
-# if defined(__hpux)
-#  include <sys/time.h>
-# endif
-# if !defined(__hpux) || defined(__SELECT)
-#  include <sys/select.h>
-# endif
-# include <sys/socket.h>
-# include <sys/uio.h>
-# include <sys/un.h>
-# include <netinet/in.h>
-# if !defined(__SYMBIAN32__)
-#  include <netinet/tcp.h>
-# endif
-# include <arpa/inet.h>
-# include <netdb.h>
-# include <net/if.h>
-# include <limits.h>
-# if defined(__sun)
-#  include <sys/filio.h>
-#  include <sys/sockio.h>
-# endif
-#endif
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-#if defined(ASIO_WINDOWS_RUNTIME)
-const int max_addr_v4_str_len = 256;
-const int max_addr_v6_str_len = 256;
-typedef unsigned __int32 u_long_type;
-typedef unsigned __int16 u_short_type;
-struct in4_addr_type { u_long_type s_addr; };
-struct in4_mreq_type { in4_addr_type imr_multiaddr, imr_interface; };
-struct in6_addr_type { unsigned char s6_addr[16]; };
-struct in6_mreq_type { in6_addr_type ipv6mr_multiaddr;
-  unsigned long ipv6mr_interface; };
-struct socket_addr_type { int sa_family; };
-struct sockaddr_in4_type { int sin_family;
-  in4_addr_type sin_addr; u_short_type sin_port; };
-struct sockaddr_in6_type { int sin6_family;
-  in6_addr_type sin6_addr; u_short_type sin6_port;
-  u_long_type sin6_flowinfo; u_long_type sin6_scope_id; };
-struct sockaddr_storage_type { int ss_family;
-  unsigned char ss_bytes[128 - sizeof(int)]; };
-struct addrinfo_type { int ai_flags;
-  int ai_family, ai_socktype, ai_protocol;
-  int ai_addrlen; const void* ai_addr;
-  const char* ai_canonname; addrinfo_type* ai_next; };
-struct linger_type { u_short_type l_onoff, l_linger; };
-typedef u_long_type ioctl_arg_type;
-typedef int signed_size_type;
-# define ASIO_OS_DEF(c) ASIO_OS_DEF_##c
-# define ASIO_OS_DEF_AF_UNSPEC 0
-# define ASIO_OS_DEF_AF_INET 2
-# define ASIO_OS_DEF_AF_INET6 23
-# define ASIO_OS_DEF_SOCK_STREAM 1
-# define ASIO_OS_DEF_SOCK_DGRAM 2
-# define ASIO_OS_DEF_SOCK_RAW 3
-# define ASIO_OS_DEF_SOCK_SEQPACKET 5
-# define ASIO_OS_DEF_IPPROTO_IP 0
-# define ASIO_OS_DEF_IPPROTO_IPV6 41
-# define ASIO_OS_DEF_IPPROTO_TCP 6
-# define ASIO_OS_DEF_IPPROTO_UDP 17
-# define ASIO_OS_DEF_IPPROTO_ICMP 1
-# define ASIO_OS_DEF_IPPROTO_ICMPV6 58
-# define ASIO_OS_DEF_FIONBIO 1
-# define ASIO_OS_DEF_FIONREAD 2
-# define ASIO_OS_DEF_INADDR_ANY 0
-# define ASIO_OS_DEF_MSG_OOB 0x1
-# define ASIO_OS_DEF_MSG_PEEK 0x2
-# define ASIO_OS_DEF_MSG_DONTROUTE 0x4
-# define ASIO_OS_DEF_MSG_EOR 0 // Not supported.
-# define ASIO_OS_DEF_SHUT_RD 0x0
-# define ASIO_OS_DEF_SHUT_WR 0x1
-# define ASIO_OS_DEF_SHUT_RDWR 0x2
-# define ASIO_OS_DEF_SOMAXCONN 0x7fffffff
-# define ASIO_OS_DEF_SOL_SOCKET 0xffff
-# define ASIO_OS_DEF_SO_BROADCAST 0x20
-# define ASIO_OS_DEF_SO_DEBUG 0x1
-# define ASIO_OS_DEF_SO_DONTROUTE 0x10
-# define ASIO_OS_DEF_SO_KEEPALIVE 0x8
-# define ASIO_OS_DEF_SO_LINGER 0x80
-# define ASIO_OS_DEF_SO_SNDBUF 0x1001
-# define ASIO_OS_DEF_SO_RCVBUF 0x1002
-# define ASIO_OS_DEF_SO_SNDLOWAT 0x1003
-# define ASIO_OS_DEF_SO_RCVLOWAT 0x1004
-# define ASIO_OS_DEF_SO_REUSEADDR 0x4
-# define ASIO_OS_DEF_TCP_NODELAY 0x1
-# define ASIO_OS_DEF_IP_MULTICAST_IF 2
-# define ASIO_OS_DEF_IP_MULTICAST_TTL 3
-# define ASIO_OS_DEF_IP_MULTICAST_LOOP 4
-# define ASIO_OS_DEF_IP_ADD_MEMBERSHIP 5
-# define ASIO_OS_DEF_IP_DROP_MEMBERSHIP 6
-# define ASIO_OS_DEF_IP_TTL 7
-# define ASIO_OS_DEF_IPV6_UNICAST_HOPS 4
-# define ASIO_OS_DEF_IPV6_MULTICAST_IF 9
-# define ASIO_OS_DEF_IPV6_MULTICAST_HOPS 10
-# define ASIO_OS_DEF_IPV6_MULTICAST_LOOP 11
-# define ASIO_OS_DEF_IPV6_JOIN_GROUP 12
-# define ASIO_OS_DEF_IPV6_LEAVE_GROUP 13
-# define ASIO_OS_DEF_AI_CANONNAME 0x2
-# define ASIO_OS_DEF_AI_PASSIVE 0x1
-# define ASIO_OS_DEF_AI_NUMERICHOST 0x4
-# define ASIO_OS_DEF_AI_NUMERICSERV 0x8
-# define ASIO_OS_DEF_AI_V4MAPPED 0x800
-# define ASIO_OS_DEF_AI_ALL 0x100
-# define ASIO_OS_DEF_AI_ADDRCONFIG 0x400
-#elif defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-typedef SOCKET socket_type;
-const SOCKET invalid_socket = INVALID_SOCKET;
-const int socket_error_retval = SOCKET_ERROR;
-const int max_addr_v4_str_len = 256;
-const int max_addr_v6_str_len = 256;
-typedef sockaddr socket_addr_type;
-typedef in_addr in4_addr_type;
-typedef ip_mreq in4_mreq_type;
-typedef sockaddr_in sockaddr_in4_type;
-# if defined(ASIO_HAS_OLD_WIN_SDK)
-typedef in6_addr_emulation in6_addr_type;
-typedef ipv6_mreq_emulation in6_mreq_type;
-typedef sockaddr_in6_emulation sockaddr_in6_type;
-typedef sockaddr_storage_emulation sockaddr_storage_type;
-typedef addrinfo_emulation addrinfo_type;
-# else
-typedef in6_addr in6_addr_type;
-typedef ipv6_mreq in6_mreq_type;
-typedef sockaddr_in6 sockaddr_in6_type;
-typedef sockaddr_storage sockaddr_storage_type;
-typedef addrinfo addrinfo_type;
-# endif
-typedef ::linger linger_type;
-typedef unsigned long ioctl_arg_type;
-typedef u_long u_long_type;
-typedef u_short u_short_type;
-typedef int signed_size_type;
-# define ASIO_OS_DEF(c) ASIO_OS_DEF_##c
-# define ASIO_OS_DEF_AF_UNSPEC AF_UNSPEC
-# define ASIO_OS_DEF_AF_INET AF_INET
-# define ASIO_OS_DEF_AF_INET6 AF_INET6
-# define ASIO_OS_DEF_SOCK_STREAM SOCK_STREAM
-# define ASIO_OS_DEF_SOCK_DGRAM SOCK_DGRAM
-# define ASIO_OS_DEF_SOCK_RAW SOCK_RAW
-# define ASIO_OS_DEF_SOCK_SEQPACKET SOCK_SEQPACKET
-# define ASIO_OS_DEF_IPPROTO_IP IPPROTO_IP
-# define ASIO_OS_DEF_IPPROTO_IPV6 IPPROTO_IPV6
-# define ASIO_OS_DEF_IPPROTO_TCP IPPROTO_TCP
-# define ASIO_OS_DEF_IPPROTO_UDP IPPROTO_UDP
-# define ASIO_OS_DEF_IPPROTO_ICMP IPPROTO_ICMP
-# define ASIO_OS_DEF_IPPROTO_ICMPV6 IPPROTO_ICMPV6
-# define ASIO_OS_DEF_FIONBIO FIONBIO
-# define ASIO_OS_DEF_FIONREAD FIONREAD
-# define ASIO_OS_DEF_INADDR_ANY INADDR_ANY
-# define ASIO_OS_DEF_MSG_OOB MSG_OOB
-# define ASIO_OS_DEF_MSG_PEEK MSG_PEEK
-# define ASIO_OS_DEF_MSG_DONTROUTE MSG_DONTROUTE
-# define ASIO_OS_DEF_MSG_EOR 0 // Not supported on Windows.
-# define ASIO_OS_DEF_SHUT_RD SD_RECEIVE
-# define ASIO_OS_DEF_SHUT_WR SD_SEND
-# define ASIO_OS_DEF_SHUT_RDWR SD_BOTH
-# define ASIO_OS_DEF_SOMAXCONN SOMAXCONN
-# define ASIO_OS_DEF_SOL_SOCKET SOL_SOCKET
-# define ASIO_OS_DEF_SO_BROADCAST SO_BROADCAST
-# define ASIO_OS_DEF_SO_DEBUG SO_DEBUG
-# define ASIO_OS_DEF_SO_DONTROUTE SO_DONTROUTE
-# define ASIO_OS_DEF_SO_KEEPALIVE SO_KEEPALIVE
-# define ASIO_OS_DEF_SO_LINGER SO_LINGER
-# define ASIO_OS_DEF_SO_SNDBUF SO_SNDBUF
-# define ASIO_OS_DEF_SO_RCVBUF SO_RCVBUF
-# define ASIO_OS_DEF_SO_SNDLOWAT SO_SNDLOWAT
-# define ASIO_OS_DEF_SO_RCVLOWAT SO_RCVLOWAT
-# define ASIO_OS_DEF_SO_REUSEADDR SO_REUSEADDR
-# define ASIO_OS_DEF_TCP_NODELAY TCP_NODELAY
-# define ASIO_OS_DEF_IP_MULTICAST_IF IP_MULTICAST_IF
-# define ASIO_OS_DEF_IP_MULTICAST_TTL IP_MULTICAST_TTL
-# define ASIO_OS_DEF_IP_MULTICAST_LOOP IP_MULTICAST_LOOP
-# define ASIO_OS_DEF_IP_ADD_MEMBERSHIP IP_ADD_MEMBERSHIP
-# define ASIO_OS_DEF_IP_DROP_MEMBERSHIP IP_DROP_MEMBERSHIP
-# define ASIO_OS_DEF_IP_TTL IP_TTL
-# define ASIO_OS_DEF_IPV6_UNICAST_HOPS IPV6_UNICAST_HOPS
-# define ASIO_OS_DEF_IPV6_MULTICAST_IF IPV6_MULTICAST_IF
-# define ASIO_OS_DEF_IPV6_MULTICAST_HOPS IPV6_MULTICAST_HOPS
-# define ASIO_OS_DEF_IPV6_MULTICAST_LOOP IPV6_MULTICAST_LOOP
-# define ASIO_OS_DEF_IPV6_JOIN_GROUP IPV6_JOIN_GROUP
-# define ASIO_OS_DEF_IPV6_LEAVE_GROUP IPV6_LEAVE_GROUP
-# define ASIO_OS_DEF_AI_CANONNAME AI_CANONNAME
-# define ASIO_OS_DEF_AI_PASSIVE AI_PASSIVE
-# define ASIO_OS_DEF_AI_NUMERICHOST AI_NUMERICHOST
-# if defined(AI_NUMERICSERV)
-#  define ASIO_OS_DEF_AI_NUMERICSERV AI_NUMERICSERV
-# else
-#  define ASIO_OS_DEF_AI_NUMERICSERV 0
-# endif
-# if defined(AI_V4MAPPED)
-#  define ASIO_OS_DEF_AI_V4MAPPED AI_V4MAPPED
-# else
-#  define ASIO_OS_DEF_AI_V4MAPPED 0
-# endif
-# if defined(AI_ALL)
-#  define ASIO_OS_DEF_AI_ALL AI_ALL
-# else
-#  define ASIO_OS_DEF_AI_ALL 0
-# endif
-# if defined(AI_ADDRCONFIG)
-#  define ASIO_OS_DEF_AI_ADDRCONFIG AI_ADDRCONFIG
-# else
-#  define ASIO_OS_DEF_AI_ADDRCONFIG 0
-# endif
-# if defined (_WIN32_WINNT)
-const int max_iov_len = 64;
-# else
-const int max_iov_len = 16;
-# endif
-#else
-typedef int socket_type;
-const int invalid_socket = -1;
-const int socket_error_retval = -1;
-const int max_addr_v4_str_len = INET_ADDRSTRLEN;
-#if defined(INET6_ADDRSTRLEN)
-const int max_addr_v6_str_len = INET6_ADDRSTRLEN + 1 + IF_NAMESIZE;
-#else // defined(INET6_ADDRSTRLEN)
-const int max_addr_v6_str_len = 256;
-#endif // defined(INET6_ADDRSTRLEN)
-typedef sockaddr socket_addr_type;
-typedef in_addr in4_addr_type;
-# if defined(__hpux)
-// HP-UX doesn't provide ip_mreq when _XOPEN_SOURCE_EXTENDED is defined.
-struct in4_mreq_type
-{
-  struct in_addr imr_multiaddr;
-  struct in_addr imr_interface;
-};
-# else
-typedef ip_mreq in4_mreq_type;
-# endif
-typedef sockaddr_in sockaddr_in4_type;
-typedef in6_addr in6_addr_type;
-typedef ipv6_mreq in6_mreq_type;
-typedef sockaddr_in6 sockaddr_in6_type;
-typedef sockaddr_storage sockaddr_storage_type;
-typedef sockaddr_un sockaddr_un_type;
-typedef addrinfo addrinfo_type;
-typedef ::linger linger_type;
-typedef int ioctl_arg_type;
-typedef uint32_t u_long_type;
-typedef uint16_t u_short_type;
-#if defined(ASIO_HAS_SSIZE_T)
-typedef ssize_t signed_size_type;
-#else // defined(ASIO_HAS_SSIZE_T)
-typedef int signed_size_type;
-#endif // defined(ASIO_HAS_SSIZE_T)
-# define ASIO_OS_DEF(c) ASIO_OS_DEF_##c
-# define ASIO_OS_DEF_AF_UNSPEC AF_UNSPEC
-# define ASIO_OS_DEF_AF_INET AF_INET
-# define ASIO_OS_DEF_AF_INET6 AF_INET6
-# define ASIO_OS_DEF_SOCK_STREAM SOCK_STREAM
-# define ASIO_OS_DEF_SOCK_DGRAM SOCK_DGRAM
-# define ASIO_OS_DEF_SOCK_RAW SOCK_RAW
-# define ASIO_OS_DEF_SOCK_SEQPACKET SOCK_SEQPACKET
-# define ASIO_OS_DEF_IPPROTO_IP IPPROTO_IP
-# define ASIO_OS_DEF_IPPROTO_IPV6 IPPROTO_IPV6
-# define ASIO_OS_DEF_IPPROTO_TCP IPPROTO_TCP
-# define ASIO_OS_DEF_IPPROTO_UDP IPPROTO_UDP
-# define ASIO_OS_DEF_IPPROTO_ICMP IPPROTO_ICMP
-# define ASIO_OS_DEF_IPPROTO_ICMPV6 IPPROTO_ICMPV6
-# define ASIO_OS_DEF_FIONBIO FIONBIO
-# define ASIO_OS_DEF_FIONREAD FIONREAD
-# define ASIO_OS_DEF_INADDR_ANY INADDR_ANY
-# define ASIO_OS_DEF_MSG_OOB MSG_OOB
-# define ASIO_OS_DEF_MSG_PEEK MSG_PEEK
-# define ASIO_OS_DEF_MSG_DONTROUTE MSG_DONTROUTE
-# define ASIO_OS_DEF_MSG_EOR MSG_EOR
-# define ASIO_OS_DEF_SHUT_RD SHUT_RD
-# define ASIO_OS_DEF_SHUT_WR SHUT_WR
-# define ASIO_OS_DEF_SHUT_RDWR SHUT_RDWR
-# define ASIO_OS_DEF_SOMAXCONN SOMAXCONN
-# define ASIO_OS_DEF_SOL_SOCKET SOL_SOCKET
-# define ASIO_OS_DEF_SO_BROADCAST SO_BROADCAST
-# define ASIO_OS_DEF_SO_DEBUG SO_DEBUG
-# define ASIO_OS_DEF_SO_DONTROUTE SO_DONTROUTE
-# define ASIO_OS_DEF_SO_KEEPALIVE SO_KEEPALIVE
-# define ASIO_OS_DEF_SO_LINGER SO_LINGER
-# define ASIO_OS_DEF_SO_SNDBUF SO_SNDBUF
-# define ASIO_OS_DEF_SO_RCVBUF SO_RCVBUF
-# define ASIO_OS_DEF_SO_SNDLOWAT SO_SNDLOWAT
-# define ASIO_OS_DEF_SO_RCVLOWAT SO_RCVLOWAT
-# define ASIO_OS_DEF_SO_REUSEADDR SO_REUSEADDR
-# define ASIO_OS_DEF_TCP_NODELAY TCP_NODELAY
-# define ASIO_OS_DEF_IP_MULTICAST_IF IP_MULTICAST_IF
-# define ASIO_OS_DEF_IP_MULTICAST_TTL IP_MULTICAST_TTL
-# define ASIO_OS_DEF_IP_MULTICAST_LOOP IP_MULTICAST_LOOP
-# define ASIO_OS_DEF_IP_ADD_MEMBERSHIP IP_ADD_MEMBERSHIP
-# define ASIO_OS_DEF_IP_DROP_MEMBERSHIP IP_DROP_MEMBERSHIP
-# define ASIO_OS_DEF_IP_TTL IP_TTL
-# define ASIO_OS_DEF_IPV6_UNICAST_HOPS IPV6_UNICAST_HOPS
-# define ASIO_OS_DEF_IPV6_MULTICAST_IF IPV6_MULTICAST_IF
-# define ASIO_OS_DEF_IPV6_MULTICAST_HOPS IPV6_MULTICAST_HOPS
-# define ASIO_OS_DEF_IPV6_MULTICAST_LOOP IPV6_MULTICAST_LOOP
-# define ASIO_OS_DEF_IPV6_JOIN_GROUP IPV6_JOIN_GROUP
-# define ASIO_OS_DEF_IPV6_LEAVE_GROUP IPV6_LEAVE_GROUP
-# define ASIO_OS_DEF_AI_CANONNAME AI_CANONNAME
-# define ASIO_OS_DEF_AI_PASSIVE AI_PASSIVE
-# define ASIO_OS_DEF_AI_NUMERICHOST AI_NUMERICHOST
-# if defined(AI_NUMERICSERV)
-#  define ASIO_OS_DEF_AI_NUMERICSERV AI_NUMERICSERV
-# else
-#  define ASIO_OS_DEF_AI_NUMERICSERV 0
-# endif
-// Note: QNX Neutrino 6.3 defines AI_V4MAPPED, AI_ALL and AI_ADDRCONFIG but
-// does not implement them. Therefore they are specifically excluded here.
-# if defined(AI_V4MAPPED) && !defined(__QNXNTO__)
-#  define ASIO_OS_DEF_AI_V4MAPPED AI_V4MAPPED
-# else
-#  define ASIO_OS_DEF_AI_V4MAPPED 0
-# endif
-# if defined(AI_ALL) && !defined(__QNXNTO__)
-#  define ASIO_OS_DEF_AI_ALL AI_ALL
-# else
-#  define ASIO_OS_DEF_AI_ALL 0
-# endif
-# if defined(AI_ADDRCONFIG) && !defined(__QNXNTO__)
-#  define ASIO_OS_DEF_AI_ADDRCONFIG AI_ADDRCONFIG
-# else
-#  define ASIO_OS_DEF_AI_ADDRCONFIG 0
-# endif
-# if defined(IOV_MAX)
-const int max_iov_len = IOV_MAX;
-# else
-// POSIX platforms are not required to define IOV_MAX.
-const int max_iov_len = 16;
-# endif
-#endif
-const int custom_socket_option_level = 0xA5100000;
-const int enable_connection_aborted_option = 1;
-const int always_fail_option = 2;
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_DETAIL_SOCKET_TYPES_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/solaris_fenced_block.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/solaris_fenced_block.hpp
deleted file mode 100644
index 46932b2df0e2..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/solaris_fenced_block.hpp
+++ /dev/null
@@ -1,61 +0,0 @@
-//
-// detail/solaris_fenced_block.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_SOLARIS_FENCED_BLOCK_HPP
-#define ASIO_DETAIL_SOLARIS_FENCED_BLOCK_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(__sun)
-
-#include <atomic.h>
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-class solaris_fenced_block
-  : private noncopyable
-{
-public:
-  enum half_t { half };
-  enum full_t { full };
-
-  // Constructor for a half fenced block.
-  explicit solaris_fenced_block(half_t)
-  {
-  }
-
-  // Constructor for a full fenced block.
-  explicit solaris_fenced_block(full_t)
-  {
-    membar_consumer();
-  }
-
-  // Destructor.
-  ~solaris_fenced_block()
-  {
-    membar_producer();
-  }
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // defined(__sun)
-
-#endif // ASIO_DETAIL_SOLARIS_FENCED_BLOCK_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/static_mutex.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/static_mutex.hpp
deleted file mode 100644
index 35432b52b57d..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/static_mutex.hpp
+++ /dev/null
@@ -1,52 +0,0 @@
-//
-// detail/static_mutex.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_STATIC_MUTEX_HPP
-#define ASIO_DETAIL_STATIC_MUTEX_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if !defined(ASIO_HAS_THREADS)
-# include "asio/detail/null_static_mutex.hpp"
-#elif defined(ASIO_WINDOWS)
-# include "asio/detail/win_static_mutex.hpp"
-#elif defined(ASIO_HAS_PTHREADS)
-# include "asio/detail/posix_static_mutex.hpp"
-#elif defined(ASIO_HAS_STD_MUTEX_AND_CONDVAR)
-# include "asio/detail/std_static_mutex.hpp"
-#else
-# error Only Windows and POSIX are supported!
-#endif
-
-namespace asio {
-namespace detail {
-
-#if !defined(ASIO_HAS_THREADS)
-typedef null_static_mutex static_mutex;
-# define ASIO_STATIC_MUTEX_INIT ASIO_NULL_STATIC_MUTEX_INIT
-#elif defined(ASIO_WINDOWS)
-typedef win_static_mutex static_mutex;
-# define ASIO_STATIC_MUTEX_INIT ASIO_WIN_STATIC_MUTEX_INIT
-#elif defined(ASIO_HAS_PTHREADS)
-typedef posix_static_mutex static_mutex;
-# define ASIO_STATIC_MUTEX_INIT ASIO_POSIX_STATIC_MUTEX_INIT
-#elif defined(ASIO_HAS_STD_MUTEX_AND_CONDVAR)
-typedef std_static_mutex static_mutex;
-# define ASIO_STATIC_MUTEX_INIT ASIO_STD_STATIC_MUTEX_INIT
-#endif
-
-} // namespace detail
-} // namespace asio
-
-#endif // ASIO_DETAIL_STATIC_MUTEX_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/std_event.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/std_event.hpp
deleted file mode 100644
index 027e10d08581..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/std_event.hpp
+++ /dev/null
@@ -1,176 +0,0 @@
-//
-// detail/std_event.hpp
-// ~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_STD_EVENT_HPP
-#define ASIO_DETAIL_STD_EVENT_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_HAS_STD_MUTEX_AND_CONDVAR)
-
-#include <chrono>
-#include <condition_variable>
-#include "asio/detail/assert.hpp"
-#include "asio/detail/noncopyable.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-class std_event
-  : private noncopyable
-{
-public:
-  // Constructor.
-  std_event()
-    : state_(0)
-  {
-  }
-
-  // Destructor.
-  ~std_event()
-  {
-  }
-
-  // Signal the event. (Retained for backward compatibility.)
-  template <typename Lock>
-  void signal(Lock& lock)
-  {
-    this->signal_all(lock);
-  }
-
-  // Signal all waiters.
-  template <typename Lock>
-  void signal_all(Lock& lock)
-  {
-    ASIO_ASSERT(lock.locked());
-    (void)lock;
-    state_ |= 1;
-    cond_.notify_all();
-  }
-
-  // Unlock the mutex and signal one waiter.
-  template <typename Lock>
-  void unlock_and_signal_one(Lock& lock)
-  {
-    ASIO_ASSERT(lock.locked());
-    state_ |= 1;
-    bool have_waiters = (state_ > 1);
-    lock.unlock();
-    if (have_waiters)
-      cond_.notify_one();
-  }
-
-  // If there's a waiter, unlock the mutex and signal it.
-  template <typename Lock>
-  bool maybe_unlock_and_signal_one(Lock& lock)
-  {
-    ASIO_ASSERT(lock.locked());
-    state_ |= 1;
-    if (state_ > 1)
-    {
-      lock.unlock();
-      cond_.notify_one();
-      return true;
-    }
-    return false;
-  }
-
-  // Reset the event.
-  template <typename Lock>
-  void clear(Lock& lock)
-  {
-    ASIO_ASSERT(lock.locked());
-    (void)lock;
-    state_ &= ~std::size_t(1);
-  }
-
-  // Wait for the event to become signalled.
-  template <typename Lock>
-  void wait(Lock& lock)
-  {
-    ASIO_ASSERT(lock.locked());
-    unique_lock_adapter u_lock(lock);
-    while ((state_ & 1) == 0)
-    {
-      waiter w(state_);
-      cond_.wait(u_lock.unique_lock_);
-    }
-  }
-
-  // Timed wait for the event to become signalled.
-  template <typename Lock>
-  bool wait_for_usec(Lock& lock, long usec)
-  {
-    ASIO_ASSERT(lock.locked());
-    unique_lock_adapter u_lock(lock);
-    if ((state_ & 1) == 0)
-    {
-      waiter w(state_);
-      cond_.wait_for(u_lock.unique_lock_, std::chrono::microseconds(usec));
-    }
-    return (state_ & 1) != 0;
-  }
-
-private:
-  // Helper class to temporarily adapt a scoped_lock into a unique_lock so that
-  // it can be passed to std::condition_variable::wait().
-  struct unique_lock_adapter
-  {
-    template <typename Lock>
-    explicit unique_lock_adapter(Lock& lock)
-      : unique_lock_(lock.mutex().mutex_, std::adopt_lock)
-    {
-    }
-
-    ~unique_lock_adapter()
-    {
-      unique_lock_.release();
-    }
-
-    std::unique_lock<std::mutex> unique_lock_;
-  };
-
-  // Helper to increment and decrement the state to track outstanding waiters.
-  class waiter
-  {
-  public:
-    explicit waiter(std::size_t& state)
-      : state_(state)
-    {
-      state_ += 2;
-    }
-
-    ~waiter()
-    {
-      state_ -= 2;
-    }
-
-  private:
-    std::size_t& state_;
-  };
-
-  std::condition_variable cond_;
-  std::size_t state_;
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // defined(ASIO_HAS_STD_MUTEX_AND_CONDVAR)
-
-#endif // ASIO_DETAIL_STD_EVENT_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/std_mutex.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/std_mutex.hpp
deleted file mode 100644
index d88a08b484aa..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/std_mutex.hpp
+++ /dev/null
@@ -1,73 +0,0 @@
-//
-// detail/std_mutex.hpp
-// ~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_STD_MUTEX_HPP
-#define ASIO_DETAIL_STD_MUTEX_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_HAS_STD_MUTEX_AND_CONDVAR)
-
-#include <mutex>
-#include "asio/detail/noncopyable.hpp"
-#include "asio/detail/scoped_lock.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-class std_event;
-
-class std_mutex
-  : private noncopyable
-{
-public:
-  typedef asio::detail::scoped_lock<std_mutex> scoped_lock;
-
-  // Constructor.
-  std_mutex()
-  {
-  }
-
-  // Destructor.
-  ~std_mutex()
-  {
-  }
-
-  // Lock the mutex.
-  void lock()
-  {
-    mutex_.lock();
-  }
-
-  // Unlock the mutex.
-  void unlock()
-  {
-    mutex_.unlock();
-  }
-
-private:
-  friend class std_event;
-  std::mutex mutex_;
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // defined(ASIO_HAS_STD_MUTEX_AND_CONDVAR)
-
-#endif // ASIO_DETAIL_STD_MUTEX_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/std_static_mutex.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/std_static_mutex.hpp
deleted file mode 100644
index c7c08c1e8bf8..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/std_static_mutex.hpp
+++ /dev/null
@@ -1,81 +0,0 @@
-//
-// detail/std_static_mutex.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_STD_STATIC_MUTEX_HPP
-#define ASIO_DETAIL_STD_STATIC_MUTEX_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_HAS_STD_MUTEX_AND_CONDVAR)
-
-#include <mutex>
-#include "asio/detail/noncopyable.hpp"
-#include "asio/detail/scoped_lock.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-class std_event;
-
-class std_static_mutex
-  : private noncopyable
-{
-public:
-  typedef asio::detail::scoped_lock<std_static_mutex> scoped_lock;
-
-  // Constructor.
-  std_static_mutex(int)
-  {
-  }
-
-  // Destructor.
-  ~std_static_mutex()
-  {
-  }
-
-  // Initialise the mutex.
-  void init()
-  {
-    // Nothing to do.
-  }
-
-  // Lock the mutex.
-  void lock()
-  {
-    mutex_.lock();
-  }
-
-  // Unlock the mutex.
-  void unlock()
-  {
-    mutex_.unlock();
-  }
-
-private:
-  friend class std_event;
-  std::mutex mutex_;
-};
-
-#define ASIO_STD_STATIC_MUTEX_INIT 0
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // defined(ASIO_HAS_STD_MUTEX_AND_CONDVAR)
-
-#endif // ASIO_DETAIL_STD_STATIC_MUTEX_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/std_thread.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/std_thread.hpp
deleted file mode 100644
index b93a165dca17..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/std_thread.hpp
+++ /dev/null
@@ -1,65 +0,0 @@
-//
-// detail/std_thread.hpp
-// ~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_STD_THREAD_HPP
-#define ASIO_DETAIL_STD_THREAD_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_HAS_STD_THREAD)
-
-#include <thread>
-#include "asio/detail/noncopyable.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-class std_thread
-  : private noncopyable
-{
-public:
-  // Constructor.
-  template <typename Function>
-  std_thread(Function f, unsigned int = 0)
-    : thread_(f)
-  {
-  }
-
-  // Destructor.
-  ~std_thread()
-  {
-    join();
-  }
-
-  // Wait for the thread to exit.
-  void join()
-  {
-    if (thread_.joinable())
-      thread_.join();
-  }
-
-private:
-  std::thread thread_;
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // defined(ASIO_HAS_STD_THREAD)
-
-#endif // ASIO_DETAIL_STD_THREAD_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/strand_service.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/strand_service.hpp
deleted file mode 100644
index e2c5530b9391..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/strand_service.hpp
+++ /dev/null
@@ -1,142 +0,0 @@
-//
-// detail/strand_service.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_STRAND_SERVICE_HPP
-#define ASIO_DETAIL_STRAND_SERVICE_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include "asio/io_service.hpp"
-#include "asio/detail/mutex.hpp"
-#include "asio/detail/op_queue.hpp"
-#include "asio/detail/operation.hpp"
-#include "asio/detail/scoped_ptr.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-// Default service implementation for a strand.
-class strand_service
-  : public asio::detail::service_base<strand_service>
-{
-private:
-  // Helper class to re-post the strand on exit.
-  struct on_do_complete_exit;
-
-  // Helper class to re-post the strand on exit.
-  struct on_dispatch_exit;
-
-public:
-
-  // The underlying implementation of a strand.
-  class strand_impl
-    : public operation
-  {
-  public:
-    strand_impl();
-
-  private:
-    // Only this service will have access to the internal values.
-    friend class strand_service;
-    friend struct on_do_complete_exit;
-    friend struct on_dispatch_exit;
-
-    // Mutex to protect access to internal data.
-    asio::detail::mutex mutex_;
-
-    // Indicates whether the strand is currently "locked" by a handler. This
-    // means that there is a handler upcall in progress, or that the strand
-    // itself has been scheduled in order to invoke some pending handlers.
-    bool locked_;
-
-    // The handlers that are waiting on the strand but should not be run until
-    // after the next time the strand is scheduled. This queue must only be
-    // modified while the mutex is locked.
-    op_queue<operation> waiting_queue_;
-
-    // The handlers that are ready to be run. Logically speaking, these are the
-    // handlers that hold the strand's lock. The ready queue is only modified
-    // from within the strand and so may be accessed without locking the mutex.
-    op_queue<operation> ready_queue_;
-  };
-
-  typedef strand_impl* implementation_type;
-
-  // Construct a new strand service for the specified io_service.
-  ASIO_DECL explicit strand_service(asio::io_service& io_service);
-
-  // Destroy all user-defined handler objects owned by the service.
-  ASIO_DECL void shutdown_service();
-
-  // Construct a new strand implementation.
-  ASIO_DECL void construct(implementation_type& impl);
-
-  // Request the io_service to invoke the given handler.
-  template <typename Handler>
-  void dispatch(implementation_type& impl, Handler& handler);
-
-  // Request the io_service to invoke the given handler and return immediately.
-  template <typename Handler>
-  void post(implementation_type& impl, Handler& handler);
-
-  // Determine whether the strand is running in the current thread.
-  ASIO_DECL bool running_in_this_thread(
-      const implementation_type& impl) const;
-
-private:
-  // Helper function to dispatch a handler. Returns true if the handler should
-  // be dispatched immediately.
-  ASIO_DECL bool do_dispatch(implementation_type& impl, operation* op);
-
-  // Helper fiunction to post a handler.
-  ASIO_DECL void do_post(implementation_type& impl,
-      operation* op, bool is_continuation);
-
-  ASIO_DECL static void do_complete(io_service_impl* owner,
-      operation* base, const asio::error_code& ec,
-      std::size_t bytes_transferred);
-
-  // The io_service implementation used to post completions.
-  io_service_impl& io_service_;
-
-  // Mutex to protect access to the array of implementations.
-  asio::detail::mutex mutex_;
-
-  // Number of implementations shared between all strand objects.
-#if defined(ASIO_STRAND_IMPLEMENTATIONS)
-  enum { num_implementations = ASIO_STRAND_IMPLEMENTATIONS };
-#else // defined(ASIO_STRAND_IMPLEMENTATIONS)
-  enum { num_implementations = 193 };
-#endif // defined(ASIO_STRAND_IMPLEMENTATIONS)
-
-  // Pool of implementations.
-  scoped_ptr<strand_impl> implementations_[num_implementations];
-
-  // Extra value used when hashing to prevent recycled memory locations from
-  // getting the same strand implementation.
-  std::size_t salt_;
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#include "asio/detail/impl/strand_service.hpp"
-#if defined(ASIO_HEADER_ONLY)
-# include "asio/detail/impl/strand_service.ipp"
-#endif // defined(ASIO_HEADER_ONLY)
-
-#endif // ASIO_DETAIL_STRAND_SERVICE_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/task_io_service.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/task_io_service.hpp
deleted file mode 100644
index 569c41aaf1a7..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/task_io_service.hpp
+++ /dev/null
@@ -1,201 +0,0 @@
-//
-// detail/task_io_service.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_TASK_IO_SERVICE_HPP
-#define ASIO_DETAIL_TASK_IO_SERVICE_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if !defined(ASIO_HAS_IOCP)
-
-#include "asio/error_code.hpp"
-#include "asio/io_service.hpp"
-#include "asio/detail/atomic_count.hpp"
-#include "asio/detail/call_stack.hpp"
-#include "asio/detail/event.hpp"
-#include "asio/detail/mutex.hpp"
-#include "asio/detail/op_queue.hpp"
-#include "asio/detail/reactor_fwd.hpp"
-#include "asio/detail/task_io_service_operation.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-struct task_io_service_thread_info;
-
-class task_io_service
-  : public asio::detail::service_base<task_io_service>
-{
-public:
-  typedef task_io_service_operation operation;
-
-  // Constructor. Specifies the number of concurrent threads that are likely to
-  // run the io_service. If set to 1 certain optimisation are performed.
-  ASIO_DECL task_io_service(asio::io_service& io_service,
-      std::size_t concurrency_hint = 0);
-
-  // Destroy all user-defined handler objects owned by the service.
-  ASIO_DECL void shutdown_service();
-
-  // Initialise the task, if required.
-  ASIO_DECL void init_task();
-
-  // Run the event loop until interrupted or no more work.
-  ASIO_DECL std::size_t run(asio::error_code& ec);
-
-  // Run until interrupted or one operation is performed.
-  ASIO_DECL std::size_t run_one(asio::error_code& ec);
-
-  // Poll for operations without blocking.
-  ASIO_DECL std::size_t poll(asio::error_code& ec);
-
-  // Poll for one operation without blocking.
-  ASIO_DECL std::size_t poll_one(asio::error_code& ec);
-
-  // Interrupt the event processing loop.
-  ASIO_DECL void stop();
-
-  // Determine whether the io_service is stopped.
-  ASIO_DECL bool stopped() const;
-
-  // Reset in preparation for a subsequent run invocation.
-  ASIO_DECL void reset();
-
-  // Notify that some work has started.
-  void work_started()
-  {
-    ++outstanding_work_;
-  }
-
-  // Notify that some work has finished.
-  void work_finished()
-  {
-    if (--outstanding_work_ == 0)
-      stop();
-  }
-
-  // Return whether a handler can be dispatched immediately.
-  bool can_dispatch()
-  {
-    return thread_call_stack::contains(this) != 0;
-  }
-
-  // Request invocation of the given handler.
-  template <typename Handler>
-  void dispatch(Handler& handler);
-
-  // Request invocation of the given handler and return immediately.
-  template <typename Handler>
-  void post(Handler& handler);
-
-  // Request invocation of the given operation and return immediately. Assumes
-  // that work_started() has not yet been called for the operation.
-  ASIO_DECL void post_immediate_completion(
-      operation* op, bool is_continuation);
-
-  // Request invocation of the given operation and return immediately. Assumes
-  // that work_started() was previously called for the operation.
-  ASIO_DECL void post_deferred_completion(operation* op);
-
-  // Request invocation of the given operations and return immediately. Assumes
-  // that work_started() was previously called for each operation.
-  ASIO_DECL void post_deferred_completions(op_queue<operation>& ops);
-
-  // Process unfinished operations as part of a shutdown_service operation.
-  // Assumes that work_started() was previously called for the operations.
-  ASIO_DECL void abandon_operations(op_queue<operation>& ops);
-
-private:
-  // Structure containing thread-specific data.
-  typedef task_io_service_thread_info thread_info;
-
-  // Enqueue the given operation following a failed attempt to dispatch the
-  // operation for immediate invocation.
-  ASIO_DECL void do_dispatch(operation* op);
-
-  // Run at most one operation. May block.
-  ASIO_DECL std::size_t do_run_one(mutex::scoped_lock& lock,
-      thread_info& this_thread, const asio::error_code& ec);
-
-  // Poll for at most one operation.
-  ASIO_DECL std::size_t do_poll_one(mutex::scoped_lock& lock,
-      thread_info& this_thread, const asio::error_code& ec);
-
-  // Stop the task and all idle threads.
-  ASIO_DECL void stop_all_threads(mutex::scoped_lock& lock);
-
-  // Wake a single idle thread, or the task, and always unlock the mutex.
-  ASIO_DECL void wake_one_thread_and_unlock(
-      mutex::scoped_lock& lock);
-
-  // Helper class to perform task-related operations on block exit.
-  struct task_cleanup;
-  friend struct task_cleanup;
-
-  // Helper class to call work-related operations on block exit.
-  struct work_cleanup;
-  friend struct work_cleanup;
-
-  // Whether to optimise for single-threaded use cases.
-  const bool one_thread_;
-
-  // Mutex to protect access to internal data.
-  mutable mutex mutex_;
-
-  // Event to wake up blocked threads.
-  event wakeup_event_;
-
-  // The task to be run by this service.
-  reactor* task_;
-
-  // Operation object to represent the position of the task in the queue.
-  struct task_operation : operation
-  {
-    task_operation() : operation(0) {}
-  } task_operation_;
-
-  // Whether the task has been interrupted.
-  bool task_interrupted_;
-
-  // The count of unfinished work.
-  atomic_count outstanding_work_;
-
-  // The queue of handlers that are ready to be delivered.
-  op_queue<operation> op_queue_;
-
-  // Flag to indicate that the dispatcher has been stopped.
-  bool stopped_;
-
-  // Flag to indicate that the dispatcher has been shut down.
-  bool shutdown_;
-
-  // Per-thread call stack to track the state of each thread in the io_service.
-  typedef call_stack<task_io_service, thread_info> thread_call_stack;
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#include "asio/detail/impl/task_io_service.hpp"
-#if defined(ASIO_HEADER_ONLY)
-# include "asio/detail/impl/task_io_service.ipp"
-#endif // defined(ASIO_HEADER_ONLY)
-
-#endif // !defined(ASIO_HAS_IOCP)
-
-#endif // ASIO_DETAIL_TASK_IO_SERVICE_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/task_io_service_operation.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/task_io_service_operation.hpp
deleted file mode 100644
index 9dbfa16f97f5..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/task_io_service_operation.hpp
+++ /dev/null
@@ -1,76 +0,0 @@
-//
-// detail/task_io_service_operation.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_TASK_IO_SERVICE_OPERATION_HPP
-#define ASIO_DETAIL_TASK_IO_SERVICE_OPERATION_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/error_code.hpp"
-#include "asio/detail/handler_tracking.hpp"
-#include "asio/detail/op_queue.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-class task_io_service;
-
-// Base class for all operations. A function pointer is used instead of virtual
-// functions to avoid the associated overhead.
-class task_io_service_operation ASIO_INHERIT_TRACKED_HANDLER
-{
-public:
-  void complete(task_io_service& owner,
-      const asio::error_code& ec, std::size_t bytes_transferred)
-  {
-    func_(&owner, this, ec, bytes_transferred);
-  }
-
-  void destroy()
-  {
-    func_(0, this, asio::error_code(), 0);
-  }
-
-protected:
-  typedef void (*func_type)(task_io_service*,
-      task_io_service_operation*,
-      const asio::error_code&, std::size_t);
-
-  task_io_service_operation(func_type func)
-    : next_(0),
-      func_(func),
-      task_result_(0)
-  {
-  }
-
-  // Prevents deletion through this type.
-  ~task_io_service_operation()
-  {
-  }
-
-private:
-  friend class op_queue_access;
-  task_io_service_operation* next_;
-  func_type func_;
-protected:
-  friend class task_io_service;
-  unsigned int task_result_; // Passed into bytes transferred.
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_DETAIL_TASK_IO_SERVICE_OPERATION_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/task_io_service_thread_info.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/task_io_service_thread_info.hpp
deleted file mode 100644
index 862c8753f6ec..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/task_io_service_thread_info.hpp
+++ /dev/null
@@ -1,40 +0,0 @@
-//
-// detail/task_io_service_thread_info.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_TASK_IO_SERVICE_THREAD_INFO_HPP
-#define ASIO_DETAIL_TASK_IO_SERVICE_THREAD_INFO_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/op_queue.hpp"
-#include "asio/detail/thread_info_base.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-class task_io_service;
-class task_io_service_operation;
-
-struct task_io_service_thread_info : public thread_info_base
-{
-  op_queue<task_io_service_operation> private_op_queue;
-  long private_outstanding_work;
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_DETAIL_TASK_IO_SERVICE_THREAD_INFO_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/thread.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/thread.hpp
deleted file mode 100644
index fc9155b0725e..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/thread.hpp
+++ /dev/null
@@ -1,56 +0,0 @@
-//
-// detail/thread.hpp
-// ~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_THREAD_HPP
-#define ASIO_DETAIL_THREAD_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if !defined(ASIO_HAS_THREADS)
-# include "asio/detail/null_thread.hpp"
-#elif defined(ASIO_WINDOWS)
-# if defined(UNDER_CE)
-#  include "asio/detail/wince_thread.hpp"
-# else
-#  include "asio/detail/win_thread.hpp"
-# endif
-#elif defined(ASIO_HAS_PTHREADS)
-# include "asio/detail/posix_thread.hpp"
-#elif defined(ASIO_HAS_STD_THREAD)
-# include "asio/detail/std_thread.hpp"
-#else
-# error Only Windows, POSIX and std::thread are supported!
-#endif
-
-namespace asio {
-namespace detail {
-
-#if !defined(ASIO_HAS_THREADS)
-typedef null_thread thread;
-#elif defined(ASIO_WINDOWS)
-# if defined(UNDER_CE)
-typedef wince_thread thread;
-# else
-typedef win_thread thread;
-# endif
-#elif defined(ASIO_HAS_PTHREADS)
-typedef posix_thread thread;
-#elif defined(ASIO_HAS_STD_THREAD)
-typedef std_thread thread;
-#endif
-
-} // namespace detail
-} // namespace asio
-
-#endif // ASIO_DETAIL_THREAD_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/thread_info_base.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/thread_info_base.hpp
deleted file mode 100644
index 40d77e6e5c9a..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/thread_info_base.hpp
+++ /dev/null
@@ -1,91 +0,0 @@
-//
-// detail/thread_info_base.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_THREAD_INFO_BASE_HPP
-#define ASIO_DETAIL_THREAD_INFO_BASE_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include <climits>
-#include <cstddef>
-#include "asio/detail/noncopyable.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-class thread_info_base
-  : private noncopyable
-{
-public:
-  thread_info_base()
-    : reusable_memory_(0)
-  {
-  }
-
-  ~thread_info_base()
-  {
-    if (reusable_memory_)
-      ::operator delete(reusable_memory_);
-  }
-
-  static void* allocate(thread_info_base* this_thread, std::size_t size)
-  {
-    if (this_thread && this_thread->reusable_memory_)
-    {
-      void* const pointer = this_thread->reusable_memory_;
-      this_thread->reusable_memory_ = 0;
-
-      unsigned char* const mem = static_cast<unsigned char*>(pointer);
-      if (static_cast<std::size_t>(mem[0]) >= size)
-      {
-        mem[size] = mem[0];
-        return pointer;
-      }
-
-      ::operator delete(pointer);
-    }
-
-    void* const pointer = ::operator new(size + 1);
-    unsigned char* const mem = static_cast<unsigned char*>(pointer);
-    mem[size] = (size <= UCHAR_MAX) ? static_cast<unsigned char>(size) : 0;
-    return pointer;
-  }
-
-  static void deallocate(thread_info_base* this_thread,
-      void* pointer, std::size_t size)
-  {
-    if (size <= UCHAR_MAX)
-    {
-      if (this_thread && this_thread->reusable_memory_ == 0)
-      {
-        unsigned char* const mem = static_cast<unsigned char*>(pointer);
-        mem[0] = mem[size];
-        this_thread->reusable_memory_ = pointer;
-        return;
-      }
-    }
-
-    ::operator delete(pointer);
-  }
-
-private:
-  void* reusable_memory_;
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_DETAIL_THREAD_INFO_BASE_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/throw_error.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/throw_error.hpp
deleted file mode 100644
index 34a08a855809..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/throw_error.hpp
+++ /dev/null
@@ -1,53 +0,0 @@
-//
-// detail/throw_error.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_THROW_ERROR_HPP
-#define ASIO_DETAIL_THROW_ERROR_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include "asio/error_code.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-ASIO_DECL void do_throw_error(const asio::error_code& err);
-
-ASIO_DECL void do_throw_error(const asio::error_code& err,
-    const char* location);
-
-inline void throw_error(const asio::error_code& err)
-{
-  if (err)
-    do_throw_error(err);
-}
-
-inline void throw_error(const asio::error_code& err,
-    const char* location)
-{
-  if (err)
-    do_throw_error(err, location);
-}
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#if defined(ASIO_HEADER_ONLY)
-# include "asio/detail/impl/throw_error.ipp"
-#endif // defined(ASIO_HEADER_ONLY)
-
-#endif // ASIO_DETAIL_THROW_ERROR_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/throw_exception.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/throw_exception.hpp
deleted file mode 100644
index 5587a0081797..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/throw_exception.hpp
+++ /dev/null
@@ -1,51 +0,0 @@
-//
-// detail/throw_exception.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_THROW_EXCEPTION_HPP
-#define ASIO_DETAIL_THROW_EXCEPTION_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_HAS_BOOST_THROW_EXCEPTION)
-# include <boost/throw_exception.hpp>
-#endif // defined(ASIO_BOOST_THROW_EXCEPTION)
-
-namespace asio {
-namespace detail {
-
-#if defined(ASIO_HAS_BOOST_THROW_EXCEPTION)
-using boost::throw_exception;
-#else // defined(ASIO_HAS_BOOST_THROW_EXCEPTION)
-
-// Declare the throw_exception function for all targets.
-template <typename Exception>
-void throw_exception(const Exception& e);
-
-// Only define the throw_exception function when exceptions are enabled.
-// Otherwise, it is up to the application to provide a definition of this
-// function.
-# if !defined(ASIO_NO_EXCEPTIONS)
-template <typename Exception>
-void throw_exception(const Exception& e)
-{
-  throw e;
-}
-# endif // !defined(ASIO_NO_EXCEPTIONS)
-
-#endif // defined(ASIO_HAS_BOOST_THROW_EXCEPTION)
-
-} // namespace detail
-} // namespace asio
-
-#endif // ASIO_DETAIL_THROW_EXCEPTION_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/timer_queue.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/timer_queue.hpp
deleted file mode 100644
index 171619cff073..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/timer_queue.hpp
+++ /dev/null
@@ -1,332 +0,0 @@
-//
-// detail/timer_queue.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_TIMER_QUEUE_HPP
-#define ASIO_DETAIL_TIMER_QUEUE_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include <cstddef>
-#include <vector>
-#include "asio/detail/cstdint.hpp"
-#include "asio/detail/date_time_fwd.hpp"
-#include "asio/detail/limits.hpp"
-#include "asio/detail/op_queue.hpp"
-#include "asio/detail/timer_queue_base.hpp"
-#include "asio/detail/wait_op.hpp"
-#include "asio/error.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-template <typename Time_Traits>
-class timer_queue
-  : public timer_queue_base
-{
-public:
-  // The time type.
-  typedef typename Time_Traits::time_type time_type;
-
-  // The duration type.
-  typedef typename Time_Traits::duration_type duration_type;
-
-  // Per-timer data.
-  class per_timer_data
-  {
-  public:
-    per_timer_data() : next_(0), prev_(0) {}
-
-  private:
-    friend class timer_queue;
-
-    // The operations waiting on the timer.
-    op_queue<wait_op> op_queue_;
-
-    // The index of the timer in the heap.
-    std::size_t heap_index_;
-
-    // Pointers to adjacent timers in a linked list.
-    per_timer_data* next_;
-    per_timer_data* prev_;
-  };
-
-  // Constructor.
-  timer_queue()
-    : timers_(),
-      heap_()
-  {
-  }
-
-  // Add a new timer to the queue. Returns true if this is the timer that is
-  // earliest in the queue, in which case the reactor's event demultiplexing
-  // function call may need to be interrupted and restarted.
-  bool enqueue_timer(const time_type& time, per_timer_data& timer, wait_op* op)
-  {
-    // Enqueue the timer object.
-    if (timer.prev_ == 0 && &timer != timers_)
-    {
-      if (this->is_positive_infinity(time))
-      {
-        // No heap entry is required for timers that never expire.
-        timer.heap_index_ = (std::numeric_limits<std::size_t>::max)();
-      }
-      else
-      {
-        // Put the new timer at the correct position in the heap. This is done
-        // first since push_back() can throw due to allocation failure.
-        timer.heap_index_ = heap_.size();
-        heap_entry entry = { time, &timer };
-        heap_.push_back(entry);
-        up_heap(heap_.size() - 1);
-      }
-
-      // Insert the new timer into the linked list of active timers.
-      timer.next_ = timers_;
-      timer.prev_ = 0;
-      if (timers_)
-        timers_->prev_ = &timer;
-      timers_ = &timer;
-    }
-
-    // Enqueue the individual timer operation.
-    timer.op_queue_.push(op);
-
-    // Interrupt reactor only if newly added timer is first to expire.
-    return timer.heap_index_ == 0 && timer.op_queue_.front() == op;
-  }
-
-  // Whether there are no timers in the queue.
-  virtual bool empty() const
-  {
-    return timers_ == 0;
-  }
-
-  // Get the time for the timer that is earliest in the queue.
-  virtual long wait_duration_msec(long max_duration) const
-  {
-    if (heap_.empty())
-      return max_duration;
-
-    return this->to_msec(
-        Time_Traits::to_posix_duration(
-          Time_Traits::subtract(heap_[0].time_, Time_Traits::now())),
-        max_duration);
-  }
-
-  // Get the time for the timer that is earliest in the queue.
-  virtual long wait_duration_usec(long max_duration) const
-  {
-    if (heap_.empty())
-      return max_duration;
-
-    return this->to_usec(
-        Time_Traits::to_posix_duration(
-          Time_Traits::subtract(heap_[0].time_, Time_Traits::now())),
-        max_duration);
-  }
-
-  // Dequeue all timers not later than the current time.
-  virtual void get_ready_timers(op_queue<operation>& ops)
-  {
-    if (!heap_.empty())
-    {
-      const time_type now = Time_Traits::now();
-      while (!heap_.empty() && !Time_Traits::less_than(now, heap_[0].time_))
-      {
-        per_timer_data* timer = heap_[0].timer_;
-        ops.push(timer->op_queue_);
-        remove_timer(*timer);
-      }
-    }
-  }
-
-  // Dequeue all timers.
-  virtual void get_all_timers(op_queue<operation>& ops)
-  {
-    while (timers_)
-    {
-      per_timer_data* timer = timers_;
-      timers_ = timers_->next_;
-      ops.push(timer->op_queue_);
-      timer->next_ = 0;
-      timer->prev_ = 0;
-    }
-
-    heap_.clear();
-  }
-
-  // Cancel and dequeue operations for the given timer.
-  std::size_t cancel_timer(per_timer_data& timer, op_queue<operation>& ops,
-      std::size_t max_cancelled = (std::numeric_limits<std::size_t>::max)())
-  {
-    std::size_t num_cancelled = 0;
-    if (timer.prev_ != 0 || &timer == timers_)
-    {
-      while (wait_op* op = (num_cancelled != max_cancelled)
-          ? timer.op_queue_.front() : 0)
-      {
-        op->ec_ = asio::error::operation_aborted;
-        timer.op_queue_.pop();
-        ops.push(op);
-        ++num_cancelled;
-      }
-      if (timer.op_queue_.empty())
-        remove_timer(timer);
-    }
-    return num_cancelled;
-  }
-
-private:
-  // Move the item at the given index up the heap to its correct position.
-  void up_heap(std::size_t index)
-  {
-    std::size_t parent = (index - 1) / 2;
-    while (index > 0
-        && Time_Traits::less_than(heap_[index].time_, heap_[parent].time_))
-    {
-      swap_heap(index, parent);
-      index = parent;
-      parent = (index - 1) / 2;
-    }
-  }
-
-  // Move the item at the given index down the heap to its correct position.
-  void down_heap(std::size_t index)
-  {
-    std::size_t child = index * 2 + 1;
-    while (child < heap_.size())
-    {
-      std::size_t min_child = (child + 1 == heap_.size()
-          || Time_Traits::less_than(
-            heap_[child].time_, heap_[child + 1].time_))
-        ? child : child + 1;
-      if (Time_Traits::less_than(heap_[index].time_, heap_[min_child].time_))
-        break;
-      swap_heap(index, min_child);
-      index = min_child;
-      child = index * 2 + 1;
-    }
-  }
-
-  // Swap two entries in the heap.
-  void swap_heap(std::size_t index1, std::size_t index2)
-  {
-    heap_entry tmp = heap_[index1];
-    heap_[index1] = heap_[index2];
-    heap_[index2] = tmp;
-    heap_[index1].timer_->heap_index_ = index1;
-    heap_[index2].timer_->heap_index_ = index2;
-  }
-
-  // Remove a timer from the heap and list of timers.
-  void remove_timer(per_timer_data& timer)
-  {
-    // Remove the timer from the heap.
-    std::size_t index = timer.heap_index_;
-    if (!heap_.empty() && index < heap_.size())
-    {
-      if (index == heap_.size() - 1)
-      {
-        heap_.pop_back();
-      }
-      else
-      {
-        swap_heap(index, heap_.size() - 1);
-        heap_.pop_back();
-        std::size_t parent = (index - 1) / 2;
-        if (index > 0 && Time_Traits::less_than(
-              heap_[index].time_, heap_[parent].time_))
-          up_heap(index);
-        else
-          down_heap(index);
-      }
-    }
-
-    // Remove the timer from the linked list of active timers.
-    if (timers_ == &timer)
-      timers_ = timer.next_;
-    if (timer.prev_)
-      timer.prev_->next_ = timer.next_;
-    if (timer.next_)
-      timer.next_->prev_= timer.prev_;
-    timer.next_ = 0;
-    timer.prev_ = 0;
-  }
-
-  // Determine if the specified absolute time is positive infinity.
-  template <typename Time_Type>
-  static bool is_positive_infinity(const Time_Type&)
-  {
-    return false;
-  }
-
-  // Determine if the specified absolute time is positive infinity.
-  template <typename T, typename TimeSystem>
-  static bool is_positive_infinity(
-      const boost::date_time::base_time<T, TimeSystem>& time)
-  {
-    return time.is_pos_infinity();
-  }
-
-  // Helper function to convert a duration into milliseconds.
-  template <typename Duration>
-  long to_msec(const Duration& d, long max_duration) const
-  {
-    if (d.ticks() <= 0)
-      return 0;
-    int64_t msec = d.total_milliseconds();
-    if (msec == 0)
-      return 1;
-    if (msec > max_duration)
-      return max_duration;
-    return static_cast<long>(msec);
-  }
-
-  // Helper function to convert a duration into microseconds.
-  template <typename Duration>
-  long to_usec(const Duration& d, long max_duration) const
-  {
-    if (d.ticks() <= 0)
-      return 0;
-    int64_t usec = d.total_microseconds();
-    if (usec == 0)
-      return 1;
-    if (usec > max_duration)
-      return max_duration;
-    return static_cast<long>(usec);
-  }
-
-  // The head of a linked list of all active timers.
-  per_timer_data* timers_;
-
-  struct heap_entry
-  {
-    // The time when the timer should fire.
-    time_type time_;
-
-    // The associated timer with enqueued operations.
-    per_timer_data* timer_;
-  };
-
-  // The heap of timers, with the earliest timer at the front.
-  std::vector<heap_entry> heap_;
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_DETAIL_TIMER_QUEUE_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/timer_queue_base.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/timer_queue_base.hpp
deleted file mode 100644
index 6d0be83b4227..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/timer_queue_base.hpp
+++ /dev/null
@@ -1,68 +0,0 @@
-//
-// detail/timer_queue_base.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_TIMER_QUEUE_BASE_HPP
-#define ASIO_DETAIL_TIMER_QUEUE_BASE_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include "asio/detail/noncopyable.hpp"
-#include "asio/detail/op_queue.hpp"
-#include "asio/detail/operation.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-class timer_queue_base
-  : private noncopyable
-{
-public:
-  // Constructor.
-  timer_queue_base() : next_(0) {}
-
-  // Destructor.
-  virtual ~timer_queue_base() {}
-
-  // Whether there are no timers in the queue.
-  virtual bool empty() const = 0;
-
-  // Get the time to wait until the next timer.
-  virtual long wait_duration_msec(long max_duration) const = 0;
-
-  // Get the time to wait until the next timer.
-  virtual long wait_duration_usec(long max_duration) const = 0;
-
-  // Dequeue all ready timers.
-  virtual void get_ready_timers(op_queue<operation>& ops) = 0;
-
-  // Dequeue all timers.
-  virtual void get_all_timers(op_queue<operation>& ops) = 0;
-
-private:
-  friend class timer_queue_set;
-
-  // Next timer queue in the set.
-  timer_queue_base* next_;
-};
-
-template <typename Time_Traits>
-class timer_queue;
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_DETAIL_TIMER_QUEUE_BASE_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/timer_queue_ptime.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/timer_queue_ptime.hpp
deleted file mode 100644
index 989e150acfdd..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/timer_queue_ptime.hpp
+++ /dev/null
@@ -1,93 +0,0 @@
-//
-// detail/timer_queue_ptime.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_TIMER_QUEUE_PTIME_HPP
-#define ASIO_DETAIL_TIMER_QUEUE_PTIME_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/time_traits.hpp"
-#include "asio/detail/timer_queue.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-#if defined(ASIO_HAS_BOOST_DATE_TIME)
-
-namespace asio {
-namespace detail {
-
-struct forwarding_posix_time_traits : time_traits<boost::posix_time::ptime> {};
-
-// Template specialisation for the commonly used instantation.
-template <>
-class timer_queue<time_traits<boost::posix_time::ptime> >
-  : public timer_queue_base
-{
-public:
-  // The time type.
-  typedef boost::posix_time::ptime time_type;
-
-  // The duration type.
-  typedef boost::posix_time::time_duration duration_type;
-
-  // Per-timer data.
-  typedef timer_queue<forwarding_posix_time_traits>::per_timer_data
-    per_timer_data;
-
-  // Constructor.
-  ASIO_DECL timer_queue();
-
-  // Destructor.
-  ASIO_DECL virtual ~timer_queue();
-
-  // Add a new timer to the queue. Returns true if this is the timer that is
-  // earliest in the queue, in which case the reactor's event demultiplexing
-  // function call may need to be interrupted and restarted.
-  ASIO_DECL bool enqueue_timer(const time_type& time,
-      per_timer_data& timer, wait_op* op);
-
-  // Whether there are no timers in the queue.
-  ASIO_DECL virtual bool empty() const;
-
-  // Get the time for the timer that is earliest in the queue.
-  ASIO_DECL virtual long wait_duration_msec(long max_duration) const;
-
-  // Get the time for the timer that is earliest in the queue.
-  ASIO_DECL virtual long wait_duration_usec(long max_duration) const;
-
-  // Dequeue all timers not later than the current time.
-  ASIO_DECL virtual void get_ready_timers(op_queue<operation>& ops);
-
-  // Dequeue all timers.
-  ASIO_DECL virtual void get_all_timers(op_queue<operation>& ops);
-
-  // Cancel and dequeue operations for the given timer.
-  ASIO_DECL std::size_t cancel_timer(
-      per_timer_data& timer, op_queue<operation>& ops,
-      std::size_t max_cancelled = (std::numeric_limits<std::size_t>::max)());
-
-private:
-  timer_queue<forwarding_posix_time_traits> impl_;
-};
-
-} // namespace detail
-} // namespace asio
-
-#endif // defined(ASIO_HAS_BOOST_DATE_TIME)
-
-#include "asio/detail/pop_options.hpp"
-
-#if defined(ASIO_HEADER_ONLY)
-# include "asio/detail/impl/timer_queue_ptime.ipp"
-#endif // defined(ASIO_HEADER_ONLY)
-
-#endif // ASIO_DETAIL_TIMER_QUEUE_PTIME_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/timer_queue_set.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/timer_queue_set.hpp
deleted file mode 100644
index 07306aa6bdd1..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/timer_queue_set.hpp
+++ /dev/null
@@ -1,66 +0,0 @@
-//
-// detail/timer_queue_set.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_TIMER_QUEUE_SET_HPP
-#define ASIO_DETAIL_TIMER_QUEUE_SET_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include "asio/detail/timer_queue_base.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-class timer_queue_set
-{
-public:
-  // Constructor.
-  ASIO_DECL timer_queue_set();
-
-  // Add a timer queue to the set.
-  ASIO_DECL void insert(timer_queue_base* q);
-
-  // Remove a timer queue from the set.
-  ASIO_DECL void erase(timer_queue_base* q);
-
-  // Determine whether all queues are empty.
-  ASIO_DECL bool all_empty() const;
-
-  // Get the wait duration in milliseconds.
-  ASIO_DECL long wait_duration_msec(long max_duration) const;
-
-  // Get the wait duration in microseconds.
-  ASIO_DECL long wait_duration_usec(long max_duration) const;
-
-  // Dequeue all ready timers.
-  ASIO_DECL void get_ready_timers(op_queue<operation>& ops);
-
-  // Dequeue all timers.
-  ASIO_DECL void get_all_timers(op_queue<operation>& ops);
-
-private:
-  timer_queue_base* first_;
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#if defined(ASIO_HEADER_ONLY)
-# include "asio/detail/impl/timer_queue_set.ipp"
-#endif // defined(ASIO_HEADER_ONLY)
-
-#endif // ASIO_DETAIL_TIMER_QUEUE_SET_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/timer_scheduler.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/timer_scheduler.hpp
deleted file mode 100644
index 9148e2bd4e2e..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/timer_scheduler.hpp
+++ /dev/null
@@ -1,35 +0,0 @@
-//
-// detail/timer_scheduler.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_TIMER_SCHEDULER_HPP
-#define ASIO_DETAIL_TIMER_SCHEDULER_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include "asio/detail/timer_scheduler_fwd.hpp"
-
-#if defined(ASIO_WINDOWS_RUNTIME)
-# include "asio/detail/winrt_timer_scheduler.hpp"
-#elif defined(ASIO_HAS_IOCP)
-# include "asio/detail/win_iocp_io_service.hpp"
-#elif defined(ASIO_HAS_EPOLL)
-# include "asio/detail/epoll_reactor.hpp"
-#elif defined(ASIO_HAS_KQUEUE)
-# include "asio/detail/kqueue_reactor.hpp"
-#elif defined(ASIO_HAS_DEV_POLL)
-# include "asio/detail/dev_poll_reactor.hpp"
-#else
-# include "asio/detail/select_reactor.hpp"
-#endif
-
-#endif // ASIO_DETAIL_TIMER_SCHEDULER_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/timer_scheduler_fwd.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/timer_scheduler_fwd.hpp
deleted file mode 100644
index 9ad660c6775d..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/timer_scheduler_fwd.hpp
+++ /dev/null
@@ -1,40 +0,0 @@
-//
-// detail/timer_scheduler_fwd.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_TIMER_SCHEDULER_FWD_HPP
-#define ASIO_DETAIL_TIMER_SCHEDULER_FWD_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-namespace asio {
-namespace detail {
-
-#if defined(ASIO_WINDOWS_RUNTIME)
-typedef class winrt_timer_scheduler timer_scheduler;
-#elif defined(ASIO_HAS_IOCP)
-typedef class win_iocp_io_service timer_scheduler;
-#elif defined(ASIO_HAS_EPOLL)
-typedef class epoll_reactor timer_scheduler;
-#elif defined(ASIO_HAS_KQUEUE)
-typedef class kqueue_reactor timer_scheduler;
-#elif defined(ASIO_HAS_DEV_POLL)
-typedef class dev_poll_reactor timer_scheduler;
-#else
-typedef class select_reactor timer_scheduler;
-#endif
-
-} // namespace detail
-} // namespace asio
-
-#endif // ASIO_DETAIL_TIMER_SCHEDULER_FWD_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/tss_ptr.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/tss_ptr.hpp
deleted file mode 100644
index bdb2df59d1cb..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/tss_ptr.hpp
+++ /dev/null
@@ -1,69 +0,0 @@
-//
-// detail/tss_ptr.hpp
-// ~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_TSS_PTR_HPP
-#define ASIO_DETAIL_TSS_PTR_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if !defined(ASIO_HAS_THREADS)
-# include "asio/detail/null_tss_ptr.hpp"
-#elif defined(ASIO_HAS_THREAD_KEYWORD_EXTENSION)
-# include "asio/detail/keyword_tss_ptr.hpp"
-#elif defined(ASIO_WINDOWS)
-# include "asio/detail/win_tss_ptr.hpp"
-#elif defined(ASIO_HAS_PTHREADS)
-# include "asio/detail/posix_tss_ptr.hpp"
-#else
-# error Only Windows and POSIX are supported!
-#endif
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-template <typename T>
-class tss_ptr
-#if !defined(ASIO_HAS_THREADS)
-  : public null_tss_ptr<T>
-#elif defined(ASIO_HAS_THREAD_KEYWORD_EXTENSION)
-  : public keyword_tss_ptr<T>
-#elif defined(ASIO_WINDOWS)
-  : public win_tss_ptr<T>
-#elif defined(ASIO_HAS_PTHREADS)
-  : public posix_tss_ptr<T>
-#endif
-{
-public:
-  void operator=(T* value)
-  {
-#if !defined(ASIO_HAS_THREADS)
-    null_tss_ptr<T>::operator=(value);
-#elif defined(ASIO_HAS_THREAD_KEYWORD_EXTENSION)
-    keyword_tss_ptr<T>::operator=(value);
-#elif defined(ASIO_WINDOWS)
-    win_tss_ptr<T>::operator=(value);
-#elif defined(ASIO_HAS_PTHREADS)
-    posix_tss_ptr<T>::operator=(value);
-#endif
-  }
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_DETAIL_TSS_PTR_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/type_traits.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/type_traits.hpp
deleted file mode 100644
index e701ecadb46d..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/type_traits.hpp
+++ /dev/null
@@ -1,58 +0,0 @@
-//
-// detail/type_traits.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_TYPE_TRAITS_HPP
-#define ASIO_DETAIL_TYPE_TRAITS_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_HAS_STD_TYPE_TRAITS)
-# include <type_traits>
-#else // defined(ASIO_HAS_TYPE_TRAITS)
-# include <boost/type_traits/add_const.hpp>
-# include <boost/type_traits/is_const.hpp>
-# include <boost/type_traits/is_convertible.hpp>
-# include <boost/type_traits/is_function.hpp>
-# include <boost/type_traits/is_same.hpp>
-# include <boost/type_traits/remove_pointer.hpp>
-# include <boost/type_traits/remove_reference.hpp>
-# include <boost/utility/enable_if.hpp>
-#endif // defined(ASIO_HAS_TYPE_TRAITS)
-
-namespace asio {
-
-#if defined(ASIO_HAS_STD_TYPE_TRAITS)
-using std::add_const;
-using std::enable_if;
-using std::is_const;
-using std::is_convertible;
-using std::is_function;
-using std::is_same;
-using std::remove_pointer;
-using std::remove_reference;
-#else // defined(ASIO_HAS_STD_TYPE_TRAITS)
-using boost::add_const;
-template <bool Condition, typename Type = void>
-struct enable_if : boost::enable_if_c<Condition, Type> {};
-using boost::is_const;
-using boost::is_convertible;
-using boost::is_function;
-using boost::is_same;
-using boost::remove_pointer;
-using boost::remove_reference;
-#endif // defined(ASIO_HAS_STD_TYPE_TRAITS)
-
-} // namespace asio
-
-#endif // ASIO_DETAIL_TYPE_TRAITS_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/variadic_templates.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/variadic_templates.hpp
deleted file mode 100644
index f8ea5c0eecaf..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/variadic_templates.hpp
+++ /dev/null
@@ -1,63 +0,0 @@
-//
-// detail/variadic_templates.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_VARIADIC_TEMPLATES_HPP
-#define ASIO_DETAIL_VARIADIC_TEMPLATES_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if !defined(ASIO_HAS_VARIADIC_TEMPLATES)
-
-# define ASIO_VARIADIC_TPARAMS(n) ASIO_VARIADIC_TPARAMS_##n
-
-# define ASIO_VARIADIC_TPARAMS_1 \
-  typename T1
-# define ASIO_VARIADIC_TPARAMS_2 \
-  typename T1, typename T2
-# define ASIO_VARIADIC_TPARAMS_3 \
-  typename T1, typename T2, typename T3
-# define ASIO_VARIADIC_TPARAMS_4 \
-  typename T1, typename T2, typename T3, typename T4
-# define ASIO_VARIADIC_TPARAMS_5 \
-  typename T1, typename T2, typename T3, typename T4, typename T5
-
-# define ASIO_VARIADIC_TARGS(n) ASIO_VARIADIC_TARGS_##n
-
-# define ASIO_VARIADIC_TARGS_1 x1
-# define ASIO_VARIADIC_TARGS_2 x1, x2
-# define ASIO_VARIADIC_TARGS_3 x1, x2, x3
-# define ASIO_VARIADIC_TARGS_4 x1, x2, x3, x4
-# define ASIO_VARIADIC_TARGS_5 x1, x2, x3, x4, x5
-
-# define ASIO_VARIADIC_PARAMS(n) ASIO_VARIADIC_PARAMS_##n
-
-# define ASIO_VARIADIC_PARAMS_1 T1 x1
-# define ASIO_VARIADIC_PARAMS_2 T1 x1, T2 x2
-# define ASIO_VARIADIC_PARAMS_3 T1 x1, T2 x2, T3 x3
-# define ASIO_VARIADIC_PARAMS_4 T1 x1, T2 x2, T3 x3, T4 x4
-# define ASIO_VARIADIC_PARAMS_5 T1 x1, T2 x2, T3 x3, T4 x4, T5 x5
-
-# define ASIO_VARIADIC_ARGS(n) ASIO_VARIADIC_ARGS_##n
-
-# define ASIO_VARIADIC_ARGS_1 x1
-# define ASIO_VARIADIC_ARGS_2 x1, x2
-# define ASIO_VARIADIC_ARGS_3 x1, x2, x3
-# define ASIO_VARIADIC_ARGS_4 x1, x2, x3, x4
-# define ASIO_VARIADIC_ARGS_5 x1, x2, x3, x4, x5
-
-# define ASIO_VARIADIC_GENERATE(m) m(1) m(2) m(3) m(4) m(5)
-
-#endif // !defined(ASIO_HAS_VARIADIC_TEMPLATES)
-
-#endif // ASIO_DETAIL_VARIADIC_TEMPLATES_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/wait_handler.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/wait_handler.hpp
deleted file mode 100644
index 752a18e5a2b7..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/wait_handler.hpp
+++ /dev/null
@@ -1,83 +0,0 @@
-//
-// detail/wait_handler.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_WAIT_HANDLER_HPP
-#define ASIO_DETAIL_WAIT_HANDLER_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include "asio/detail/addressof.hpp"
-#include "asio/detail/fenced_block.hpp"
-#include "asio/detail/handler_alloc_helpers.hpp"
-#include "asio/detail/handler_invoke_helpers.hpp"
-#include "asio/detail/wait_op.hpp"
-#include "asio/io_service.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-template <typename Handler>
-class wait_handler : public wait_op
-{
-public:
-  ASIO_DEFINE_HANDLER_PTR(wait_handler);
-
-  wait_handler(Handler& h)
-    : wait_op(&wait_handler::do_complete),
-      handler_(ASIO_MOVE_CAST(Handler)(h))
-  {
-  }
-
-  static void do_complete(io_service_impl* owner, operation* base,
-      const asio::error_code& /*ec*/,
-      std::size_t /*bytes_transferred*/)
-  {
-    // Take ownership of the handler object.
-    wait_handler* h(static_cast<wait_handler*>(base));
-    ptr p = { asio::detail::addressof(h->handler_), h, h };
-
-    ASIO_HANDLER_COMPLETION((h));
-
-    // Make a copy of the handler so that the memory can be deallocated before
-    // the upcall is made. Even if we're not about to make an upcall, a
-    // sub-object of the handler may be the true owner of the memory associated
-    // with the handler. Consequently, a local copy of the handler is required
-    // to ensure that any owning sub-object remains valid until after we have
-    // deallocated the memory here.
-    detail::binder1<Handler, asio::error_code>
-      handler(h->handler_, h->ec_);
-    p.h = asio::detail::addressof(handler.handler_);
-    p.reset();
-
-    // Make the upcall if required.
-    if (owner)
-    {
-      fenced_block b(fenced_block::half);
-      ASIO_HANDLER_INVOCATION_BEGIN((handler.arg1_));
-      asio_handler_invoke_helpers::invoke(handler, handler.handler_);
-      ASIO_HANDLER_INVOCATION_END;
-    }
-  }
-
-private:
-  Handler handler_;
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_DETAIL_WAIT_HANDLER_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/wait_op.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/wait_op.hpp
deleted file mode 100644
index 1838325aee78..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/wait_op.hpp
+++ /dev/null
@@ -1,45 +0,0 @@
-//
-// detail/wait_op.hpp
-// ~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_WAIT_OP_HPP
-#define ASIO_DETAIL_WAIT_OP_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include "asio/detail/operation.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-class wait_op
-  : public operation
-{
-public:
-  // The error code to be passed to the completion handler.
-  asio::error_code ec_;
-
-protected:
-  wait_op(func_type func)
-    : operation(func)
-  {
-  }
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_DETAIL_WAIT_OP_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/weak_ptr.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/weak_ptr.hpp
deleted file mode 100644
index cdfd315dc72e..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/weak_ptr.hpp
+++ /dev/null
@@ -1,38 +0,0 @@
-//
-// detail/weak_ptr.hpp
-// ~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_WEAK_PTR_HPP
-#define ASIO_DETAIL_WEAK_PTR_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_HAS_STD_SHARED_PTR)
-# include <memory>
-#else // defined(ASIO_HAS_STD_SHARED_PTR)
-# include <boost/weak_ptr.hpp>
-#endif // defined(ASIO_HAS_STD_SHARED_PTR)
-
-namespace asio {
-namespace detail {
-
-#if defined(ASIO_HAS_STD_SHARED_PTR)
-using std::weak_ptr;
-#else // defined(ASIO_HAS_STD_SHARED_PTR)
-using boost::weak_ptr;
-#endif // defined(ASIO_HAS_STD_SHARED_PTR)
-
-} // namespace detail
-} // namespace asio
-
-#endif // ASIO_DETAIL_WEAK_PTR_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/win_event.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/win_event.hpp
deleted file mode 100644
index b73abbd03a80..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/win_event.hpp
+++ /dev/null
@@ -1,126 +0,0 @@
-//
-// detail/win_event.hpp
-// ~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_WIN_EVENT_HPP
-#define ASIO_DETAIL_WIN_EVENT_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_WINDOWS)
-
-#include "asio/detail/assert.hpp"
-#include "asio/detail/noncopyable.hpp"
-#include "asio/detail/socket_types.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-class win_event
-  : private noncopyable
-{
-public:
-  // Constructor.
-  ASIO_DECL win_event();
-
-  // Destructor.
-  ASIO_DECL ~win_event();
-
-  // Signal the event. (Retained for backward compatibility.)
-  template <typename Lock>
-  void signal(Lock& lock)
-  {
-    this->signal_all(lock);
-  }
-
-  // Signal all waiters.
-  template <typename Lock>
-  void signal_all(Lock& lock)
-  {
-    ASIO_ASSERT(lock.locked());
-    (void)lock;
-    state_ |= 1;
-    ::SetEvent(events_[0]);
-  }
-
-  // Unlock the mutex and signal one waiter.
-  template <typename Lock>
-  void unlock_and_signal_one(Lock& lock)
-  {
-    ASIO_ASSERT(lock.locked());
-    state_ |= 1;
-    bool have_waiters = (state_ > 1);
-    lock.unlock();
-    if (have_waiters)
-      ::SetEvent(events_[1]);
-  }
-
-  // If there's a waiter, unlock the mutex and signal it.
-  template <typename Lock>
-  bool maybe_unlock_and_signal_one(Lock& lock)
-  {
-    ASIO_ASSERT(lock.locked());
-    state_ |= 1;
-    if (state_ > 1)
-    {
-      lock.unlock();
-      ::SetEvent(events_[1]);
-      return true;
-    }
-    return false;
-  }
-
-  // Reset the event.
-  template <typename Lock>
-  void clear(Lock& lock)
-  {
-    ASIO_ASSERT(lock.locked());
-    (void)lock;
-    ::ResetEvent(events_[0]);
-    state_ &= ~std::size_t(1);
-  }
-
-  // Wait for the event to become signalled.
-  template <typename Lock>
-  void wait(Lock& lock)
-  {
-    ASIO_ASSERT(lock.locked());
-    while ((state_ & 1) == 0)
-    {
-      state_ += 2;
-      lock.unlock();
-      ::WaitForMultipleObjects(2, events_, false, INFINITE);
-      lock.lock();
-      state_ -= 2;
-    }
-  }
-
-private:
-  HANDLE events_[2];
-  std::size_t state_;
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#if defined(ASIO_HEADER_ONLY)
-# include "asio/detail/impl/win_event.ipp"
-#endif // defined(ASIO_HEADER_ONLY)
-
-#endif // defined(ASIO_WINDOWS)
-
-#endif // ASIO_DETAIL_WIN_EVENT_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/win_fd_set_adapter.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/win_fd_set_adapter.hpp
deleted file mode 100644
index b7acdef20f56..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/win_fd_set_adapter.hpp
+++ /dev/null
@@ -1,149 +0,0 @@
-//
-// detail/win_fd_set_adapter.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_WIN_FD_SET_ADAPTER_HPP
-#define ASIO_DETAIL_WIN_FD_SET_ADAPTER_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-
-#include "asio/detail/noncopyable.hpp"
-#include "asio/detail/reactor_op_queue.hpp"
-#include "asio/detail/socket_types.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-// Adapts the FD_SET type to meet the Descriptor_Set concept's requirements.
-class win_fd_set_adapter : noncopyable
-{
-public:
-  enum { default_fd_set_size = 1024 };
-
-  win_fd_set_adapter()
-    : capacity_(default_fd_set_size),
-      max_descriptor_(invalid_socket)
-  {
-    fd_set_ = static_cast<win_fd_set*>(::operator new(
-          sizeof(win_fd_set) - sizeof(SOCKET)
-          + sizeof(SOCKET) * (capacity_)));
-    fd_set_->fd_count = 0;
-  }
-
-  ~win_fd_set_adapter()
-  {
-    ::operator delete(fd_set_);
-  }
-
-  void reset()
-  {
-    fd_set_->fd_count = 0;
-    max_descriptor_ = invalid_socket;
-  }
-
-  bool set(socket_type descriptor)
-  {
-    for (u_int i = 0; i < fd_set_->fd_count; ++i)
-      if (fd_set_->fd_array[i] == descriptor)
-        return true;
-
-    reserve(fd_set_->fd_count + 1);
-    fd_set_->fd_array[fd_set_->fd_count++] = descriptor;
-    return true;
-  }
-
-  void set(reactor_op_queue<socket_type>& operations, op_queue<operation>&)
-  {
-    reactor_op_queue<socket_type>::iterator i = operations.begin();
-    while (i != operations.end())
-    {
-      reactor_op_queue<socket_type>::iterator op_iter = i++;
-      reserve(fd_set_->fd_count + 1);
-      fd_set_->fd_array[fd_set_->fd_count++] = op_iter->first;
-    }
-  }
-
-  bool is_set(socket_type descriptor) const
-  {
-    return !!__WSAFDIsSet(descriptor,
-        const_cast<fd_set*>(reinterpret_cast<const fd_set*>(fd_set_)));
-  }
-
-  operator fd_set*()
-  {
-    return reinterpret_cast<fd_set*>(fd_set_);
-  }
-
-  socket_type max_descriptor() const
-  {
-    return max_descriptor_;
-  }
-
-  void perform(reactor_op_queue<socket_type>& operations,
-      op_queue<operation>& ops) const
-  {
-    for (u_int i = 0; i < fd_set_->fd_count; ++i)
-      operations.perform_operations(fd_set_->fd_array[i], ops);
-  }
-
-private:
-  // This structure is defined to be compatible with the Windows API fd_set
-  // structure, but without being dependent on the value of FD_SETSIZE. We use
-  // the "struct hack" to allow the number of descriptors to be varied at
-  // runtime.
-  struct win_fd_set
-  {
-    u_int fd_count;
-    SOCKET fd_array[1];
-  };
-
-  // Increase the fd_set_ capacity to at least the specified number of elements.
-  void reserve(u_int n)
-  {
-    if (n <= capacity_)
-      return;
-
-    u_int new_capacity = capacity_ + capacity_ / 2;
-    if (new_capacity < n)
-      new_capacity = n;
-
-    win_fd_set* new_fd_set = static_cast<win_fd_set*>(::operator new(
-          sizeof(win_fd_set) - sizeof(SOCKET)
-          + sizeof(SOCKET) * (new_capacity)));
-
-    new_fd_set->fd_count = fd_set_->fd_count;
-    for (u_int i = 0; i < fd_set_->fd_count; ++i)
-      new_fd_set->fd_array[i] = fd_set_->fd_array[i];
-
-    ::operator delete(fd_set_);
-    fd_set_ = new_fd_set;
-    capacity_ = new_capacity;
-  }
-
-  win_fd_set* fd_set_;
-  u_int capacity_;
-  socket_type max_descriptor_;
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-
-#endif // ASIO_DETAIL_WIN_FD_SET_ADAPTER_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/win_fenced_block.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/win_fenced_block.hpp
deleted file mode 100644
index 73b7b66db81c..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/win_fenced_block.hpp
+++ /dev/null
@@ -1,89 +0,0 @@
-//
-// detail/win_fenced_block.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_WIN_FENCED_BLOCK_HPP
-#define ASIO_DETAIL_WIN_FENCED_BLOCK_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_WINDOWS) && !defined(UNDER_CE)
-
-#include "asio/detail/socket_types.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-class win_fenced_block
-  : private noncopyable
-{
-public:
-  enum half_t { half };
-  enum full_t { full };
-
-  // Constructor for a half fenced block.
-  explicit win_fenced_block(half_t)
-  {
-  }
-
-  // Constructor for a full fenced block.
-  explicit win_fenced_block(full_t)
-  {
-#if defined(__BORLANDC__)
-    LONG barrier = 0;
-    ::InterlockedExchange(&barrier, 1);
-#elif defined(ASIO_MSVC) \
-  && ((ASIO_MSVC < 1400) || !defined(MemoryBarrier))
-# if defined(_M_IX86)
-#  pragma warning(push)
-#  pragma warning(disable:4793)
-    LONG barrier;
-    __asm { xchg barrier, eax }
-#  pragma warning(pop)
-# endif // defined(_M_IX86)
-#else
-    MemoryBarrier();
-#endif
-  }
-
-  // Destructor.
-  ~win_fenced_block()
-  {
-#if defined(__BORLANDC__)
-    LONG barrier = 0;
-    ::InterlockedExchange(&barrier, 1);
-#elif defined(ASIO_MSVC) \
-  && ((ASIO_MSVC < 1400) || !defined(MemoryBarrier))
-# if defined(_M_IX86)
-#  pragma warning(push)
-#  pragma warning(disable:4793)
-    LONG barrier;
-    __asm { xchg barrier, eax }
-#  pragma warning(pop)
-# endif // defined(_M_IX86)
-#else
-    MemoryBarrier();
-#endif
-  }
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // defined(ASIO_WINDOWS) && !defined(UNDER_CE)
-
-#endif // ASIO_DETAIL_WIN_FENCED_BLOCK_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/win_iocp_handle_read_op.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/win_iocp_handle_read_op.hpp
deleted file mode 100644
index 316c6aed8ff5..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/win_iocp_handle_read_op.hpp
+++ /dev/null
@@ -1,109 +0,0 @@
-//
-// detail/win_iocp_handle_read_op.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-// Copyright (c) 2008 Rep Invariant Systems, Inc. (info@repinvariant.com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_WIN_IOCP_HANDLE_READ_OP_HPP
-#define ASIO_DETAIL_WIN_IOCP_HANDLE_READ_OP_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_HAS_IOCP)
-
-#include "asio/error.hpp"
-#include "asio/detail/addressof.hpp"
-#include "asio/detail/bind_handler.hpp"
-#include "asio/detail/buffer_sequence_adapter.hpp"
-#include "asio/detail/fenced_block.hpp"
-#include "asio/detail/handler_alloc_helpers.hpp"
-#include "asio/detail/handler_invoke_helpers.hpp"
-#include "asio/detail/operation.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-template <typename MutableBufferSequence, typename Handler>
-class win_iocp_handle_read_op : public operation
-{
-public:
-  ASIO_DEFINE_HANDLER_PTR(win_iocp_handle_read_op);
-
-  win_iocp_handle_read_op(
-      const MutableBufferSequence& buffers, Handler& handler)
-    : operation(&win_iocp_handle_read_op::do_complete),
-      buffers_(buffers),
-      handler_(ASIO_MOVE_CAST(Handler)(handler))
-  {
-  }
-
-  static void do_complete(io_service_impl* owner, operation* base,
-      const asio::error_code& result_ec,
-      std::size_t bytes_transferred)
-  {
-    asio::error_code ec(result_ec);
-
-    // Take ownership of the operation object.
-    win_iocp_handle_read_op* o(static_cast<win_iocp_handle_read_op*>(base));
-    ptr p = { asio::detail::addressof(o->handler_), o, o };
-
-    ASIO_HANDLER_COMPLETION((o));
-
-#if defined(ASIO_ENABLE_BUFFER_DEBUGGING)
-    if (owner)
-    {
-      // Check whether buffers are still valid.
-      buffer_sequence_adapter<asio::mutable_buffer,
-          MutableBufferSequence>::validate(o->buffers_);
-    }
-#endif // defined(ASIO_ENABLE_BUFFER_DEBUGGING)
-
-    // Map non-portable errors to their portable counterparts.
-    if (ec.value() == ERROR_HANDLE_EOF)
-      ec = asio::error::eof;
-
-    // Make a copy of the handler so that the memory can be deallocated before
-    // the upcall is made. Even if we're not about to make an upcall, a
-    // sub-object of the handler may be the true owner of the memory associated
-    // with the handler. Consequently, a local copy of the handler is required
-    // to ensure that any owning sub-object remains valid until after we have
-    // deallocated the memory here.
-    detail::binder2<Handler, asio::error_code, std::size_t>
-      handler(o->handler_, ec, bytes_transferred);
-    p.h = asio::detail::addressof(handler.handler_);
-    p.reset();
-
-    // Make the upcall if required.
-    if (owner)
-    {
-      fenced_block b(fenced_block::half);
-      ASIO_HANDLER_INVOCATION_BEGIN((handler.arg1_, handler.arg2_));
-      asio_handler_invoke_helpers::invoke(handler, handler.handler_);
-      ASIO_HANDLER_INVOCATION_END;
-    }
-  }
-
-private:
-  MutableBufferSequence buffers_;
-  Handler handler_;
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // defined(ASIO_HAS_IOCP)
-
-#endif // ASIO_DETAIL_WIN_IOCP_HANDLE_READ_OP_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/win_iocp_handle_service.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/win_iocp_handle_service.hpp
deleted file mode 100644
index 8e61c8891bbb..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/win_iocp_handle_service.hpp
+++ /dev/null
@@ -1,322 +0,0 @@
-//
-// detail/win_iocp_handle_service.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-// Copyright (c) 2008 Rep Invariant Systems, Inc. (info@repinvariant.com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_WIN_IOCP_HANDLE_SERVICE_HPP
-#define ASIO_DETAIL_WIN_IOCP_HANDLE_SERVICE_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_HAS_IOCP)
-
-#include "asio/error.hpp"
-#include "asio/io_service.hpp"
-#include "asio/detail/addressof.hpp"
-#include "asio/detail/buffer_sequence_adapter.hpp"
-#include "asio/detail/cstdint.hpp"
-#include "asio/detail/handler_alloc_helpers.hpp"
-#include "asio/detail/mutex.hpp"
-#include "asio/detail/operation.hpp"
-#include "asio/detail/win_iocp_handle_read_op.hpp"
-#include "asio/detail/win_iocp_handle_write_op.hpp"
-#include "asio/detail/win_iocp_io_service.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-class win_iocp_handle_service
-{
-public:
-  // The native type of a stream handle.
-  typedef HANDLE native_handle_type;
-
-  // The implementation type of the stream handle.
-  class implementation_type
-  {
-  public:
-    // Default constructor.
-    implementation_type()
-      : handle_(INVALID_HANDLE_VALUE),
-        safe_cancellation_thread_id_(0),
-        next_(0),
-        prev_(0)
-    {
-    }
-
-  private:
-    // Only this service will have access to the internal values.
-    friend class win_iocp_handle_service;
-
-    // The native stream handle representation.
-    native_handle_type handle_;
-
-    // The ID of the thread from which it is safe to cancel asynchronous
-    // operations. 0 means no asynchronous operations have been started yet.
-    // ~0 means asynchronous operations have been started from more than one
-    // thread, and cancellation is not supported for the handle.
-    DWORD safe_cancellation_thread_id_;
-
-    // Pointers to adjacent handle implementations in linked list.
-    implementation_type* next_;
-    implementation_type* prev_;
-  };
-
-  ASIO_DECL win_iocp_handle_service(asio::io_service& io_service);
-
-  // Destroy all user-defined handler objects owned by the service.
-  ASIO_DECL void shutdown_service();
-
-  // Construct a new handle implementation.
-  ASIO_DECL void construct(implementation_type& impl);
-
-  // Move-construct a new handle implementation.
-  ASIO_DECL void move_construct(implementation_type& impl,
-      implementation_type& other_impl);
-
-  // Move-assign from another handle implementation.
-  ASIO_DECL void move_assign(implementation_type& impl,
-      win_iocp_handle_service& other_service,
-      implementation_type& other_impl);
-
-  // Destroy a handle implementation.
-  ASIO_DECL void destroy(implementation_type& impl);
-
-  // Assign a native handle to a handle implementation.
-  ASIO_DECL asio::error_code assign(implementation_type& impl,
-      const native_handle_type& handle, asio::error_code& ec);
-
-  // Determine whether the handle is open.
-  bool is_open(const implementation_type& impl) const
-  {
-    return impl.handle_ != INVALID_HANDLE_VALUE;
-  }
-
-  // Destroy a handle implementation.
-  ASIO_DECL asio::error_code close(implementation_type& impl,
-      asio::error_code& ec);
-
-  // Get the native handle representation.
-  native_handle_type native_handle(const implementation_type& impl) const
-  {
-    return impl.handle_;
-  }
-
-  // Cancel all operations associated with the handle.
-  ASIO_DECL asio::error_code cancel(implementation_type& impl,
-      asio::error_code& ec);
-
-  // Write the given data. Returns the number of bytes written.
-  template <typename ConstBufferSequence>
-  size_t write_some(implementation_type& impl,
-      const ConstBufferSequence& buffers, asio::error_code& ec)
-  {
-    return write_some_at(impl, 0, buffers, ec);
-  }
-
-  // Write the given data at the specified offset. Returns the number of bytes
-  // written.
-  template <typename ConstBufferSequence>
-  size_t write_some_at(implementation_type& impl, uint64_t offset,
-      const ConstBufferSequence& buffers, asio::error_code& ec)
-  {
-    asio::const_buffer buffer =
-      buffer_sequence_adapter<asio::const_buffer,
-        ConstBufferSequence>::first(buffers);
-
-    return do_write(impl, offset, buffer, ec);
-  }
-
-  // Start an asynchronous write. The data being written must be valid for the
-  // lifetime of the asynchronous operation.
-  template <typename ConstBufferSequence, typename Handler>
-  void async_write_some(implementation_type& impl,
-      const ConstBufferSequence& buffers, Handler& handler)
-  {
-    // Allocate and construct an operation to wrap the handler.
-    typedef win_iocp_handle_write_op<ConstBufferSequence, Handler> op;
-    typename op::ptr p = { asio::detail::addressof(handler),
-      asio_handler_alloc_helpers::allocate(
-        sizeof(op), handler), 0 };
-    p.p = new (p.v) op(buffers, handler);
-
-    ASIO_HANDLER_CREATION((p.p, "handle", &impl, "async_write_some"));
-
-    start_write_op(impl, 0,
-        buffer_sequence_adapter<asio::const_buffer,
-          ConstBufferSequence>::first(buffers), p.p);
-    p.v = p.p = 0;
-  }
-
-  // Start an asynchronous write at a specified offset. The data being written
-  // must be valid for the lifetime of the asynchronous operation.
-  template <typename ConstBufferSequence, typename Handler>
-  void async_write_some_at(implementation_type& impl, uint64_t offset,
-      const ConstBufferSequence& buffers, Handler& handler)
-  {
-    // Allocate and construct an operation to wrap the handler.
-    typedef win_iocp_handle_write_op<ConstBufferSequence, Handler> op;
-    typename op::ptr p = { asio::detail::addressof(handler),
-      asio_handler_alloc_helpers::allocate(
-        sizeof(op), handler), 0 };
-    p.p = new (p.v) op(buffers, handler);
-
-    ASIO_HANDLER_CREATION((p.p, "handle", &impl, "async_write_some_at"));
-
-    start_write_op(impl, offset,
-        buffer_sequence_adapter<asio::const_buffer,
-          ConstBufferSequence>::first(buffers), p.p);
-    p.v = p.p = 0;
-  }
-
-  // Read some data. Returns the number of bytes received.
-  template <typename MutableBufferSequence>
-  size_t read_some(implementation_type& impl,
-      const MutableBufferSequence& buffers, asio::error_code& ec)
-  {
-    return read_some_at(impl, 0, buffers, ec);
-  }
-
-  // Read some data at a specified offset. Returns the number of bytes received.
-  template <typename MutableBufferSequence>
-  size_t read_some_at(implementation_type& impl, uint64_t offset,
-      const MutableBufferSequence& buffers, asio::error_code& ec)
-  {
-    asio::mutable_buffer buffer =
-      buffer_sequence_adapter<asio::mutable_buffer,
-        MutableBufferSequence>::first(buffers);
-
-    return do_read(impl, offset, buffer, ec);
-  }
-
-  // Start an asynchronous read. The buffer for the data being received must be
-  // valid for the lifetime of the asynchronous operation.
-  template <typename MutableBufferSequence, typename Handler>
-  void async_read_some(implementation_type& impl,
-      const MutableBufferSequence& buffers, Handler& handler)
-  {
-    // Allocate and construct an operation to wrap the handler.
-    typedef win_iocp_handle_read_op<MutableBufferSequence, Handler> op;
-    typename op::ptr p = { asio::detail::addressof(handler),
-      asio_handler_alloc_helpers::allocate(
-        sizeof(op), handler), 0 };
-    p.p = new (p.v) op(buffers, handler);
-
-    ASIO_HANDLER_CREATION((p.p, "handle", &impl, "async_read_some"));
-
-    start_read_op(impl, 0,
-        buffer_sequence_adapter<asio::mutable_buffer,
-          MutableBufferSequence>::first(buffers), p.p);
-    p.v = p.p = 0;
-  }
-
-  // Start an asynchronous read at a specified offset. The buffer for the data
-  // being received must be valid for the lifetime of the asynchronous
-  // operation.
-  template <typename MutableBufferSequence, typename Handler>
-  void async_read_some_at(implementation_type& impl, uint64_t offset,
-      const MutableBufferSequence& buffers, Handler& handler)
-  {
-    // Allocate and construct an operation to wrap the handler.
-    typedef win_iocp_handle_read_op<MutableBufferSequence, Handler> op;
-    typename op::ptr p = { asio::detail::addressof(handler),
-      asio_handler_alloc_helpers::allocate(
-        sizeof(op), handler), 0 };
-    p.p = new (p.v) op(buffers, handler);
-
-    ASIO_HANDLER_CREATION((p.p, "handle", &impl, "async_read_some_at"));
-
-    start_read_op(impl, offset,
-        buffer_sequence_adapter<asio::mutable_buffer,
-          MutableBufferSequence>::first(buffers), p.p);
-    p.v = p.p = 0;
-  }
-
-private:
-  // Prevent the use of the null_buffers type with this service.
-  size_t write_some(implementation_type& impl,
-      const null_buffers& buffers, asio::error_code& ec);
-  size_t write_some_at(implementation_type& impl, uint64_t offset,
-      const null_buffers& buffers, asio::error_code& ec);
-  template <typename Handler>
-  void async_write_some(implementation_type& impl,
-      const null_buffers& buffers, Handler& handler);
-  template <typename Handler>
-  void async_write_some_at(implementation_type& impl, uint64_t offset,
-      const null_buffers& buffers, Handler& handler);
-  size_t read_some(implementation_type& impl,
-      const null_buffers& buffers, asio::error_code& ec);
-  size_t read_some_at(implementation_type& impl, uint64_t offset,
-      const null_buffers& buffers, asio::error_code& ec);
-  template <typename Handler>
-  void async_read_some(implementation_type& impl,
-      const null_buffers& buffers, Handler& handler);
-  template <typename Handler>
-  void async_read_some_at(implementation_type& impl, uint64_t offset,
-      const null_buffers& buffers, Handler& handler);
-
-  // Helper class for waiting for synchronous operations to complete.
-  class overlapped_wrapper;
-
-  // Helper function to perform a synchronous write operation.
-  ASIO_DECL size_t do_write(implementation_type& impl,
-      uint64_t offset, const asio::const_buffer& buffer,
-      asio::error_code& ec);
-
-  // Helper function to start a write operation.
-  ASIO_DECL void start_write_op(implementation_type& impl,
-      uint64_t offset, const asio::const_buffer& buffer,
-      operation* op);
-
-  // Helper function to perform a synchronous write operation.
-  ASIO_DECL size_t do_read(implementation_type& impl,
-      uint64_t offset, const asio::mutable_buffer& buffer,
-      asio::error_code& ec);
-
-  // Helper function to start a read operation.
-  ASIO_DECL void start_read_op(implementation_type& impl,
-      uint64_t offset, const asio::mutable_buffer& buffer,
-      operation* op);
-
-  // Update the ID of the thread from which cancellation is safe.
-  ASIO_DECL void update_cancellation_thread_id(implementation_type& impl);
-
-  // Helper function to close a handle when the associated object is being
-  // destroyed.
-  ASIO_DECL void close_for_destruction(implementation_type& impl);
-
-  // The IOCP service used for running asynchronous operations and dispatching
-  // handlers.
-  win_iocp_io_service& iocp_service_;
-
-  // Mutex to protect access to the linked list of implementations.
-  mutex mutex_;
-
-  // The head of a linked list of all implementations.
-  implementation_type* impl_list_;
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#if defined(ASIO_HEADER_ONLY)
-# include "asio/detail/impl/win_iocp_handle_service.ipp"
-#endif // defined(ASIO_HEADER_ONLY)
-
-#endif // defined(ASIO_HAS_IOCP)
-
-#endif // ASIO_DETAIL_WIN_IOCP_HANDLE_SERVICE_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/win_iocp_handle_write_op.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/win_iocp_handle_write_op.hpp
deleted file mode 100644
index 799290f907d9..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/win_iocp_handle_write_op.hpp
+++ /dev/null
@@ -1,101 +0,0 @@
-//
-// detail/win_iocp_handle_write_op.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-// Copyright (c) 2008 Rep Invariant Systems, Inc. (info@repinvariant.com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_WIN_IOCP_HANDLE_WRITE_OP_HPP
-#define ASIO_DETAIL_WIN_IOCP_HANDLE_WRITE_OP_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_HAS_IOCP)
-
-#include "asio/error.hpp"
-#include "asio/detail/addressof.hpp"
-#include "asio/detail/bind_handler.hpp"
-#include "asio/detail/buffer_sequence_adapter.hpp"
-#include "asio/detail/fenced_block.hpp"
-#include "asio/detail/handler_alloc_helpers.hpp"
-#include "asio/detail/handler_invoke_helpers.hpp"
-#include "asio/detail/operation.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-template <typename ConstBufferSequence, typename Handler>
-class win_iocp_handle_write_op : public operation
-{
-public:
-  ASIO_DEFINE_HANDLER_PTR(win_iocp_handle_write_op);
-
-  win_iocp_handle_write_op(const ConstBufferSequence& buffers, Handler& handler)
-    : operation(&win_iocp_handle_write_op::do_complete),
-      buffers_(buffers),
-      handler_(ASIO_MOVE_CAST(Handler)(handler))
-  {
-  }
-
-  static void do_complete(io_service_impl* owner, operation* base,
-      const asio::error_code& ec, std::size_t bytes_transferred)
-  {
-    // Take ownership of the operation object.
-    win_iocp_handle_write_op* o(static_cast<win_iocp_handle_write_op*>(base));
-    ptr p = { asio::detail::addressof(o->handler_), o, o };
-
-    ASIO_HANDLER_COMPLETION((o));
-
-#if defined(ASIO_ENABLE_BUFFER_DEBUGGING)
-    if (owner)
-    {
-      // Check whether buffers are still valid.
-      buffer_sequence_adapter<asio::const_buffer,
-          ConstBufferSequence>::validate(o->buffers_);
-    }
-#endif // defined(ASIO_ENABLE_BUFFER_DEBUGGING)
-
-    // Make a copy of the handler so that the memory can be deallocated before
-    // the upcall is made. Even if we're not about to make an upcall, a
-    // sub-object of the handler may be the true owner of the memory associated
-    // with the handler. Consequently, a local copy of the handler is required
-    // to ensure that any owning sub-object remains valid until after we have
-    // deallocated the memory here.
-    detail::binder2<Handler, asio::error_code, std::size_t>
-      handler(o->handler_, ec, bytes_transferred);
-    p.h = asio::detail::addressof(handler.handler_);
-    p.reset();
-
-    // Make the upcall if required.
-    if (owner)
-    {
-      fenced_block b(fenced_block::half);
-      ASIO_HANDLER_INVOCATION_BEGIN((handler.arg1_, handler.arg2_));
-      asio_handler_invoke_helpers::invoke(handler, handler.handler_);
-      ASIO_HANDLER_INVOCATION_END;
-    }
-  }
-
-private:
-  ConstBufferSequence buffers_;
-  Handler handler_;
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // defined(ASIO_HAS_IOCP)
-
-#endif // ASIO_DETAIL_WIN_IOCP_HANDLE_WRITE_OP_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/win_iocp_io_service.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/win_iocp_io_service.hpp
deleted file mode 100644
index d722b392fa44..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/win_iocp_io_service.hpp
+++ /dev/null
@@ -1,315 +0,0 @@
-//
-// detail/win_iocp_io_service.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_WIN_IOCP_IO_SERVICE_HPP
-#define ASIO_DETAIL_WIN_IOCP_IO_SERVICE_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_HAS_IOCP)
-
-#include "asio/io_service.hpp"
-#include "asio/detail/call_stack.hpp"
-#include "asio/detail/limits.hpp"
-#include "asio/detail/mutex.hpp"
-#include "asio/detail/op_queue.hpp"
-#include "asio/detail/scoped_ptr.hpp"
-#include "asio/detail/socket_types.hpp"
-#include "asio/detail/thread.hpp"
-#include "asio/detail/timer_queue_base.hpp"
-#include "asio/detail/timer_queue_set.hpp"
-#include "asio/detail/wait_op.hpp"
-#include "asio/detail/win_iocp_operation.hpp"
-#include "asio/detail/win_iocp_thread_info.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-class wait_op;
-
-class win_iocp_io_service
-  : public asio::detail::service_base<win_iocp_io_service>
-{
-public:
-
-  // Constructor. Specifies a concurrency hint that is passed through to the
-  // underlying I/O completion port.
-  ASIO_DECL win_iocp_io_service(asio::io_service& io_service,
-      size_t concurrency_hint = 0);
-
-  // Destroy all user-defined handler objects owned by the service.
-  ASIO_DECL void shutdown_service();
-
-  // Initialise the task. Nothing to do here.
-  void init_task()
-  {
-  }
-
-  // Register a handle with the IO completion port.
-  ASIO_DECL asio::error_code register_handle(
-      HANDLE handle, asio::error_code& ec);
-
-  // Run the event loop until stopped or no more work.
-  ASIO_DECL size_t run(asio::error_code& ec);
-
-  // Run until stopped or one operation is performed.
-  ASIO_DECL size_t run_one(asio::error_code& ec);
-
-  // Poll for operations without blocking.
-  ASIO_DECL size_t poll(asio::error_code& ec);
-
-  // Poll for one operation without blocking.
-  ASIO_DECL size_t poll_one(asio::error_code& ec);
-
-  // Stop the event processing loop.
-  ASIO_DECL void stop();
-
-  // Determine whether the io_service is stopped.
-  bool stopped() const
-  {
-    return ::InterlockedExchangeAdd(&stopped_, 0) != 0;
-  }
-
-  // Reset in preparation for a subsequent run invocation.
-  void reset()
-  {
-    ::InterlockedExchange(&stopped_, 0);
-  }
-
-  // Notify that some work has started.
-  void work_started()
-  {
-    ::InterlockedIncrement(&outstanding_work_);
-  }
-
-  // Notify that some work has finished.
-  void work_finished()
-  {
-    if (::InterlockedDecrement(&outstanding_work_) == 0)
-      stop();
-  }
-
-  // Return whether a handler can be dispatched immediately.
-  bool can_dispatch()
-  {
-    return thread_call_stack::contains(this) != 0;
-  }
-
-  // Request invocation of the given handler.
-  template <typename Handler>
-  void dispatch(Handler& handler);
-
-  // Request invocation of the given handler and return immediately.
-  template <typename Handler>
-  void post(Handler& handler);
-
-  // Request invocation of the given operation and return immediately. Assumes
-  // that work_started() has not yet been called for the operation.
-  void post_immediate_completion(win_iocp_operation* op, bool)
-  {
-    work_started();
-    post_deferred_completion(op);
-  }
-
-  // Request invocation of the given operation and return immediately. Assumes
-  // that work_started() was previously called for the operation.
-  ASIO_DECL void post_deferred_completion(win_iocp_operation* op);
-
-  // Request invocation of the given operation and return immediately. Assumes
-  // that work_started() was previously called for the operations.
-  ASIO_DECL void post_deferred_completions(
-      op_queue<win_iocp_operation>& ops);
-
-  // Request invocation of the given operation using the thread-private queue
-  // and return immediately. Assumes that work_started() has not yet been
-  // called for the operation.
-  void post_private_immediate_completion(win_iocp_operation* op)
-  {
-    post_immediate_completion(op, false);
-  }
-
-  // Request invocation of the given operation using the thread-private queue
-  // and return immediately. Assumes that work_started() was previously called
-  // for the operation.
-  void post_private_deferred_completion(win_iocp_operation* op)
-  {
-    post_deferred_completion(op);
-  }
-
-  // Process unfinished operations as part of a shutdown_service operation.
-  // Assumes that work_started() was previously called for the operations.
-  ASIO_DECL void abandon_operations(op_queue<operation>& ops);
-
-  // Called after starting an overlapped I/O operation that did not complete
-  // immediately. The caller must have already called work_started() prior to
-  // starting the operation.
-  ASIO_DECL void on_pending(win_iocp_operation* op);
-
-  // Called after starting an overlapped I/O operation that completed
-  // immediately. The caller must have already called work_started() prior to
-  // starting the operation.
-  ASIO_DECL void on_completion(win_iocp_operation* op,
-      DWORD last_error = 0, DWORD bytes_transferred = 0);
-
-  // Called after starting an overlapped I/O operation that completed
-  // immediately. The caller must have already called work_started() prior to
-  // starting the operation.
-  ASIO_DECL void on_completion(win_iocp_operation* op,
-      const asio::error_code& ec, DWORD bytes_transferred = 0);
-
-  // Add a new timer queue to the service.
-  template <typename Time_Traits>
-  void add_timer_queue(timer_queue<Time_Traits>& timer_queue);
-
-  // Remove a timer queue from the service.
-  template <typename Time_Traits>
-  void remove_timer_queue(timer_queue<Time_Traits>& timer_queue);
-
-  // Schedule a new operation in the given timer queue to expire at the
-  // specified absolute time.
-  template <typename Time_Traits>
-  void schedule_timer(timer_queue<Time_Traits>& queue,
-      const typename Time_Traits::time_type& time,
-      typename timer_queue<Time_Traits>::per_timer_data& timer, wait_op* op);
-
-  // Cancel the timer associated with the given token. Returns the number of
-  // handlers that have been posted or dispatched.
-  template <typename Time_Traits>
-  std::size_t cancel_timer(timer_queue<Time_Traits>& queue,
-      typename timer_queue<Time_Traits>::per_timer_data& timer,
-      std::size_t max_cancelled = (std::numeric_limits<std::size_t>::max)());
-
-private:
-#if defined(WINVER) && (WINVER < 0x0500)
-  typedef DWORD dword_ptr_t;
-  typedef ULONG ulong_ptr_t;
-#else // defined(WINVER) && (WINVER < 0x0500)
-  typedef DWORD_PTR dword_ptr_t;
-  typedef ULONG_PTR ulong_ptr_t;
-#endif // defined(WINVER) && (WINVER < 0x0500)
-
-  // Dequeues at most one operation from the I/O completion port, and then
-  // executes it. Returns the number of operations that were dequeued (i.e.
-  // either 0 or 1).
-  ASIO_DECL size_t do_one(bool block, asio::error_code& ec);
-
-  // Helper to calculate the GetQueuedCompletionStatus timeout.
-  ASIO_DECL static DWORD get_gqcs_timeout();
-
-  // Helper function to add a new timer queue.
-  ASIO_DECL void do_add_timer_queue(timer_queue_base& queue);
-
-  // Helper function to remove a timer queue.
-  ASIO_DECL void do_remove_timer_queue(timer_queue_base& queue);
-
-  // Called to recalculate and update the timeout.
-  ASIO_DECL void update_timeout();
-
-  // Helper class to call work_finished() on block exit.
-  struct work_finished_on_block_exit;
-
-  // Helper class for managing a HANDLE.
-  struct auto_handle
-  {
-    HANDLE handle;
-    auto_handle() : handle(0) {}
-    ~auto_handle() { if (handle) ::CloseHandle(handle); }
-  };
-
-  // The IO completion port used for queueing operations.
-  auto_handle iocp_;
-
-  // The count of unfinished work.
-  long outstanding_work_;
-
-  // Flag to indicate whether the event loop has been stopped.
-  mutable long stopped_;
-
-  // Flag to indicate whether there is an in-flight stop event. Every event
-  // posted using PostQueuedCompletionStatus consumes non-paged pool, so to
-  // avoid exhausting this resouce we limit the number of outstanding events.
-  long stop_event_posted_;
-
-  // Flag to indicate whether the service has been shut down.
-  long shutdown_;
-
-  enum
-  {
-    // Timeout to use with GetQueuedCompletionStatus on older versions of
-    // Windows. Some versions of windows have a "bug" where a call to
-    // GetQueuedCompletionStatus can appear stuck even though there are events
-    // waiting on the queue. Using a timeout helps to work around the issue.
-    default_gqcs_timeout = 500,
-
-    // Maximum waitable timer timeout, in milliseconds.
-    max_timeout_msec = 5 * 60 * 1000,
-
-    // Maximum waitable timer timeout, in microseconds.
-    max_timeout_usec = max_timeout_msec * 1000,
-
-    // Completion key value used to wake up a thread to dispatch timers or
-    // completed operations.
-    wake_for_dispatch = 1,
-
-    // Completion key value to indicate that an operation has posted with the
-    // original last_error and bytes_transferred values stored in the fields of
-    // the OVERLAPPED structure.
-    overlapped_contains_result = 2
-  };
-
-  // Timeout to use with GetQueuedCompletionStatus.
-  const DWORD gqcs_timeout_;
-
-  // Function object for processing timeouts in a background thread.
-  struct timer_thread_function;
-  friend struct timer_thread_function;
-
-  // Background thread used for processing timeouts.
-  scoped_ptr<thread> timer_thread_;
-
-  // A waitable timer object used for waiting for timeouts.
-  auto_handle waitable_timer_;
-
-  // Non-zero if timers or completed operations need to be dispatched.
-  long dispatch_required_;
-
-  // Mutex for protecting access to the timer queues and completed operations.
-  mutex dispatch_mutex_;
-
-  // The timer queues.
-  timer_queue_set timer_queues_;
-
-  // The operations that are ready to dispatch.
-  op_queue<win_iocp_operation> completed_ops_;
-
-  // Per-thread call stack to track the state of each thread in the io_service.
-  typedef call_stack<win_iocp_io_service,
-      win_iocp_thread_info> thread_call_stack;
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#include "asio/detail/impl/win_iocp_io_service.hpp"
-#if defined(ASIO_HEADER_ONLY)
-# include "asio/detail/impl/win_iocp_io_service.ipp"
-#endif // defined(ASIO_HEADER_ONLY)
-
-#endif // defined(ASIO_HAS_IOCP)
-
-#endif // ASIO_DETAIL_WIN_IOCP_IO_SERVICE_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/win_iocp_null_buffers_op.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/win_iocp_null_buffers_op.hpp
deleted file mode 100644
index b849e37241ed..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/win_iocp_null_buffers_op.hpp
+++ /dev/null
@@ -1,119 +0,0 @@
-//
-// detail/win_iocp_null_buffers_op.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_WIN_IOCP_NULL_BUFFERS_OP_HPP
-#define ASIO_DETAIL_WIN_IOCP_NULL_BUFFERS_OP_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_HAS_IOCP)
-
-#include "asio/detail/addressof.hpp"
-#include "asio/detail/bind_handler.hpp"
-#include "asio/detail/buffer_sequence_adapter.hpp"
-#include "asio/detail/fenced_block.hpp"
-#include "asio/detail/handler_alloc_helpers.hpp"
-#include "asio/detail/handler_invoke_helpers.hpp"
-#include "asio/detail/reactor_op.hpp"
-#include "asio/detail/socket_ops.hpp"
-#include "asio/error.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-template <typename Handler>
-class win_iocp_null_buffers_op : public reactor_op
-{
-public:
-  ASIO_DEFINE_HANDLER_PTR(win_iocp_null_buffers_op);
-
-  win_iocp_null_buffers_op(socket_ops::weak_cancel_token_type cancel_token,
-      Handler& handler)
-    : reactor_op(&win_iocp_null_buffers_op::do_perform,
-        &win_iocp_null_buffers_op::do_complete),
-      cancel_token_(cancel_token),
-      handler_(ASIO_MOVE_CAST(Handler)(handler))
-  {
-  }
-
-  static bool do_perform(reactor_op*)
-  {
-    return true;
-  }
-
-  static void do_complete(io_service_impl* owner, operation* base,
-      const asio::error_code& result_ec,
-      std::size_t bytes_transferred)
-  {
-    asio::error_code ec(result_ec);
-
-    // Take ownership of the operation object.
-    win_iocp_null_buffers_op* o(static_cast<win_iocp_null_buffers_op*>(base));
-    ptr p = { asio::detail::addressof(o->handler_), o, o };
-
-    ASIO_HANDLER_COMPLETION((o));
-
-    // The reactor may have stored a result in the operation object.
-    if (o->ec_)
-      ec = o->ec_;
-
-    // Map non-portable errors to their portable counterparts.
-    if (ec.value() == ERROR_NETNAME_DELETED)
-    {
-      if (o->cancel_token_.expired())
-        ec = asio::error::operation_aborted;
-      else
-        ec = asio::error::connection_reset;
-    }
-    else if (ec.value() == ERROR_PORT_UNREACHABLE)
-    {
-      ec = asio::error::connection_refused;
-    }
-
-    // Make a copy of the handler so that the memory can be deallocated before
-    // the upcall is made. Even if we're not about to make an upcall, a
-    // sub-object of the handler may be the true owner of the memory associated
-    // with the handler. Consequently, a local copy of the handler is required
-    // to ensure that any owning sub-object remains valid until after we have
-    // deallocated the memory here.
-    detail::binder2<Handler, asio::error_code, std::size_t>
-      handler(o->handler_, ec, bytes_transferred);
-    p.h = asio::detail::addressof(handler.handler_);
-    p.reset();
-
-    // Make the upcall if required.
-    if (owner)
-    {
-      fenced_block b(fenced_block::half);
-      ASIO_HANDLER_INVOCATION_BEGIN((handler.arg1_, handler.arg2_));
-      asio_handler_invoke_helpers::invoke(handler, handler.handler_);
-      ASIO_HANDLER_INVOCATION_END;
-    }
-  }
-
-private:
-  socket_ops::weak_cancel_token_type cancel_token_;
-  Handler handler_;
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // defined(ASIO_HAS_IOCP)
-
-#endif // ASIO_DETAIL_WIN_IOCP_NULL_BUFFERS_OP_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/win_iocp_operation.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/win_iocp_operation.hpp
deleted file mode 100644
index 4581b329d738..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/win_iocp_operation.hpp
+++ /dev/null
@@ -1,95 +0,0 @@
-//
-// detail/win_iocp_operation.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_WIN_IOCP_OPERATION_HPP
-#define ASIO_DETAIL_WIN_IOCP_OPERATION_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_HAS_IOCP)
-
-#include "asio/detail/handler_tracking.hpp"
-#include "asio/detail/op_queue.hpp"
-#include "asio/detail/socket_types.hpp"
-#include "asio/error_code.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-class win_iocp_io_service;
-
-// Base class for all operations. A function pointer is used instead of virtual
-// functions to avoid the associated overhead.
-class win_iocp_operation
-  : public OVERLAPPED
-    ASIO_ALSO_INHERIT_TRACKED_HANDLER
-{
-public:
-  void complete(win_iocp_io_service& owner,
-      const asio::error_code& ec,
-      std::size_t bytes_transferred)
-  {
-    func_(&owner, this, ec, bytes_transferred);
-  }
-
-  void destroy()
-  {
-    func_(0, this, asio::error_code(), 0);
-  }
-
-protected:
-  typedef void (*func_type)(
-      win_iocp_io_service*, win_iocp_operation*,
-      const asio::error_code&, std::size_t);
-
-  win_iocp_operation(func_type func)
-    : next_(0),
-      func_(func)
-  {
-    reset();
-  }
-
-  // Prevents deletion through this type.
-  ~win_iocp_operation()
-  {
-  }
-
-  void reset()
-  {
-    Internal = 0;
-    InternalHigh = 0;
-    Offset = 0;
-    OffsetHigh = 0;
-    hEvent = 0;
-    ready_ = 0;
-  }
-
-private:
-  friend class op_queue_access;
-  friend class win_iocp_io_service;
-  win_iocp_operation* next_;
-  func_type func_;
-  long ready_;
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // defined(ASIO_HAS_IOCP)
-
-#endif // ASIO_DETAIL_WIN_IOCP_OPERATION_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/win_iocp_overlapped_op.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/win_iocp_overlapped_op.hpp
deleted file mode 100644
index 90651f031ec3..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/win_iocp_overlapped_op.hpp
+++ /dev/null
@@ -1,88 +0,0 @@
-//
-// detail/win_iocp_overlapped_op.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_WIN_IOCP_OVERLAPPED_OP_HPP
-#define ASIO_DETAIL_WIN_IOCP_OVERLAPPED_OP_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_HAS_IOCP)
-
-#include "asio/error.hpp"
-#include "asio/detail/addressof.hpp"
-#include "asio/detail/bind_handler.hpp"
-#include "asio/detail/fenced_block.hpp"
-#include "asio/detail/handler_alloc_helpers.hpp"
-#include "asio/detail/handler_invoke_helpers.hpp"
-#include "asio/detail/operation.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-template <typename Handler>
-class win_iocp_overlapped_op : public operation
-{
-public:
-  ASIO_DEFINE_HANDLER_PTR(win_iocp_overlapped_op);
-
-  win_iocp_overlapped_op(Handler& handler)
-    : operation(&win_iocp_overlapped_op::do_complete),
-      handler_(ASIO_MOVE_CAST(Handler)(handler))
-  {
-  }
-
-  static void do_complete(io_service_impl* owner, operation* base,
-      const asio::error_code& ec, std::size_t bytes_transferred)
-  {
-    // Take ownership of the operation object.
-    win_iocp_overlapped_op* o(static_cast<win_iocp_overlapped_op*>(base));
-    ptr p = { asio::detail::addressof(o->handler_), o, o };
-
-    ASIO_HANDLER_COMPLETION((o));
-
-    // Make a copy of the handler so that the memory can be deallocated before
-    // the upcall is made. Even if we're not about to make an upcall, a
-    // sub-object of the handler may be the true owner of the memory associated
-    // with the handler. Consequently, a local copy of the handler is required
-    // to ensure that any owning sub-object remains valid until after we have
-    // deallocated the memory here.
-    detail::binder2<Handler, asio::error_code, std::size_t>
-      handler(o->handler_, ec, bytes_transferred);
-    p.h = asio::detail::addressof(handler.handler_);
-    p.reset();
-
-    // Make the upcall if required.
-    if (owner)
-    {
-      fenced_block b(fenced_block::half);
-      ASIO_HANDLER_INVOCATION_BEGIN((handler.arg1_, handler.arg2_));
-      asio_handler_invoke_helpers::invoke(handler, handler.handler_);
-      ASIO_HANDLER_INVOCATION_END;
-    }
-  }
-
-private:
-  Handler handler_;
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // defined(ASIO_HAS_IOCP)
-
-#endif // ASIO_DETAIL_WIN_IOCP_OVERLAPPED_OP_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/win_iocp_overlapped_ptr.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/win_iocp_overlapped_ptr.hpp
deleted file mode 100644
index 7f816c5d67be..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/win_iocp_overlapped_ptr.hpp
+++ /dev/null
@@ -1,144 +0,0 @@
-//
-// detail/win_iocp_overlapped_ptr.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_WIN_IOCP_OVERLAPPED_PTR_HPP
-#define ASIO_DETAIL_WIN_IOCP_OVERLAPPED_PTR_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_HAS_IOCP)
-
-#include "asio/io_service.hpp"
-#include "asio/detail/addressof.hpp"
-#include "asio/detail/handler_alloc_helpers.hpp"
-#include "asio/detail/noncopyable.hpp"
-#include "asio/detail/win_iocp_overlapped_op.hpp"
-#include "asio/detail/win_iocp_io_service.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-// Wraps a handler to create an OVERLAPPED object for use with overlapped I/O.
-class win_iocp_overlapped_ptr
-  : private noncopyable
-{
-public:
-  // Construct an empty win_iocp_overlapped_ptr.
-  win_iocp_overlapped_ptr()
-    : ptr_(0),
-      iocp_service_(0)
-  {
-  }
-
-  // Construct an win_iocp_overlapped_ptr to contain the specified handler.
-  template <typename Handler>
-  explicit win_iocp_overlapped_ptr(
-      asio::io_service& io_service, ASIO_MOVE_ARG(Handler) handler)
-    : ptr_(0),
-      iocp_service_(0)
-  {
-    this->reset(io_service, ASIO_MOVE_CAST(Handler)(handler));
-  }
-
-  // Destructor automatically frees the OVERLAPPED object unless released.
-  ~win_iocp_overlapped_ptr()
-  {
-    reset();
-  }
-
-  // Reset to empty.
-  void reset()
-  {
-    if (ptr_)
-    {
-      ptr_->destroy();
-      ptr_ = 0;
-      iocp_service_->work_finished();
-      iocp_service_ = 0;
-    }
-  }
-
-  // Reset to contain the specified handler, freeing any current OVERLAPPED
-  // object.
-  template <typename Handler>
-  void reset(asio::io_service& io_service, Handler handler)
-  {
-    typedef win_iocp_overlapped_op<Handler> op;
-    typename op::ptr p = { asio::detail::addressof(handler),
-      asio_handler_alloc_helpers::allocate(
-        sizeof(op), handler), 0 };
-    p.p = new (p.v) op(handler);
-
-    ASIO_HANDLER_CREATION((p.p, "io_service",
-          &io_service.impl_, "overlapped"));
-
-    io_service.impl_.work_started();
-    reset();
-    ptr_ = p.p;
-    p.v = p.p = 0;
-    iocp_service_ = &io_service.impl_;
-  }
-
-  // Get the contained OVERLAPPED object.
-  OVERLAPPED* get()
-  {
-    return ptr_;
-  }
-
-  // Get the contained OVERLAPPED object.
-  const OVERLAPPED* get() const
-  {
-    return ptr_;
-  }
-
-  // Release ownership of the OVERLAPPED object.
-  OVERLAPPED* release()
-  {
-    if (ptr_)
-      iocp_service_->on_pending(ptr_);
-
-    OVERLAPPED* tmp = ptr_;
-    ptr_ = 0;
-    iocp_service_ = 0;
-    return tmp;
-  }
-
-  // Post completion notification for overlapped operation. Releases ownership.
-  void complete(const asio::error_code& ec,
-      std::size_t bytes_transferred)
-  {
-    if (ptr_)
-    {
-      iocp_service_->on_completion(ptr_, ec,
-          static_cast<DWORD>(bytes_transferred));
-      ptr_ = 0;
-      iocp_service_ = 0;
-    }
-  }
-
-private:
-  win_iocp_operation* ptr_;
-  win_iocp_io_service* iocp_service_;
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // defined(ASIO_HAS_IOCP)
-
-#endif // ASIO_DETAIL_WIN_IOCP_OVERLAPPED_PTR_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/win_iocp_serial_port_service.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/win_iocp_serial_port_service.hpp
deleted file mode 100644
index 86d852cee0b1..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/win_iocp_serial_port_service.hpp
+++ /dev/null
@@ -1,228 +0,0 @@
-//
-// detail/win_iocp_serial_port_service.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-// Copyright (c) 2008 Rep Invariant Systems, Inc. (info@repinvariant.com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_WIN_IOCP_SERIAL_PORT_SERVICE_HPP
-#define ASIO_DETAIL_WIN_IOCP_SERIAL_PORT_SERVICE_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_HAS_IOCP) && defined(ASIO_HAS_SERIAL_PORT)
-
-#include <string>
-#include "asio/error.hpp"
-#include "asio/io_service.hpp"
-#include "asio/detail/win_iocp_handle_service.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-// Extend win_iocp_handle_service to provide serial port support.
-class win_iocp_serial_port_service
-{
-public:
-  // The native type of a serial port.
-  typedef win_iocp_handle_service::native_handle_type native_handle_type;
-
-  // The implementation type of the serial port.
-  typedef win_iocp_handle_service::implementation_type implementation_type;
-
-  // Constructor.
-  ASIO_DECL win_iocp_serial_port_service(
-      asio::io_service& io_service);
-
-  // Destroy all user-defined handler objects owned by the service.
-  ASIO_DECL void shutdown_service();
-
-  // Construct a new serial port implementation.
-  void construct(implementation_type& impl)
-  {
-    handle_service_.construct(impl);
-  }
-
-  // Move-construct a new serial port implementation.
-  void move_construct(implementation_type& impl,
-      implementation_type& other_impl)
-  {
-    handle_service_.move_construct(impl, other_impl);
-  }
-
-  // Move-assign from another serial port implementation.
-  void move_assign(implementation_type& impl,
-      win_iocp_serial_port_service& other_service,
-      implementation_type& other_impl)
-  {
-    handle_service_.move_assign(impl,
-        other_service.handle_service_, other_impl);
-  }
-
-  // Destroy a serial port implementation.
-  void destroy(implementation_type& impl)
-  {
-    handle_service_.destroy(impl);
-  }
-
-  // Open the serial port using the specified device name.
-  ASIO_DECL asio::error_code open(implementation_type& impl,
-      const std::string& device, asio::error_code& ec);
-
-  // Assign a native handle to a serial port implementation.
-  asio::error_code assign(implementation_type& impl,
-      const native_handle_type& handle, asio::error_code& ec)
-  {
-    return handle_service_.assign(impl, handle, ec);
-  }
-
-  // Determine whether the serial port is open.
-  bool is_open(const implementation_type& impl) const
-  {
-    return handle_service_.is_open(impl);
-  }
-
-  // Destroy a serial port implementation.
-  asio::error_code close(implementation_type& impl,
-      asio::error_code& ec)
-  {
-    return handle_service_.close(impl, ec);
-  }
-
-  // Get the native serial port representation.
-  native_handle_type native_handle(implementation_type& impl)
-  {
-    return handle_service_.native_handle(impl);
-  }
-
-  // Cancel all operations associated with the handle.
-  asio::error_code cancel(implementation_type& impl,
-      asio::error_code& ec)
-  {
-    return handle_service_.cancel(impl, ec);
-  }
-
-  // Set an option on the serial port.
-  template <typename SettableSerialPortOption>
-  asio::error_code set_option(implementation_type& impl,
-      const SettableSerialPortOption& option, asio::error_code& ec)
-  {
-    return do_set_option(impl,
-        &win_iocp_serial_port_service::store_option<SettableSerialPortOption>,
-        &option, ec);
-  }
-
-  // Get an option from the serial port.
-  template <typename GettableSerialPortOption>
-  asio::error_code get_option(const implementation_type& impl,
-      GettableSerialPortOption& option, asio::error_code& ec) const
-  {
-    return do_get_option(impl,
-        &win_iocp_serial_port_service::load_option<GettableSerialPortOption>,
-        &option, ec);
-  }
-
-  // Send a break sequence to the serial port.
-  asio::error_code send_break(implementation_type&,
-      asio::error_code& ec)
-  {
-    ec = asio::error::operation_not_supported;
-    return ec;
-  }
-
-  // Write the given data. Returns the number of bytes sent.
-  template <typename ConstBufferSequence>
-  size_t write_some(implementation_type& impl,
-      const ConstBufferSequence& buffers, asio::error_code& ec)
-  {
-    return handle_service_.write_some(impl, buffers, ec);
-  }
-
-  // Start an asynchronous write. The data being written must be valid for the
-  // lifetime of the asynchronous operation.
-  template <typename ConstBufferSequence, typename Handler>
-  void async_write_some(implementation_type& impl,
-      const ConstBufferSequence& buffers, Handler& handler)
-  {
-    handle_service_.async_write_some(impl, buffers, handler);
-  }
-
-  // Read some data. Returns the number of bytes received.
-  template <typename MutableBufferSequence>
-  size_t read_some(implementation_type& impl,
-      const MutableBufferSequence& buffers, asio::error_code& ec)
-  {
-    return handle_service_.read_some(impl, buffers, ec);
-  }
-
-  // Start an asynchronous read. The buffer for the data being received must be
-  // valid for the lifetime of the asynchronous operation.
-  template <typename MutableBufferSequence, typename Handler>
-  void async_read_some(implementation_type& impl,
-      const MutableBufferSequence& buffers, Handler& handler)
-  {
-    handle_service_.async_read_some(impl, buffers, handler);
-  }
-
-private:
-  // Function pointer type for storing a serial port option.
-  typedef asio::error_code (*store_function_type)(
-      const void*, ::DCB&, asio::error_code&);
-
-  // Helper function template to store a serial port option.
-  template <typename SettableSerialPortOption>
-  static asio::error_code store_option(const void* option,
-      ::DCB& storage, asio::error_code& ec)
-  {
-    return static_cast<const SettableSerialPortOption*>(option)->store(
-        storage, ec);
-  }
-
-  // Helper function to set a serial port option.
-  ASIO_DECL asio::error_code do_set_option(
-      implementation_type& impl, store_function_type store,
-      const void* option, asio::error_code& ec);
-
-  // Function pointer type for loading a serial port option.
-  typedef asio::error_code (*load_function_type)(
-      void*, const ::DCB&, asio::error_code&);
-
-  // Helper function template to load a serial port option.
-  template <typename GettableSerialPortOption>
-  static asio::error_code load_option(void* option,
-      const ::DCB& storage, asio::error_code& ec)
-  {
-    return static_cast<GettableSerialPortOption*>(option)->load(storage, ec);
-  }
-
-  // Helper function to get a serial port option.
-  ASIO_DECL asio::error_code do_get_option(
-      const implementation_type& impl, load_function_type load,
-      void* option, asio::error_code& ec) const;
-
-  // The implementation used for initiating asynchronous operations.
-  win_iocp_handle_service handle_service_;
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#if defined(ASIO_HEADER_ONLY)
-# include "asio/detail/impl/win_iocp_serial_port_service.ipp"
-#endif // defined(ASIO_HEADER_ONLY)
-
-#endif // defined(ASIO_HAS_IOCP) && defined(ASIO_HAS_SERIAL_PORT)
-
-#endif // ASIO_DETAIL_WIN_IOCP_SERIAL_PORT_SERVICE_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/win_iocp_socket_accept_op.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/win_iocp_socket_accept_op.hpp
deleted file mode 100644
index d0d2e7df2e1a..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/win_iocp_socket_accept_op.hpp
+++ /dev/null
@@ -1,165 +0,0 @@
-//
-// detail/win_iocp_socket_accept_op.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_WIN_IOCP_SOCKET_ACCEPT_OP_HPP
-#define ASIO_DETAIL_WIN_IOCP_SOCKET_ACCEPT_OP_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_HAS_IOCP)
-
-#include "asio/detail/addressof.hpp"
-#include "asio/detail/bind_handler.hpp"
-#include "asio/detail/buffer_sequence_adapter.hpp"
-#include "asio/detail/fenced_block.hpp"
-#include "asio/detail/handler_alloc_helpers.hpp"
-#include "asio/detail/handler_invoke_helpers.hpp"
-#include "asio/detail/operation.hpp"
-#include "asio/detail/socket_ops.hpp"
-#include "asio/detail/win_iocp_socket_service_base.hpp"
-#include "asio/error.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-template <typename Socket, typename Protocol, typename Handler>
-class win_iocp_socket_accept_op : public operation
-{
-public:
-  ASIO_DEFINE_HANDLER_PTR(win_iocp_socket_accept_op);
-
-  win_iocp_socket_accept_op(win_iocp_socket_service_base& socket_service,
-      socket_type socket, Socket& peer, const Protocol& protocol,
-      typename Protocol::endpoint* peer_endpoint,
-      bool enable_connection_aborted, Handler& handler)
-    : operation(&win_iocp_socket_accept_op::do_complete),
-      socket_service_(socket_service),
-      socket_(socket),
-      peer_(peer),
-      protocol_(protocol),
-      peer_endpoint_(peer_endpoint),
-      enable_connection_aborted_(enable_connection_aborted),
-      handler_(ASIO_MOVE_CAST(Handler)(handler))
-  {
-  }
-
-  socket_holder& new_socket()
-  {
-    return new_socket_;
-  }
-
-  void* output_buffer()
-  {
-    return output_buffer_;
-  }
-
-  DWORD address_length()
-  {
-    return sizeof(sockaddr_storage_type) + 16;
-  }
-
-  static void do_complete(io_service_impl* owner, operation* base,
-      const asio::error_code& result_ec,
-      std::size_t /*bytes_transferred*/)
-  {
-    asio::error_code ec(result_ec);
-
-    // Take ownership of the operation object.
-    win_iocp_socket_accept_op* o(static_cast<win_iocp_socket_accept_op*>(base));
-    ptr p = { asio::detail::addressof(o->handler_), o, o };
-
-    if (owner)
-    {
-      typename Protocol::endpoint peer_endpoint;
-      std::size_t addr_len = peer_endpoint.capacity();
-      socket_ops::complete_iocp_accept(o->socket_,
-          o->output_buffer(), o->address_length(),
-          peer_endpoint.data(), &addr_len,
-          o->new_socket_.get(), ec);
-
-      // Restart the accept operation if we got the connection_aborted error
-      // and the enable_connection_aborted socket option is not set.
-      if (ec == asio::error::connection_aborted
-          && !o->enable_connection_aborted_)
-      {
-        o->reset();
-        o->socket_service_.restart_accept_op(o->socket_,
-            o->new_socket_, o->protocol_.family(),
-            o->protocol_.type(), o->protocol_.protocol(),
-            o->output_buffer(), o->address_length(), o);
-        p.v = p.p = 0;
-        return;
-      }
-
-      // If the socket was successfully accepted, transfer ownership of the
-      // socket to the peer object.
-      if (!ec)
-      {
-        o->peer_.assign(o->protocol_,
-            typename Socket::native_handle_type(
-              o->new_socket_.get(), peer_endpoint), ec);
-        if (!ec)
-          o->new_socket_.release();
-      }
-
-      // Pass endpoint back to caller.
-      if (o->peer_endpoint_)
-        *o->peer_endpoint_ = peer_endpoint;
-    }
-
-    ASIO_HANDLER_COMPLETION((o));
-
-    // Make a copy of the handler so that the memory can be deallocated before
-    // the upcall is made. Even if we're not about to make an upcall, a
-    // sub-object of the handler may be the true owner of the memory associated
-    // with the handler. Consequently, a local copy of the handler is required
-    // to ensure that any owning sub-object remains valid until after we have
-    // deallocated the memory here.
-    detail::binder1<Handler, asio::error_code>
-      handler(o->handler_, ec);
-    p.h = asio::detail::addressof(handler.handler_);
-    p.reset();
-
-    // Make the upcall if required.
-    if (owner)
-    {
-      fenced_block b(fenced_block::half);
-      ASIO_HANDLER_INVOCATION_BEGIN((handler.arg1_));
-      asio_handler_invoke_helpers::invoke(handler, handler.handler_);
-      ASIO_HANDLER_INVOCATION_END;
-    }
-  }
-
-private:
-  win_iocp_socket_service_base& socket_service_;
-  socket_type socket_;
-  socket_holder new_socket_;
-  Socket& peer_;
-  Protocol protocol_;
-  typename Protocol::endpoint* peer_endpoint_;
-  unsigned char output_buffer_[(sizeof(sockaddr_storage_type) + 16) * 2];
-  bool enable_connection_aborted_;
-  Handler handler_;
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // defined(ASIO_HAS_IOCP)
-
-#endif // ASIO_DETAIL_WIN_IOCP_SOCKET_ACCEPT_OP_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/win_iocp_socket_connect_op.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/win_iocp_socket_connect_op.hpp
deleted file mode 100644
index 4472d25d8394..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/win_iocp_socket_connect_op.hpp
+++ /dev/null
@@ -1,124 +0,0 @@
-//
-// detail/win_iocp_socket_connect_op.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_WIN_IOCP_SOCKET_CONNECT_OP_HPP
-#define ASIO_DETAIL_WIN_IOCP_SOCKET_CONNECT_OP_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_HAS_IOCP)
-
-#include "asio/detail/addressof.hpp"
-#include "asio/detail/bind_handler.hpp"
-#include "asio/detail/fenced_block.hpp"
-#include "asio/detail/handler_alloc_helpers.hpp"
-#include "asio/detail/handler_invoke_helpers.hpp"
-#include "asio/detail/reactor_op.hpp"
-#include "asio/detail/socket_ops.hpp"
-#include "asio/error.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-class win_iocp_socket_connect_op_base : public reactor_op
-{
-public:
-  win_iocp_socket_connect_op_base(socket_type socket, func_type complete_func)
-    : reactor_op(&win_iocp_socket_connect_op_base::do_perform, complete_func),
-      socket_(socket),
-      connect_ex_(false)
-  {
-  }
-
-  static bool do_perform(reactor_op* base)
-  {
-    win_iocp_socket_connect_op_base* o(
-        static_cast<win_iocp_socket_connect_op_base*>(base));
-
-    return socket_ops::non_blocking_connect(o->socket_, o->ec_);
-  }
-
-  socket_type socket_;
-  bool connect_ex_;
-};
-
-template <typename Handler>
-class win_iocp_socket_connect_op : public win_iocp_socket_connect_op_base
-{
-public:
-  ASIO_DEFINE_HANDLER_PTR(win_iocp_socket_connect_op);
-
-  win_iocp_socket_connect_op(socket_type socket, Handler& handler)
-    : win_iocp_socket_connect_op_base(socket,
-        &win_iocp_socket_connect_op::do_complete),
-      handler_(ASIO_MOVE_CAST(Handler)(handler))
-  {
-  }
-
-  static void do_complete(io_service_impl* owner, operation* base,
-      const asio::error_code& result_ec,
-      std::size_t /*bytes_transferred*/)
-  {
-    asio::error_code ec(result_ec);
-
-    // Take ownership of the operation object.
-    win_iocp_socket_connect_op* o(
-        static_cast<win_iocp_socket_connect_op*>(base));
-    ptr p = { asio::detail::addressof(o->handler_), o, o };
-
-    if (owner)
-    {
-      if (o->connect_ex_)
-        socket_ops::complete_iocp_connect(o->socket_, ec);
-      else
-        ec = o->ec_;
-    }
-
-    ASIO_HANDLER_COMPLETION((o));
-
-    // Make a copy of the handler so that the memory can be deallocated before
-    // the upcall is made. Even if we're not about to make an upcall, a
-    // sub-object of the handler may be the true owner of the memory associated
-    // with the handler. Consequently, a local copy of the handler is required
-    // to ensure that any owning sub-object remains valid until after we have
-    // deallocated the memory here.
-    detail::binder1<Handler, asio::error_code>
-      handler(o->handler_, ec);
-    p.h = asio::detail::addressof(handler.handler_);
-    p.reset();
-
-    // Make the upcall if required.
-    if (owner)
-    {
-      fenced_block b(fenced_block::half);
-      ASIO_HANDLER_INVOCATION_BEGIN((handler.arg1_));
-      asio_handler_invoke_helpers::invoke(handler, handler.handler_);
-      ASIO_HANDLER_INVOCATION_END;
-    }
-  }
-
-private:
-  Handler handler_;
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // defined(ASIO_HAS_IOCP)
-
-#endif // ASIO_DETAIL_WIN_IOCP_SOCKET_CONNECT_OP_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/win_iocp_socket_recv_op.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/win_iocp_socket_recv_op.hpp
deleted file mode 100644
index ebd2131e3864..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/win_iocp_socket_recv_op.hpp
+++ /dev/null
@@ -1,115 +0,0 @@
-//
-// detail/win_iocp_socket_recv_op.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_WIN_IOCP_SOCKET_RECV_OP_HPP
-#define ASIO_DETAIL_WIN_IOCP_SOCKET_RECV_OP_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_HAS_IOCP)
-
-#include "asio/detail/addressof.hpp"
-#include "asio/detail/bind_handler.hpp"
-#include "asio/detail/buffer_sequence_adapter.hpp"
-#include "asio/detail/fenced_block.hpp"
-#include "asio/detail/handler_alloc_helpers.hpp"
-#include "asio/detail/handler_invoke_helpers.hpp"
-#include "asio/detail/operation.hpp"
-#include "asio/detail/socket_ops.hpp"
-#include "asio/error.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-template <typename MutableBufferSequence, typename Handler>
-class win_iocp_socket_recv_op : public operation
-{
-public:
-  ASIO_DEFINE_HANDLER_PTR(win_iocp_socket_recv_op);
-
-  win_iocp_socket_recv_op(socket_ops::state_type state,
-      socket_ops::weak_cancel_token_type cancel_token,
-      const MutableBufferSequence& buffers, Handler& handler)
-    : operation(&win_iocp_socket_recv_op::do_complete),
-      state_(state),
-      cancel_token_(cancel_token),
-      buffers_(buffers),
-      handler_(ASIO_MOVE_CAST(Handler)(handler))
-  {
-  }
-
-  static void do_complete(io_service_impl* owner, operation* base,
-      const asio::error_code& result_ec,
-      std::size_t bytes_transferred)
-  {
-    asio::error_code ec(result_ec);
-
-    // Take ownership of the operation object.
-    win_iocp_socket_recv_op* o(static_cast<win_iocp_socket_recv_op*>(base));
-    ptr p = { asio::detail::addressof(o->handler_), o, o };
-
-    ASIO_HANDLER_COMPLETION((o));
-
-#if defined(ASIO_ENABLE_BUFFER_DEBUGGING)
-    // Check whether buffers are still valid.
-    if (owner)
-    {
-      buffer_sequence_adapter<asio::mutable_buffer,
-          MutableBufferSequence>::validate(o->buffers_);
-    }
-#endif // defined(ASIO_ENABLE_BUFFER_DEBUGGING)
-
-    socket_ops::complete_iocp_recv(o->state_, o->cancel_token_,
-        buffer_sequence_adapter<asio::mutable_buffer,
-          MutableBufferSequence>::all_empty(o->buffers_),
-        ec, bytes_transferred);
-
-    // Make a copy of the handler so that the memory can be deallocated before
-    // the upcall is made. Even if we're not about to make an upcall, a
-    // sub-object of the handler may be the true owner of the memory associated
-    // with the handler. Consequently, a local copy of the handler is required
-    // to ensure that any owning sub-object remains valid until after we have
-    // deallocated the memory here.
-    detail::binder2<Handler, asio::error_code, std::size_t>
-      handler(o->handler_, ec, bytes_transferred);
-    p.h = asio::detail::addressof(handler.handler_);
-    p.reset();
-
-    // Make the upcall if required.
-    if (owner)
-    {
-      fenced_block b(fenced_block::half);
-      ASIO_HANDLER_INVOCATION_BEGIN((handler.arg1_, handler.arg2_));
-      asio_handler_invoke_helpers::invoke(handler, handler.handler_);
-      ASIO_HANDLER_INVOCATION_END;
-    }
-  }
-
-private:
-  socket_ops::state_type state_;
-  socket_ops::weak_cancel_token_type cancel_token_;
-  MutableBufferSequence buffers_;
-  Handler handler_;
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // defined(ASIO_HAS_IOCP)
-
-#endif // ASIO_DETAIL_WIN_IOCP_SOCKET_RECV_OP_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/win_iocp_socket_recvfrom_op.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/win_iocp_socket_recvfrom_op.hpp
deleted file mode 100644
index 8a20db1bca7f..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/win_iocp_socket_recvfrom_op.hpp
+++ /dev/null
@@ -1,123 +0,0 @@
-//
-// detail/win_iocp_socket_recvfrom_op.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_WIN_IOCP_SOCKET_RECVFROM_OP_HPP
-#define ASIO_DETAIL_WIN_IOCP_SOCKET_RECVFROM_OP_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_HAS_IOCP)
-
-#include "asio/detail/addressof.hpp"
-#include "asio/detail/bind_handler.hpp"
-#include "asio/detail/buffer_sequence_adapter.hpp"
-#include "asio/detail/fenced_block.hpp"
-#include "asio/detail/handler_alloc_helpers.hpp"
-#include "asio/detail/handler_invoke_helpers.hpp"
-#include "asio/detail/operation.hpp"
-#include "asio/detail/socket_ops.hpp"
-#include "asio/error.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-template <typename MutableBufferSequence, typename Endpoint, typename Handler>
-class win_iocp_socket_recvfrom_op : public operation
-{
-public:
-  ASIO_DEFINE_HANDLER_PTR(win_iocp_socket_recvfrom_op);
-
-  win_iocp_socket_recvfrom_op(Endpoint& endpoint,
-      socket_ops::weak_cancel_token_type cancel_token,
-      const MutableBufferSequence& buffers, Handler& handler)
-    : operation(&win_iocp_socket_recvfrom_op::do_complete),
-      endpoint_(endpoint),
-      endpoint_size_(static_cast<int>(endpoint.capacity())),
-      cancel_token_(cancel_token),
-      buffers_(buffers),
-      handler_(ASIO_MOVE_CAST(Handler)(handler))
-  {
-  }
-
-  int& endpoint_size()
-  {
-    return endpoint_size_;
-  }
-
-  static void do_complete(io_service_impl* owner, operation* base,
-      const asio::error_code& result_ec,
-      std::size_t bytes_transferred)
-  {
-    asio::error_code ec(result_ec);
-
-    // Take ownership of the operation object.
-    win_iocp_socket_recvfrom_op* o(
-        static_cast<win_iocp_socket_recvfrom_op*>(base));
-    ptr p = { asio::detail::addressof(o->handler_), o, o };
-
-    ASIO_HANDLER_COMPLETION((o));
-
-#if defined(ASIO_ENABLE_BUFFER_DEBUGGING)
-    // Check whether buffers are still valid.
-    if (owner)
-    {
-      buffer_sequence_adapter<asio::mutable_buffer,
-          MutableBufferSequence>::validate(o->buffers_);
-    }
-#endif // defined(ASIO_ENABLE_BUFFER_DEBUGGING)
-
-    socket_ops::complete_iocp_recvfrom(o->cancel_token_, ec);
-
-    // Record the size of the endpoint returned by the operation.
-    o->endpoint_.resize(o->endpoint_size_);
-
-    // Make a copy of the handler so that the memory can be deallocated before
-    // the upcall is made. Even if we're not about to make an upcall, a
-    // sub-object of the handler may be the true owner of the memory associated
-    // with the handler. Consequently, a local copy of the handler is required
-    // to ensure that any owning sub-object remains valid until after we have
-    // deallocated the memory here.
-    detail::binder2<Handler, asio::error_code, std::size_t>
-      handler(o->handler_, ec, bytes_transferred);
-    p.h = asio::detail::addressof(handler.handler_);
-    p.reset();
-
-    // Make the upcall if required.
-    if (owner)
-    {
-      fenced_block b(fenced_block::half);
-      ASIO_HANDLER_INVOCATION_BEGIN((handler.arg1_, handler.arg2_));
-      asio_handler_invoke_helpers::invoke(handler, handler.handler_);
-      ASIO_HANDLER_INVOCATION_END;
-    }
-  }
-
-private:
-  Endpoint& endpoint_;
-  int endpoint_size_;
-  socket_ops::weak_cancel_token_type cancel_token_;
-  MutableBufferSequence buffers_;
-  Handler handler_;
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // defined(ASIO_HAS_IOCP)
-
-#endif // ASIO_DETAIL_WIN_IOCP_SOCKET_RECVFROM_OP_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/win_iocp_socket_recvmsg_op.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/win_iocp_socket_recvmsg_op.hpp
deleted file mode 100644
index 1699b28aac8f..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/win_iocp_socket_recvmsg_op.hpp
+++ /dev/null
@@ -1,116 +0,0 @@
-//
-// detail/win_iocp_socket_recvmsg_op.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_WIN_IOCP_SOCKET_RECVMSG_OP_HPP
-#define ASIO_DETAIL_WIN_IOCP_SOCKET_RECVMSG_OP_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_HAS_IOCP)
-
-#include "asio/detail/addressof.hpp"
-#include "asio/detail/bind_handler.hpp"
-#include "asio/detail/buffer_sequence_adapter.hpp"
-#include "asio/detail/fenced_block.hpp"
-#include "asio/detail/handler_alloc_helpers.hpp"
-#include "asio/detail/handler_invoke_helpers.hpp"
-#include "asio/detail/operation.hpp"
-#include "asio/detail/socket_ops.hpp"
-#include "asio/error.hpp"
-#include "asio/socket_base.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-template <typename MutableBufferSequence, typename Handler>
-class win_iocp_socket_recvmsg_op : public operation
-{
-public:
-  ASIO_DEFINE_HANDLER_PTR(win_iocp_socket_recvmsg_op);
-
-  win_iocp_socket_recvmsg_op(
-      socket_ops::weak_cancel_token_type cancel_token,
-      const MutableBufferSequence& buffers,
-      socket_base::message_flags& out_flags, Handler& handler)
-    : operation(&win_iocp_socket_recvmsg_op::do_complete),
-      cancel_token_(cancel_token),
-      buffers_(buffers),
-      out_flags_(out_flags),
-      handler_(ASIO_MOVE_CAST(Handler)(handler))
-  {
-  }
-
-  static void do_complete(io_service_impl* owner, operation* base,
-      const asio::error_code& result_ec,
-      std::size_t bytes_transferred)
-  {
-    asio::error_code ec(result_ec);
-
-    // Take ownership of the operation object.
-    win_iocp_socket_recvmsg_op* o(
-        static_cast<win_iocp_socket_recvmsg_op*>(base));
-    ptr p = { asio::detail::addressof(o->handler_), o, o };
-
-    ASIO_HANDLER_COMPLETION((o));
-
-#if defined(ASIO_ENABLE_BUFFER_DEBUGGING)
-    // Check whether buffers are still valid.
-    if (owner)
-    {
-      buffer_sequence_adapter<asio::mutable_buffer,
-          MutableBufferSequence>::validate(o->buffers_);
-    }
-#endif // defined(ASIO_ENABLE_BUFFER_DEBUGGING)
-
-    socket_ops::complete_iocp_recvmsg(o->cancel_token_, ec);
-    o->out_flags_ = 0;
-
-    // Make a copy of the handler so that the memory can be deallocated before
-    // the upcall is made. Even if we're not about to make an upcall, a
-    // sub-object of the handler may be the true owner of the memory associated
-    // with the handler. Consequently, a local copy of the handler is required
-    // to ensure that any owning sub-object remains valid until after we have
-    // deallocated the memory here.
-    detail::binder2<Handler, asio::error_code, std::size_t>
-      handler(o->handler_, ec, bytes_transferred);
-    p.h = asio::detail::addressof(handler.handler_);
-    p.reset();
-
-    // Make the upcall if required.
-    if (owner)
-    {
-      fenced_block b(fenced_block::half);
-      ASIO_HANDLER_INVOCATION_BEGIN((handler.arg1_, handler.arg2_));
-      asio_handler_invoke_helpers::invoke(handler, handler.handler_);
-      ASIO_HANDLER_INVOCATION_END;
-    }
-  }
-
-private:
-  socket_ops::weak_cancel_token_type cancel_token_;
-  MutableBufferSequence buffers_;
-  socket_base::message_flags& out_flags_;
-  Handler handler_;
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // defined(ASIO_HAS_IOCP)
-
-#endif // ASIO_DETAIL_WIN_IOCP_SOCKET_RECVMSG_OP_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/win_iocp_socket_send_op.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/win_iocp_socket_send_op.hpp
deleted file mode 100644
index 455de90fae42..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/win_iocp_socket_send_op.hpp
+++ /dev/null
@@ -1,109 +0,0 @@
-//
-// detail/win_iocp_socket_send_op.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_WIN_IOCP_SOCKET_SEND_OP_HPP
-#define ASIO_DETAIL_WIN_IOCP_SOCKET_SEND_OP_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_HAS_IOCP)
-
-#include "asio/detail/addressof.hpp"
-#include "asio/detail/bind_handler.hpp"
-#include "asio/detail/buffer_sequence_adapter.hpp"
-#include "asio/detail/fenced_block.hpp"
-#include "asio/detail/handler_alloc_helpers.hpp"
-#include "asio/detail/handler_invoke_helpers.hpp"
-#include "asio/detail/operation.hpp"
-#include "asio/detail/socket_ops.hpp"
-#include "asio/error.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-template <typename ConstBufferSequence, typename Handler>
-class win_iocp_socket_send_op : public operation
-{
-public:
-  ASIO_DEFINE_HANDLER_PTR(win_iocp_socket_send_op);
-
-  win_iocp_socket_send_op(socket_ops::weak_cancel_token_type cancel_token,
-      const ConstBufferSequence& buffers, Handler& handler)
-    : operation(&win_iocp_socket_send_op::do_complete),
-      cancel_token_(cancel_token),
-      buffers_(buffers),
-      handler_(ASIO_MOVE_CAST(Handler)(handler))
-  {
-  }
-
-  static void do_complete(io_service_impl* owner, operation* base,
-      const asio::error_code& result_ec,
-      std::size_t bytes_transferred)
-  {
-    asio::error_code ec(result_ec);
-
-    // Take ownership of the operation object.
-    win_iocp_socket_send_op* o(static_cast<win_iocp_socket_send_op*>(base));
-    ptr p = { asio::detail::addressof(o->handler_), o, o };
-
-    ASIO_HANDLER_COMPLETION((o));
-
-#if defined(ASIO_ENABLE_BUFFER_DEBUGGING)
-    // Check whether buffers are still valid.
-    if (owner)
-    {
-      buffer_sequence_adapter<asio::const_buffer,
-          ConstBufferSequence>::validate(o->buffers_);
-    }
-#endif // defined(ASIO_ENABLE_BUFFER_DEBUGGING)
-
-    socket_ops::complete_iocp_send(o->cancel_token_, ec);
-
-    // Make a copy of the handler so that the memory can be deallocated before
-    // the upcall is made. Even if we're not about to make an upcall, a
-    // sub-object of the handler may be the true owner of the memory associated
-    // with the handler. Consequently, a local copy of the handler is required
-    // to ensure that any owning sub-object remains valid until after we have
-    // deallocated the memory here.
-    detail::binder2<Handler, asio::error_code, std::size_t>
-      handler(o->handler_, ec, bytes_transferred);
-    p.h = asio::detail::addressof(handler.handler_);
-    p.reset();
-
-    // Make the upcall if required.
-    if (owner)
-    {
-      fenced_block b(fenced_block::half);
-      ASIO_HANDLER_INVOCATION_BEGIN((handler.arg1_, handler.arg2_));
-      asio_handler_invoke_helpers::invoke(handler, handler.handler_);
-      ASIO_HANDLER_INVOCATION_END;
-    }
-  }
-
-private:
-  socket_ops::weak_cancel_token_type cancel_token_;
-  ConstBufferSequence buffers_;
-  Handler handler_;
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // defined(ASIO_HAS_IOCP)
-
-#endif // ASIO_DETAIL_WIN_IOCP_SOCKET_SEND_OP_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/win_iocp_socket_service.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/win_iocp_socket_service.hpp
deleted file mode 100644
index a3c5decf416b..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/win_iocp_socket_service.hpp
+++ /dev/null
@@ -1,525 +0,0 @@
-//
-// detail/win_iocp_socket_service.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_WIN_IOCP_SOCKET_SERVICE_HPP
-#define ASIO_DETAIL_WIN_IOCP_SOCKET_SERVICE_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_HAS_IOCP)
-
-#include <cstring>
-#include "asio/error.hpp"
-#include "asio/io_service.hpp"
-#include "asio/socket_base.hpp"
-#include "asio/detail/addressof.hpp"
-#include "asio/detail/bind_handler.hpp"
-#include "asio/detail/buffer_sequence_adapter.hpp"
-#include "asio/detail/fenced_block.hpp"
-#include "asio/detail/handler_alloc_helpers.hpp"
-#include "asio/detail/handler_invoke_helpers.hpp"
-#include "asio/detail/mutex.hpp"
-#include "asio/detail/operation.hpp"
-#include "asio/detail/reactor.hpp"
-#include "asio/detail/reactor_op.hpp"
-#include "asio/detail/socket_holder.hpp"
-#include "asio/detail/socket_ops.hpp"
-#include "asio/detail/socket_types.hpp"
-#include "asio/detail/win_iocp_io_service.hpp"
-#include "asio/detail/win_iocp_null_buffers_op.hpp"
-#include "asio/detail/win_iocp_socket_accept_op.hpp"
-#include "asio/detail/win_iocp_socket_connect_op.hpp"
-#include "asio/detail/win_iocp_socket_recvfrom_op.hpp"
-#include "asio/detail/win_iocp_socket_send_op.hpp"
-#include "asio/detail/win_iocp_socket_service_base.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-template <typename Protocol>
-class win_iocp_socket_service : public win_iocp_socket_service_base
-{
-public:
-  // The protocol type.
-  typedef Protocol protocol_type;
-
-  // The endpoint type.
-  typedef typename Protocol::endpoint endpoint_type;
-
-  // The native type of a socket.
-  class native_handle_type
-  {
-  public:
-    native_handle_type(socket_type s)
-      : socket_(s),
-        have_remote_endpoint_(false)
-    {
-    }
-
-    native_handle_type(socket_type s, const endpoint_type& ep)
-      : socket_(s),
-        have_remote_endpoint_(true),
-        remote_endpoint_(ep)
-    {
-    }
-
-    void operator=(socket_type s)
-    {
-      socket_ = s;
-      have_remote_endpoint_ = false;
-      remote_endpoint_ = endpoint_type();
-    }
-
-    operator socket_type() const
-    {
-      return socket_;
-    }
-
-    bool have_remote_endpoint() const
-    {
-      return have_remote_endpoint_;
-    }
-
-    endpoint_type remote_endpoint() const
-    {
-      return remote_endpoint_;
-    }
-
-  private:
-    socket_type socket_;
-    bool have_remote_endpoint_;
-    endpoint_type remote_endpoint_;
-  };
-
-  // The implementation type of the socket.
-  struct implementation_type :
-    win_iocp_socket_service_base::base_implementation_type
-  {
-    // Default constructor.
-    implementation_type()
-      : protocol_(endpoint_type().protocol()),
-        have_remote_endpoint_(false),
-        remote_endpoint_()
-    {
-    }
-
-    // The protocol associated with the socket.
-    protocol_type protocol_;
-
-    // Whether we have a cached remote endpoint.
-    bool have_remote_endpoint_;
-
-    // A cached remote endpoint.
-    endpoint_type remote_endpoint_;
-  };
-
-  // Constructor.
-  win_iocp_socket_service(asio::io_service& io_service)
-    : win_iocp_socket_service_base(io_service)
-  {
-  }
-
-  // Move-construct a new socket implementation.
-  void move_construct(implementation_type& impl,
-      implementation_type& other_impl)
-  {
-    this->base_move_construct(impl, other_impl);
-
-    impl.protocol_ = other_impl.protocol_;
-    other_impl.protocol_ = endpoint_type().protocol();
-
-    impl.have_remote_endpoint_ = other_impl.have_remote_endpoint_;
-    other_impl.have_remote_endpoint_ = false;
-
-    impl.remote_endpoint_ = other_impl.remote_endpoint_;
-    other_impl.remote_endpoint_ = endpoint_type();
-  }
-
-  // Move-assign from another socket implementation.
-  void move_assign(implementation_type& impl,
-      win_iocp_socket_service_base& other_service,
-      implementation_type& other_impl)
-  {
-    this->base_move_assign(impl, other_service, other_impl);
-
-    impl.protocol_ = other_impl.protocol_;
-    other_impl.protocol_ = endpoint_type().protocol();
-
-    impl.have_remote_endpoint_ = other_impl.have_remote_endpoint_;
-    other_impl.have_remote_endpoint_ = false;
-
-    impl.remote_endpoint_ = other_impl.remote_endpoint_;
-    other_impl.remote_endpoint_ = endpoint_type();
-  }
-
-  // Move-construct a new socket implementation from another protocol type.
-  template <typename Protocol1>
-  void converting_move_construct(implementation_type& impl,
-      typename win_iocp_socket_service<
-        Protocol1>::implementation_type& other_impl)
-  {
-    this->base_move_construct(impl, other_impl);
-
-    impl.protocol_ = protocol_type(other_impl.protocol_);
-    other_impl.protocol_ = typename Protocol1::endpoint().protocol();
-
-    impl.have_remote_endpoint_ = other_impl.have_remote_endpoint_;
-    other_impl.have_remote_endpoint_ = false;
-
-    impl.remote_endpoint_ = other_impl.remote_endpoint_;
-    other_impl.remote_endpoint_ = typename Protocol1::endpoint();
-  }
-
-  // Open a new socket implementation.
-  asio::error_code open(implementation_type& impl,
-      const protocol_type& protocol, asio::error_code& ec)
-  {
-    if (!do_open(impl, protocol.family(),
-          protocol.type(), protocol.protocol(), ec))
-    {
-      impl.protocol_ = protocol;
-      impl.have_remote_endpoint_ = false;
-      impl.remote_endpoint_ = endpoint_type();
-    }
-    return ec;
-  }
-
-  // Assign a native socket to a socket implementation.
-  asio::error_code assign(implementation_type& impl,
-      const protocol_type& protocol, const native_handle_type& native_socket,
-      asio::error_code& ec)
-  {
-    if (!do_assign(impl, protocol.type(), native_socket, ec))
-    {
-      impl.protocol_ = protocol;
-      impl.have_remote_endpoint_ = native_socket.have_remote_endpoint();
-      impl.remote_endpoint_ = native_socket.remote_endpoint();
-    }
-    return ec;
-  }
-
-  // Get the native socket representation.
-  native_handle_type native_handle(implementation_type& impl)
-  {
-    if (impl.have_remote_endpoint_)
-      return native_handle_type(impl.socket_, impl.remote_endpoint_);
-    return native_handle_type(impl.socket_);
-  }
-
-  // Bind the socket to the specified local endpoint.
-  asio::error_code bind(implementation_type& impl,
-      const endpoint_type& endpoint, asio::error_code& ec)
-  {
-    socket_ops::bind(impl.socket_, endpoint.data(), endpoint.size(), ec);
-    return ec;
-  }
-
-  // Set a socket option.
-  template <typename Option>
-  asio::error_code set_option(implementation_type& impl,
-      const Option& option, asio::error_code& ec)
-  {
-    socket_ops::setsockopt(impl.socket_, impl.state_,
-        option.level(impl.protocol_), option.name(impl.protocol_),
-        option.data(impl.protocol_), option.size(impl.protocol_), ec);
-    return ec;
-  }
-
-  // Set a socket option.
-  template <typename Option>
-  asio::error_code get_option(const implementation_type& impl,
-      Option& option, asio::error_code& ec) const
-  {
-    std::size_t size = option.size(impl.protocol_);
-    socket_ops::getsockopt(impl.socket_, impl.state_,
-        option.level(impl.protocol_), option.name(impl.protocol_),
-        option.data(impl.protocol_), &size, ec);
-    if (!ec)
-      option.resize(impl.protocol_, size);
-    return ec;
-  }
-
-  // Get the local endpoint.
-  endpoint_type local_endpoint(const implementation_type& impl,
-      asio::error_code& ec) const
-  {
-    endpoint_type endpoint;
-    std::size_t addr_len = endpoint.capacity();
-    if (socket_ops::getsockname(impl.socket_, endpoint.data(), &addr_len, ec))
-      return endpoint_type();
-    endpoint.resize(addr_len);
-    return endpoint;
-  }
-
-  // Get the remote endpoint.
-  endpoint_type remote_endpoint(const implementation_type& impl,
-      asio::error_code& ec) const
-  {
-    endpoint_type endpoint = impl.remote_endpoint_;
-    std::size_t addr_len = endpoint.capacity();
-    if (socket_ops::getpeername(impl.socket_, endpoint.data(),
-          &addr_len, impl.have_remote_endpoint_, ec))
-      return endpoint_type();
-    endpoint.resize(addr_len);
-    return endpoint;
-  }
-
-  // Send a datagram to the specified endpoint. Returns the number of bytes
-  // sent.
-  template <typename ConstBufferSequence>
-  size_t send_to(implementation_type& impl, const ConstBufferSequence& buffers,
-      const endpoint_type& destination, socket_base::message_flags flags,
-      asio::error_code& ec)
-  {
-    buffer_sequence_adapter<asio::const_buffer,
-        ConstBufferSequence> bufs(buffers);
-
-    return socket_ops::sync_sendto(impl.socket_, impl.state_,
-        bufs.buffers(), bufs.count(), flags,
-        destination.data(), destination.size(), ec);
-  }
-
-  // Wait until data can be sent without blocking.
-  size_t send_to(implementation_type& impl, const null_buffers&,
-      const endpoint_type&, socket_base::message_flags,
-      asio::error_code& ec)
-  {
-    // Wait for socket to become ready.
-    socket_ops::poll_write(impl.socket_, impl.state_, ec);
-
-    return 0;
-  }
-
-  // Start an asynchronous send. The data being sent must be valid for the
-  // lifetime of the asynchronous operation.
-  template <typename ConstBufferSequence, typename Handler>
-  void async_send_to(implementation_type& impl,
-      const ConstBufferSequence& buffers, const endpoint_type& destination,
-      socket_base::message_flags flags, Handler& handler)
-  {
-    // Allocate and construct an operation to wrap the handler.
-    typedef win_iocp_socket_send_op<ConstBufferSequence, Handler> op;
-    typename op::ptr p = { asio::detail::addressof(handler),
-      asio_handler_alloc_helpers::allocate(
-        sizeof(op), handler), 0 };
-    p.p = new (p.v) op(impl.cancel_token_, buffers, handler);
-
-    ASIO_HANDLER_CREATION((p.p, "socket", &impl, "async_send_to"));
-
-    buffer_sequence_adapter<asio::const_buffer,
-        ConstBufferSequence> bufs(buffers);
-
-    start_send_to_op(impl, bufs.buffers(), bufs.count(),
-        destination.data(), static_cast<int>(destination.size()),
-        flags, p.p);
-    p.v = p.p = 0;
-  }
-
-  // Start an asynchronous wait until data can be sent without blocking.
-  template <typename Handler>
-  void async_send_to(implementation_type& impl, const null_buffers&,
-      const endpoint_type&, socket_base::message_flags, Handler& handler)
-  {
-    // Allocate and construct an operation to wrap the handler.
-    typedef win_iocp_null_buffers_op<Handler> op;
-    typename op::ptr p = { asio::detail::addressof(handler),
-      asio_handler_alloc_helpers::allocate(
-        sizeof(op), handler), 0 };
-    p.p = new (p.v) op(impl.cancel_token_, handler);
-
-    ASIO_HANDLER_CREATION((p.p, "socket",
-          &impl, "async_send_to(null_buffers)"));
-
-    start_reactor_op(impl, reactor::write_op, p.p);
-    p.v = p.p = 0;
-  }
-
-  // Receive a datagram with the endpoint of the sender. Returns the number of
-  // bytes received.
-  template <typename MutableBufferSequence>
-  size_t receive_from(implementation_type& impl,
-      const MutableBufferSequence& buffers,
-      endpoint_type& sender_endpoint, socket_base::message_flags flags,
-      asio::error_code& ec)
-  {
-    buffer_sequence_adapter<asio::mutable_buffer,
-        MutableBufferSequence> bufs(buffers);
-
-    std::size_t addr_len = sender_endpoint.capacity();
-    std::size_t bytes_recvd = socket_ops::sync_recvfrom(
-        impl.socket_, impl.state_, bufs.buffers(), bufs.count(),
-        flags, sender_endpoint.data(), &addr_len, ec);
-
-    if (!ec)
-      sender_endpoint.resize(addr_len);
-
-    return bytes_recvd;
-  }
-
-  // Wait until data can be received without blocking.
-  size_t receive_from(implementation_type& impl,
-      const null_buffers&, endpoint_type& sender_endpoint,
-      socket_base::message_flags, asio::error_code& ec)
-  {
-    // Wait for socket to become ready.
-    socket_ops::poll_read(impl.socket_, impl.state_, ec);
-
-    // Reset endpoint since it can be given no sensible value at this time.
-    sender_endpoint = endpoint_type();
-
-    return 0;
-  }
-
-  // Start an asynchronous receive. The buffer for the data being received and
-  // the sender_endpoint object must both be valid for the lifetime of the
-  // asynchronous operation.
-  template <typename MutableBufferSequence, typename Handler>
-  void async_receive_from(implementation_type& impl,
-      const MutableBufferSequence& buffers, endpoint_type& sender_endp,
-      socket_base::message_flags flags, Handler& handler)
-  {
-    // Allocate and construct an operation to wrap the handler.
-    typedef win_iocp_socket_recvfrom_op<
-      MutableBufferSequence, endpoint_type, Handler> op;
-    typename op::ptr p = { asio::detail::addressof(handler),
-      asio_handler_alloc_helpers::allocate(
-        sizeof(op), handler), 0 };
-    p.p = new (p.v) op(sender_endp, impl.cancel_token_, buffers, handler);
-
-    ASIO_HANDLER_CREATION((p.p, "socket", &impl, "async_receive_from"));
-
-    buffer_sequence_adapter<asio::mutable_buffer,
-        MutableBufferSequence> bufs(buffers);
-
-    start_receive_from_op(impl, bufs.buffers(), bufs.count(),
-        sender_endp.data(), flags, &p.p->endpoint_size(), p.p);
-    p.v = p.p = 0;
-  }
-
-  // Wait until data can be received without blocking.
-  template <typename Handler>
-  void async_receive_from(implementation_type& impl,
-      const null_buffers&, endpoint_type& sender_endpoint,
-      socket_base::message_flags flags, Handler& handler)
-  {
-    // Allocate and construct an operation to wrap the handler.
-    typedef win_iocp_null_buffers_op<Handler> op;
-    typename op::ptr p = { asio::detail::addressof(handler),
-      asio_handler_alloc_helpers::allocate(
-        sizeof(op), handler), 0 };
-    p.p = new (p.v) op(impl.cancel_token_, handler);
-
-    ASIO_HANDLER_CREATION((p.p, "socket", &impl,
-          "async_receive_from(null_buffers)"));
-
-    // Reset endpoint since it can be given no sensible value at this time.
-    sender_endpoint = endpoint_type();
-
-    start_null_buffers_receive_op(impl, flags, p.p);
-    p.v = p.p = 0;
-  }
-
-  // Accept a new connection.
-  template <typename Socket>
-  asio::error_code accept(implementation_type& impl, Socket& peer,
-      endpoint_type* peer_endpoint, asio::error_code& ec)
-  {
-    // We cannot accept a socket that is already open.
-    if (peer.is_open())
-    {
-      ec = asio::error::already_open;
-      return ec;
-    }
-
-    std::size_t addr_len = peer_endpoint ? peer_endpoint->capacity() : 0;
-    socket_holder new_socket(socket_ops::sync_accept(impl.socket_,
-          impl.state_, peer_endpoint ? peer_endpoint->data() : 0,
-          peer_endpoint ? &addr_len : 0, ec));
-
-    // On success, assign new connection to peer socket object.
-    if (new_socket.get() != invalid_socket)
-    {
-      if (peer_endpoint)
-        peer_endpoint->resize(addr_len);
-      if (!peer.assign(impl.protocol_, new_socket.get(), ec))
-        new_socket.release();
-    }
-
-    return ec;
-  }
-
-  // Start an asynchronous accept. The peer and peer_endpoint objects
-  // must be valid until the accept's handler is invoked.
-  template <typename Socket, typename Handler>
-  void async_accept(implementation_type& impl, Socket& peer,
-      endpoint_type* peer_endpoint, Handler& handler)
-  {
-    // Allocate and construct an operation to wrap the handler.
-    typedef win_iocp_socket_accept_op<Socket, protocol_type, Handler> op;
-    typename op::ptr p = { asio::detail::addressof(handler),
-      asio_handler_alloc_helpers::allocate(
-        sizeof(op), handler), 0 };
-    bool enable_connection_aborted =
-      (impl.state_ & socket_ops::enable_connection_aborted) != 0;
-    p.p = new (p.v) op(*this, impl.socket_, peer, impl.protocol_,
-        peer_endpoint, enable_connection_aborted, handler);
-
-    ASIO_HANDLER_CREATION((p.p, "socket", &impl, "async_accept"));
-
-    start_accept_op(impl, peer.is_open(), p.p->new_socket(),
-        impl.protocol_.family(), impl.protocol_.type(),
-        impl.protocol_.protocol(), p.p->output_buffer(),
-        p.p->address_length(), p.p);
-    p.v = p.p = 0;
-  }
-
-  // Connect the socket to the specified endpoint.
-  asio::error_code connect(implementation_type& impl,
-      const endpoint_type& peer_endpoint, asio::error_code& ec)
-  {
-    socket_ops::sync_connect(impl.socket_,
-        peer_endpoint.data(), peer_endpoint.size(), ec);
-    return ec;
-  }
-
-  // Start an asynchronous connect.
-  template <typename Handler>
-  void async_connect(implementation_type& impl,
-      const endpoint_type& peer_endpoint, Handler& handler)
-  {
-    // Allocate and construct an operation to wrap the handler.
-    typedef win_iocp_socket_connect_op<Handler> op;
-    typename op::ptr p = { asio::detail::addressof(handler),
-      asio_handler_alloc_helpers::allocate(
-        sizeof(op), handler), 0 };
-    p.p = new (p.v) op(impl.socket_, handler);
-
-    ASIO_HANDLER_CREATION((p.p, "socket", &impl, "async_connect"));
-
-    start_connect_op(impl, impl.protocol_.family(), impl.protocol_.type(),
-        peer_endpoint.data(), static_cast<int>(peer_endpoint.size()), p.p);
-    p.v = p.p = 0;
-  }
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // defined(ASIO_HAS_IOCP)
-
-#endif // ASIO_DETAIL_WIN_IOCP_SOCKET_SERVICE_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/win_iocp_socket_service_base.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/win_iocp_socket_service_base.hpp
deleted file mode 100644
index f1584fd04403..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/win_iocp_socket_service_base.hpp
+++ /dev/null
@@ -1,524 +0,0 @@
-//
-// detail/win_iocp_socket_service_base.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_WIN_IOCP_SOCKET_SERVICE_BASE_HPP
-#define ASIO_DETAIL_WIN_IOCP_SOCKET_SERVICE_BASE_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_HAS_IOCP)
-
-#include "asio/error.hpp"
-#include "asio/io_service.hpp"
-#include "asio/socket_base.hpp"
-#include "asio/detail/addressof.hpp"
-#include "asio/detail/bind_handler.hpp"
-#include "asio/detail/buffer_sequence_adapter.hpp"
-#include "asio/detail/fenced_block.hpp"
-#include "asio/detail/handler_alloc_helpers.hpp"
-#include "asio/detail/handler_invoke_helpers.hpp"
-#include "asio/detail/mutex.hpp"
-#include "asio/detail/operation.hpp"
-#include "asio/detail/reactor.hpp"
-#include "asio/detail/reactor_op.hpp"
-#include "asio/detail/socket_holder.hpp"
-#include "asio/detail/socket_ops.hpp"
-#include "asio/detail/socket_types.hpp"
-#include "asio/detail/win_iocp_io_service.hpp"
-#include "asio/detail/win_iocp_null_buffers_op.hpp"
-#include "asio/detail/win_iocp_socket_connect_op.hpp"
-#include "asio/detail/win_iocp_socket_send_op.hpp"
-#include "asio/detail/win_iocp_socket_recv_op.hpp"
-#include "asio/detail/win_iocp_socket_recvmsg_op.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-class win_iocp_socket_service_base
-{
-public:
-  // The implementation type of the socket.
-  struct base_implementation_type
-  {
-    // The native socket representation.
-    socket_type socket_;
-
-    // The current state of the socket.
-    socket_ops::state_type state_;
-
-    // We use a shared pointer as a cancellation token here to work around the
-    // broken Windows support for cancellation. MSDN says that when you call
-    // closesocket any outstanding WSARecv or WSASend operations will complete
-    // with the error ERROR_OPERATION_ABORTED. In practice they complete with
-    // ERROR_NETNAME_DELETED, which means you can't tell the difference between
-    // a local cancellation and the socket being hard-closed by the peer.
-    socket_ops::shared_cancel_token_type cancel_token_;
-
-    // Per-descriptor data used by the reactor.
-    reactor::per_descriptor_data reactor_data_;
-
-#if defined(ASIO_ENABLE_CANCELIO)
-    // The ID of the thread from which it is safe to cancel asynchronous
-    // operations. 0 means no asynchronous operations have been started yet.
-    // ~0 means asynchronous operations have been started from more than one
-    // thread, and cancellation is not supported for the socket.
-    DWORD safe_cancellation_thread_id_;
-#endif // defined(ASIO_ENABLE_CANCELIO)
-
-    // Pointers to adjacent socket implementations in linked list.
-    base_implementation_type* next_;
-    base_implementation_type* prev_;
-  };
-
-  // Constructor.
-  ASIO_DECL win_iocp_socket_service_base(
-      asio::io_service& io_service);
-
-  // Destroy all user-defined handler objects owned by the service.
-  ASIO_DECL void shutdown_service();
-
-  // Construct a new socket implementation.
-  ASIO_DECL void construct(base_implementation_type& impl);
-
-  // Move-construct a new socket implementation.
-  ASIO_DECL void base_move_construct(base_implementation_type& impl,
-      base_implementation_type& other_impl);
-
-  // Move-assign from another socket implementation.
-  ASIO_DECL void base_move_assign(base_implementation_type& impl,
-      win_iocp_socket_service_base& other_service,
-      base_implementation_type& other_impl);
-
-  // Destroy a socket implementation.
-  ASIO_DECL void destroy(base_implementation_type& impl);
-
-  // Determine whether the socket is open.
-  bool is_open(const base_implementation_type& impl) const
-  {
-    return impl.socket_ != invalid_socket;
-  }
-
-  // Destroy a socket implementation.
-  ASIO_DECL asio::error_code close(
-      base_implementation_type& impl, asio::error_code& ec);
-
-  // Cancel all operations associated with the socket.
-  ASIO_DECL asio::error_code cancel(
-      base_implementation_type& impl, asio::error_code& ec);
-
-  // Determine whether the socket is at the out-of-band data mark.
-  bool at_mark(const base_implementation_type& impl,
-      asio::error_code& ec) const
-  {
-    return socket_ops::sockatmark(impl.socket_, ec);
-  }
-
-  // Determine the number of bytes available for reading.
-  std::size_t available(const base_implementation_type& impl,
-      asio::error_code& ec) const
-  {
-    return socket_ops::available(impl.socket_, ec);
-  }
-
-  // Place the socket into the state where it will listen for new connections.
-  asio::error_code listen(base_implementation_type& impl,
-      int backlog, asio::error_code& ec)
-  {
-    socket_ops::listen(impl.socket_, backlog, ec);
-    return ec;
-  }
-
-  // Perform an IO control command on the socket.
-  template <typename IO_Control_Command>
-  asio::error_code io_control(base_implementation_type& impl,
-      IO_Control_Command& command, asio::error_code& ec)
-  {
-    socket_ops::ioctl(impl.socket_, impl.state_, command.name(),
-        static_cast<ioctl_arg_type*>(command.data()), ec);
-    return ec;
-  }
-
-  // Gets the non-blocking mode of the socket.
-  bool non_blocking(const base_implementation_type& impl) const
-  {
-    return (impl.state_ & socket_ops::user_set_non_blocking) != 0;
-  }
-
-  // Sets the non-blocking mode of the socket.
-  asio::error_code non_blocking(base_implementation_type& impl,
-      bool mode, asio::error_code& ec)
-  {
-    socket_ops::set_user_non_blocking(impl.socket_, impl.state_, mode, ec);
-    return ec;
-  }
-
-  // Gets the non-blocking mode of the native socket implementation.
-  bool native_non_blocking(const base_implementation_type& impl) const
-  {
-    return (impl.state_ & socket_ops::internal_non_blocking) != 0;
-  }
-
-  // Sets the non-blocking mode of the native socket implementation.
-  asio::error_code native_non_blocking(base_implementation_type& impl,
-      bool mode, asio::error_code& ec)
-  {
-    socket_ops::set_internal_non_blocking(impl.socket_, impl.state_, mode, ec);
-    return ec;
-  }
-
-  // Disable sends or receives on the socket.
-  asio::error_code shutdown(base_implementation_type& impl,
-      socket_base::shutdown_type what, asio::error_code& ec)
-  {
-    socket_ops::shutdown(impl.socket_, what, ec);
-    return ec;
-  }
-
-  // Send the given data to the peer. Returns the number of bytes sent.
-  template <typename ConstBufferSequence>
-  size_t send(base_implementation_type& impl,
-      const ConstBufferSequence& buffers,
-      socket_base::message_flags flags, asio::error_code& ec)
-  {
-    buffer_sequence_adapter<asio::const_buffer,
-        ConstBufferSequence> bufs(buffers);
-
-    return socket_ops::sync_send(impl.socket_, impl.state_,
-        bufs.buffers(), bufs.count(), flags, bufs.all_empty(), ec);
-  }
-
-  // Wait until data can be sent without blocking.
-  size_t send(base_implementation_type& impl, const null_buffers&,
-      socket_base::message_flags, asio::error_code& ec)
-  {
-    // Wait for socket to become ready.
-    socket_ops::poll_write(impl.socket_, impl.state_, ec);
-
-    return 0;
-  }
-
-  // Start an asynchronous send. The data being sent must be valid for the
-  // lifetime of the asynchronous operation.
-  template <typename ConstBufferSequence, typename Handler>
-  void async_send(base_implementation_type& impl,
-      const ConstBufferSequence& buffers,
-      socket_base::message_flags flags, Handler& handler)
-  {
-    // Allocate and construct an operation to wrap the handler.
-    typedef win_iocp_socket_send_op<ConstBufferSequence, Handler> op;
-    typename op::ptr p = { asio::detail::addressof(handler),
-      asio_handler_alloc_helpers::allocate(
-        sizeof(op), handler), 0 };
-    p.p = new (p.v) op(impl.cancel_token_, buffers, handler);
-
-    ASIO_HANDLER_CREATION((p.p, "socket", &impl, "async_send"));
-
-    buffer_sequence_adapter<asio::const_buffer,
-        ConstBufferSequence> bufs(buffers);
-
-    start_send_op(impl, bufs.buffers(), bufs.count(), flags,
-        (impl.state_ & socket_ops::stream_oriented) != 0 && bufs.all_empty(),
-        p.p);
-    p.v = p.p = 0;
-  }
-
-  // Start an asynchronous wait until data can be sent without blocking.
-  template <typename Handler>
-  void async_send(base_implementation_type& impl, const null_buffers&,
-      socket_base::message_flags, Handler& handler)
-  {
-    // Allocate and construct an operation to wrap the handler.
-    typedef win_iocp_null_buffers_op<Handler> op;
-    typename op::ptr p = { asio::detail::addressof(handler),
-      asio_handler_alloc_helpers::allocate(
-        sizeof(op), handler), 0 };
-    p.p = new (p.v) op(impl.cancel_token_, handler);
-
-    ASIO_HANDLER_CREATION((p.p, "socket",
-          &impl, "async_send(null_buffers)"));
-
-    start_reactor_op(impl, reactor::write_op, p.p);
-    p.v = p.p = 0;
-  }
-
-  // Receive some data from the peer. Returns the number of bytes received.
-  template <typename MutableBufferSequence>
-  size_t receive(base_implementation_type& impl,
-      const MutableBufferSequence& buffers,
-      socket_base::message_flags flags, asio::error_code& ec)
-  {
-    buffer_sequence_adapter<asio::mutable_buffer,
-        MutableBufferSequence> bufs(buffers);
-
-    return socket_ops::sync_recv(impl.socket_, impl.state_,
-        bufs.buffers(), bufs.count(), flags, bufs.all_empty(), ec);
-  }
-
-  // Wait until data can be received without blocking.
-  size_t receive(base_implementation_type& impl, const null_buffers&,
-      socket_base::message_flags, asio::error_code& ec)
-  {
-    // Wait for socket to become ready.
-    socket_ops::poll_read(impl.socket_, impl.state_, ec);
-
-    return 0;
-  }
-
-  // Start an asynchronous receive. The buffer for the data being received
-  // must be valid for the lifetime of the asynchronous operation.
-  template <typename MutableBufferSequence, typename Handler>
-  void async_receive(base_implementation_type& impl,
-      const MutableBufferSequence& buffers,
-      socket_base::message_flags flags, Handler& handler)
-  {
-    // Allocate and construct an operation to wrap the handler.
-    typedef win_iocp_socket_recv_op<MutableBufferSequence, Handler> op;
-    typename op::ptr p = { asio::detail::addressof(handler),
-      asio_handler_alloc_helpers::allocate(
-        sizeof(op), handler), 0 };
-    p.p = new (p.v) op(impl.state_, impl.cancel_token_, buffers, handler);
-
-    ASIO_HANDLER_CREATION((p.p, "socket", &impl, "async_receive"));
-
-    buffer_sequence_adapter<asio::mutable_buffer,
-        MutableBufferSequence> bufs(buffers);
-
-    start_receive_op(impl, bufs.buffers(), bufs.count(), flags,
-        (impl.state_ & socket_ops::stream_oriented) != 0 && bufs.all_empty(),
-        p.p);
-    p.v = p.p = 0;
-  }
-
-  // Wait until data can be received without blocking.
-  template <typename Handler>
-  void async_receive(base_implementation_type& impl, const null_buffers&,
-      socket_base::message_flags flags, Handler& handler)
-  {
-    // Allocate and construct an operation to wrap the handler.
-    typedef win_iocp_null_buffers_op<Handler> op;
-    typename op::ptr p = { asio::detail::addressof(handler),
-      asio_handler_alloc_helpers::allocate(
-        sizeof(op), handler), 0 };
-    p.p = new (p.v) op(impl.cancel_token_, handler);
-
-    ASIO_HANDLER_CREATION((p.p, "socket",
-          &impl, "async_receive(null_buffers)"));
-
-    start_null_buffers_receive_op(impl, flags, p.p);
-    p.v = p.p = 0;
-  }
-
-  // Receive some data with associated flags. Returns the number of bytes
-  // received.
-  template <typename MutableBufferSequence>
-  size_t receive_with_flags(base_implementation_type& impl,
-      const MutableBufferSequence& buffers,
-      socket_base::message_flags in_flags,
-      socket_base::message_flags& out_flags, asio::error_code& ec)
-  {
-    buffer_sequence_adapter<asio::mutable_buffer,
-        MutableBufferSequence> bufs(buffers);
-
-    return socket_ops::sync_recvmsg(impl.socket_, impl.state_,
-        bufs.buffers(), bufs.count(), in_flags, out_flags, ec);
-  }
-
-  // Wait until data can be received without blocking.
-  size_t receive_with_flags(base_implementation_type& impl,
-      const null_buffers&, socket_base::message_flags,
-      socket_base::message_flags& out_flags, asio::error_code& ec)
-  {
-    // Wait for socket to become ready.
-    socket_ops::poll_read(impl.socket_, impl.state_, ec);
-
-    // Clear out_flags, since we cannot give it any other sensible value when
-    // performing a null_buffers operation.
-    out_flags = 0;
-
-    return 0;
-  }
-
-  // Start an asynchronous receive. The buffer for the data being received
-  // must be valid for the lifetime of the asynchronous operation.
-  template <typename MutableBufferSequence, typename Handler>
-  void async_receive_with_flags(base_implementation_type& impl,
-      const MutableBufferSequence& buffers, socket_base::message_flags in_flags,
-      socket_base::message_flags& out_flags, Handler& handler)
-  {
-    // Allocate and construct an operation to wrap the handler.
-    typedef win_iocp_socket_recvmsg_op<MutableBufferSequence, Handler> op;
-    typename op::ptr p = { asio::detail::addressof(handler),
-      asio_handler_alloc_helpers::allocate(
-        sizeof(op), handler), 0 };
-    p.p = new (p.v) op(impl.cancel_token_, buffers, out_flags, handler);
-
-    ASIO_HANDLER_CREATION((p.p, "socket",
-          &impl, "async_receive_with_flags"));
-
-    buffer_sequence_adapter<asio::mutable_buffer,
-        MutableBufferSequence> bufs(buffers);
-
-    start_receive_op(impl, bufs.buffers(), bufs.count(), in_flags, false, p.p);
-    p.v = p.p = 0;
-  }
-
-  // Wait until data can be received without blocking.
-  template <typename Handler>
-  void async_receive_with_flags(base_implementation_type& impl,
-      const null_buffers&, socket_base::message_flags in_flags,
-      socket_base::message_flags& out_flags, Handler& handler)
-  {
-    // Allocate and construct an operation to wrap the handler.
-    typedef win_iocp_null_buffers_op<Handler> op;
-    typename op::ptr p = { asio::detail::addressof(handler),
-      asio_handler_alloc_helpers::allocate(
-        sizeof(op), handler), 0 };
-    p.p = new (p.v) op(impl.cancel_token_, handler);
-
-    ASIO_HANDLER_CREATION((p.p, "socket", &impl,
-          "async_receive_with_flags(null_buffers)"));
-
-    // Reset out_flags since it can be given no sensible value at this time.
-    out_flags = 0;
-
-    start_null_buffers_receive_op(impl, in_flags, p.p);
-    p.v = p.p = 0;
-  }
-
-  // Helper function to restart an asynchronous accept operation.
-  ASIO_DECL void restart_accept_op(socket_type s,
-      socket_holder& new_socket, int family, int type, int protocol,
-      void* output_buffer, DWORD address_length, operation* op);
-
-protected:
-  // Open a new socket implementation.
-  ASIO_DECL asio::error_code do_open(
-      base_implementation_type& impl, int family, int type,
-      int protocol, asio::error_code& ec);
-
-  // Assign a native socket to a socket implementation.
-  ASIO_DECL asio::error_code do_assign(
-      base_implementation_type& impl, int type,
-      socket_type native_socket, asio::error_code& ec);
-
-  // Helper function to start an asynchronous send operation.
-  ASIO_DECL void start_send_op(base_implementation_type& impl,
-      WSABUF* buffers, std::size_t buffer_count,
-      socket_base::message_flags flags, bool noop, operation* op);
-
-  // Helper function to start an asynchronous send_to operation.
-  ASIO_DECL void start_send_to_op(base_implementation_type& impl,
-      WSABUF* buffers, std::size_t buffer_count,
-      const socket_addr_type* addr, int addrlen,
-      socket_base::message_flags flags, operation* op);
-
-  // Helper function to start an asynchronous receive operation.
-  ASIO_DECL void start_receive_op(base_implementation_type& impl,
-      WSABUF* buffers, std::size_t buffer_count,
-      socket_base::message_flags flags, bool noop, operation* op);
-
-  // Helper function to start an asynchronous null_buffers receive operation.
-  ASIO_DECL void start_null_buffers_receive_op(
-      base_implementation_type& impl,
-      socket_base::message_flags flags, reactor_op* op);
-
-  // Helper function to start an asynchronous receive_from operation.
-  ASIO_DECL void start_receive_from_op(base_implementation_type& impl,
-      WSABUF* buffers, std::size_t buffer_count, socket_addr_type* addr,
-      socket_base::message_flags flags, int* addrlen, operation* op);
-
-  // Helper function to start an asynchronous accept operation.
-  ASIO_DECL void start_accept_op(base_implementation_type& impl,
-      bool peer_is_open, socket_holder& new_socket, int family, int type,
-      int protocol, void* output_buffer, DWORD address_length, operation* op);
-
-  // Start an asynchronous read or write operation using the reactor.
-  ASIO_DECL void start_reactor_op(base_implementation_type& impl,
-      int op_type, reactor_op* op);
-
-  // Start the asynchronous connect operation using the reactor.
-  ASIO_DECL void start_connect_op(base_implementation_type& impl,
-      int family, int type, const socket_addr_type* remote_addr,
-      std::size_t remote_addrlen, win_iocp_socket_connect_op_base* op);
-
-  // Helper function to close a socket when the associated object is being
-  // destroyed.
-  ASIO_DECL void close_for_destruction(base_implementation_type& impl);
-
-  // Update the ID of the thread from which cancellation is safe.
-  ASIO_DECL void update_cancellation_thread_id(
-      base_implementation_type& impl);
-
-  // Helper function to get the reactor. If no reactor has been created yet, a
-  // new one is obtained from the io_service and a pointer to it is cached in
-  // this service.
-  ASIO_DECL reactor& get_reactor();
-
-  // The type of a ConnectEx function pointer, as old SDKs may not provide it.
-  typedef BOOL (PASCAL *connect_ex_fn)(SOCKET,
-      const socket_addr_type*, int, void*, DWORD, DWORD*, OVERLAPPED*);
-
-  // Helper function to get the ConnectEx pointer. If no ConnectEx pointer has
-  // been obtained yet, one is obtained using WSAIoctl and the pointer is
-  // cached. Returns a null pointer if ConnectEx is not available.
-  ASIO_DECL connect_ex_fn get_connect_ex(
-      base_implementation_type& impl, int type);
-
-  // Helper function to emulate InterlockedCompareExchangePointer functionality
-  // for:
-  // - very old Platform SDKs; and
-  // - platform SDKs where MSVC's /Wp64 option causes spurious warnings.
-  ASIO_DECL void* interlocked_compare_exchange_pointer(
-      void** dest, void* exch, void* cmp);
-
-  // Helper function to emulate InterlockedExchangePointer functionality for:
-  // - very old Platform SDKs; and
-  // - platform SDKs where MSVC's /Wp64 option causes spurious warnings.
-  ASIO_DECL void* interlocked_exchange_pointer(void** dest, void* val);
-
-  // The io_service used to obtain the reactor, if required.
-  asio::io_service& io_service_;
-
-  // The IOCP service used for running asynchronous operations and dispatching
-  // handlers.
-  win_iocp_io_service& iocp_service_;
-
-  // The reactor used for performing connect operations. This object is created
-  // only if needed.
-  reactor* reactor_;
-
-  // Pointer to ConnectEx implementation.
-  void* connect_ex_;
-
-  // Mutex to protect access to the linked list of implementations. 
-  asio::detail::mutex mutex_;
-
-  // The head of a linked list of all implementations.
-  base_implementation_type* impl_list_;
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#if defined(ASIO_HEADER_ONLY)
-# include "asio/detail/impl/win_iocp_socket_service_base.ipp"
-#endif // defined(ASIO_HEADER_ONLY)
-
-#endif // defined(ASIO_HAS_IOCP)
-
-#endif // ASIO_DETAIL_WIN_IOCP_SOCKET_SERVICE_BASE_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/win_iocp_thread_info.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/win_iocp_thread_info.hpp
deleted file mode 100644
index 55a3c8ef3181..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/win_iocp_thread_info.hpp
+++ /dev/null
@@ -1,34 +0,0 @@
-//
-// detail/win_iocp_thread_info.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_WIN_IOCP_THREAD_INFO_HPP
-#define ASIO_DETAIL_WIN_IOCP_THREAD_INFO_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/thread_info_base.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-struct win_iocp_thread_info : public thread_info_base
-{
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_DETAIL_WIN_IOCP_THREAD_INFO_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/win_mutex.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/win_mutex.hpp
deleted file mode 100644
index 0ced34becc34..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/win_mutex.hpp
+++ /dev/null
@@ -1,78 +0,0 @@
-//
-// detail/win_mutex.hpp
-// ~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_WIN_MUTEX_HPP
-#define ASIO_DETAIL_WIN_MUTEX_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_WINDOWS)
-
-#include "asio/detail/noncopyable.hpp"
-#include "asio/detail/scoped_lock.hpp"
-#include "asio/detail/socket_types.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-class win_mutex
-  : private noncopyable
-{
-public:
-  typedef asio::detail::scoped_lock<win_mutex> scoped_lock;
-
-  // Constructor.
-  ASIO_DECL win_mutex();
-
-  // Destructor.
-  ~win_mutex()
-  {
-    ::DeleteCriticalSection(&crit_section_);
-  }
-
-  // Lock the mutex.
-  void lock()
-  {
-    ::EnterCriticalSection(&crit_section_);
-  }
-
-  // Unlock the mutex.
-  void unlock()
-  {
-    ::LeaveCriticalSection(&crit_section_);
-  }
-
-private:
-  // Initialisation must be performed in a separate function to the constructor
-  // since the compiler does not support the use of structured exceptions and
-  // C++ exceptions in the same function.
-  ASIO_DECL int do_init();
-
-  ::CRITICAL_SECTION crit_section_;
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#if defined(ASIO_HEADER_ONLY)
-# include "asio/detail/impl/win_mutex.ipp"
-#endif // defined(ASIO_HEADER_ONLY)
-
-#endif // defined(ASIO_WINDOWS)
-
-#endif // ASIO_DETAIL_WIN_MUTEX_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/win_object_handle_service.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/win_object_handle_service.hpp
deleted file mode 100644
index b937f8c6dcf3..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/win_object_handle_service.hpp
+++ /dev/null
@@ -1,183 +0,0 @@
-//
-// detail/win_object_handle_service.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-// Copyright (c) 2011 Boris Schaeling (boris@highscore.de)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_WIN_OBJECT_HANDLE_SERVICE_HPP
-#define ASIO_DETAIL_WIN_OBJECT_HANDLE_SERVICE_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_HAS_WINDOWS_OBJECT_HANDLE)
-
-#include "asio/detail/addressof.hpp"
-#include "asio/detail/handler_alloc_helpers.hpp"
-#include "asio/detail/wait_handler.hpp"
-#include "asio/error.hpp"
-#include "asio/io_service.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-class win_object_handle_service
-{
-public:
-  // The native type of an object handle.
-  typedef HANDLE native_handle_type;
-
-  // The implementation type of the object handle.
-  class implementation_type
-  {
-   public:
-    // Default constructor.
-    implementation_type()
-      : handle_(INVALID_HANDLE_VALUE),
-        wait_handle_(INVALID_HANDLE_VALUE),
-        owner_(0),
-        next_(0),
-        prev_(0)
-    {
-    }
-
-  private:
-    // Only this service will have access to the internal values.
-    friend class win_object_handle_service;
-
-    // The native object handle representation. May be accessed or modified
-    // without locking the mutex.
-    native_handle_type handle_;
-
-    // The handle used to unregister the wait operation. The mutex must be
-    // locked when accessing or modifying this member.
-    HANDLE wait_handle_;
-
-    // The operations waiting on the object handle. If there is a registered
-    // wait then the mutex must be locked when accessing or modifying this
-    // member
-    op_queue<wait_op> op_queue_;
-
-    // The service instance that owns the object handle implementation.
-    win_object_handle_service* owner_;
-
-    // Pointers to adjacent handle implementations in linked list. The mutex
-    // must be locked when accessing or modifying these members.
-    implementation_type* next_;
-    implementation_type* prev_;
-  };
-
-  // Constructor.
-  ASIO_DECL win_object_handle_service(
-      asio::io_service& io_service);
-
-  // Destroy all user-defined handler objects owned by the service.
-  ASIO_DECL void shutdown_service();
-
-  // Construct a new handle implementation.
-  ASIO_DECL void construct(implementation_type& impl);
-
-  // Move-construct a new handle implementation.
-  ASIO_DECL void move_construct(implementation_type& impl,
-      implementation_type& other_impl);
-
-  // Move-assign from another handle implementation.
-  ASIO_DECL void move_assign(implementation_type& impl,
-      win_object_handle_service& other_service,
-      implementation_type& other_impl);
-
-  // Destroy a handle implementation.
-  ASIO_DECL void destroy(implementation_type& impl);
-
-  // Assign a native handle to a handle implementation.
-  ASIO_DECL asio::error_code assign(implementation_type& impl,
-      const native_handle_type& handle, asio::error_code& ec);
-
-  // Determine whether the handle is open.
-  bool is_open(const implementation_type& impl) const
-  {
-    return impl.handle_ != INVALID_HANDLE_VALUE && impl.handle_ != 0;
-  }
-
-  // Destroy a handle implementation.
-  ASIO_DECL asio::error_code close(implementation_type& impl,
-      asio::error_code& ec);
-
-  // Get the native handle representation.
-  native_handle_type native_handle(const implementation_type& impl) const
-  {
-    return impl.handle_;
-  }
-
-  // Cancel all operations associated with the handle.
-  ASIO_DECL asio::error_code cancel(implementation_type& impl,
-      asio::error_code& ec);
-
-  // Perform a synchronous wait for the object to enter a signalled state.
-  ASIO_DECL void wait(implementation_type& impl,
-      asio::error_code& ec);
-
-  /// Start an asynchronous wait.
-  template <typename Handler>
-  void async_wait(implementation_type& impl, Handler& handler)
-  {
-    // Allocate and construct an operation to wrap the handler.
-    typedef wait_handler<Handler> op;
-    typename op::ptr p = { asio::detail::addressof(handler),
-      asio_handler_alloc_helpers::allocate(
-        sizeof(op), handler), 0 };
-    p.p = new (p.v) op(handler);
-
-    ASIO_HANDLER_CREATION((p.p, "object_handle", &impl, "async_wait"));
-
-    start_wait_op(impl, p.p);
-    p.v = p.p = 0;
-  }
-
-private:
-  // Helper function to start an asynchronous wait operation.
-  ASIO_DECL void start_wait_op(implementation_type& impl, wait_op* op);
-
-  // Helper function to register a wait operation.
-  ASIO_DECL void register_wait_callback(
-      implementation_type& impl, mutex::scoped_lock& lock);
-
-  // Callback function invoked when the registered wait completes.
-  static ASIO_DECL VOID CALLBACK wait_callback(
-      PVOID param, BOOLEAN timeout);
-
-  // The io_service implementation used to post completions.
-  io_service_impl& io_service_;
-
-  // Mutex to protect access to internal state.
-  mutex mutex_;
-
-  // The head of a linked list of all implementations.
-  implementation_type* impl_list_;
-
-  // Flag to indicate that the dispatcher has been shut down.
-  bool shutdown_;
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#if defined(ASIO_HEADER_ONLY)
-# include "asio/detail/impl/win_object_handle_service.ipp"
-#endif // defined(ASIO_HEADER_ONLY)
-
-#endif // defined(ASIO_HAS_WINDOWS_OBJECT_HANDLE)
-
-#endif // ASIO_DETAIL_WIN_OBJECT_HANDLE_SERVICE_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/win_static_mutex.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/win_static_mutex.hpp
deleted file mode 100644
index 7d0251ab8d25..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/win_static_mutex.hpp
+++ /dev/null
@@ -1,74 +0,0 @@
-//
-// detail/win_static_mutex.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_WIN_STATIC_MUTEX_HPP
-#define ASIO_DETAIL_WIN_STATIC_MUTEX_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_WINDOWS)
-
-#include "asio/detail/scoped_lock.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-struct win_static_mutex
-{
-  typedef asio::detail::scoped_lock<win_static_mutex> scoped_lock;
-
-  // Initialise the mutex.
-  ASIO_DECL void init();
-
-  // Initialisation must be performed in a separate function to the "public"
-  // init() function since the compiler does not support the use of structured
-  // exceptions and C++ exceptions in the same function.
-  ASIO_DECL int do_init();
-
-  // Lock the mutex.
-  void lock()
-  {
-    ::EnterCriticalSection(&crit_section_);
-  }
-
-  // Unlock the mutex.
-  void unlock()
-  {
-    ::LeaveCriticalSection(&crit_section_);
-  }
-
-  bool initialised_;
-  ::CRITICAL_SECTION crit_section_;
-};
-
-#if defined(UNDER_CE)
-# define ASIO_WIN_STATIC_MUTEX_INIT { false, { 0, 0, 0, 0, 0 } }
-#else // defined(UNDER_CE)
-# define ASIO_WIN_STATIC_MUTEX_INIT { false, { 0, 0, 0, 0, 0, 0 } }
-#endif // defined(UNDER_CE)
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#if defined(ASIO_HEADER_ONLY)
-# include "asio/detail/impl/win_static_mutex.ipp"
-#endif // defined(ASIO_HEADER_ONLY)
-
-#endif // defined(ASIO_WINDOWS)
-
-#endif // ASIO_DETAIL_WIN_STATIC_MUTEX_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/win_thread.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/win_thread.hpp
deleted file mode 100644
index 0f8abc4c05a9..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/win_thread.hpp
+++ /dev/null
@@ -1,139 +0,0 @@
-//
-// detail/win_thread.hpp
-// ~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_WIN_THREAD_HPP
-#define ASIO_DETAIL_WIN_THREAD_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_WINDOWS) && !defined(UNDER_CE)
-
-#include "asio/detail/noncopyable.hpp"
-#include "asio/detail/socket_types.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-ASIO_DECL unsigned int __stdcall win_thread_function(void* arg);
-
-#if defined(WINVER) && (WINVER < 0x0500)
-ASIO_DECL void __stdcall apc_function(ULONG data);
-#else
-ASIO_DECL void __stdcall apc_function(ULONG_PTR data);
-#endif
-
-template <typename T>
-class win_thread_base
-{
-public:
-  static bool terminate_threads()
-  {
-    return ::InterlockedExchangeAdd(&terminate_threads_, 0) != 0;
-  }
-
-  static void set_terminate_threads(bool b)
-  {
-    ::InterlockedExchange(&terminate_threads_, b ? 1 : 0);
-  }
-
-private:
-  static long terminate_threads_;
-};
-
-template <typename T>
-long win_thread_base<T>::terminate_threads_ = 0;
-
-class win_thread
-  : private noncopyable,
-    public win_thread_base<win_thread>
-{
-public:
-  // Constructor.
-  template <typename Function>
-  win_thread(Function f, unsigned int stack_size = 0)
-    : thread_(0),
-      exit_event_(0)
-  {
-    start_thread(new func<Function>(f), stack_size);
-  }
-
-  // Destructor.
-  ASIO_DECL ~win_thread();
-
-  // Wait for the thread to exit.
-  ASIO_DECL void join();
-
-private:
-  friend ASIO_DECL unsigned int __stdcall win_thread_function(void* arg);
-
-#if defined(WINVER) && (WINVER < 0x0500)
-  friend ASIO_DECL void __stdcall apc_function(ULONG);
-#else
-  friend ASIO_DECL void __stdcall apc_function(ULONG_PTR);
-#endif
-
-  class func_base
-  {
-  public:
-    virtual ~func_base() {}
-    virtual void run() = 0;
-    ::HANDLE entry_event_;
-    ::HANDLE exit_event_;
-  };
-
-  struct auto_func_base_ptr
-  {
-    func_base* ptr;
-    ~auto_func_base_ptr() { delete ptr; }
-  };
-
-  template <typename Function>
-  class func
-    : public func_base
-  {
-  public:
-    func(Function f)
-      : f_(f)
-    {
-    }
-
-    virtual void run()
-    {
-      f_();
-    }
-
-  private:
-    Function f_;
-  };
-
-  ASIO_DECL void start_thread(func_base* arg, unsigned int stack_size);
-
-  ::HANDLE thread_;
-  ::HANDLE exit_event_;
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#if defined(ASIO_HEADER_ONLY)
-# include "asio/detail/impl/win_thread.ipp"
-#endif // defined(ASIO_HEADER_ONLY)
-
-#endif // defined(ASIO_WINDOWS) && !defined(UNDER_CE)
-
-#endif // ASIO_DETAIL_WIN_THREAD_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/win_tss_ptr.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/win_tss_ptr.hpp
deleted file mode 100644
index 48a949881866..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/win_tss_ptr.hpp
+++ /dev/null
@@ -1,79 +0,0 @@
-//
-// detail/win_tss_ptr.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_WIN_TSS_PTR_HPP
-#define ASIO_DETAIL_WIN_TSS_PTR_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_WINDOWS)
-
-#include "asio/detail/noncopyable.hpp"
-#include "asio/detail/socket_types.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-// Helper function to create thread-specific storage.
-ASIO_DECL DWORD win_tss_ptr_create();
-
-template <typename T>
-class win_tss_ptr
-  : private noncopyable
-{
-public:
-  // Constructor.
-  win_tss_ptr()
-    : tss_key_(win_tss_ptr_create())
-  {
-  }
-
-  // Destructor.
-  ~win_tss_ptr()
-  {
-    ::TlsFree(tss_key_);
-  }
-
-  // Get the value.
-  operator T*() const
-  {
-    return static_cast<T*>(::TlsGetValue(tss_key_));
-  }
-
-  // Set the value.
-  void operator=(T* value)
-  {
-    ::TlsSetValue(tss_key_, value);
-  }
-
-private:
-  // Thread-specific storage to allow unlocked access to determine whether a
-  // thread is a member of the pool.
-  DWORD tss_key_;
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#if defined(ASIO_HEADER_ONLY)
-# include "asio/detail/impl/win_tss_ptr.ipp"
-#endif // defined(ASIO_HEADER_ONLY)
-
-#endif // defined(ASIO_WINDOWS)
-
-#endif // ASIO_DETAIL_WIN_TSS_PTR_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/wince_thread.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/wince_thread.hpp
deleted file mode 100644
index 5d3319950dc5..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/wince_thread.hpp
+++ /dev/null
@@ -1,116 +0,0 @@
-//
-// detail/wince_thread.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_WINCE_THREAD_HPP
-#define ASIO_DETAIL_WINCE_THREAD_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_WINDOWS) && defined(UNDER_CE)
-
-#include <memory>
-#include "asio/detail/noncopyable.hpp"
-#include "asio/detail/socket_types.hpp"
-#include "asio/detail/throw_error.hpp"
-#include "asio/error.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-DWORD WINAPI wince_thread_function(LPVOID arg);
-
-class wince_thread
-  : private noncopyable
-{
-public:
-  // Constructor.
-  template <typename Function>
-  wince_thread(Function f, unsigned int = 0)
-  {
-    std::auto_ptr<func_base> arg(new func<Function>(f));
-    DWORD thread_id = 0;
-    thread_ = ::CreateThread(0, 0, wince_thread_function,
-        arg.get(), 0, &thread_id);
-    if (!thread_)
-    {
-      DWORD last_error = ::GetLastError();
-      asio::error_code ec(last_error,
-          asio::error::get_system_category());
-      asio::detail::throw_error(ec, "thread");
-    }
-    arg.release();
-  }
-
-  // Destructor.
-  ~wince_thread()
-  {
-    ::CloseHandle(thread_);
-  }
-
-  // Wait for the thread to exit.
-  void join()
-  {
-    ::WaitForSingleObject(thread_, INFINITE);
-  }
-
-private:
-  friend DWORD WINAPI wince_thread_function(LPVOID arg);
-
-  class func_base
-  {
-  public:
-    virtual ~func_base() {}
-    virtual void run() = 0;
-  };
-
-  template <typename Function>
-  class func
-    : public func_base
-  {
-  public:
-    func(Function f)
-      : f_(f)
-    {
-    }
-
-    virtual void run()
-    {
-      f_();
-    }
-
-  private:
-    Function f_;
-  };
-
-  ::HANDLE thread_;
-};
-
-inline DWORD WINAPI wince_thread_function(LPVOID arg)
-{
-  std::auto_ptr<wince_thread::func_base> func(
-      static_cast<wince_thread::func_base*>(arg));
-  func->run();
-  return 0;
-}
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // defined(ASIO_WINDOWS) && defined(UNDER_CE)
-
-#endif // ASIO_DETAIL_WINCE_THREAD_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/winrt_async_manager.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/winrt_async_manager.hpp
deleted file mode 100644
index b02c69670d21..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/winrt_async_manager.hpp
+++ /dev/null
@@ -1,294 +0,0 @@
-//
-// detail/winrt_async_manager.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_WINRT_ASYNC_MANAGER_HPP
-#define ASIO_DETAIL_WINRT_ASYNC_MANAGER_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_WINDOWS_RUNTIME)
-
-#include <future>
-#include "asio/detail/atomic_count.hpp"
-#include "asio/detail/winrt_async_op.hpp"
-#include "asio/error.hpp"
-#include "asio/io_service.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-class winrt_async_manager
-  : public asio::detail::service_base<winrt_async_manager>
-{
-public:
-  // Constructor.
-  winrt_async_manager(asio::io_service& io_service)
-    : asio::detail::service_base<winrt_async_manager>(io_service),
-      io_service_(use_service<io_service_impl>(io_service)),
-      outstanding_ops_(1)
-  {
-  }
-
-  // Destructor.
-  ~winrt_async_manager()
-  {
-  }
-
-  // Destroy all user-defined handler objects owned by the service.
-  void shutdown_service()
-  {
-    if (--outstanding_ops_ > 0)
-    {
-      // Block until last operation is complete.
-      std::future<void> f = promise_.get_future();
-      f.wait();
-    }
-  }
-
-  void sync(Windows::Foundation::IAsyncAction^ action,
-      asio::error_code& ec)
-  {
-    using namespace Windows::Foundation;
-    using Windows::Foundation::AsyncStatus;
-
-    auto promise = std::make_shared<std::promise<asio::error_code>>();
-    auto future = promise->get_future();
-
-    action->Completed = ref new AsyncActionCompletedHandler(
-      [promise](IAsyncAction^ action, AsyncStatus status)
-      {
-        switch (status)
-        {
-        case AsyncStatus::Canceled:
-          promise->set_value(asio::error::operation_aborted);
-          break;
-        case AsyncStatus::Error:
-        case AsyncStatus::Completed:
-        default:
-          asio::error_code ec(
-              action->ErrorCode.Value,
-              asio::system_category());
-          promise->set_value(ec);
-          break;
-        }
-      });
-
-    ec = future.get();
-  }
-
-  template <typename TResult>
-  TResult sync(Windows::Foundation::IAsyncOperation<TResult>^ operation,
-      asio::error_code& ec)
-  {
-    using namespace Windows::Foundation;
-    using Windows::Foundation::AsyncStatus;
-
-    auto promise = std::make_shared<std::promise<asio::error_code>>();
-    auto future = promise->get_future();
-
-    operation->Completed = ref new AsyncOperationCompletedHandler<TResult>(
-      [promise](IAsyncOperation<TResult>^ operation, AsyncStatus status)
-      {
-        switch (status)
-        {
-        case AsyncStatus::Canceled:
-          promise->set_value(asio::error::operation_aborted);
-          break;
-        case AsyncStatus::Error:
-        case AsyncStatus::Completed:
-        default:
-          asio::error_code ec(
-              operation->ErrorCode.Value,
-              asio::system_category());
-          promise->set_value(ec);
-          break;
-        }
-      });
-
-    ec = future.get();
-    return operation->GetResults();
-  }
-
-  template <typename TResult, typename TProgress>
-  TResult sync(
-      Windows::Foundation::IAsyncOperationWithProgress<
-        TResult, TProgress>^ operation,
-      asio::error_code& ec)
-  {
-    using namespace Windows::Foundation;
-    using Windows::Foundation::AsyncStatus;
-
-    auto promise = std::make_shared<std::promise<asio::error_code>>();
-    auto future = promise->get_future();
-
-    operation->Completed
-      = ref new AsyncOperationWithProgressCompletedHandler<TResult, TProgress>(
-        [promise](IAsyncOperationWithProgress<TResult, TProgress>^ operation,
-          AsyncStatus status)
-        {
-          switch (status)
-          {
-          case AsyncStatus::Canceled:
-            promise->set_value(asio::error::operation_aborted);
-            break;
-          case AsyncStatus::Started:
-            break;
-          case AsyncStatus::Error:
-          case AsyncStatus::Completed:
-          default:
-            asio::error_code ec(
-                operation->ErrorCode.Value,
-                asio::system_category());
-            promise->set_value(ec);
-            break;
-          }
-        });
-
-    ec = future.get();
-    return operation->GetResults();
-  }
-
-  void async(Windows::Foundation::IAsyncAction^ action,
-      winrt_async_op<void>* handler)
-  {
-    using namespace Windows::Foundation;
-    using Windows::Foundation::AsyncStatus;
-
-    auto on_completed = ref new AsyncActionCompletedHandler(
-      [this, handler](IAsyncAction^ action, AsyncStatus status)
-      {
-        switch (status)
-        {
-        case AsyncStatus::Canceled:
-          handler->ec_ = asio::error::operation_aborted;
-          break;
-        case AsyncStatus::Started:
-          return;
-        case AsyncStatus::Completed:
-        case AsyncStatus::Error:
-        default:
-          handler->ec_ = asio::error_code(
-              action->ErrorCode.Value,
-              asio::system_category());
-          break;
-        }
-        io_service_.post_deferred_completion(handler);
-        if (--outstanding_ops_ == 0)
-          promise_.set_value();
-      });
-
-    io_service_.work_started();
-    ++outstanding_ops_;
-    action->Completed = on_completed;
-  }
-
-  template <typename TResult>
-  void async(Windows::Foundation::IAsyncOperation<TResult>^ operation,
-      winrt_async_op<TResult>* handler)
-  {
-    using namespace Windows::Foundation;
-    using Windows::Foundation::AsyncStatus;
-
-    auto on_completed = ref new AsyncOperationCompletedHandler<TResult>(
-      [this, handler](IAsyncOperation<TResult>^ operation, AsyncStatus status)
-      {
-        switch (status)
-        {
-        case AsyncStatus::Canceled:
-          handler->ec_ = asio::error::operation_aborted;
-          break;
-        case AsyncStatus::Started:
-          return;
-        case AsyncStatus::Completed:
-          handler->result_ = operation->GetResults();
-          // Fall through.
-        case AsyncStatus::Error:
-        default:
-          handler->ec_ = asio::error_code(
-              operation->ErrorCode.Value,
-              asio::system_category());
-          break;
-        }
-        io_service_.post_deferred_completion(handler);
-        if (--outstanding_ops_ == 0)
-          promise_.set_value();
-      });
-
-    io_service_.work_started();
-    ++outstanding_ops_;
-    operation->Completed = on_completed;
-  }
-
-  template <typename TResult, typename TProgress>
-  void async(
-      Windows::Foundation::IAsyncOperationWithProgress<
-        TResult, TProgress>^ operation,
-      winrt_async_op<TResult>* handler)
-  {
-    using namespace Windows::Foundation;
-    using Windows::Foundation::AsyncStatus;
-
-    auto on_completed
-      = ref new AsyncOperationWithProgressCompletedHandler<TResult, TProgress>(
-        [this, handler](IAsyncOperationWithProgress<
-          TResult, TProgress>^ operation, AsyncStatus status)
-        {
-          switch (status)
-          {
-          case AsyncStatus::Canceled:
-            handler->ec_ = asio::error::operation_aborted;
-            break;
-          case AsyncStatus::Started:
-            return;
-          case AsyncStatus::Completed:
-            handler->result_ = operation->GetResults();
-            // Fall through.
-          case AsyncStatus::Error:
-          default:
-            handler->ec_ = asio::error_code(
-                operation->ErrorCode.Value,
-                asio::system_category());
-            break;
-          }
-          io_service_.post_deferred_completion(handler);
-          if (--outstanding_ops_ == 0)
-            promise_.set_value();
-        });
-
-    io_service_.work_started();
-    ++outstanding_ops_;
-    operation->Completed = on_completed;
-  }
-
-private:
-  // The io_service implementation used to post completed handlers.
-  io_service_impl& io_service_;
-
-  // Count of outstanding operations.
-  atomic_count outstanding_ops_;
-
-  // Used to keep wait for outstanding operations to complete.
-  std::promise<void> promise_;
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // defined(ASIO_WINDOWS_RUNTIME)
-
-#endif // ASIO_DETAIL_WINRT_ASYNC_MANAGER_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/winrt_async_op.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/winrt_async_op.hpp
deleted file mode 100644
index 7afe0cc2af58..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/winrt_async_op.hpp
+++ /dev/null
@@ -1,65 +0,0 @@
-//
-// detail/winrt_async_op.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_WINRT_ASYNC_OP_HPP
-#define ASIO_DETAIL_WINRT_ASYNC_OP_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include "asio/detail/operation.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-template <typename TResult>
-class winrt_async_op
-  : public operation
-{
-public:
-  // The error code to be passed to the completion handler.
-  asio::error_code ec_;
-
-  // The result of the operation, to be passed to the completion handler.
-  TResult result_;
-
-protected:
-  winrt_async_op(func_type complete_func)
-    : operation(complete_func),
-      result_()
-  {
-  }
-};
-
-template <>
-class winrt_async_op<void>
-  : public operation
-{
-public:
-  // The error code to be passed to the completion handler.
-  asio::error_code ec_;
-
-protected:
-  winrt_async_op(func_type complete_func)
-    : operation(complete_func)
-  {
-  }
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_DETAIL_WINRT_ASYNC_OP_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/winrt_resolve_op.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/winrt_resolve_op.hpp
deleted file mode 100644
index 736f90834921..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/winrt_resolve_op.hpp
+++ /dev/null
@@ -1,117 +0,0 @@
-//
-// detail/winrt_resolve_op.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_WINRT_RESOLVE_OP_HPP
-#define ASIO_DETAIL_WINRT_RESOLVE_OP_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_WINDOWS_RUNTIME)
-
-#include "asio/detail/addressof.hpp"
-#include "asio/detail/bind_handler.hpp"
-#include "asio/detail/fenced_block.hpp"
-#include "asio/detail/handler_alloc_helpers.hpp"
-#include "asio/detail/handler_invoke_helpers.hpp"
-#include "asio/detail/winrt_async_op.hpp"
-#include "asio/ip/basic_resolver_iterator.hpp"
-#include "asio/error.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-template <typename Protocol, typename Handler>
-class winrt_resolve_op :
-  public winrt_async_op<
-    Windows::Foundation::Collections::IVectorView<
-      Windows::Networking::EndpointPair^>^>
-{
-public:
-  ASIO_DEFINE_HANDLER_PTR(winrt_resolve_op);
-
-  typedef typename Protocol::endpoint endpoint_type;
-  typedef asio::ip::basic_resolver_query<Protocol> query_type;
-  typedef asio::ip::basic_resolver_iterator<Protocol> iterator_type;
-
-  winrt_resolve_op(const query_type& query, Handler& handler)
-    : winrt_async_op<
-        Windows::Foundation::Collections::IVectorView<
-          Windows::Networking::EndpointPair^>^>(
-            &winrt_resolve_op::do_complete),
-      query_(query),
-      handler_(ASIO_MOVE_CAST(Handler)(handler))
-  {
-  }
-
-  static void do_complete(io_service_impl* owner, operation* base,
-      const asio::error_code&, std::size_t)
-  {
-    // Take ownership of the operation object.
-    winrt_resolve_op* o(static_cast<winrt_resolve_op*>(base));
-    ptr p = { asio::detail::addressof(o->handler_), o, o };
-
-    ASIO_HANDLER_COMPLETION((o));
-
-    iterator_type iterator = iterator_type();
-    if (!o->ec_)
-    {
-      try
-      {
-        iterator = iterator_type::create(
-            o->result_, o->query_.hints(),
-            o->query_.host_name(), o->query_.service_name());
-      }
-      catch (Platform::Exception^ e)
-      {
-        o->ec_ = asio::error_code(e->HResult,
-            asio::system_category());
-      }
-    }
-
-    // Make a copy of the handler so that the memory can be deallocated before
-    // the upcall is made. Even if we're not about to make an upcall, a
-    // sub-object of the handler may be the true owner of the memory associated
-    // with the handler. Consequently, a local copy of the handler is required
-    // to ensure that any owning sub-object remains valid until after we have
-    // deallocated the memory here.
-    detail::binder2<Handler, asio::error_code, iterator_type>
-      handler(o->handler_, o->ec_, iterator);
-    p.h = asio::detail::addressof(handler.handler_);
-    p.reset();
-
-    // Make the upcall if required.
-    if (owner)
-    {
-      fenced_block b(fenced_block::half);
-      ASIO_HANDLER_INVOCATION_BEGIN((handler.arg1_, handler.arg2_));
-      asio_handler_invoke_helpers::invoke(handler, handler.handler_);
-      ASIO_HANDLER_INVOCATION_END;
-    }
-  }
-
-private:
-  query_type query_;
-  Handler handler_;
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // defined(ASIO_WINDOWS_RUNTIME)
-
-#endif // ASIO_DETAIL_WINRT_RESOLVE_OP_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/winrt_resolver_service.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/winrt_resolver_service.hpp
deleted file mode 100644
index a7dab1b13234..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/winrt_resolver_service.hpp
+++ /dev/null
@@ -1,183 +0,0 @@
-//
-// detail/winrt_resolver_service.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_WINRT_RESOLVER_SERVICE_HPP
-#define ASIO_DETAIL_WINRT_RESOLVER_SERVICE_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_WINDOWS_RUNTIME)
-
-#include "asio/ip/basic_resolver_iterator.hpp"
-#include "asio/ip/basic_resolver_query.hpp"
-#include "asio/detail/addressof.hpp"
-#include "asio/detail/bind_handler.hpp"
-#include "asio/detail/socket_ops.hpp"
-#include "asio/detail/winrt_async_manager.hpp"
-#include "asio/detail/winrt_resolve_op.hpp"
-#include "asio/detail/winrt_utils.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-template <typename Protocol>
-class winrt_resolver_service
-{
-public:
-  // The implementation type of the resolver. A cancellation token is used to
-  // indicate to the asynchronous operation that the operation has been
-  // cancelled.
-  typedef socket_ops::shared_cancel_token_type implementation_type;
-
-  // The endpoint type.
-  typedef typename Protocol::endpoint endpoint_type;
-
-  // The query type.
-  typedef asio::ip::basic_resolver_query<Protocol> query_type;
-
-  // The iterator type.
-  typedef asio::ip::basic_resolver_iterator<Protocol> iterator_type;
-
-  // Constructor.
-  winrt_resolver_service(asio::io_service& io_service)
-    : io_service_(use_service<io_service_impl>(io_service)),
-      async_manager_(use_service<winrt_async_manager>(io_service))
-  {
-  }
-
-  // Destructor.
-  ~winrt_resolver_service()
-  {
-  }
-
-  // Destroy all user-defined handler objects owned by the service.
-  void shutdown_service()
-  {
-  }
-
-  // Perform any fork-related housekeeping.
-  void fork_service(asio::io_service::fork_event)
-  {
-  }
-
-  // Construct a new resolver implementation.
-  void construct(implementation_type&)
-  {
-  }
-
-  // Destroy a resolver implementation.
-  void destroy(implementation_type&)
-  {
-  }
-
-  // Cancel pending asynchronous operations.
-  void cancel(implementation_type&)
-  {
-  }
-
-  // Resolve a query to a list of entries.
-  iterator_type resolve(implementation_type&,
-      const query_type& query, asio::error_code& ec)
-  {
-    try
-    {
-      using namespace Windows::Networking::Sockets;
-      auto endpoint_pairs = async_manager_.sync(
-          DatagramSocket::GetEndpointPairsAsync(
-            winrt_utils::host_name(query.host_name()),
-            winrt_utils::string(query.service_name())), ec);
-
-      if (ec)
-        return iterator_type();
-
-      return iterator_type::create(
-          endpoint_pairs, query.hints(),
-          query.host_name(), query.service_name());
-    }
-    catch (Platform::Exception^ e)
-    {
-      ec = asio::error_code(e->HResult,
-          asio::system_category());
-      return iterator_type();
-    }
-  }
-
-  // Asynchronously resolve a query to a list of entries.
-  template <typename Handler>
-  void async_resolve(implementation_type&,
-      const query_type& query, Handler& handler)
-  {
-    bool is_continuation =
-      asio_handler_cont_helpers::is_continuation(handler);
-
-    // Allocate and construct an operation to wrap the handler.
-    typedef winrt_resolve_op<Protocol, Handler> op;
-    typename op::ptr p = { asio::detail::addressof(handler),
-      asio_handler_alloc_helpers::allocate(
-        sizeof(op), handler), 0 };
-    p.p = new (p.v) op(query, handler);
-
-    ASIO_HANDLER_CREATION((p.p, "resolver", &impl, "async_resolve"));
-
-    try
-    {
-      using namespace Windows::Networking::Sockets;
-      async_manager_.async(DatagramSocket::GetEndpointPairsAsync(
-            winrt_utils::host_name(query.host_name()),
-            winrt_utils::string(query.service_name())), p.p);
-      p.v = p.p = 0;
-    }
-    catch (Platform::Exception^ e)
-    {
-      p.p->ec_ = asio::error_code(
-          e->HResult, asio::system_category());
-      io_service_.post_immediate_completion(p.p, is_continuation);
-      p.v = p.p = 0;
-    }
-  }
-
-  // Resolve an endpoint to a list of entries.
-  iterator_type resolve(implementation_type&,
-      const endpoint_type&, asio::error_code& ec)
-  {
-    ec = asio::error::operation_not_supported;
-    return iterator_type();
-  }
-
-  // Asynchronously resolve an endpoint to a list of entries.
-  template <typename Handler>
-  void async_resolve(implementation_type&,
-      const endpoint_type&, Handler& handler)
-  {
-    asio::error_code ec = asio::error::operation_not_supported;
-    const iterator_type iterator;
-    io_service_.get_io_service().post(
-        detail::bind_handler(handler, ec, iterator));
-  }
-
-private:
-  io_service_impl& io_service_;
-  winrt_async_manager& async_manager_;
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // defined(ASIO_WINDOWS_RUNTIME)
-
-#endif // ASIO_DETAIL_WINRT_RESOLVER_SERVICE_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/winrt_socket_connect_op.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/winrt_socket_connect_op.hpp
deleted file mode 100644
index 76bc4a1e573d..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/winrt_socket_connect_op.hpp
+++ /dev/null
@@ -1,90 +0,0 @@
-//
-// detail/winrt_socket_connect_op.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_WINRT_SOCKET_CONNECT_OP_HPP
-#define ASIO_DETAIL_WINRT_SOCKET_CONNECT_OP_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_WINDOWS_RUNTIME)
-
-#include "asio/detail/addressof.hpp"
-#include "asio/detail/bind_handler.hpp"
-#include "asio/detail/buffer_sequence_adapter.hpp"
-#include "asio/detail/fenced_block.hpp"
-#include "asio/detail/handler_alloc_helpers.hpp"
-#include "asio/detail/handler_invoke_helpers.hpp"
-#include "asio/detail/winrt_async_op.hpp"
-#include "asio/error.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-template <typename Handler>
-class winrt_socket_connect_op :
-  public winrt_async_op<void>
-{
-public:
-  ASIO_DEFINE_HANDLER_PTR(winrt_socket_connect_op);
-
-  winrt_socket_connect_op(Handler& handler)
-    : winrt_async_op<void>(&winrt_socket_connect_op::do_complete),
-      handler_(ASIO_MOVE_CAST(Handler)(handler))
-  {
-  }
-
-  static void do_complete(io_service_impl* owner, operation* base,
-      const asio::error_code&, std::size_t)
-  {
-    // Take ownership of the operation object.
-    winrt_socket_connect_op* o(static_cast<winrt_socket_connect_op*>(base));
-    ptr p = { asio::detail::addressof(o->handler_), o, o };
-
-    ASIO_HANDLER_COMPLETION((o));
-
-    // Make a copy of the handler so that the memory can be deallocated before
-    // the upcall is made. Even if we're not about to make an upcall, a
-    // sub-object of the handler may be the true owner of the memory associated
-    // with the handler. Consequently, a local copy of the handler is required
-    // to ensure that any owning sub-object remains valid until after we have
-    // deallocated the memory here.
-    detail::binder1<Handler, asio::error_code>
-      handler(o->handler_, o->ec_);
-    p.h = asio::detail::addressof(handler.handler_);
-    p.reset();
-
-    // Make the upcall if required.
-    if (owner)
-    {
-      fenced_block b(fenced_block::half);
-      ASIO_HANDLER_INVOCATION_BEGIN((handler.arg1_, handler.arg2_));
-      asio_handler_invoke_helpers::invoke(handler, handler.handler_);
-      ASIO_HANDLER_INVOCATION_END;
-    }
-  }
-
-private:
-  Handler handler_;
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // defined(ASIO_WINDOWS_RUNTIME)
-
-#endif // ASIO_DETAIL_WINRT_SOCKET_CONNECT_OP_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/winrt_socket_recv_op.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/winrt_socket_recv_op.hpp
deleted file mode 100644
index b360e806920b..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/winrt_socket_recv_op.hpp
+++ /dev/null
@@ -1,110 +0,0 @@
-//
-// detail/winrt_socket_recv_op.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_WINRT_SOCKET_RECV_OP_HPP
-#define ASIO_DETAIL_WINRT_SOCKET_RECV_OP_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_WINDOWS_RUNTIME)
-
-#include "asio/detail/addressof.hpp"
-#include "asio/detail/bind_handler.hpp"
-#include "asio/detail/buffer_sequence_adapter.hpp"
-#include "asio/detail/fenced_block.hpp"
-#include "asio/detail/handler_alloc_helpers.hpp"
-#include "asio/detail/handler_invoke_helpers.hpp"
-#include "asio/detail/winrt_async_op.hpp"
-#include "asio/error.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-template <typename MutableBufferSequence, typename Handler>
-class winrt_socket_recv_op :
-  public winrt_async_op<Windows::Storage::Streams::IBuffer^>
-{
-public:
-  ASIO_DEFINE_HANDLER_PTR(winrt_socket_recv_op);
-
-  winrt_socket_recv_op(const MutableBufferSequence& buffers, Handler& handler)
-    : winrt_async_op<Windows::Storage::Streams::IBuffer^>(
-          &winrt_socket_recv_op::do_complete),
-      buffers_(buffers),
-      handler_(ASIO_MOVE_CAST(Handler)(handler))
-  {
-  }
-
-  static void do_complete(io_service_impl* owner, operation* base,
-      const asio::error_code&, std::size_t)
-  {
-    // Take ownership of the operation object.
-    winrt_socket_recv_op* o(static_cast<winrt_socket_recv_op*>(base));
-    ptr p = { asio::detail::addressof(o->handler_), o, o };
-
-    ASIO_HANDLER_COMPLETION((o));
-
-#if defined(ASIO_ENABLE_BUFFER_DEBUGGING)
-    // Check whether buffers are still valid.
-    if (owner)
-    {
-      buffer_sequence_adapter<asio::mutable_buffer,
-          MutableBufferSequence>::validate(o->buffers_);
-    }
-#endif // defined(ASIO_ENABLE_BUFFER_DEBUGGING)
-
-    std::size_t bytes_transferred = o->result_ ? o->result_->Length : 0;
-    if (bytes_transferred == 0 && !o->ec_ &&
-        !buffer_sequence_adapter<asio::mutable_buffer,
-          MutableBufferSequence>::all_empty(o->buffers_))
-    {
-      o->ec_ = asio::error::eof;
-    }
-
-    // Make a copy of the handler so that the memory can be deallocated before
-    // the upcall is made. Even if we're not about to make an upcall, a
-    // sub-object of the handler may be the true owner of the memory associated
-    // with the handler. Consequently, a local copy of the handler is required
-    // to ensure that any owning sub-object remains valid until after we have
-    // deallocated the memory here.
-    detail::binder2<Handler, asio::error_code, std::size_t>
-      handler(o->handler_, o->ec_, bytes_transferred);
-    p.h = asio::detail::addressof(handler.handler_);
-    p.reset();
-
-    // Make the upcall if required.
-    if (owner)
-    {
-      fenced_block b(fenced_block::half);
-      ASIO_HANDLER_INVOCATION_BEGIN((handler.arg1_, handler.arg2_));
-      asio_handler_invoke_helpers::invoke(handler, handler.handler_);
-      ASIO_HANDLER_INVOCATION_END;
-    }
-  }
-
-private:
-  MutableBufferSequence buffers_;
-  Handler handler_;
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // defined(ASIO_WINDOWS_RUNTIME)
-
-#endif // ASIO_DETAIL_WINRT_SOCKET_RECV_OP_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/winrt_socket_send_op.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/winrt_socket_send_op.hpp
deleted file mode 100644
index 87880306dc63..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/winrt_socket_send_op.hpp
+++ /dev/null
@@ -1,101 +0,0 @@
-//
-// detail/winrt_socket_send_op.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_WINRT_SOCKET_SEND_OP_HPP
-#define ASIO_DETAIL_WINRT_SOCKET_SEND_OP_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_WINDOWS_RUNTIME)
-
-#include "asio/detail/addressof.hpp"
-#include "asio/detail/bind_handler.hpp"
-#include "asio/detail/buffer_sequence_adapter.hpp"
-#include "asio/detail/fenced_block.hpp"
-#include "asio/detail/handler_alloc_helpers.hpp"
-#include "asio/detail/handler_invoke_helpers.hpp"
-#include "asio/detail/winrt_async_op.hpp"
-#include "asio/error.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-template <typename ConstBufferSequence, typename Handler>
-class winrt_socket_send_op :
-  public winrt_async_op<unsigned int>
-{
-public:
-  ASIO_DEFINE_HANDLER_PTR(winrt_socket_send_op);
-
-  winrt_socket_send_op(const ConstBufferSequence& buffers, Handler& handler)
-    : winrt_async_op<unsigned int>(&winrt_socket_send_op::do_complete),
-      buffers_(buffers),
-      handler_(ASIO_MOVE_CAST(Handler)(handler))
-  {
-  }
-
-  static void do_complete(io_service_impl* owner, operation* base,
-      const asio::error_code&, std::size_t)
-  {
-    // Take ownership of the operation object.
-    winrt_socket_send_op* o(static_cast<winrt_socket_send_op*>(base));
-    ptr p = { asio::detail::addressof(o->handler_), o, o };
-
-    ASIO_HANDLER_COMPLETION((o));
-
-#if defined(ASIO_ENABLE_BUFFER_DEBUGGING)
-    // Check whether buffers are still valid.
-    if (owner)
-    {
-      buffer_sequence_adapter<asio::const_buffer,
-          ConstBufferSequence>::validate(o->buffers_);
-    }
-#endif // defined(ASIO_ENABLE_BUFFER_DEBUGGING)
-
-    // Make a copy of the handler so that the memory can be deallocated before
-    // the upcall is made. Even if we're not about to make an upcall, a
-    // sub-object of the handler may be the true owner of the memory associated
-    // with the handler. Consequently, a local copy of the handler is required
-    // to ensure that any owning sub-object remains valid until after we have
-    // deallocated the memory here.
-    detail::binder2<Handler, asio::error_code, std::size_t>
-      handler(o->handler_, o->ec_, o->result_);
-    p.h = asio::detail::addressof(handler.handler_);
-    p.reset();
-
-    // Make the upcall if required.
-    if (owner)
-    {
-      fenced_block b(fenced_block::half);
-      ASIO_HANDLER_INVOCATION_BEGIN((handler.arg1_, handler.arg2_));
-      asio_handler_invoke_helpers::invoke(handler, handler.handler_);
-      ASIO_HANDLER_INVOCATION_END;
-    }
-  }
-
-private:
-  ConstBufferSequence buffers_;
-  Handler handler_;
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // defined(ASIO_WINDOWS_RUNTIME)
-
-#endif // ASIO_DETAIL_WINRT_SOCKET_SEND_OP_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/winrt_ssocket_service.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/winrt_ssocket_service.hpp
deleted file mode 100644
index c793114bd363..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/winrt_ssocket_service.hpp
+++ /dev/null
@@ -1,232 +0,0 @@
-//
-// detail/winrt_ssocket_service.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_WINRT_SSOCKET_SERVICE_HPP
-#define ASIO_DETAIL_WINRT_SSOCKET_SERVICE_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_WINDOWS_RUNTIME)
-
-#include "asio/error.hpp"
-#include "asio/io_service.hpp"
-#include "asio/detail/addressof.hpp"
-#include "asio/detail/winrt_socket_connect_op.hpp"
-#include "asio/detail/winrt_ssocket_service_base.hpp"
-#include "asio/detail/winrt_utils.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-template <typename Protocol>
-class winrt_ssocket_service :
-  public winrt_ssocket_service_base
-{
-public:
-  // The protocol type.
-  typedef Protocol protocol_type;
-
-  // The endpoint type.
-  typedef typename Protocol::endpoint endpoint_type;
-
-  // The native type of a socket.
-  typedef Windows::Networking::Sockets::StreamSocket^ native_handle_type;
-
-  // The implementation type of the socket.
-  struct implementation_type : base_implementation_type
-  {
-    // Default constructor.
-    implementation_type()
-      : base_implementation_type(),
-        protocol_(endpoint_type().protocol())
-    {
-    }
-
-    // The protocol associated with the socket.
-    protocol_type protocol_;
-  };
-
-  // Constructor.
-  winrt_ssocket_service(asio::io_service& io_service)
-    : winrt_ssocket_service_base(io_service)
-  {
-  }
-
-  // Move-construct a new socket implementation.
-  void move_construct(implementation_type& impl,
-      implementation_type& other_impl)
-  {
-    this->base_move_construct(impl, other_impl);
-
-    impl.protocol_ = other_impl.protocol_;
-    other_impl.protocol_ = endpoint_type().protocol();
-  }
-
-  // Move-assign from another socket implementation.
-  void move_assign(implementation_type& impl,
-      winrt_ssocket_service& other_service,
-      implementation_type& other_impl)
-  {
-    this->base_move_assign(impl, other_service, other_impl);
-
-    impl.protocol_ = other_impl.protocol_;
-    other_impl.protocol_ = endpoint_type().protocol();
-  }
-
-  // Move-construct a new socket implementation from another protocol type.
-  template <typename Protocol1>
-  void converting_move_construct(implementation_type& impl,
-      typename winrt_ssocket_service<
-        Protocol1>::implementation_type& other_impl)
-  {
-    this->base_move_construct(impl, other_impl);
-
-    impl.protocol_ = protocol_type(other_impl.protocol_);
-    other_impl.protocol_ = typename Protocol1::endpoint().protocol();
-  }
-
-  // Open a new socket implementation.
-  asio::error_code open(implementation_type& impl,
-      const protocol_type& protocol, asio::error_code& ec)
-  {
-    if (is_open(impl))
-    {
-      ec = asio::error::already_open;
-      return ec;
-    }
-
-    try
-    {
-      impl.socket_ = ref new Windows::Networking::Sockets::StreamSocket;
-      impl.protocol_ = protocol;
-      ec = asio::error_code();
-    }
-    catch (Platform::Exception^ e)
-    {
-      ec = asio::error_code(e->HResult,
-            asio::system_category());
-    }
-
-    return ec;
-  }
-
-  // Assign a native socket to a socket implementation.
-  asio::error_code assign(implementation_type& impl,
-      const protocol_type& protocol, const native_handle_type& native_socket,
-      asio::error_code& ec)
-  {
-    if (is_open(impl))
-    {
-      ec = asio::error::already_open;
-      return ec;
-    }
-
-    impl.socket_ = native_socket;
-    impl.protocol_ = protocol;
-    ec = asio::error_code();
-
-    return ec;
-  }
-
-  // Bind the socket to the specified local endpoint.
-  asio::error_code bind(implementation_type&,
-      const endpoint_type&, asio::error_code& ec)
-  {
-    ec = asio::error::operation_not_supported;
-    return ec;
-  }
-
-  // Get the local endpoint.
-  endpoint_type local_endpoint(const implementation_type& impl,
-      asio::error_code& ec) const
-  {
-    endpoint_type endpoint;
-    endpoint.resize(do_get_endpoint(impl, true,
-          endpoint.data(), endpoint.size(), ec));
-    return endpoint;
-  }
-
-  // Get the remote endpoint.
-  endpoint_type remote_endpoint(const implementation_type& impl,
-      asio::error_code& ec) const
-  {
-    endpoint_type endpoint;
-    endpoint.resize(do_get_endpoint(impl, false,
-          endpoint.data(), endpoint.size(), ec));
-    return endpoint;
-  }
-
-  // Set a socket option.
-  template <typename Option>
-  asio::error_code set_option(implementation_type& impl,
-      const Option& option, asio::error_code& ec)
-  {
-    return do_set_option(impl, option.level(impl.protocol_),
-        option.name(impl.protocol_), option.data(impl.protocol_),
-        option.size(impl.protocol_), ec);
-  }
-
-  // Get a socket option.
-  template <typename Option>
-  asio::error_code get_option(const implementation_type& impl,
-      Option& option, asio::error_code& ec) const
-  {
-    std::size_t size = option.size(impl.protocol_);
-    do_get_option(impl, option.level(impl.protocol_),
-        option.name(impl.protocol_),
-        option.data(impl.protocol_), &size, ec);
-    if (!ec)
-      option.resize(impl.protocol_, size);
-    return ec;
-  }
-
-  // Connect the socket to the specified endpoint.
-  asio::error_code connect(implementation_type& impl,
-      const endpoint_type& peer_endpoint, asio::error_code& ec)
-  {
-    return do_connect(impl, peer_endpoint.data(), ec);
-  }
-
-  // Start an asynchronous connect.
-  template <typename Handler>
-  void async_connect(implementation_type& impl,
-      const endpoint_type& peer_endpoint, Handler& handler)
-  {
-    bool is_continuation =
-      asio_handler_cont_helpers::is_continuation(handler);
-
-    // Allocate and construct an operation to wrap the handler.
-    typedef winrt_socket_connect_op<Handler> op;
-    typename op::ptr p = { asio::detail::addressof(handler),
-      asio_handler_alloc_helpers::allocate(
-        sizeof(op), handler), 0 };
-    p.p = new (p.v) op(handler);
-
-    ASIO_HANDLER_CREATION((p.p, "socket", &impl, "async_connect"));
-
-    start_connect_op(impl, peer_endpoint.data(), p.p, is_continuation);
-    p.v = p.p = 0;
-  }
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // defined(ASIO_WINDOWS_RUNTIME)
-
-#endif // ASIO_DETAIL_WINRT_SSOCKET_SERVICE_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/winrt_ssocket_service_base.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/winrt_ssocket_service_base.hpp
deleted file mode 100644
index 592f58b68665..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/winrt_ssocket_service_base.hpp
+++ /dev/null
@@ -1,355 +0,0 @@
-//
-// detail/winrt_ssocket_service_base.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_WINRT_SSOCKET_SERVICE_BASE_HPP
-#define ASIO_DETAIL_WINRT_SSOCKET_SERVICE_BASE_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_WINDOWS_RUNTIME)
-
-#include "asio/buffer.hpp"
-#include "asio/error.hpp"
-#include "asio/io_service.hpp"
-#include "asio/socket_base.hpp"
-#include "asio/detail/addressof.hpp"
-#include "asio/detail/buffer_sequence_adapter.hpp"
-#include "asio/detail/socket_types.hpp"
-#include "asio/detail/winrt_async_manager.hpp"
-#include "asio/detail/winrt_socket_recv_op.hpp"
-#include "asio/detail/winrt_socket_send_op.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-class winrt_ssocket_service_base
-{
-public:
-  // The native type of a socket.
-  typedef Windows::Networking::Sockets::StreamSocket^ native_handle_type;
-
-  // The implementation type of the socket.
-  struct base_implementation_type
-  {
-    // Default constructor.
-    base_implementation_type()
-      : socket_(nullptr),
-        next_(0),
-        prev_(0)
-    {
-    }
-
-    // The underlying native socket.
-    native_handle_type socket_;
-
-    // Pointers to adjacent socket implementations in linked list.
-    base_implementation_type* next_;
-    base_implementation_type* prev_;
-  };
-
-  // Constructor.
-  ASIO_DECL winrt_ssocket_service_base(
-      asio::io_service& io_service);
-
-  // Destroy all user-defined handler objects owned by the service.
-  ASIO_DECL void shutdown_service();
-
-  // Construct a new socket implementation.
-  ASIO_DECL void construct(base_implementation_type&);
-
-  // Move-construct a new socket implementation.
-  ASIO_DECL void base_move_construct(base_implementation_type& impl,
-      base_implementation_type& other_impl);
-
-  // Move-assign from another socket implementation.
-  ASIO_DECL void base_move_assign(base_implementation_type& impl,
-      winrt_ssocket_service_base& other_service,
-      base_implementation_type& other_impl);
-
-  // Destroy a socket implementation.
-  ASIO_DECL void destroy(base_implementation_type& impl);
-
-  // Determine whether the socket is open.
-  bool is_open(const base_implementation_type& impl) const
-  {
-    return impl.socket_ != nullptr;
-  }
-
-  // Destroy a socket implementation.
-  ASIO_DECL asio::error_code close(
-      base_implementation_type& impl, asio::error_code& ec);
-
-  // Get the native socket representation.
-  native_handle_type native_handle(base_implementation_type& impl)
-  {
-    return impl.socket_;
-  }
-
-  // Cancel all operations associated with the socket.
-  asio::error_code cancel(base_implementation_type&,
-      asio::error_code& ec)
-  {
-    ec = asio::error::operation_not_supported;
-    return ec;
-  }
-
-  // Determine whether the socket is at the out-of-band data mark.
-  bool at_mark(const base_implementation_type&,
-      asio::error_code& ec) const
-  {
-    ec = asio::error::operation_not_supported;
-    return false;
-  }
-
-  // Determine the number of bytes available for reading.
-  std::size_t available(const base_implementation_type&,
-      asio::error_code& ec) const
-  {
-    ec = asio::error::operation_not_supported;
-    return 0;
-  }
-
-  // Perform an IO control command on the socket.
-  template <typename IO_Control_Command>
-  asio::error_code io_control(base_implementation_type&,
-      IO_Control_Command&, asio::error_code& ec)
-  {
-    ec = asio::error::operation_not_supported;
-    return ec;
-  }
-
-  // Gets the non-blocking mode of the socket.
-  bool non_blocking(const base_implementation_type&) const
-  {
-    return false;
-  }
-
-  // Sets the non-blocking mode of the socket.
-  asio::error_code non_blocking(base_implementation_type&,
-      bool, asio::error_code& ec)
-  {
-    ec = asio::error::operation_not_supported;
-    return ec;
-  }
-
-  // Gets the non-blocking mode of the native socket implementation.
-  bool native_non_blocking(const base_implementation_type&) const
-  {
-    return false;
-  }
-
-  // Sets the non-blocking mode of the native socket implementation.
-  asio::error_code native_non_blocking(base_implementation_type&,
-      bool, asio::error_code& ec)
-  {
-    ec = asio::error::operation_not_supported;
-    return ec;
-  }
-
-  // Disable sends or receives on the socket.
-  asio::error_code shutdown(base_implementation_type&,
-      socket_base::shutdown_type, asio::error_code& ec)
-  {
-    ec = asio::error::operation_not_supported;
-    return ec;
-  }
-
-  // Send the given data to the peer.
-  template <typename ConstBufferSequence>
-  std::size_t send(base_implementation_type& impl,
-      const ConstBufferSequence& buffers,
-      socket_base::message_flags flags, asio::error_code& ec)
-  {
-    return do_send(impl,
-        buffer_sequence_adapter<asio::const_buffer,
-          ConstBufferSequence>::first(buffers), flags, ec);
-  }
-
-  // Wait until data can be sent without blocking.
-  std::size_t send(base_implementation_type&, const null_buffers&,
-      socket_base::message_flags, asio::error_code& ec)
-  {
-    ec = asio::error::operation_not_supported;
-    return 0;
-  }
-
-  // Start an asynchronous send. The data being sent must be valid for the
-  // lifetime of the asynchronous operation.
-  template <typename ConstBufferSequence, typename Handler>
-  void async_send(base_implementation_type& impl,
-      const ConstBufferSequence& buffers,
-      socket_base::message_flags flags, Handler& handler)
-  {
-    bool is_continuation =
-      asio_handler_cont_helpers::is_continuation(handler);
-
-    // Allocate and construct an operation to wrap the handler.
-    typedef winrt_socket_send_op<ConstBufferSequence, Handler> op;
-    typename op::ptr p = { asio::detail::addressof(handler),
-      asio_handler_alloc_helpers::allocate(
-        sizeof(op), handler), 0 };
-    p.p = new (p.v) op(buffers, handler);
-
-    ASIO_HANDLER_CREATION((p.p, "socket", &impl, "async_send"));
-
-    start_send_op(impl,
-        buffer_sequence_adapter<asio::const_buffer,
-          ConstBufferSequence>::first(buffers),
-        flags, p.p, is_continuation);
-    p.v = p.p = 0;
-  }
-
-  // Start an asynchronous wait until data can be sent without blocking.
-  template <typename Handler>
-  void async_send(base_implementation_type&, const null_buffers&,
-      socket_base::message_flags, Handler& handler)
-  {
-    asio::error_code ec = asio::error::operation_not_supported;
-    const std::size_t bytes_transferred = 0;
-    io_service_.get_io_service().post(
-        detail::bind_handler(handler, ec, bytes_transferred));
-  }
-
-  // Receive some data from the peer. Returns the number of bytes received.
-  template <typename MutableBufferSequence>
-  std::size_t receive(base_implementation_type& impl,
-      const MutableBufferSequence& buffers,
-      socket_base::message_flags flags, asio::error_code& ec)
-  {
-    return do_receive(impl,
-        buffer_sequence_adapter<asio::mutable_buffer,
-          MutableBufferSequence>::first(buffers), flags, ec);
-  }
-
-  // Wait until data can be received without blocking.
-  std::size_t receive(base_implementation_type&, const null_buffers&,
-      socket_base::message_flags, asio::error_code& ec)
-  {
-    ec = asio::error::operation_not_supported;
-    return 0;
-  }
-
-  // Start an asynchronous receive. The buffer for the data being received
-  // must be valid for the lifetime of the asynchronous operation.
-  template <typename MutableBufferSequence, typename Handler>
-  void async_receive(base_implementation_type& impl,
-      const MutableBufferSequence& buffers,
-      socket_base::message_flags flags, Handler& handler)
-  {
-    bool is_continuation =
-      asio_handler_cont_helpers::is_continuation(handler);
-
-    // Allocate and construct an operation to wrap the handler.
-    typedef winrt_socket_recv_op<MutableBufferSequence, Handler> op;
-    typename op::ptr p = { asio::detail::addressof(handler),
-      asio_handler_alloc_helpers::allocate(
-        sizeof(op), handler), 0 };
-    p.p = new (p.v) op(buffers, handler);
-
-    ASIO_HANDLER_CREATION((p.p, "socket", &impl, "async_receive"));
-
-    start_receive_op(impl,
-        buffer_sequence_adapter<asio::mutable_buffer,
-          MutableBufferSequence>::first(buffers),
-        flags, p.p, is_continuation);
-    p.v = p.p = 0;
-  }
-
-  // Wait until data can be received without blocking.
-  template <typename Handler>
-  void async_receive(base_implementation_type&, const null_buffers&,
-      socket_base::message_flags, Handler& handler)
-  {
-    asio::error_code ec = asio::error::operation_not_supported;
-    const std::size_t bytes_transferred = 0;
-    io_service_.get_io_service().post(
-        detail::bind_handler(handler, ec, bytes_transferred));
-  }
-
-protected:
-  // Helper function to obtain endpoints associated with the connection.
-  ASIO_DECL std::size_t do_get_endpoint(
-      const base_implementation_type& impl, bool local,
-      void* addr, std::size_t addr_len, asio::error_code& ec) const;
-
-  // Helper function to set a socket option.
-  ASIO_DECL asio::error_code do_set_option(
-      base_implementation_type& impl,
-      int level, int optname, const void* optval,
-      std::size_t optlen, asio::error_code& ec);
-
-  // Helper function to get a socket option.
-  ASIO_DECL void do_get_option(
-      const base_implementation_type& impl,
-      int level, int optname, void* optval,
-      std::size_t* optlen, asio::error_code& ec) const;
-
-  // Helper function to perform a synchronous connect.
-  ASIO_DECL asio::error_code do_connect(
-      base_implementation_type& impl,
-      const void* addr, asio::error_code& ec);
-
-  // Helper function to start an asynchronous connect.
-  ASIO_DECL void start_connect_op(
-      base_implementation_type& impl, const void* addr,
-      winrt_async_op<void>* op, bool is_continuation);
-
-  // Helper function to perform a synchronous send.
-  ASIO_DECL std::size_t do_send(
-      base_implementation_type& impl, const asio::const_buffer& data,
-      socket_base::message_flags flags, asio::error_code& ec);
-
-  // Helper function to start an asynchronous send.
-  ASIO_DECL void start_send_op(base_implementation_type& impl,
-      const asio::const_buffer& data, socket_base::message_flags flags,
-      winrt_async_op<unsigned int>* op, bool is_continuation);
-
-  // Helper function to perform a synchronous receive.
-  ASIO_DECL std::size_t do_receive(
-      base_implementation_type& impl, const asio::mutable_buffer& data,
-      socket_base::message_flags flags, asio::error_code& ec);
-
-  // Helper function to start an asynchronous receive.
-  ASIO_DECL void start_receive_op(base_implementation_type& impl,
-      const asio::mutable_buffer& data, socket_base::message_flags flags,
-      winrt_async_op<Windows::Storage::Streams::IBuffer^>* op,
-      bool is_continuation);
-
-  // The io_service implementation used for delivering completions.
-  io_service_impl& io_service_;
-
-  // The manager that keeps track of outstanding operations.
-  winrt_async_manager& async_manager_;
-
-  // Mutex to protect access to the linked list of implementations. 
-  asio::detail::mutex mutex_;
-
-  // The head of a linked list of all implementations.
-  base_implementation_type* impl_list_;
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#if defined(ASIO_HEADER_ONLY)
-# include "asio/detail/impl/winrt_ssocket_service_base.ipp"
-#endif // defined(ASIO_HEADER_ONLY)
-
-#endif // defined(ASIO_WINDOWS_RUNTIME)
-
-#endif // ASIO_DETAIL_WINRT_SSOCKET_SERVICE_BASE_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/winrt_timer_scheduler.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/winrt_timer_scheduler.hpp
deleted file mode 100644
index b4cbb6381ada..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/winrt_timer_scheduler.hpp
+++ /dev/null
@@ -1,131 +0,0 @@
-//
-// detail/winrt_timer_scheduler.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_WINRT_TIMER_SCHEDULER_HPP
-#define ASIO_DETAIL_WINRT_TIMER_SCHEDULER_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_WINDOWS_RUNTIME)
-
-#include <cstddef>
-#include "asio/detail/event.hpp"
-#include "asio/detail/limits.hpp"
-#include "asio/detail/mutex.hpp"
-#include "asio/detail/op_queue.hpp"
-#include "asio/detail/thread.hpp"
-#include "asio/detail/timer_queue_base.hpp"
-#include "asio/detail/timer_queue_set.hpp"
-#include "asio/detail/wait_op.hpp"
-#include "asio/io_service.hpp"
-
-#if defined(ASIO_HAS_IOCP)
-# include "asio/detail/thread.hpp"
-#endif // defined(ASIO_HAS_IOCP)
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-class winrt_timer_scheduler
-  : public asio::detail::service_base<winrt_timer_scheduler>
-{
-public:
-  // Constructor.
-  ASIO_DECL winrt_timer_scheduler(asio::io_service& io_service);
-
-  // Destructor.
-  ASIO_DECL ~winrt_timer_scheduler();
-
-  // Destroy all user-defined handler objects owned by the service.
-  ASIO_DECL void shutdown_service();
-
-  // Recreate internal descriptors following a fork.
-  ASIO_DECL void fork_service(
-      asio::io_service::fork_event fork_ev);
-
-  // Initialise the task. No effect as this class uses its own thread.
-  ASIO_DECL void init_task();
-
-  // Add a new timer queue to the reactor.
-  template <typename Time_Traits>
-  void add_timer_queue(timer_queue<Time_Traits>& queue);
-
-  // Remove a timer queue from the reactor.
-  template <typename Time_Traits>
-  void remove_timer_queue(timer_queue<Time_Traits>& queue);
-
-  // Schedule a new operation in the given timer queue to expire at the
-  // specified absolute time.
-  template <typename Time_Traits>
-  void schedule_timer(timer_queue<Time_Traits>& queue,
-      const typename Time_Traits::time_type& time,
-      typename timer_queue<Time_Traits>::per_timer_data& timer, wait_op* op);
-
-  // Cancel the timer operations associated with the given token. Returns the
-  // number of operations that have been posted or dispatched.
-  template <typename Time_Traits>
-  std::size_t cancel_timer(timer_queue<Time_Traits>& queue,
-      typename timer_queue<Time_Traits>::per_timer_data& timer,
-      std::size_t max_cancelled = (std::numeric_limits<std::size_t>::max)());
-
-private:
-  // Run the select loop in the thread.
-  ASIO_DECL void run_thread();
-
-  // Entry point for the select loop thread.
-  ASIO_DECL static void call_run_thread(winrt_timer_scheduler* reactor);
-
-  // Helper function to add a new timer queue.
-  ASIO_DECL void do_add_timer_queue(timer_queue_base& queue);
-
-  // Helper function to remove a timer queue.
-  ASIO_DECL void do_remove_timer_queue(timer_queue_base& queue);
-
-  // The io_service implementation used to post completions.
-  io_service_impl& io_service_;
-
-  // Mutex used to protect internal variables.
-  asio::detail::mutex mutex_;
-
-  // Event used to wake up background thread.
-  asio::detail::event event_;
-
-  // The timer queues.
-  timer_queue_set timer_queues_;
-
-  // The background thread that is waiting for timers to expire.
-  asio::detail::thread* thread_;
-
-  // Does the background thread need to stop.
-  bool stop_thread_;
-
-  // Whether the service has been shut down.
-  bool shutdown_;
-};
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#include "asio/detail/impl/winrt_timer_scheduler.hpp"
-#if defined(ASIO_HEADER_ONLY)
-# include "asio/detail/impl/winrt_timer_scheduler.ipp"
-#endif // defined(ASIO_HEADER_ONLY)
-
-#endif // defined(ASIO_WINDOWS_RUNTIME)
-
-#endif // ASIO_DETAIL_WINRT_TIMER_SCHEDULER_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/winrt_utils.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/winrt_utils.hpp
deleted file mode 100644
index 3d41fdc354d6..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/winrt_utils.hpp
+++ /dev/null
@@ -1,106 +0,0 @@
-//
-// detail/winrt_utils.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_WINRT_UTILS_HPP
-#define ASIO_DETAIL_WINRT_UTILS_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_WINDOWS_RUNTIME)
-
-#include <codecvt>
-#include <cstdlib>
-#include <future>
-#include <locale>
-#include <memory>
-#include <robuffer.h>
-#include <windows.storage.streams.h>
-#include <wrl/implements.h>
-#include "asio/buffer.hpp"
-#include "asio/error_code.hpp"
-#include "asio/detail/addressof.hpp"
-#include "asio/detail/socket_ops.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-namespace winrt_utils {
-
-inline Platform::String^ string(const char* from)
-{
-  std::wstring tmp(from, from + std::strlen(from));
-  return ref new Platform::String(tmp.c_str());
-}
-
-inline Platform::String^ string(const std::string& from)
-{
-  std::wstring tmp(from.begin(), from.end());
-  return ref new Platform::String(tmp.c_str());
-}
-
-inline std::string string(Platform::String^ from)
-{
-  std::wstring_convert<std::codecvt_utf8<wchar_t>> converter;
-  return converter.to_bytes(from->Data());
-}
-
-inline Platform::String^ string(unsigned short from)
-{
-  return string(std::to_string(from));
-}
-
-template <typename T>
-inline Platform::String^ string(const T& from)
-{
-  return string(from.to_string());
-}
-
-inline int integer(Platform::String^ from)
-{
-  return _wtoi(from->Data());
-}
-
-template <typename T>
-inline Windows::Networking::HostName^ host_name(const T& from)
-{
-  return ref new Windows::Networking::HostName((string)(from));
-}
-
-template <typename ConstBufferSequence>
-inline Windows::Storage::Streams::IBuffer^ buffer_dup(
-    const ConstBufferSequence& buffers)
-{
-  using Microsoft::WRL::ComPtr;
-  std::size_t size = asio::buffer_size(buffers);
-  auto b = ref new Windows::Storage::Streams::Buffer(size);
-  ComPtr<IInspectable> insp = reinterpret_cast<IInspectable*>(b);
-  ComPtr<Windows::Storage::Streams::IBufferByteAccess> bacc;
-  insp.As(&bacc);
-  byte* bytes = nullptr;
-  bacc->Buffer(&bytes);
-  asio::buffer_copy(asio::buffer(bytes, size), buffers);
-  b->Length = size;
-  return b;
-}
-
-} // namespace winrt_utils
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // defined(ASIO_WINDOWS_RUNTIME)
-
-#endif // ASIO_DETAIL_WINRT_UTILS_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/winsock_init.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/winsock_init.hpp
deleted file mode 100644
index a2cb903605a5..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/winsock_init.hpp
+++ /dev/null
@@ -1,128 +0,0 @@
-//
-// detail/winsock_init.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_WINSOCK_INIT_HPP
-#define ASIO_DETAIL_WINSOCK_INIT_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-class winsock_init_base
-{
-protected:
-  // Structure to track result of initialisation and number of uses. POD is used
-  // to ensure that the values are zero-initialised prior to any code being run.
-  struct data
-  {
-    long init_count_;
-    long result_;
-  };
-
-  ASIO_DECL static void startup(data& d,
-      unsigned char major, unsigned char minor);
-
-  ASIO_DECL static void manual_startup(data& d);
-
-  ASIO_DECL static void cleanup(data& d);
-
-  ASIO_DECL static void manual_cleanup(data& d);
-
-  ASIO_DECL static void throw_on_error(data& d);
-};
-
-template <int Major = 2, int Minor = 0>
-class winsock_init : private winsock_init_base
-{
-public:
-  winsock_init(bool allow_throw = true)
-  {
-    startup(data_, Major, Minor);
-    if (allow_throw)
-      throw_on_error(data_);
-  }
-
-  winsock_init(const winsock_init&)
-  {
-    startup(data_, Major, Minor);
-    throw_on_error(data_);
-  }
-
-  ~winsock_init()
-  {
-    cleanup(data_);
-  }
-
-  // This class may be used to indicate that user code will manage Winsock
-  // initialisation and cleanup. This may be required in the case of a DLL, for
-  // example, where it is not safe to initialise Winsock from global object
-  // constructors.
-  //
-  // To prevent asio from initialising Winsock, the object must be constructed
-  // before any Asio's own global objects. With MSVC, this may be accomplished
-  // by adding the following code to the DLL:
-  //
-  //   #pragma warning(push)
-  //   #pragma warning(disable:4073)
-  //   #pragma init_seg(lib)
-  //   asio::detail::winsock_init<>::manual manual_winsock_init;
-  //   #pragma warning(pop)
-  class manual
-  {
-  public:
-    manual()
-    {
-      manual_startup(data_);
-    }
-
-    manual(const manual&)
-    {
-      manual_startup(data_);
-    }
-
-    ~manual()
-    {
-      manual_cleanup(data_);
-    }
-  };
-
-private:
-  friend class manual;
-  static data data_;
-};
-
-template <int Major, int Minor>
-winsock_init_base::data winsock_init<Major, Minor>::data_;
-
-// Static variable to ensure that winsock is initialised before main, and
-// therefore before any other threads can get started.
-static const winsock_init<>& winsock_init_instance = winsock_init<>(false);
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#if defined(ASIO_HEADER_ONLY)
-# include "asio/detail/impl/winsock_init.ipp"
-#endif // defined(ASIO_HEADER_ONLY)
-
-#endif // defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-
-#endif // ASIO_DETAIL_WINSOCK_INIT_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/wrapped_handler.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/wrapped_handler.hpp
deleted file mode 100644
index 5cefcf407759..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/detail/wrapped_handler.hpp
+++ /dev/null
@@ -1,291 +0,0 @@
-//
-// detail/wrapped_handler.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_DETAIL_WRAPPED_HANDLER_HPP
-#define ASIO_DETAIL_WRAPPED_HANDLER_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/bind_handler.hpp"
-#include "asio/detail/handler_alloc_helpers.hpp"
-#include "asio/detail/handler_cont_helpers.hpp"
-#include "asio/detail/handler_invoke_helpers.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-struct is_continuation_delegated
-{
-  template <typename Dispatcher, typename Handler>
-  bool operator()(Dispatcher&, Handler& handler) const
-  {
-    return asio_handler_cont_helpers::is_continuation(handler);
-  }
-};
-
-struct is_continuation_if_running
-{
-  template <typename Dispatcher, typename Handler>
-  bool operator()(Dispatcher& dispatcher, Handler&) const
-  {
-    return dispatcher.running_in_this_thread();
-  }
-};
-
-template <typename Dispatcher, typename Handler,
-    typename IsContinuation = is_continuation_delegated>
-class wrapped_handler
-{
-public:
-  typedef void result_type;
-
-  wrapped_handler(Dispatcher dispatcher, Handler& handler)
-    : dispatcher_(dispatcher),
-      handler_(ASIO_MOVE_CAST(Handler)(handler))
-  {
-  }
-
-#if defined(ASIO_HAS_MOVE)
-  wrapped_handler(const wrapped_handler& other)
-    : dispatcher_(other.dispatcher_),
-      handler_(other.handler_)
-  {
-  }
-
-  wrapped_handler(wrapped_handler&& other)
-    : dispatcher_(other.dispatcher_),
-      handler_(ASIO_MOVE_CAST(Handler)(other.handler_))
-  {
-  }
-#endif // defined(ASIO_HAS_MOVE)
-
-  void operator()()
-  {
-    dispatcher_.dispatch(ASIO_MOVE_CAST(Handler)(handler_));
-  }
-
-  void operator()() const
-  {
-    dispatcher_.dispatch(handler_);
-  }
-
-  template <typename Arg1>
-  void operator()(const Arg1& arg1)
-  {
-    dispatcher_.dispatch(detail::bind_handler(handler_, arg1));
-  }
-
-  template <typename Arg1>
-  void operator()(const Arg1& arg1) const
-  {
-    dispatcher_.dispatch(detail::bind_handler(handler_, arg1));
-  }
-
-  template <typename Arg1, typename Arg2>
-  void operator()(const Arg1& arg1, const Arg2& arg2)
-  {
-    dispatcher_.dispatch(detail::bind_handler(handler_, arg1, arg2));
-  }
-
-  template <typename Arg1, typename Arg2>
-  void operator()(const Arg1& arg1, const Arg2& arg2) const
-  {
-    dispatcher_.dispatch(detail::bind_handler(handler_, arg1, arg2));
-  }
-
-  template <typename Arg1, typename Arg2, typename Arg3>
-  void operator()(const Arg1& arg1, const Arg2& arg2, const Arg3& arg3)
-  {
-    dispatcher_.dispatch(detail::bind_handler(handler_, arg1, arg2, arg3));
-  }
-
-  template <typename Arg1, typename Arg2, typename Arg3>
-  void operator()(const Arg1& arg1, const Arg2& arg2, const Arg3& arg3) const
-  {
-    dispatcher_.dispatch(detail::bind_handler(handler_, arg1, arg2, arg3));
-  }
-
-  template <typename Arg1, typename Arg2, typename Arg3, typename Arg4>
-  void operator()(const Arg1& arg1, const Arg2& arg2, const Arg3& arg3,
-      const Arg4& arg4)
-  {
-    dispatcher_.dispatch(
-        detail::bind_handler(handler_, arg1, arg2, arg3, arg4));
-  }
-
-  template <typename Arg1, typename Arg2, typename Arg3, typename Arg4>
-  void operator()(const Arg1& arg1, const Arg2& arg2, const Arg3& arg3,
-      const Arg4& arg4) const
-  {
-    dispatcher_.dispatch(
-        detail::bind_handler(handler_, arg1, arg2, arg3, arg4));
-  }
-
-  template <typename Arg1, typename Arg2, typename Arg3, typename Arg4,
-      typename Arg5>
-  void operator()(const Arg1& arg1, const Arg2& arg2, const Arg3& arg3,
-      const Arg4& arg4, const Arg5& arg5)
-  {
-    dispatcher_.dispatch(
-        detail::bind_handler(handler_, arg1, arg2, arg3, arg4, arg5));
-  }
-
-  template <typename Arg1, typename Arg2, typename Arg3, typename Arg4,
-      typename Arg5>
-  void operator()(const Arg1& arg1, const Arg2& arg2, const Arg3& arg3,
-      const Arg4& arg4, const Arg5& arg5) const
-  {
-    dispatcher_.dispatch(
-        detail::bind_handler(handler_, arg1, arg2, arg3, arg4, arg5));
-  }
-
-//private:
-  Dispatcher dispatcher_;
-  Handler handler_;
-};
-
-template <typename Handler, typename Context>
-class rewrapped_handler
-{
-public:
-  explicit rewrapped_handler(Handler& handler, const Context& context)
-    : context_(context),
-      handler_(ASIO_MOVE_CAST(Handler)(handler))
-  {
-  }
-
-  explicit rewrapped_handler(const Handler& handler, const Context& context)
-    : context_(context),
-      handler_(handler)
-  {
-  }
-
-#if defined(ASIO_HAS_MOVE)
-  rewrapped_handler(const rewrapped_handler& other)
-    : context_(other.context_),
-      handler_(other.handler_)
-  {
-  }
-
-  rewrapped_handler(rewrapped_handler&& other)
-    : context_(ASIO_MOVE_CAST(Context)(other.context_)),
-      handler_(ASIO_MOVE_CAST(Handler)(other.handler_))
-  {
-  }
-#endif // defined(ASIO_HAS_MOVE)
-
-  void operator()()
-  {
-    handler_();
-  }
-
-  void operator()() const
-  {
-    handler_();
-  }
-
-//private:
-  Context context_;
-  Handler handler_;
-};
-
-template <typename Dispatcher, typename Handler, typename IsContinuation>
-inline void* asio_handler_allocate(std::size_t size,
-    wrapped_handler<Dispatcher, Handler, IsContinuation>* this_handler)
-{
-  return asio_handler_alloc_helpers::allocate(
-      size, this_handler->handler_);
-}
-
-template <typename Dispatcher, typename Handler, typename IsContinuation>
-inline void asio_handler_deallocate(void* pointer, std::size_t size,
-    wrapped_handler<Dispatcher, Handler, IsContinuation>* this_handler)
-{
-  asio_handler_alloc_helpers::deallocate(
-      pointer, size, this_handler->handler_);
-}
-
-template <typename Dispatcher, typename Handler, typename IsContinuation>
-inline bool asio_handler_is_continuation(
-    wrapped_handler<Dispatcher, Handler, IsContinuation>* this_handler)
-{
-  return IsContinuation()(this_handler->dispatcher_, this_handler->handler_);
-}
-
-template <typename Function, typename Dispatcher,
-    typename Handler, typename IsContinuation>
-inline void asio_handler_invoke(Function& function,
-    wrapped_handler<Dispatcher, Handler, IsContinuation>* this_handler)
-{
-  this_handler->dispatcher_.dispatch(
-      rewrapped_handler<Function, Handler>(
-        function, this_handler->handler_));
-}
-
-template <typename Function, typename Dispatcher,
-    typename Handler, typename IsContinuation>
-inline void asio_handler_invoke(const Function& function,
-    wrapped_handler<Dispatcher, Handler, IsContinuation>* this_handler)
-{
-  this_handler->dispatcher_.dispatch(
-      rewrapped_handler<Function, Handler>(
-        function, this_handler->handler_));
-}
-
-template <typename Handler, typename Context>
-inline void* asio_handler_allocate(std::size_t size,
-    rewrapped_handler<Handler, Context>* this_handler)
-{
-  return asio_handler_alloc_helpers::allocate(
-      size, this_handler->context_);
-}
-
-template <typename Handler, typename Context>
-inline void asio_handler_deallocate(void* pointer, std::size_t size,
-    rewrapped_handler<Handler, Context>* this_handler)
-{
-  asio_handler_alloc_helpers::deallocate(
-      pointer, size, this_handler->context_);
-}
-
-template <typename Dispatcher, typename Context>
-inline bool asio_handler_is_continuation(
-    rewrapped_handler<Dispatcher, Context>* this_handler)
-{
-  return asio_handler_cont_helpers::is_continuation(
-      this_handler->context_);
-}
-
-template <typename Function, typename Handler, typename Context>
-inline void asio_handler_invoke(Function& function,
-    rewrapped_handler<Handler, Context>* this_handler)
-{
-  asio_handler_invoke_helpers::invoke(
-      function, this_handler->context_);
-}
-
-template <typename Function, typename Handler, typename Context>
-inline void asio_handler_invoke(const Function& function,
-    rewrapped_handler<Handler, Context>* this_handler)
-{
-  asio_handler_invoke_helpers::invoke(
-      function, this_handler->context_);
-}
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_DETAIL_WRAPPED_HANDLER_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/error.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/error.hpp
deleted file mode 100644
index 6a0af9ee3419..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/error.hpp
+++ /dev/null
@@ -1,331 +0,0 @@
-//
-// error.hpp
-// ~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_ERROR_HPP
-#define ASIO_ERROR_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include "asio/error_code.hpp"
-#include "asio/system_error.hpp"
-#if defined(ASIO_WINDOWS) \
-  || defined(__CYGWIN__) \
-  || defined(ASIO_WINDOWS_RUNTIME)
-# include <winerror.h>
-#else
-# include <cerrno>
-# include <netdb.h>
-#endif
-
-#if defined(GENERATING_DOCUMENTATION)
-/// INTERNAL ONLY.
-# define ASIO_NATIVE_ERROR(e) implementation_defined
-/// INTERNAL ONLY.
-# define ASIO_SOCKET_ERROR(e) implementation_defined
-/// INTERNAL ONLY.
-# define ASIO_NETDB_ERROR(e) implementation_defined
-/// INTERNAL ONLY.
-# define ASIO_GETADDRINFO_ERROR(e) implementation_defined
-/// INTERNAL ONLY.
-# define ASIO_WIN_OR_POSIX(e_win, e_posix) implementation_defined
-#elif defined(ASIO_WINDOWS_RUNTIME)
-# define ASIO_NATIVE_ERROR(e) __HRESULT_FROM_WIN32(e)
-# define ASIO_SOCKET_ERROR(e) __HRESULT_FROM_WIN32(WSA ## e)
-# define ASIO_NETDB_ERROR(e) __HRESULT_FROM_WIN32(WSA ## e)
-# define ASIO_GETADDRINFO_ERROR(e) __HRESULT_FROM_WIN32(WSA ## e)
-# define ASIO_WIN_OR_POSIX(e_win, e_posix) e_win
-#elif defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-# define ASIO_NATIVE_ERROR(e) e
-# define ASIO_SOCKET_ERROR(e) WSA ## e
-# define ASIO_NETDB_ERROR(e) WSA ## e
-# define ASIO_GETADDRINFO_ERROR(e) WSA ## e
-# define ASIO_WIN_OR_POSIX(e_win, e_posix) e_win
-#else
-# define ASIO_NATIVE_ERROR(e) e
-# define ASIO_SOCKET_ERROR(e) e
-# define ASIO_NETDB_ERROR(e) e
-# define ASIO_GETADDRINFO_ERROR(e) e
-# define ASIO_WIN_OR_POSIX(e_win, e_posix) e_posix
-#endif
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace error {
-
-enum basic_errors
-{
-  /// Permission denied.
-  access_denied = ASIO_SOCKET_ERROR(EACCES),
-
-  /// Address family not supported by protocol.
-  address_family_not_supported = ASIO_SOCKET_ERROR(EAFNOSUPPORT),
-
-  /// Address already in use.
-  address_in_use = ASIO_SOCKET_ERROR(EADDRINUSE),
-
-  /// Transport endpoint is already connected.
-  already_connected = ASIO_SOCKET_ERROR(EISCONN),
-
-  /// Operation already in progress.
-  already_started = ASIO_SOCKET_ERROR(EALREADY),
-
-  /// Broken pipe.
-  broken_pipe = ASIO_WIN_OR_POSIX(
-      ASIO_NATIVE_ERROR(ERROR_BROKEN_PIPE),
-      ASIO_NATIVE_ERROR(EPIPE)),
-
-  /// A connection has been aborted.
-  connection_aborted = ASIO_SOCKET_ERROR(ECONNABORTED),
-
-  /// Connection refused.
-  connection_refused = ASIO_SOCKET_ERROR(ECONNREFUSED),
-
-  /// Connection reset by peer.
-  connection_reset = ASIO_SOCKET_ERROR(ECONNRESET),
-
-  /// Bad file descriptor.
-  bad_descriptor = ASIO_SOCKET_ERROR(EBADF),
-
-  /// Bad address.
-  fault = ASIO_SOCKET_ERROR(EFAULT),
-
-  /// No route to host.
-  host_unreachable = ASIO_SOCKET_ERROR(EHOSTUNREACH),
-
-  /// Operation now in progress.
-  in_progress = ASIO_SOCKET_ERROR(EINPROGRESS),
-
-  /// Interrupted system call.
-  interrupted = ASIO_SOCKET_ERROR(EINTR),
-
-  /// Invalid argument.
-  invalid_argument = ASIO_SOCKET_ERROR(EINVAL),
-
-  /// Message too long.
-  message_size = ASIO_SOCKET_ERROR(EMSGSIZE),
-
-  /// The name was too long.
-  name_too_long = ASIO_SOCKET_ERROR(ENAMETOOLONG),
-
-  /// Network is down.
-  network_down = ASIO_SOCKET_ERROR(ENETDOWN),
-
-  /// Network dropped connection on reset.
-  network_reset = ASIO_SOCKET_ERROR(ENETRESET),
-
-  /// Network is unreachable.
-  network_unreachable = ASIO_SOCKET_ERROR(ENETUNREACH),
-
-  /// Too many open files.
-  no_descriptors = ASIO_SOCKET_ERROR(EMFILE),
-
-  /// No buffer space available.
-  no_buffer_space = ASIO_SOCKET_ERROR(ENOBUFS),
-
-  /// Cannot allocate memory.
-  no_memory = ASIO_WIN_OR_POSIX(
-      ASIO_NATIVE_ERROR(ERROR_OUTOFMEMORY),
-      ASIO_NATIVE_ERROR(ENOMEM)),
-
-  /// Operation not permitted.
-  no_permission = ASIO_WIN_OR_POSIX(
-      ASIO_NATIVE_ERROR(ERROR_ACCESS_DENIED),
-      ASIO_NATIVE_ERROR(EPERM)),
-
-  /// Protocol not available.
-  no_protocol_option = ASIO_SOCKET_ERROR(ENOPROTOOPT),
-
-  /// Transport endpoint is not connected.
-  not_connected = ASIO_SOCKET_ERROR(ENOTCONN),
-
-  /// Socket operation on non-socket.
-  not_socket = ASIO_SOCKET_ERROR(ENOTSOCK),
-
-  /// Operation cancelled.
-  operation_aborted = ASIO_WIN_OR_POSIX(
-      ASIO_NATIVE_ERROR(ERROR_OPERATION_ABORTED),
-      ASIO_NATIVE_ERROR(ECANCELED)),
-
-  /// Operation not supported.
-  operation_not_supported = ASIO_SOCKET_ERROR(EOPNOTSUPP),
-
-  /// Cannot send after transport endpoint shutdown.
-  shut_down = ASIO_SOCKET_ERROR(ESHUTDOWN),
-
-  /// Connection timed out.
-  timed_out = ASIO_SOCKET_ERROR(ETIMEDOUT),
-
-  /// Resource temporarily unavailable.
-  try_again = ASIO_WIN_OR_POSIX(
-      ASIO_NATIVE_ERROR(ERROR_RETRY),
-      ASIO_NATIVE_ERROR(EAGAIN)),
-
-  /// The socket is marked non-blocking and the requested operation would block.
-  would_block = ASIO_SOCKET_ERROR(EWOULDBLOCK)
-};
-
-enum netdb_errors
-{
-  /// Host not found (authoritative).
-  host_not_found = ASIO_NETDB_ERROR(HOST_NOT_FOUND),
-
-  /// Host not found (non-authoritative).
-  host_not_found_try_again = ASIO_NETDB_ERROR(TRY_AGAIN),
-
-  /// The query is valid but does not have associated address data.
-  no_data = ASIO_NETDB_ERROR(NO_DATA),
-
-  /// A non-recoverable error occurred.
-  no_recovery = ASIO_NETDB_ERROR(NO_RECOVERY)
-};
-
-enum addrinfo_errors
-{
-  /// The service is not supported for the given socket type.
-  service_not_found = ASIO_WIN_OR_POSIX(
-      ASIO_NATIVE_ERROR(WSATYPE_NOT_FOUND),
-      ASIO_GETADDRINFO_ERROR(EAI_SERVICE)),
-
-  /// The socket type is not supported.
-  socket_type_not_supported = ASIO_WIN_OR_POSIX(
-      ASIO_NATIVE_ERROR(WSAESOCKTNOSUPPORT),
-      ASIO_GETADDRINFO_ERROR(EAI_SOCKTYPE))
-};
-
-enum misc_errors
-{
-  /// Already open.
-  already_open = 1,
-
-  /// End of file or stream.
-  eof,
-
-  /// Element not found.
-  not_found,
-
-  /// The descriptor cannot fit into the select system call's fd_set.
-  fd_set_failure
-};
-
-inline const asio::error_category& get_system_category()
-{
-  return asio::system_category();
-}
-
-#if !defined(ASIO_WINDOWS) && !defined(__CYGWIN__)
-
-extern ASIO_DECL
-const asio::error_category& get_netdb_category();
-
-extern ASIO_DECL
-const asio::error_category& get_addrinfo_category();
-
-#else // !defined(ASIO_WINDOWS) && !defined(__CYGWIN__)
-
-inline const asio::error_category& get_netdb_category()
-{
-  return get_system_category();
-}
-
-inline const asio::error_category& get_addrinfo_category()
-{
-  return get_system_category();
-}
-
-#endif // !defined(ASIO_WINDOWS) && !defined(__CYGWIN__)
-
-extern ASIO_DECL
-const asio::error_category& get_misc_category();
-
-static const asio::error_category& system_category
-  = asio::error::get_system_category();
-static const asio::error_category& netdb_category
-  = asio::error::get_netdb_category();
-static const asio::error_category& addrinfo_category
-  = asio::error::get_addrinfo_category();
-static const asio::error_category& misc_category
-  = asio::error::get_misc_category();
-
-} // namespace error
-} // namespace asio
-
-#if defined(ASIO_HAS_STD_SYSTEM_ERROR)
-namespace std {
-
-template<> struct is_error_code_enum<asio::error::basic_errors>
-{
-  static const bool value = true;
-};
-
-template<> struct is_error_code_enum<asio::error::netdb_errors>
-{
-  static const bool value = true;
-};
-
-template<> struct is_error_code_enum<asio::error::addrinfo_errors>
-{
-  static const bool value = true;
-};
-
-template<> struct is_error_code_enum<asio::error::misc_errors>
-{
-  static const bool value = true;
-};
-
-} // namespace std
-#endif // defined(ASIO_HAS_STD_SYSTEM_ERROR)
-
-namespace asio {
-namespace error {
-
-inline asio::error_code make_error_code(basic_errors e)
-{
-  return asio::error_code(
-      static_cast<int>(e), get_system_category());
-}
-
-inline asio::error_code make_error_code(netdb_errors e)
-{
-  return asio::error_code(
-      static_cast<int>(e), get_netdb_category());
-}
-
-inline asio::error_code make_error_code(addrinfo_errors e)
-{
-  return asio::error_code(
-      static_cast<int>(e), get_addrinfo_category());
-}
-
-inline asio::error_code make_error_code(misc_errors e)
-{
-  return asio::error_code(
-      static_cast<int>(e), get_misc_category());
-}
-
-} // namespace error
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#undef ASIO_NATIVE_ERROR
-#undef ASIO_SOCKET_ERROR
-#undef ASIO_NETDB_ERROR
-#undef ASIO_GETADDRINFO_ERROR
-#undef ASIO_WIN_OR_POSIX
-
-#if defined(ASIO_HEADER_ONLY)
-# include "asio/impl/error.ipp"
-#endif // defined(ASIO_HEADER_ONLY)
-
-#endif // ASIO_ERROR_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/error_code.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/error_code.hpp
deleted file mode 100644
index 182c1821676c..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/error_code.hpp
+++ /dev/null
@@ -1,188 +0,0 @@
-//
-// error_code.hpp
-// ~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_ERROR_CODE_HPP
-#define ASIO_ERROR_CODE_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_HAS_STD_SYSTEM_ERROR)
-# include <system_error>
-#else // defined(ASIO_HAS_STD_SYSTEM_ERROR)
-# include <string>
-# include "asio/detail/noncopyable.hpp"
-# if !defined(ASIO_NO_IOSTREAM)
-#  include <iosfwd>
-# endif // !defined(ASIO_NO_IOSTREAM)
-#endif // defined(ASIO_HAS_STD_SYSTEM_ERROR)
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-
-#if defined(ASIO_HAS_STD_SYSTEM_ERROR)
-
-typedef std::error_category error_category;
-
-#else // defined(ASIO_HAS_STD_SYSTEM_ERROR)
-
-/// Base class for all error categories.
-class error_category : private noncopyable
-{
-public:
-  /// Destructor.
-  virtual ~error_category()
-  {
-  }
-
-  /// Returns a string naming the error gategory.
-  virtual const char* name() const = 0;
-
-  /// Returns a string describing the error denoted by @c value.
-  virtual std::string message(int value) const = 0;
-
-  /// Equality operator to compare two error categories.
-  bool operator==(const error_category& rhs) const
-  {
-    return this == &rhs;
-  }
-
-  /// Inequality operator to compare two error categories.
-  bool operator!=(const error_category& rhs) const
-  {
-    return !(*this == rhs);
-  }
-};
-
-#endif // defined(ASIO_HAS_STD_SYSTEM_ERROR)
-
-/// Returns the error category used for the system errors produced by asio.
-extern ASIO_DECL const error_category& system_category();
-
-#if defined(ASIO_HAS_STD_SYSTEM_ERROR)
-
-typedef std::error_code error_code;
-
-#else // defined(ASIO_HAS_STD_SYSTEM_ERROR)
-
-/// Class to represent an error code value.
-class error_code
-{
-public:
-  /// Default constructor.
-  error_code()
-    : value_(0),
-      category_(&system_category())
-  {
-  }
-
-  /// Construct with specific error code and category.
-  error_code(int v, const error_category& c)
-    : value_(v),
-      category_(&c)
-  {
-  }
-
-  /// Construct from an error code enum.
-  template <typename ErrorEnum>
-  error_code(ErrorEnum e)
-  {
-    *this = make_error_code(e);
-  }
-
-  /// Get the error value.
-  int value() const
-  {
-    return value_;
-  }
-
-  /// Get the error category.
-  const error_category& category() const
-  {
-    return *category_;
-  }
-
-  /// Get the message associated with the error.
-  std::string message() const
-  {
-    return category_->message(value_);
-  }
-
-  struct unspecified_bool_type_t
-  {
-  };
-
-  typedef void (*unspecified_bool_type)(unspecified_bool_type_t);
-
-  static void unspecified_bool_true(unspecified_bool_type_t) {}
-
-  /// Operator returns non-null if there is a non-success error code.
-  operator unspecified_bool_type() const
-  {
-    if (value_ == 0)
-      return 0;
-    else
-      return &error_code::unspecified_bool_true;
-  }
-
-  /// Operator to test if the error represents success.
-  bool operator!() const
-  {
-    return value_ == 0;
-  }
-
-  /// Equality operator to compare two error objects.
-  friend bool operator==(const error_code& e1, const error_code& e2)
-  {
-    return e1.value_ == e2.value_ && e1.category_ == e2.category_;
-  }
-
-  /// Inequality operator to compare two error objects.
-  friend bool operator!=(const error_code& e1, const error_code& e2)
-  {
-    return e1.value_ != e2.value_ || e1.category_ != e2.category_;
-  }
-
-private:
-  // The value associated with the error code.
-  int value_;
-
-  // The category associated with the error code.
-  const error_category* category_;
-};
-
-# if !defined(ASIO_NO_IOSTREAM)
-
-/// Output an error code.
-template <typename Elem, typename Traits>
-std::basic_ostream<Elem, Traits>& operator<<(
-    std::basic_ostream<Elem, Traits>& os, const error_code& ec)
-{
-  os << ec.category().name() << ':' << ec.value();
-  return os;
-}
-
-# endif // !defined(ASIO_NO_IOSTREAM)
-
-#endif // defined(ASIO_HAS_STD_SYSTEM_ERROR)
-
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#if defined(ASIO_HEADER_ONLY)
-# include "asio/impl/error_code.ipp"
-#endif // defined(ASIO_HEADER_ONLY)
-
-#endif // ASIO_ERROR_CODE_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/generic/basic_endpoint.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/generic/basic_endpoint.hpp
deleted file mode 100644
index 81ab820de729..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/generic/basic_endpoint.hpp
+++ /dev/null
@@ -1,193 +0,0 @@
-//
-// generic/basic_endpoint.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_GENERIC_BASIC_ENDPOINT_HPP
-#define ASIO_GENERIC_BASIC_ENDPOINT_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include "asio/generic/detail/endpoint.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace generic {
-
-/// Describes an endpoint for any socket type.
-/**
- * The asio::generic::basic_endpoint class template describes an endpoint
- * that may be associated with any socket type.
- *
- * @note The socket types sockaddr type must be able to fit into a
- * @c sockaddr_storage structure.
- *
- * @par Thread Safety
- * @e Distinct @e objects: Safe.@n
- * @e Shared @e objects: Unsafe.
- *
- * @par Concepts:
- * Endpoint.
- */
-template <typename Protocol>
-class basic_endpoint
-{
-public:
-  /// The protocol type associated with the endpoint.
-  typedef Protocol protocol_type;
-
-  /// The type of the endpoint structure. This type is dependent on the
-  /// underlying implementation of the socket layer.
-#if defined(GENERATING_DOCUMENTATION)
-  typedef implementation_defined data_type;
-#else
-  typedef asio::detail::socket_addr_type data_type;
-#endif
-
-  /// Default constructor.
-  basic_endpoint()
-  {
-  }
-
-  /// Construct an endpoint from the specified socket address.
-  basic_endpoint(const void* socket_address,
-      std::size_t socket_address_size, int socket_protocol = 0)
-    : impl_(socket_address, socket_address_size, socket_protocol)
-  {
-  }
-
-  /// Construct an endpoint from the specific endpoint type.
-  template <typename Endpoint>
-  basic_endpoint(const Endpoint& endpoint)
-    : impl_(endpoint.data(), endpoint.size(), endpoint.protocol().protocol())
-  {
-  }
-
-  /// Copy constructor.
-  basic_endpoint(const basic_endpoint& other)
-    : impl_(other.impl_)
-  {
-  }
-
-#if defined(ASIO_HAS_MOVE)
-  /// Move constructor.
-  basic_endpoint(basic_endpoint&& other)
-    : impl_(other.impl_)
-  {
-  }
-#endif // defined(ASIO_HAS_MOVE)
-
-  /// Assign from another endpoint.
-  basic_endpoint& operator=(const basic_endpoint& other)
-  {
-    impl_ = other.impl_;
-    return *this;
-  }
-
-#if defined(ASIO_HAS_MOVE)
-  /// Move-assign from another endpoint.
-  basic_endpoint& operator=(basic_endpoint&& other)
-  {
-    impl_ = other.impl_;
-    return *this;
-  }
-#endif // defined(ASIO_HAS_MOVE)
-
-  /// The protocol associated with the endpoint.
-  protocol_type protocol() const
-  {
-    return protocol_type(impl_.family(), impl_.protocol());
-  }
-
-  /// Get the underlying endpoint in the native type.
-  data_type* data()
-  {
-    return impl_.data();
-  }
-
-  /// Get the underlying endpoint in the native type.
-  const data_type* data() const
-  {
-    return impl_.data();
-  }
-
-  /// Get the underlying size of the endpoint in the native type.
-  std::size_t size() const
-  {
-    return impl_.size();
-  }
-
-  /// Set the underlying size of the endpoint in the native type.
-  void resize(std::size_t new_size)
-  {
-    impl_.resize(new_size);
-  }
-
-  /// Get the capacity of the endpoint in the native type.
-  std::size_t capacity() const
-  {
-    return impl_.capacity();
-  }
-
-  /// Compare two endpoints for equality.
-  friend bool operator==(const basic_endpoint<Protocol>& e1,
-      const basic_endpoint<Protocol>& e2)
-  {
-    return e1.impl_ == e2.impl_;
-  }
-
-  /// Compare two endpoints for inequality.
-  friend bool operator!=(const basic_endpoint<Protocol>& e1,
-      const basic_endpoint<Protocol>& e2)
-  {
-    return !(e1.impl_ == e2.impl_);
-  }
-
-  /// Compare endpoints for ordering.
-  friend bool operator<(const basic_endpoint<Protocol>& e1,
-      const basic_endpoint<Protocol>& e2)
-  {
-    return e1.impl_ < e2.impl_;
-  }
-
-  /// Compare endpoints for ordering.
-  friend bool operator>(const basic_endpoint<Protocol>& e1,
-      const basic_endpoint<Protocol>& e2)
-  {
-    return e2.impl_ < e1.impl_;
-  }
-
-  /// Compare endpoints for ordering.
-  friend bool operator<=(const basic_endpoint<Protocol>& e1,
-      const basic_endpoint<Protocol>& e2)
-  {
-    return !(e2 < e1);
-  }
-
-  /// Compare endpoints for ordering.
-  friend bool operator>=(const basic_endpoint<Protocol>& e1,
-      const basic_endpoint<Protocol>& e2)
-  {
-    return !(e1 < e2);
-  }
-
-private:
-  // The underlying generic endpoint.
-  asio::generic::detail::endpoint impl_;
-};
-
-} // namespace generic
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_GENERIC_BASIC_ENDPOINT_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/generic/datagram_protocol.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/generic/datagram_protocol.hpp
deleted file mode 100644
index 2c49156ba593..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/generic/datagram_protocol.hpp
+++ /dev/null
@@ -1,123 +0,0 @@
-//
-// generic/datagram_protocol.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_GENERIC_DATAGRAM_PROTOCOL_HPP
-#define ASIO_GENERIC_DATAGRAM_PROTOCOL_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#include <typeinfo>
-#include "asio/basic_datagram_socket.hpp"
-#include "asio/detail/socket_types.hpp"
-#include "asio/detail/throw_exception.hpp"
-#include "asio/generic/basic_endpoint.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace generic {
-
-/// Encapsulates the flags needed for a generic datagram-oriented socket.
-/**
- * The asio::generic::datagram_protocol class contains flags necessary
- * for datagram-oriented sockets of any address family and protocol.
- *
- * @par Examples
- * Constructing using a native address family and socket protocol:
- * @code datagram_protocol p(AF_INET, IPPROTO_UDP); @endcode
- * Constructing from a specific protocol type:
- * @code datagram_protocol p(asio::ip::udp::v4()); @endcode
- *
- * @par Thread Safety
- * @e Distinct @e objects: Safe.@n
- * @e Shared @e objects: Safe.
- *
- * @par Concepts:
- * Protocol.
- */
-class datagram_protocol
-{
-public:
-  /// Construct a protocol object for a specific address family and protocol.
-  datagram_protocol(int address_family, int socket_protocol)
-    : family_(address_family),
-      protocol_(socket_protocol)
-  {
-  }
-
-  /// Construct a generic protocol object from a specific protocol.
-  /**
-   * @throws @c bad_cast Thrown if the source protocol is not datagram-oriented.
-   */
-  template <typename Protocol>
-  datagram_protocol(const Protocol& source_protocol)
-    : family_(source_protocol.family()),
-      protocol_(source_protocol.protocol())
-  {
-    if (source_protocol.type() != type())
-    {
-      std::bad_cast ex;
-      asio::detail::throw_exception(ex);
-    }
-  }
-
-  /// Obtain an identifier for the type of the protocol.
-  int type() const
-  {
-    return ASIO_OS_DEF(SOCK_DGRAM);
-  }
-
-  /// Obtain an identifier for the protocol.
-  int protocol() const
-  {
-    return protocol_;
-  }
-
-  /// Obtain an identifier for the protocol family.
-  int family() const
-  {
-    return family_;
-  }
-
-  /// Compare two protocols for equality.
-  friend bool operator==(const datagram_protocol& p1,
-      const datagram_protocol& p2)
-  {
-    return p1.family_ == p2.family_ && p1.protocol_ == p2.protocol_;
-  }
-
-  /// Compare two protocols for inequality.
-  friend bool operator!=(const datagram_protocol& p1,
-      const datagram_protocol& p2)
-  {
-    return !(p1 == p2);
-  }
-
-  /// The type of an endpoint.
-  typedef basic_endpoint<datagram_protocol> endpoint;
-
-  /// The generic socket type.
-  typedef basic_datagram_socket<datagram_protocol> socket;
-
-private:
-  int family_;
-  int protocol_;
-};
-
-} // namespace generic
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_GENERIC_DATAGRAM_PROTOCOL_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/generic/detail/endpoint.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/generic/detail/endpoint.hpp
deleted file mode 100644
index 830067c2109f..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/generic/detail/endpoint.hpp
+++ /dev/null
@@ -1,133 +0,0 @@
-//
-// generic/detail/endpoint.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_GENERIC_DETAIL_ENDPOINT_HPP
-#define ASIO_GENERIC_DETAIL_ENDPOINT_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#include <cstddef>
-#include "asio/detail/socket_types.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace generic {
-namespace detail {
-
-// Helper class for implementing a generic socket endpoint.
-class endpoint
-{
-public:
-  // Default constructor.
-  ASIO_DECL endpoint();
-
-  // Construct an endpoint from the specified raw bytes.
-  ASIO_DECL endpoint(const void* sock_addr,
-      std::size_t sock_addr_size, int sock_protocol);
-
-  // Copy constructor.
-  endpoint(const endpoint& other)
-    : data_(other.data_),
-      size_(other.size_),
-      protocol_(other.protocol_)
-  {
-  }
-
-  // Assign from another endpoint.
-  endpoint& operator=(const endpoint& other)
-  {
-    data_ = other.data_;
-    size_ = other.size_;
-    protocol_ = other.protocol_;
-    return *this;
-  }
-
-  // Get the address family associated with the endpoint.
-  int family() const
-  {
-    return data_.base.sa_family;
-  }
-
-  // Get the socket protocol associated with the endpoint.
-  int protocol() const
-  {
-    return protocol_;
-  }
-
-  // Get the underlying endpoint in the native type.
-  asio::detail::socket_addr_type* data()
-  {
-    return &data_.base;
-  }
-
-  // Get the underlying endpoint in the native type.
-  const asio::detail::socket_addr_type* data() const
-  {
-    return &data_.base;
-  }
-
-  // Get the underlying size of the endpoint in the native type.
-  std::size_t size() const
-  {
-    return size_;
-  }
-
-  // Set the underlying size of the endpoint in the native type.
-  ASIO_DECL void resize(std::size_t size);
-
-  // Get the capacity of the endpoint in the native type.
-  std::size_t capacity() const
-  {
-    return sizeof(asio::detail::sockaddr_storage_type);
-  }
-
-  // Compare two endpoints for equality.
-  ASIO_DECL friend bool operator==(
-      const endpoint& e1, const endpoint& e2);
-
-  // Compare endpoints for ordering.
-  ASIO_DECL friend bool operator<(
-      const endpoint& e1, const endpoint& e2);
-
-private:
-  // The underlying socket address.
-  union data_union
-  {
-    asio::detail::socket_addr_type base;
-    asio::detail::sockaddr_storage_type generic;
-  } data_;
-
-  // The length of the socket address stored in the endpoint.
-  std::size_t size_;
-
-  // The socket protocol associated with the endpoint.
-  int protocol_;
-
-  // Initialise with a specified memory.
-  ASIO_DECL void init(const void* sock_addr,
-      std::size_t sock_addr_size, int sock_protocol);
-};
-
-} // namespace detail
-} // namespace generic
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#if defined(ASIO_HEADER_ONLY)
-# include "asio/generic/detail/impl/endpoint.ipp"
-#endif // defined(ASIO_HEADER_ONLY)
-
-#endif // ASIO_GENERIC_DETAIL_ENDPOINT_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/generic/detail/impl/endpoint.ipp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/generic/detail/impl/endpoint.ipp
deleted file mode 100644
index 828764f813eb..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/generic/detail/impl/endpoint.ipp
+++ /dev/null
@@ -1,109 +0,0 @@
-//
-// generic/detail/impl/endpoint.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_GENERIC_DETAIL_IMPL_ENDPOINT_IPP
-#define ASIO_GENERIC_DETAIL_IMPL_ENDPOINT_IPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#include <cstring>
-#include <typeinfo>
-#include "asio/detail/socket_ops.hpp"
-#include "asio/detail/throw_error.hpp"
-#include "asio/detail/throw_exception.hpp"
-#include "asio/error.hpp"
-#include "asio/generic/detail/endpoint.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace generic {
-namespace detail {
-
-endpoint::endpoint()
-{
-  init(0, 0, 0);
-}
-
-endpoint::endpoint(const void* sock_addr,
-    std::size_t sock_addr_size, int sock_protocol)
-{
-  init(sock_addr, sock_addr_size, sock_protocol);
-}
-
-void endpoint::resize(std::size_t new_size)
-{
-  if (new_size > sizeof(asio::detail::sockaddr_storage_type))
-  {
-    asio::error_code ec(asio::error::invalid_argument);
-    asio::detail::throw_error(ec);
-  }
-  else
-  {
-    size_ = new_size;
-    protocol_ = 0;
-  }
-}
-
-bool operator==(const endpoint& e1, const endpoint& e2)
-{
-  using namespace std; // For memcmp.
-  return e1.size() == e2.size() && memcmp(e1.data(), e2.data(), e1.size()) == 0;
-}
-
-bool operator<(const endpoint& e1, const endpoint& e2)
-{
-  if (e1.protocol() < e2.protocol())
-    return true;
-
-  if (e1.protocol() > e2.protocol())
-    return false;
-
-  using namespace std; // For memcmp.
-  std::size_t compare_size = e1.size() < e2.size() ? e1.size() : e2.size();
-  int compare_result = memcmp(e1.data(), e2.data(), compare_size);
-
-  if (compare_result < 0)
-    return true;
-
-  if (compare_result > 0)
-    return false;
-
-  return e1.size() < e2.size();
-}
-
-void endpoint::init(const void* sock_addr,
-    std::size_t sock_addr_size, int sock_protocol)
-{
-  if (sock_addr_size > sizeof(asio::detail::sockaddr_storage_type))
-  {
-    asio::error_code ec(asio::error::invalid_argument);
-    asio::detail::throw_error(ec);
-  }
-
-  using namespace std; // For memset and memcpy.
-  memset(&data_.generic, 0, sizeof(asio::detail::sockaddr_storage_type));
-  memcpy(&data_.generic, sock_addr, sock_addr_size);
-
-  size_ = sock_addr_size;
-  protocol_ = sock_protocol;
-}
-
-} // namespace detail
-} // namespace generic
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_GENERIC_DETAIL_IMPL_ENDPOINT_IPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/generic/raw_protocol.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/generic/raw_protocol.hpp
deleted file mode 100644
index 974f36135913..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/generic/raw_protocol.hpp
+++ /dev/null
@@ -1,121 +0,0 @@
-//
-// generic/raw_protocol.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_GENERIC_RAW_PROTOCOL_HPP
-#define ASIO_GENERIC_RAW_PROTOCOL_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#include <typeinfo>
-#include "asio/basic_raw_socket.hpp"
-#include "asio/detail/socket_types.hpp"
-#include "asio/detail/throw_exception.hpp"
-#include "asio/generic/basic_endpoint.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace generic {
-
-/// Encapsulates the flags needed for a generic raw socket.
-/**
- * The asio::generic::raw_protocol class contains flags necessary for
- * raw sockets of any address family and protocol.
- *
- * @par Examples
- * Constructing using a native address family and socket protocol:
- * @code raw_protocol p(AF_INET, IPPROTO_ICMP); @endcode
- * Constructing from a specific protocol type:
- * @code raw_protocol p(asio::ip::icmp::v4()); @endcode
- *
- * @par Thread Safety
- * @e Distinct @e objects: Safe.@n
- * @e Shared @e objects: Safe.
- *
- * @par Concepts:
- * Protocol.
- */
-class raw_protocol
-{
-public:
-  /// Construct a protocol object for a specific address family and protocol.
-  raw_protocol(int address_family, int socket_protocol)
-    : family_(address_family),
-      protocol_(socket_protocol)
-  {
-  }
-
-  /// Construct a generic protocol object from a specific protocol.
-  /**
-   * @throws @c bad_cast Thrown if the source protocol is not raw-oriented.
-   */
-  template <typename Protocol>
-  raw_protocol(const Protocol& source_protocol)
-    : family_(source_protocol.family()),
-      protocol_(source_protocol.protocol())
-  {
-    if (source_protocol.type() != type())
-    {
-      std::bad_cast ex;
-      asio::detail::throw_exception(ex);
-    }
-  }
-
-  /// Obtain an identifier for the type of the protocol.
-  int type() const
-  {
-    return ASIO_OS_DEF(SOCK_RAW);
-  }
-
-  /// Obtain an identifier for the protocol.
-  int protocol() const
-  {
-    return protocol_;
-  }
-
-  /// Obtain an identifier for the protocol family.
-  int family() const
-  {
-    return family_;
-  }
-
-  /// Compare two protocols for equality.
-  friend bool operator==(const raw_protocol& p1, const raw_protocol& p2)
-  {
-    return p1.family_ == p2.family_ && p1.protocol_ == p2.protocol_;
-  }
-
-  /// Compare two protocols for inequality.
-  friend bool operator!=(const raw_protocol& p1, const raw_protocol& p2)
-  {
-    return !(p1 == p2);
-  }
-
-  /// The type of an endpoint.
-  typedef basic_endpoint<raw_protocol> endpoint;
-
-  /// The generic socket type.
-  typedef basic_raw_socket<raw_protocol> socket;
-
-private:
-  int family_;
-  int protocol_;
-};
-
-} // namespace generic
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_GENERIC_RAW_PROTOCOL_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/generic/seq_packet_protocol.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/generic/seq_packet_protocol.hpp
deleted file mode 100644
index 10186d5d98fa..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/generic/seq_packet_protocol.hpp
+++ /dev/null
@@ -1,122 +0,0 @@
-//
-// generic/seq_packet_protocol.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_GENERIC_SEQ_PACKET_PROTOCOL_HPP
-#define ASIO_GENERIC_SEQ_PACKET_PROTOCOL_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#include <typeinfo>
-#include "asio/basic_seq_packet_socket.hpp"
-#include "asio/detail/socket_types.hpp"
-#include "asio/detail/throw_exception.hpp"
-#include "asio/generic/basic_endpoint.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace generic {
-
-/// Encapsulates the flags needed for a generic sequenced packet socket.
-/**
- * The asio::generic::seq_packet_protocol class contains flags necessary
- * for seq_packet-oriented sockets of any address family and protocol.
- *
- * @par Examples
- * Constructing using a native address family and socket protocol:
- * @code seq_packet_protocol p(AF_INET, IPPROTO_SCTP); @endcode
- *
- * @par Thread Safety
- * @e Distinct @e objects: Safe.@n
- * @e Shared @e objects: Safe.
- *
- * @par Concepts:
- * Protocol.
- */
-class seq_packet_protocol
-{
-public:
-  /// Construct a protocol object for a specific address family and protocol.
-  seq_packet_protocol(int address_family, int socket_protocol)
-    : family_(address_family),
-      protocol_(socket_protocol)
-  {
-  }
-
-  /// Construct a generic protocol object from a specific protocol.
-  /**
-   * @throws @c bad_cast Thrown if the source protocol is not based around
-   * sequenced packets.
-   */
-  template <typename Protocol>
-  seq_packet_protocol(const Protocol& source_protocol)
-    : family_(source_protocol.family()),
-      protocol_(source_protocol.protocol())
-  {
-    if (source_protocol.type() != type())
-    {
-      std::bad_cast ex;
-      asio::detail::throw_exception(ex);
-    }
-  }
-
-  /// Obtain an identifier for the type of the protocol.
-  int type() const
-  {
-    return ASIO_OS_DEF(SOCK_SEQPACKET);
-  }
-
-  /// Obtain an identifier for the protocol.
-  int protocol() const
-  {
-    return protocol_;
-  }
-
-  /// Obtain an identifier for the protocol family.
-  int family() const
-  {
-    return family_;
-  }
-
-  /// Compare two protocols for equality.
-  friend bool operator==(const seq_packet_protocol& p1,
-      const seq_packet_protocol& p2)
-  {
-    return p1.family_ == p2.family_ && p1.protocol_ == p2.protocol_;
-  }
-
-  /// Compare two protocols for inequality.
-  friend bool operator!=(const seq_packet_protocol& p1,
-      const seq_packet_protocol& p2)
-  {
-    return !(p1 == p2);
-  }
-
-  /// The type of an endpoint.
-  typedef basic_endpoint<seq_packet_protocol> endpoint;
-
-  /// The generic socket type.
-  typedef basic_seq_packet_socket<seq_packet_protocol> socket;
-
-private:
-  int family_;
-  int protocol_;
-};
-
-} // namespace generic
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_GENERIC_SEQ_PACKET_PROTOCOL_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/generic/stream_protocol.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/generic/stream_protocol.hpp
deleted file mode 100644
index 25ff68189a7c..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/generic/stream_protocol.hpp
+++ /dev/null
@@ -1,127 +0,0 @@
-//
-// generic/stream_protocol.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_GENERIC_STREAM_PROTOCOL_HPP
-#define ASIO_GENERIC_STREAM_PROTOCOL_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#include <typeinfo>
-#include "asio/basic_socket_iostream.hpp"
-#include "asio/basic_stream_socket.hpp"
-#include "asio/detail/socket_types.hpp"
-#include "asio/detail/throw_exception.hpp"
-#include "asio/generic/basic_endpoint.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace generic {
-
-/// Encapsulates the flags needed for a generic stream-oriented socket.
-/**
- * The asio::generic::stream_protocol class contains flags necessary for
- * stream-oriented sockets of any address family and protocol.
- *
- * @par Examples
- * Constructing using a native address family and socket protocol:
- * @code stream_protocol p(AF_INET, IPPROTO_TCP); @endcode
- * Constructing from a specific protocol type:
- * @code stream_protocol p(asio::ip::tcp::v4()); @endcode
- *
- * @par Thread Safety
- * @e Distinct @e objects: Safe.@n
- * @e Shared @e objects: Safe.
- *
- * @par Concepts:
- * Protocol.
- */
-class stream_protocol
-{
-public:
-  /// Construct a protocol object for a specific address family and protocol.
-  stream_protocol(int address_family, int socket_protocol)
-    : family_(address_family),
-      protocol_(socket_protocol)
-  {
-  }
-
-  /// Construct a generic protocol object from a specific protocol.
-  /**
-   * @throws @c bad_cast Thrown if the source protocol is not stream-oriented.
-   */
-  template <typename Protocol>
-  stream_protocol(const Protocol& source_protocol)
-    : family_(source_protocol.family()),
-      protocol_(source_protocol.protocol())
-  {
-    if (source_protocol.type() != type())
-    {
-      std::bad_cast ex;
-      asio::detail::throw_exception(ex);
-    }
-  }
-
-  /// Obtain an identifier for the type of the protocol.
-  int type() const
-  {
-    return ASIO_OS_DEF(SOCK_STREAM);
-  }
-
-  /// Obtain an identifier for the protocol.
-  int protocol() const
-  {
-    return protocol_;
-  }
-
-  /// Obtain an identifier for the protocol family.
-  int family() const
-  {
-    return family_;
-  }
-
-  /// Compare two protocols for equality.
-  friend bool operator==(const stream_protocol& p1, const stream_protocol& p2)
-  {
-    return p1.family_ == p2.family_ && p1.protocol_ == p2.protocol_;
-  }
-
-  /// Compare two protocols for inequality.
-  friend bool operator!=(const stream_protocol& p1, const stream_protocol& p2)
-  {
-    return !(p1 == p2);
-  }
-
-  /// The type of an endpoint.
-  typedef basic_endpoint<stream_protocol> endpoint;
-
-  /// The generic socket type.
-  typedef basic_stream_socket<stream_protocol> socket;
-
-#if !defined(ASIO_NO_IOSTREAM)
-  /// The generic socket iostream type.
-  typedef basic_socket_iostream<stream_protocol> iostream;
-#endif // !defined(ASIO_NO_IOSTREAM)
-
-private:
-  int family_;
-  int protocol_;
-};
-
-} // namespace generic
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_GENERIC_STREAM_PROTOCOL_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/handler_alloc_hook.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/handler_alloc_hook.hpp
deleted file mode 100644
index 3e101419cf79..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/handler_alloc_hook.hpp
+++ /dev/null
@@ -1,81 +0,0 @@
-//
-// handler_alloc_hook.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_HANDLER_ALLOC_HOOK_HPP
-#define ASIO_HANDLER_ALLOC_HOOK_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include <cstddef>
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-
-/// Default allocation function for handlers.
-/**
- * Asynchronous operations may need to allocate temporary objects. Since
- * asynchronous operations have a handler function object, these temporary
- * objects can be said to be associated with the handler.
- *
- * Implement asio_handler_allocate and asio_handler_deallocate for your own
- * handlers to provide custom allocation for these temporary objects.
- *
- * The default implementation of these allocation hooks uses <tt>::operator
- * new</tt> and <tt>::operator delete</tt>.
- *
- * @note All temporary objects associated with a handler will be deallocated
- * before the upcall to the handler is performed. This allows the same memory to
- * be reused for a subsequent asynchronous operation initiated by the handler.
- *
- * @par Example
- * @code
- * class my_handler;
- *
- * void* asio_handler_allocate(std::size_t size, my_handler* context)
- * {
- *   return ::operator new(size);
- * }
- *
- * void asio_handler_deallocate(void* pointer, std::size_t size,
- *     my_handler* context)
- * {
- *   ::operator delete(pointer);
- * }
- * @endcode
- */
-ASIO_DECL void* asio_handler_allocate(
-    std::size_t size, ...);
-
-/// Default deallocation function for handlers.
-/**
- * Implement asio_handler_allocate and asio_handler_deallocate for your own
- * handlers to provide custom allocation for the associated temporary objects.
- *
- * The default implementation of these allocation hooks uses <tt>::operator
- * new</tt> and <tt>::operator delete</tt>.
- *
- * @sa asio_handler_allocate.
- */
-ASIO_DECL void asio_handler_deallocate(
-    void* pointer, std::size_t size, ...);
-
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#if defined(ASIO_HEADER_ONLY)
-# include "asio/impl/handler_alloc_hook.ipp"
-#endif // defined(ASIO_HEADER_ONLY)
-
-#endif // ASIO_HANDLER_ALLOC_HOOK_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/handler_continuation_hook.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/handler_continuation_hook.hpp
deleted file mode 100644
index e1944320fd38..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/handler_continuation_hook.hpp
+++ /dev/null
@@ -1,54 +0,0 @@
-//
-// handler_continuation_hook.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_HANDLER_CONTINUATION_HOOK_HPP
-#define ASIO_HANDLER_CONTINUATION_HOOK_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-
-/// Default continuation function for handlers.
-/**
- * Asynchronous operations may represent a continuation of the asynchronous
- * control flow associated with the current handler. The implementation can use
- * this knowledge to optimise scheduling of the handler.
- *
- * Implement asio_handler_is_continuation for your own handlers to indicate
- * when a handler represents a continuation.
- *
- * The default implementation of the continuation hook returns <tt>false</tt>.
- *
- * @par Example
- * @code
- * class my_handler;
- *
- * bool asio_handler_is_continuation(my_handler* context)
- * {
- *   return true;
- * }
- * @endcode
- */
-inline bool asio_handler_is_continuation(...)
-{
-  return false;
-}
-
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_HANDLER_CONTINUATION_HOOK_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/handler_invoke_hook.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/handler_invoke_hook.hpp
deleted file mode 100644
index 435fa2267b45..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/handler_invoke_hook.hpp
+++ /dev/null
@@ -1,85 +0,0 @@
-//
-// handler_invoke_hook.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_HANDLER_INVOKE_HOOK_HPP
-#define ASIO_HANDLER_INVOKE_HOOK_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-
-/** @defgroup asio_handler_invoke asio::asio_handler_invoke
- *
- * @brief Default invoke function for handlers.
- *
- * Completion handlers for asynchronous operations are invoked by the
- * io_service associated with the corresponding object (e.g. a socket or
- * deadline_timer). Certain guarantees are made on when the handler may be
- * invoked, in particular that a handler can only be invoked from a thread that
- * is currently calling @c run() on the corresponding io_service object.
- * Handlers may subsequently be invoked through other objects (such as
- * io_service::strand objects) that provide additional guarantees.
- *
- * When asynchronous operations are composed from other asynchronous
- * operations, all intermediate handlers should be invoked using the same
- * method as the final handler. This is required to ensure that user-defined
- * objects are not accessed in a way that may violate the guarantees. This
- * hooking function ensures that the invoked method used for the final handler
- * is accessible at each intermediate step.
- *
- * Implement asio_handler_invoke for your own handlers to specify a custom
- * invocation strategy.
- *
- * This default implementation invokes the function object like so:
- * @code function(); @endcode
- * If necessary, the default implementation makes a copy of the function object
- * so that the non-const operator() can be used.
- *
- * @par Example
- * @code
- * class my_handler;
- *
- * template <typename Function>
- * void asio_handler_invoke(Function function, my_handler* context)
- * {
- *   context->strand_.dispatch(function);
- * }
- * @endcode
- */
-/*@{*/
-
-/// Default handler invocation hook used for non-const function objects.
-template <typename Function>
-inline void asio_handler_invoke(Function& function, ...)
-{
-  function();
-}
-
-/// Default handler invocation hook used for const function objects.
-template <typename Function>
-inline void asio_handler_invoke(const Function& function, ...)
-{
-  Function tmp(function);
-  tmp();
-}
-
-/*@}*/
-
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_HANDLER_INVOKE_HOOK_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/handler_type.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/handler_type.hpp
deleted file mode 100644
index b70d7ec9a3e6..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/handler_type.hpp
+++ /dev/null
@@ -1,112 +0,0 @@
-//
-// handler_type.hpp
-// ~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_HANDLER_TYPE_HPP
-#define ASIO_HANDLER_TYPE_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-
-/// Default handler type traits provided for all handlers.
-/**
- * The handler_type traits class is used for determining the concrete handler
- * type to be used for an asynchronous operation. It allows the handler type to
- * be determined at the point where the specific completion handler signature
- * is known.
- *
- * This template may be specialised for user-defined handler types.
- */
-template <typename Handler, typename Signature>
-struct handler_type
-{
-  /// The handler type for the specific signature.
-  typedef Handler type;
-};
-
-#if !defined(GENERATING_DOCUMENTATION)
-
-template <typename Handler, typename Signature>
-struct handler_type<const Handler, Signature>
-  : handler_type<Handler, Signature> {};
-
-template <typename Handler, typename Signature>
-struct handler_type<volatile Handler, Signature>
-  : handler_type<Handler, Signature> {};
-
-template <typename Handler, typename Signature>
-struct handler_type<const volatile Handler, Signature>
-  : handler_type<Handler, Signature> {};
-
-template <typename Handler, typename Signature>
-struct handler_type<const Handler&, Signature>
-  : handler_type<Handler, Signature> {};
-
-template <typename Handler, typename Signature>
-struct handler_type<volatile Handler&, Signature>
-  : handler_type<Handler, Signature> {};
-
-template <typename Handler, typename Signature>
-struct handler_type<const volatile Handler&, Signature>
-  : handler_type<Handler, Signature> {};
-
-template <typename Handler, typename Signature>
-struct handler_type<Handler&, Signature>
-  : handler_type<Handler, Signature> {};
-
-#if defined(ASIO_HAS_MOVE)
-template <typename Handler, typename Signature>
-struct handler_type<Handler&&, Signature>
-  : handler_type<Handler, Signature> {};
-#endif // defined(ASIO_HAS_MOVE)
-
-template <typename ReturnType, typename Signature>
-struct handler_type<ReturnType(), Signature>
-  : handler_type<ReturnType(*)(), Signature> {};
-
-template <typename ReturnType, typename Arg1, typename Signature>
-struct handler_type<ReturnType(Arg1), Signature>
-  : handler_type<ReturnType(*)(Arg1), Signature> {};
-
-template <typename ReturnType, typename Arg1, typename Arg2, typename Signature>
-struct handler_type<ReturnType(Arg1, Arg2), Signature>
-  : handler_type<ReturnType(*)(Arg1, Arg2), Signature> {};
-
-template <typename ReturnType, typename Arg1, typename Arg2, typename Arg3,
-    typename Signature>
-struct handler_type<ReturnType(Arg1, Arg2, Arg3), Signature>
-  : handler_type<ReturnType(*)(Arg1, Arg2, Arg3), Signature> {};
-
-template <typename ReturnType, typename Arg1, typename Arg2, typename Arg3,
-    typename Arg4, typename Signature>
-struct handler_type<ReturnType(Arg1, Arg2, Arg3, Arg4), Signature>
-  : handler_type<ReturnType(*)(Arg1, Arg2, Arg3, Arg4), Signature> {};
-
-template <typename ReturnType, typename Arg1, typename Arg2, typename Arg3,
-    typename Arg4, typename Arg5, typename Signature>
-struct handler_type<ReturnType(Arg1, Arg2, Arg3, Arg4, Arg5), Signature>
-  : handler_type<ReturnType(*)(Arg1, Arg2, Arg3, Arg4, Arg5), Signature> {};
-
-#endif // !defined(GENERATING_DOCUMENTATION)
-
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#define ASIO_HANDLER_TYPE(h, sig) \
-  typename handler_type<h, sig>::type
-
-#endif // ASIO_HANDLER_TYPE_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/high_resolution_timer.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/high_resolution_timer.hpp
deleted file mode 100644
index 62b01482b702..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/high_resolution_timer.hpp
+++ /dev/null
@@ -1,63 +0,0 @@
-//
-// high_resolution_timer.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_HIGH_RESOLUTION_TIMER_HPP
-#define ASIO_HIGH_RESOLUTION_TIMER_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_HAS_STD_CHRONO) \
-  || defined(ASIO_HAS_BOOST_CHRONO) \
-  || defined(GENERATING_DOCUMENTATION)
-
-#if defined(ASIO_HAS_STD_CHRONO)
-# include <chrono>
-#elif defined(ASIO_HAS_BOOST_CHRONO)
-# include <boost/chrono/system_clocks.hpp>
-#endif
-
-#include "asio/basic_waitable_timer.hpp"
-
-namespace asio {
-
-#if defined(GENERATING_DOCUMENTATION)
-/// Typedef for a timer based on the high resolution clock.
-/**
- * This typedef uses the C++11 @c &lt;chrono&gt; standard library facility, if
- * available. Otherwise, it may use the Boost.Chrono library. To explicitly
- * utilise Boost.Chrono, use the basic_waitable_timer template directly:
- * @code
- * typedef basic_waitable_timer<boost::chrono::high_resolution_clock> timer;
- * @endcode
- */
-typedef basic_waitable_timer<
-    chrono::high_resolution_clock>
-  high_resolution_timer;
-#elif defined(ASIO_HAS_STD_CHRONO)
-typedef basic_waitable_timer<
-    std::chrono::high_resolution_clock>
-  high_resolution_timer;
-#elif defined(ASIO_HAS_BOOST_CHRONO)
-typedef basic_waitable_timer<
-    boost::chrono::high_resolution_clock>
-  high_resolution_timer;
-#endif
-
-} // namespace asio
-
-#endif // defined(ASIO_HAS_STD_CHRONO) 
-       //   || defined(ASIO_HAS_BOOST_CHRONO)
-       //   || defined(GENERATING_DOCUMENTATION)
-
-#endif // ASIO_HIGH_RESOLUTION_TIMER_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/impl/buffered_read_stream.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/impl/buffered_read_stream.hpp
deleted file mode 100644
index 3c02b4fc7bbd..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/impl/buffered_read_stream.hpp
+++ /dev/null
@@ -1,358 +0,0 @@
-//
-// impl/buffered_read_stream.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_IMPL_BUFFERED_READ_STREAM_HPP
-#define ASIO_IMPL_BUFFERED_READ_STREAM_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/handler_alloc_helpers.hpp"
-#include "asio/detail/handler_cont_helpers.hpp"
-#include "asio/detail/handler_invoke_helpers.hpp"
-#include "asio/detail/handler_type_requirements.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-
-template <typename Stream>
-std::size_t buffered_read_stream<Stream>::fill()
-{
-  detail::buffer_resize_guard<detail::buffered_stream_storage>
-    resize_guard(storage_);
-  std::size_t previous_size = storage_.size();
-  storage_.resize(storage_.capacity());
-  storage_.resize(previous_size + next_layer_.read_some(buffer(
-          storage_.data() + previous_size,
-          storage_.size() - previous_size)));
-  resize_guard.commit();
-  return storage_.size() - previous_size;
-}
-
-template <typename Stream>
-std::size_t buffered_read_stream<Stream>::fill(asio::error_code& ec)
-{
-  detail::buffer_resize_guard<detail::buffered_stream_storage>
-    resize_guard(storage_);
-  std::size_t previous_size = storage_.size();
-  storage_.resize(storage_.capacity());
-  storage_.resize(previous_size + next_layer_.read_some(buffer(
-          storage_.data() + previous_size,
-          storage_.size() - previous_size),
-        ec));
-  resize_guard.commit();
-  return storage_.size() - previous_size;
-}
-
-namespace detail
-{
-  template <typename ReadHandler>
-  class buffered_fill_handler
-  {
-  public:
-    buffered_fill_handler(detail::buffered_stream_storage& storage,
-        std::size_t previous_size, ReadHandler& handler)
-      : storage_(storage),
-        previous_size_(previous_size),
-        handler_(ASIO_MOVE_CAST(ReadHandler)(handler))
-    {
-    }
-
-#if defined(ASIO_HAS_MOVE)
-    buffered_fill_handler(const buffered_fill_handler& other)
-      : storage_(other.storage_),
-        previous_size_(other.previous_size_),
-        handler_(other.handler_)
-    {
-    }
-
-    buffered_fill_handler(buffered_fill_handler&& other)
-      : storage_(other.storage_),
-        previous_size_(other.previous_size_),
-        handler_(ASIO_MOVE_CAST(ReadHandler)(other.handler_))
-    {
-    }
-#endif // defined(ASIO_HAS_MOVE)
-
-    void operator()(const asio::error_code& ec,
-        const std::size_t bytes_transferred)
-    {
-      storage_.resize(previous_size_ + bytes_transferred);
-      handler_(ec, bytes_transferred);
-    }
-
-  //private:
-    detail::buffered_stream_storage& storage_;
-    std::size_t previous_size_;
-    ReadHandler handler_;
-  };
-
-  template <typename ReadHandler>
-  inline void* asio_handler_allocate(std::size_t size,
-      buffered_fill_handler<ReadHandler>* this_handler)
-  {
-    return asio_handler_alloc_helpers::allocate(
-        size, this_handler->handler_);
-  }
-
-  template <typename ReadHandler>
-  inline void asio_handler_deallocate(void* pointer, std::size_t size,
-      buffered_fill_handler<ReadHandler>* this_handler)
-  {
-    asio_handler_alloc_helpers::deallocate(
-        pointer, size, this_handler->handler_);
-  }
-
-  template <typename ReadHandler>
-  inline bool asio_handler_is_continuation(
-      buffered_fill_handler<ReadHandler>* this_handler)
-  {
-    return asio_handler_cont_helpers::is_continuation(
-          this_handler->handler_);
-  }
-
-  template <typename Function, typename ReadHandler>
-  inline void asio_handler_invoke(Function& function,
-      buffered_fill_handler<ReadHandler>* this_handler)
-  {
-    asio_handler_invoke_helpers::invoke(
-        function, this_handler->handler_);
-  }
-
-  template <typename Function, typename ReadHandler>
-  inline void asio_handler_invoke(const Function& function,
-      buffered_fill_handler<ReadHandler>* this_handler)
-  {
-    asio_handler_invoke_helpers::invoke(
-        function, this_handler->handler_);
-  }
-} // namespace detail
-
-template <typename Stream>
-template <typename ReadHandler>
-ASIO_INITFN_RESULT_TYPE(ReadHandler,
-    void (asio::error_code, std::size_t))
-buffered_read_stream<Stream>::async_fill(
-    ASIO_MOVE_ARG(ReadHandler) handler)
-{
-  // If you get an error on the following line it means that your handler does
-  // not meet the documented type requirements for a ReadHandler.
-  ASIO_READ_HANDLER_CHECK(ReadHandler, handler) type_check;
-
-  detail::async_result_init<
-    ReadHandler, void (asio::error_code, std::size_t)> init(
-      ASIO_MOVE_CAST(ReadHandler)(handler));
-
-  std::size_t previous_size = storage_.size();
-  storage_.resize(storage_.capacity());
-  next_layer_.async_read_some(
-      buffer(
-        storage_.data() + previous_size,
-        storage_.size() - previous_size),
-      detail::buffered_fill_handler<ASIO_HANDLER_TYPE(
-        ReadHandler, void (asio::error_code, std::size_t))>(
-        storage_, previous_size, init.handler));
-
-  return init.result.get();
-}
-
-template <typename Stream>
-template <typename MutableBufferSequence>
-std::size_t buffered_read_stream<Stream>::read_some(
-    const MutableBufferSequence& buffers)
-{
-  if (asio::buffer_size(buffers) == 0)
-    return 0;
-
-  if (storage_.empty())
-    this->fill();
-
-  return this->copy(buffers);
-}
-
-template <typename Stream>
-template <typename MutableBufferSequence>
-std::size_t buffered_read_stream<Stream>::read_some(
-    const MutableBufferSequence& buffers, asio::error_code& ec)
-{
-  ec = asio::error_code();
-
-  if (asio::buffer_size(buffers) == 0)
-    return 0;
-
-  if (storage_.empty() && !this->fill(ec))
-    return 0;
-
-  return this->copy(buffers);
-}
-
-namespace detail
-{
-  template <typename MutableBufferSequence, typename ReadHandler>
-  class buffered_read_some_handler
-  {
-  public:
-    buffered_read_some_handler(detail::buffered_stream_storage& storage,
-        const MutableBufferSequence& buffers, ReadHandler& handler)
-      : storage_(storage),
-        buffers_(buffers),
-        handler_(handler)
-    {
-    }
-
-#if defined(ASIO_HAS_MOVE)
-      buffered_read_some_handler(const buffered_read_some_handler& other)
-        : storage_(other.storage_),
-          buffers_(other.buffers_),
-          handler_(other.handler_)
-      {
-      }
-
-      buffered_read_some_handler(buffered_read_some_handler&& other)
-        : storage_(other.storage_),
-          buffers_(other.buffers_),
-          handler_(ASIO_MOVE_CAST(ReadHandler)(other.handler_))
-      {
-      }
-#endif // defined(ASIO_HAS_MOVE)
-
-    void operator()(const asio::error_code& ec, std::size_t)
-    {
-      if (ec || storage_.empty())
-      {
-        const std::size_t length = 0;
-        handler_(ec, length);
-      }
-      else
-      {
-        const std::size_t bytes_copied = asio::buffer_copy(
-            buffers_, storage_.data(), storage_.size());
-        storage_.consume(bytes_copied);
-        handler_(ec, bytes_copied);
-      }
-    }
-
-  //private:
-    detail::buffered_stream_storage& storage_;
-    MutableBufferSequence buffers_;
-    ReadHandler handler_;
-  };
-
-  template <typename MutableBufferSequence, typename ReadHandler>
-  inline void* asio_handler_allocate(std::size_t size,
-      buffered_read_some_handler<
-        MutableBufferSequence, ReadHandler>* this_handler)
-  {
-    return asio_handler_alloc_helpers::allocate(
-        size, this_handler->handler_);
-  }
-
-  template <typename MutableBufferSequence, typename ReadHandler>
-  inline void asio_handler_deallocate(void* pointer, std::size_t size,
-      buffered_read_some_handler<
-        MutableBufferSequence, ReadHandler>* this_handler)
-  {
-    asio_handler_alloc_helpers::deallocate(
-        pointer, size, this_handler->handler_);
-  }
-
-  template <typename MutableBufferSequence, typename ReadHandler>
-  inline bool asio_handler_is_continuation(
-      buffered_read_some_handler<
-        MutableBufferSequence, ReadHandler>* this_handler)
-  {
-    return asio_handler_cont_helpers::is_continuation(
-          this_handler->handler_);
-  }
-
-  template <typename Function, typename MutableBufferSequence,
-      typename ReadHandler>
-  inline void asio_handler_invoke(Function& function,
-      buffered_read_some_handler<
-        MutableBufferSequence, ReadHandler>* this_handler)
-  {
-    asio_handler_invoke_helpers::invoke(
-        function, this_handler->handler_);
-  }
-
-  template <typename Function, typename MutableBufferSequence,
-      typename ReadHandler>
-  inline void asio_handler_invoke(const Function& function,
-      buffered_read_some_handler<
-        MutableBufferSequence, ReadHandler>* this_handler)
-  {
-    asio_handler_invoke_helpers::invoke(
-        function, this_handler->handler_);
-  }
-} // namespace detail
-
-template <typename Stream>
-template <typename MutableBufferSequence, typename ReadHandler>
-ASIO_INITFN_RESULT_TYPE(ReadHandler,
-    void (asio::error_code, std::size_t))
-buffered_read_stream<Stream>::async_read_some(
-    const MutableBufferSequence& buffers,
-    ASIO_MOVE_ARG(ReadHandler) handler)
-{
-  // If you get an error on the following line it means that your handler does
-  // not meet the documented type requirements for a ReadHandler.
-  ASIO_READ_HANDLER_CHECK(ReadHandler, handler) type_check;
-
-  detail::async_result_init<
-    ReadHandler, void (asio::error_code, std::size_t)> init(
-      ASIO_MOVE_CAST(ReadHandler)(handler));
-
-  if (asio::buffer_size(buffers) == 0 || !storage_.empty())
-  {
-    next_layer_.async_read_some(asio::mutable_buffers_1(0, 0),
-        detail::buffered_read_some_handler<
-          MutableBufferSequence, ASIO_HANDLER_TYPE(
-            ReadHandler, void (asio::error_code, std::size_t))>(
-            storage_, buffers, init.handler));
-  }
-  else
-  {
-    this->async_fill(detail::buffered_read_some_handler<
-          MutableBufferSequence, ASIO_HANDLER_TYPE(
-            ReadHandler, void (asio::error_code, std::size_t))>(
-            storage_, buffers, init.handler));
-  }
-
-  return init.result.get();
-}
-
-template <typename Stream>
-template <typename MutableBufferSequence>
-std::size_t buffered_read_stream<Stream>::peek(
-    const MutableBufferSequence& buffers)
-{
-  if (storage_.empty())
-    this->fill();
-  return this->peek_copy(buffers);
-}
-
-template <typename Stream>
-template <typename MutableBufferSequence>
-std::size_t buffered_read_stream<Stream>::peek(
-    const MutableBufferSequence& buffers, asio::error_code& ec)
-{
-  ec = asio::error_code();
-  if (storage_.empty() && !this->fill(ec))
-    return 0;
-  return this->peek_copy(buffers);
-}
-
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_IMPL_BUFFERED_READ_STREAM_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/impl/buffered_write_stream.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/impl/buffered_write_stream.hpp
deleted file mode 100644
index 1e51c1137ed5..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/impl/buffered_write_stream.hpp
+++ /dev/null
@@ -1,338 +0,0 @@
-//
-// impl/buffered_write_stream.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_IMPL_BUFFERED_WRITE_STREAM_HPP
-#define ASIO_IMPL_BUFFERED_WRITE_STREAM_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/handler_alloc_helpers.hpp"
-#include "asio/detail/handler_cont_helpers.hpp"
-#include "asio/detail/handler_invoke_helpers.hpp"
-#include "asio/detail/handler_type_requirements.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-
-template <typename Stream>
-std::size_t buffered_write_stream<Stream>::flush()
-{
-  std::size_t bytes_written = write(next_layer_,
-      buffer(storage_.data(), storage_.size()));
-  storage_.consume(bytes_written);
-  return bytes_written;
-}
-
-template <typename Stream>
-std::size_t buffered_write_stream<Stream>::flush(asio::error_code& ec)
-{
-  std::size_t bytes_written = write(next_layer_,
-      buffer(storage_.data(), storage_.size()),
-      transfer_all(), ec);
-  storage_.consume(bytes_written);
-  return bytes_written;
-}
-
-namespace detail
-{
-  template <typename WriteHandler>
-  class buffered_flush_handler
-  {
-  public:
-    buffered_flush_handler(detail::buffered_stream_storage& storage,
-        WriteHandler& handler)
-      : storage_(storage),
-        handler_(handler)
-    {
-    }
-
-#if defined(ASIO_HAS_MOVE)
-    buffered_flush_handler(const buffered_flush_handler& other)
-      : storage_(other.storage_),
-        handler_(other.handler_)
-    {
-    }
-
-    buffered_flush_handler(buffered_flush_handler&& other)
-      : storage_(other.storage_),
-        handler_(ASIO_MOVE_CAST(WriteHandler)(other.handler_))
-    {
-    }
-#endif // defined(ASIO_HAS_MOVE)
-
-    void operator()(const asio::error_code& ec,
-        const std::size_t bytes_written)
-    {
-      storage_.consume(bytes_written);
-      handler_(ec, bytes_written);
-    }
-
-  //private:
-    detail::buffered_stream_storage& storage_;
-    WriteHandler handler_;
-  };
-
-  template <typename WriteHandler>
-  inline void* asio_handler_allocate(std::size_t size,
-      buffered_flush_handler<WriteHandler>* this_handler)
-  {
-    return asio_handler_alloc_helpers::allocate(
-        size, this_handler->handler_);
-  }
-
-  template <typename WriteHandler>
-  inline void asio_handler_deallocate(void* pointer, std::size_t size,
-      buffered_flush_handler<WriteHandler>* this_handler)
-  {
-    asio_handler_alloc_helpers::deallocate(
-        pointer, size, this_handler->handler_);
-  }
-
-  template <typename WriteHandler>
-  inline bool asio_handler_is_continuation(
-      buffered_flush_handler<WriteHandler>* this_handler)
-  {
-    return asio_handler_cont_helpers::is_continuation(
-          this_handler->handler_);
-  }
-
-  template <typename Function, typename WriteHandler>
-  inline void asio_handler_invoke(Function& function,
-      buffered_flush_handler<WriteHandler>* this_handler)
-  {
-    asio_handler_invoke_helpers::invoke(
-        function, this_handler->handler_);
-  }
-
-  template <typename Function, typename WriteHandler>
-  inline void asio_handler_invoke(const Function& function,
-      buffered_flush_handler<WriteHandler>* this_handler)
-  {
-    asio_handler_invoke_helpers::invoke(
-        function, this_handler->handler_);
-  }
-}
-
-template <typename Stream>
-template <typename WriteHandler>
-ASIO_INITFN_RESULT_TYPE(WriteHandler,
-    void (asio::error_code, std::size_t))
-buffered_write_stream<Stream>::async_flush(
-    ASIO_MOVE_ARG(WriteHandler) handler)
-{
-  // If you get an error on the following line it means that your handler does
-  // not meet the documented type requirements for a WriteHandler.
-  ASIO_WRITE_HANDLER_CHECK(WriteHandler, handler) type_check;
-
-  detail::async_result_init<
-    WriteHandler, void (asio::error_code, std::size_t)> init(
-      ASIO_MOVE_CAST(WriteHandler)(handler));
-
-  async_write(next_layer_, buffer(storage_.data(), storage_.size()),
-      detail::buffered_flush_handler<ASIO_HANDLER_TYPE(
-        WriteHandler, void (asio::error_code, std::size_t))>(
-        storage_, init.handler));
-
-  return init.result.get();
-}
-
-template <typename Stream>
-template <typename ConstBufferSequence>
-std::size_t buffered_write_stream<Stream>::write_some(
-    const ConstBufferSequence& buffers)
-{
-  if (asio::buffer_size(buffers) == 0)
-    return 0;
-
-  if (storage_.size() == storage_.capacity())
-    this->flush();
-
-  return this->copy(buffers);
-}
-
-template <typename Stream>
-template <typename ConstBufferSequence>
-std::size_t buffered_write_stream<Stream>::write_some(
-    const ConstBufferSequence& buffers, asio::error_code& ec)
-{
-  ec = asio::error_code();
-
-  if (asio::buffer_size(buffers) == 0)
-    return 0;
-
-  if (storage_.size() == storage_.capacity() && !flush(ec))
-    return 0;
-
-  return this->copy(buffers);
-}
-
-namespace detail
-{
-  template <typename ConstBufferSequence, typename WriteHandler>
-  class buffered_write_some_handler
-  {
-  public:
-    buffered_write_some_handler(detail::buffered_stream_storage& storage,
-        const ConstBufferSequence& buffers, WriteHandler& handler)
-      : storage_(storage),
-        buffers_(buffers),
-        handler_(handler)
-    {
-    }
-
-#if defined(ASIO_HAS_MOVE)
-      buffered_write_some_handler(const buffered_write_some_handler& other)
-        : storage_(other.storage_),
-          buffers_(other.buffers_),
-          handler_(other.handler_)
-      {
-      }
-
-      buffered_write_some_handler(buffered_write_some_handler&& other)
-        : storage_(other.storage_),
-          buffers_(other.buffers_),
-          handler_(ASIO_MOVE_CAST(WriteHandler)(other.handler_))
-      {
-      }
-#endif // defined(ASIO_HAS_MOVE)
-
-    void operator()(const asio::error_code& ec, std::size_t)
-    {
-      if (ec)
-      {
-        const std::size_t length = 0;
-        handler_(ec, length);
-      }
-      else
-      {
-        std::size_t orig_size = storage_.size();
-        std::size_t space_avail = storage_.capacity() - orig_size;
-        std::size_t bytes_avail = asio::buffer_size(buffers_);
-        std::size_t length = bytes_avail < space_avail
-          ? bytes_avail : space_avail;
-        storage_.resize(orig_size + length);
-        const std::size_t bytes_copied = asio::buffer_copy(
-            storage_.data() + orig_size, buffers_, length);
-        handler_(ec, bytes_copied);
-      }
-    }
-
-  //private:
-    detail::buffered_stream_storage& storage_;
-    ConstBufferSequence buffers_;
-    WriteHandler handler_;
-  };
-
-  template <typename ConstBufferSequence, typename WriteHandler>
-  inline void* asio_handler_allocate(std::size_t size,
-      buffered_write_some_handler<
-        ConstBufferSequence, WriteHandler>* this_handler)
-  {
-    return asio_handler_alloc_helpers::allocate(
-        size, this_handler->handler_);
-  }
-
-  template <typename ConstBufferSequence, typename WriteHandler>
-  inline void asio_handler_deallocate(void* pointer, std::size_t size,
-      buffered_write_some_handler<
-        ConstBufferSequence, WriteHandler>* this_handler)
-  {
-    asio_handler_alloc_helpers::deallocate(
-        pointer, size, this_handler->handler_);
-  }
-
-  template <typename ConstBufferSequence, typename WriteHandler>
-  inline bool asio_handler_is_continuation(
-      buffered_write_some_handler<
-        ConstBufferSequence, WriteHandler>* this_handler)
-  {
-    return asio_handler_cont_helpers::is_continuation(
-          this_handler->handler_);
-  }
-
-  template <typename Function, typename ConstBufferSequence,
-      typename WriteHandler>
-  inline void asio_handler_invoke(Function& function,
-      buffered_write_some_handler<
-        ConstBufferSequence, WriteHandler>* this_handler)
-  {
-    asio_handler_invoke_helpers::invoke(
-        function, this_handler->handler_);
-  }
-
-  template <typename Function, typename ConstBufferSequence,
-      typename WriteHandler>
-  inline void asio_handler_invoke(const Function& function,
-      buffered_write_some_handler<
-        ConstBufferSequence, WriteHandler>* this_handler)
-  {
-    asio_handler_invoke_helpers::invoke(
-        function, this_handler->handler_);
-  }
-} // namespace detail
-
-template <typename Stream>
-template <typename ConstBufferSequence, typename WriteHandler>
-ASIO_INITFN_RESULT_TYPE(WriteHandler,
-    void (asio::error_code, std::size_t))
-buffered_write_stream<Stream>::async_write_some(
-    const ConstBufferSequence& buffers,
-    ASIO_MOVE_ARG(WriteHandler) handler)
-{
-  // If you get an error on the following line it means that your handler does
-  // not meet the documented type requirements for a WriteHandler.
-  ASIO_WRITE_HANDLER_CHECK(WriteHandler, handler) type_check;
-
-  detail::async_result_init<
-    WriteHandler, void (asio::error_code, std::size_t)> init(
-      ASIO_MOVE_CAST(WriteHandler)(handler));
-
-  if (asio::buffer_size(buffers) == 0
-      || storage_.size() < storage_.capacity())
-  {
-    next_layer_.async_write_some(asio::const_buffers_1(0, 0),
-        detail::buffered_write_some_handler<
-          ConstBufferSequence, ASIO_HANDLER_TYPE(
-            WriteHandler, void (asio::error_code, std::size_t))>(
-            storage_, buffers, init.handler));
-  }
-  else
-  {
-    this->async_flush(detail::buffered_write_some_handler<
-          ConstBufferSequence, ASIO_HANDLER_TYPE(
-            WriteHandler, void (asio::error_code, std::size_t))>(
-            storage_, buffers, init.handler));
-  }
-
-  return init.result.get();
-}
-
-template <typename Stream>
-template <typename ConstBufferSequence>
-std::size_t buffered_write_stream<Stream>::copy(
-    const ConstBufferSequence& buffers)
-{
-  std::size_t orig_size = storage_.size();
-  std::size_t space_avail = storage_.capacity() - orig_size;
-  std::size_t bytes_avail = asio::buffer_size(buffers);
-  std::size_t length = bytes_avail < space_avail ? bytes_avail : space_avail;
-  storage_.resize(orig_size + length);
-  return asio::buffer_copy(
-      storage_.data() + orig_size, buffers, length);
-}
-
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_IMPL_BUFFERED_WRITE_STREAM_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/impl/connect.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/impl/connect.hpp
deleted file mode 100644
index 523e5519faf7..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/impl/connect.hpp
+++ /dev/null
@@ -1,428 +0,0 @@
-//
-// impl/connect.hpp
-// ~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_IMPL_CONNECT_HPP
-#define ASIO_IMPL_CONNECT_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/bind_handler.hpp"
-#include "asio/detail/consuming_buffers.hpp"
-#include "asio/detail/handler_alloc_helpers.hpp"
-#include "asio/detail/handler_cont_helpers.hpp"
-#include "asio/detail/handler_invoke_helpers.hpp"
-#include "asio/detail/handler_type_requirements.hpp"
-#include "asio/detail/throw_error.hpp"
-#include "asio/error.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-
-namespace detail
-{
-  struct default_connect_condition
-  {
-    template <typename Iterator>
-    Iterator operator()(const asio::error_code&, Iterator next)
-    {
-      return next;
-    }
-  };
-}
-
-template <typename Protocol, typename SocketService, typename Iterator>
-Iterator connect(basic_socket<Protocol, SocketService>& s, Iterator begin)
-{
-  asio::error_code ec;
-  Iterator result = connect(s, begin, ec);
-  asio::detail::throw_error(ec, "connect");
-  return result;
-}
-
-template <typename Protocol, typename SocketService, typename Iterator>
-inline Iterator connect(basic_socket<Protocol, SocketService>& s,
-    Iterator begin, asio::error_code& ec)
-{
-  return connect(s, begin, Iterator(), detail::default_connect_condition(), ec);
-}
-
-template <typename Protocol, typename SocketService, typename Iterator>
-Iterator connect(basic_socket<Protocol, SocketService>& s,
-    Iterator begin, Iterator end)
-{
-  asio::error_code ec;
-  Iterator result = connect(s, begin, end, ec);
-  asio::detail::throw_error(ec, "connect");
-  return result;
-}
-
-template <typename Protocol, typename SocketService, typename Iterator>
-inline Iterator connect(basic_socket<Protocol, SocketService>& s,
-    Iterator begin, Iterator end, asio::error_code& ec)
-{
-  return connect(s, begin, end, detail::default_connect_condition(), ec);
-}
-
-template <typename Protocol, typename SocketService,
-    typename Iterator, typename ConnectCondition>
-Iterator connect(basic_socket<Protocol, SocketService>& s,
-    Iterator begin, ConnectCondition connect_condition)
-{
-  asio::error_code ec;
-  Iterator result = connect(s, begin, connect_condition, ec);
-  asio::detail::throw_error(ec, "connect");
-  return result;
-}
-
-template <typename Protocol, typename SocketService,
-    typename Iterator, typename ConnectCondition>
-inline Iterator connect(basic_socket<Protocol, SocketService>& s,
-    Iterator begin, ConnectCondition connect_condition,
-    asio::error_code& ec)
-{
-  return connect(s, begin, Iterator(), connect_condition, ec);
-}
-
-template <typename Protocol, typename SocketService,
-    typename Iterator, typename ConnectCondition>
-Iterator connect(basic_socket<Protocol, SocketService>& s,
-    Iterator begin, Iterator end, ConnectCondition connect_condition)
-{
-  asio::error_code ec;
-  Iterator result = connect(s, begin, end, connect_condition, ec);
-  asio::detail::throw_error(ec, "connect");
-  return result;
-}
-
-template <typename Protocol, typename SocketService,
-    typename Iterator, typename ConnectCondition>
-Iterator connect(basic_socket<Protocol, SocketService>& s,
-    Iterator begin, Iterator end, ConnectCondition connect_condition,
-    asio::error_code& ec)
-{
-  ec = asio::error_code();
-
-  for (Iterator iter = begin; iter != end; ++iter)
-  {
-    iter = connect_condition(ec, iter);
-    if (iter != end)
-    {
-      s.close(ec);
-      s.connect(*iter, ec);
-      if (!ec)
-        return iter;
-    }
-  }
-
-  if (!ec)
-    ec = asio::error::not_found;
-
-  return end;
-}
-
-namespace detail
-{
-  // Enable the empty base class optimisation for the connect condition.
-  template <typename ConnectCondition>
-  class base_from_connect_condition
-  {
-  protected:
-    explicit base_from_connect_condition(
-        const ConnectCondition& connect_condition)
-      : connect_condition_(connect_condition)
-    {
-    }
-
-    template <typename Iterator>
-    void check_condition(const asio::error_code& ec,
-        Iterator& iter, Iterator& end)
-    {
-      if (iter != end)
-        iter = connect_condition_(ec, static_cast<const Iterator&>(iter));
-    }
-
-  private:
-    ConnectCondition connect_condition_;
-  };
-
-  // The default_connect_condition implementation is essentially a no-op. This
-  // template specialisation lets us eliminate all costs associated with it.
-  template <>
-  class base_from_connect_condition<default_connect_condition>
-  {
-  protected:
-    explicit base_from_connect_condition(const default_connect_condition&)
-    {
-    }
-
-    template <typename Iterator>
-    void check_condition(const asio::error_code&, Iterator&, Iterator&)
-    {
-    }
-  };
-
-  template <typename Protocol, typename SocketService, typename Iterator,
-      typename ConnectCondition, typename ComposedConnectHandler>
-  class connect_op : base_from_connect_condition<ConnectCondition>
-  {
-  public:
-    connect_op(basic_socket<Protocol, SocketService>& sock,
-        const Iterator& begin, const Iterator& end,
-        const ConnectCondition& connect_condition,
-        ComposedConnectHandler& handler)
-      : base_from_connect_condition<ConnectCondition>(connect_condition),
-        socket_(sock),
-        iter_(begin),
-        end_(end),
-        start_(0),
-        handler_(ASIO_MOVE_CAST(ComposedConnectHandler)(handler))
-    {
-    }
-
-#if defined(ASIO_HAS_MOVE)
-    connect_op(const connect_op& other)
-      : base_from_connect_condition<ConnectCondition>(other),
-        socket_(other.socket_),
-        iter_(other.iter_),
-        end_(other.end_),
-        start_(other.start_),
-        handler_(other.handler_)
-    {
-    }
-
-    connect_op(connect_op&& other)
-      : base_from_connect_condition<ConnectCondition>(other),
-        socket_(other.socket_),
-        iter_(other.iter_),
-        end_(other.end_),
-        start_(other.start_),
-        handler_(ASIO_MOVE_CAST(ComposedConnectHandler)(other.handler_))
-    {
-    }
-#endif // defined(ASIO_HAS_MOVE)
-
-    void operator()(asio::error_code ec, int start = 0)
-    {
-      switch (start_ = start)
-      {
-        case 1:
-        for (;;)
-        {
-          this->check_condition(ec, iter_, end_);
-
-          if (iter_ != end_)
-          {
-            socket_.close(ec);
-            socket_.async_connect(*iter_,
-                ASIO_MOVE_CAST(connect_op)(*this));
-            return;
-          }
-
-          if (start)
-          {
-            ec = asio::error::not_found;
-            socket_.get_io_service().post(detail::bind_handler(*this, ec));
-            return;
-          }
-
-          default:
-
-          if (iter_ == end_)
-            break;
-
-          if (!socket_.is_open())
-          {
-            ec = asio::error::operation_aborted;
-            break;
-          }
-
-          if (!ec)
-            break;
-
-          ++iter_;
-        }
-
-        handler_(static_cast<const asio::error_code&>(ec),
-            static_cast<const Iterator&>(iter_));
-      }
-    }
-
-  //private:
-    basic_socket<Protocol, SocketService>& socket_;
-    Iterator iter_;
-    Iterator end_;
-    int start_;
-    ComposedConnectHandler handler_;
-  };
-
-  template <typename Protocol, typename SocketService, typename Iterator,
-      typename ConnectCondition, typename ComposedConnectHandler>
-  inline void* asio_handler_allocate(std::size_t size,
-      connect_op<Protocol, SocketService, Iterator,
-        ConnectCondition, ComposedConnectHandler>* this_handler)
-  {
-    return asio_handler_alloc_helpers::allocate(
-        size, this_handler->handler_);
-  }
-
-  template <typename Protocol, typename SocketService, typename Iterator,
-      typename ConnectCondition, typename ComposedConnectHandler>
-  inline void asio_handler_deallocate(void* pointer, std::size_t size,
-      connect_op<Protocol, SocketService, Iterator,
-        ConnectCondition, ComposedConnectHandler>* this_handler)
-  {
-    asio_handler_alloc_helpers::deallocate(
-        pointer, size, this_handler->handler_);
-  }
-
-  template <typename Protocol, typename SocketService, typename Iterator,
-      typename ConnectCondition, typename ComposedConnectHandler>
-  inline bool asio_handler_is_continuation(
-      connect_op<Protocol, SocketService, Iterator,
-        ConnectCondition, ComposedConnectHandler>* this_handler)
-  {
-    return asio_handler_cont_helpers::is_continuation(
-        this_handler->handler_);
-  }
-
-  template <typename Function, typename Protocol,
-      typename SocketService, typename Iterator,
-      typename ConnectCondition, typename ComposedConnectHandler>
-  inline void asio_handler_invoke(Function& function,
-      connect_op<Protocol, SocketService, Iterator,
-        ConnectCondition, ComposedConnectHandler>* this_handler)
-  {
-    asio_handler_invoke_helpers::invoke(
-        function, this_handler->handler_);
-  }
-
-  template <typename Function, typename Protocol,
-      typename SocketService, typename Iterator,
-      typename ConnectCondition, typename ComposedConnectHandler>
-  inline void asio_handler_invoke(const Function& function,
-      connect_op<Protocol, SocketService, Iterator,
-        ConnectCondition, ComposedConnectHandler>* this_handler)
-  {
-    asio_handler_invoke_helpers::invoke(
-        function, this_handler->handler_);
-  }
-} // namespace detail
-
-template <typename Protocol, typename SocketService,
-    typename Iterator, typename ComposedConnectHandler>
-inline ASIO_INITFN_RESULT_TYPE(ComposedConnectHandler,
-    void (asio::error_code, Iterator))
-async_connect(basic_socket<Protocol, SocketService>& s,
-    Iterator begin, ASIO_MOVE_ARG(ComposedConnectHandler) handler)
-{
-  // If you get an error on the following line it means that your handler does
-  // not meet the documented type requirements for a ComposedConnectHandler.
-  ASIO_COMPOSED_CONNECT_HANDLER_CHECK(
-      ComposedConnectHandler, handler, Iterator) type_check;
-
-  detail::async_result_init<ComposedConnectHandler,
-    void (asio::error_code, Iterator)> init(
-      ASIO_MOVE_CAST(ComposedConnectHandler)(handler));
-
-  detail::connect_op<Protocol, SocketService, Iterator,
-    detail::default_connect_condition, ASIO_HANDLER_TYPE(
-      ComposedConnectHandler, void (asio::error_code, Iterator))>(s,
-        begin, Iterator(), detail::default_connect_condition(), init.handler)(
-          asio::error_code(), 1);
-
-  return init.result.get();
-}
-
-template <typename Protocol, typename SocketService,
-    typename Iterator, typename ComposedConnectHandler>
-inline ASIO_INITFN_RESULT_TYPE(ComposedConnectHandler,
-    void (asio::error_code, Iterator))
-async_connect(basic_socket<Protocol, SocketService>& s,
-    Iterator begin, Iterator end,
-    ASIO_MOVE_ARG(ComposedConnectHandler) handler)
-{
-  // If you get an error on the following line it means that your handler does
-  // not meet the documented type requirements for a ComposedConnectHandler.
-  ASIO_COMPOSED_CONNECT_HANDLER_CHECK(
-      ComposedConnectHandler, handler, Iterator) type_check;
-
-  detail::async_result_init<ComposedConnectHandler,
-    void (asio::error_code, Iterator)> init(
-      ASIO_MOVE_CAST(ComposedConnectHandler)(handler));
-
-  detail::connect_op<Protocol, SocketService, Iterator,
-    detail::default_connect_condition, ASIO_HANDLER_TYPE(
-      ComposedConnectHandler, void (asio::error_code, Iterator))>(s,
-        begin, end, detail::default_connect_condition(), init.handler)(
-          asio::error_code(), 1);
-
-  return init.result.get();
-}
-
-template <typename Protocol, typename SocketService, typename Iterator,
-    typename ConnectCondition, typename ComposedConnectHandler>
-inline ASIO_INITFN_RESULT_TYPE(ComposedConnectHandler,
-    void (asio::error_code, Iterator))
-async_connect(basic_socket<Protocol, SocketService>& s,
-    Iterator begin, ConnectCondition connect_condition,
-    ASIO_MOVE_ARG(ComposedConnectHandler) handler)
-{
-  // If you get an error on the following line it means that your handler does
-  // not meet the documented type requirements for a ComposedConnectHandler.
-  ASIO_COMPOSED_CONNECT_HANDLER_CHECK(
-      ComposedConnectHandler, handler, Iterator) type_check;
-
-  detail::async_result_init<ComposedConnectHandler,
-    void (asio::error_code, Iterator)> init(
-      ASIO_MOVE_CAST(ComposedConnectHandler)(handler));
-
-  detail::connect_op<Protocol, SocketService, Iterator,
-    ConnectCondition, ASIO_HANDLER_TYPE(
-      ComposedConnectHandler, void (asio::error_code, Iterator))>(s,
-        begin, Iterator(), connect_condition, init.handler)(
-          asio::error_code(), 1);
-
-  return init.result.get();
-}
-
-template <typename Protocol, typename SocketService, typename Iterator,
-    typename ConnectCondition, typename ComposedConnectHandler>
-inline ASIO_INITFN_RESULT_TYPE(ComposedConnectHandler,
-    void (asio::error_code, Iterator))
-async_connect(basic_socket<Protocol, SocketService>& s,
-    Iterator begin, Iterator end, ConnectCondition connect_condition,
-    ASIO_MOVE_ARG(ComposedConnectHandler) handler)
-{
-  // If you get an error on the following line it means that your handler does
-  // not meet the documented type requirements for a ComposedConnectHandler.
-  ASIO_COMPOSED_CONNECT_HANDLER_CHECK(
-      ComposedConnectHandler, handler, Iterator) type_check;
-
-  detail::async_result_init<ComposedConnectHandler,
-    void (asio::error_code, Iterator)> init(
-      ASIO_MOVE_CAST(ComposedConnectHandler)(handler));
-
-  detail::connect_op<Protocol, SocketService, Iterator,
-    ConnectCondition, ASIO_HANDLER_TYPE(
-      ComposedConnectHandler, void (asio::error_code, Iterator))>(s,
-        begin, end, connect_condition, init.handler)(
-          asio::error_code(), 1);
-
-  return init.result.get();
-}
-
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_IMPL_CONNECT_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/impl/error.ipp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/impl/error.ipp
deleted file mode 100644
index 7c5a414337a5..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/impl/error.ipp
+++ /dev/null
@@ -1,128 +0,0 @@
-//
-// impl/error.ipp
-// ~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_IMPL_ERROR_IPP
-#define ASIO_IMPL_ERROR_IPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include <string>
-#include "asio/error.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace error {
-
-#if !defined(ASIO_WINDOWS) && !defined(__CYGWIN__)
-
-namespace detail {
-
-class netdb_category : public asio::error_category
-{
-public:
-  const char* name() const ASIO_ERROR_CATEGORY_NOEXCEPT
-  {
-    return "asio.netdb";
-  }
-
-  std::string message(int value) const
-  {
-    if (value == error::host_not_found)
-      return "Host not found (authoritative)";
-    if (value == error::host_not_found_try_again)
-      return "Host not found (non-authoritative), try again later";
-    if (value == error::no_data)
-      return "The query is valid, but it does not have associated data";
-    if (value == error::no_recovery)
-      return "A non-recoverable error occurred during database lookup";
-    return "asio.netdb error";
-  }
-};
-
-} // namespace detail
-
-const asio::error_category& get_netdb_category()
-{
-  static detail::netdb_category instance;
-  return instance;
-}
-
-namespace detail {
-
-class addrinfo_category : public asio::error_category
-{
-public:
-  const char* name() const ASIO_ERROR_CATEGORY_NOEXCEPT
-  {
-    return "asio.addrinfo";
-  }
-
-  std::string message(int value) const
-  {
-    if (value == error::service_not_found)
-      return "Service not found";
-    if (value == error::socket_type_not_supported)
-      return "Socket type not supported";
-    return "asio.addrinfo error";
-  }
-};
-
-} // namespace detail
-
-const asio::error_category& get_addrinfo_category()
-{
-  static detail::addrinfo_category instance;
-  return instance;
-}
-
-#endif // !defined(ASIO_WINDOWS) && !defined(__CYGWIN__)
-
-namespace detail {
-
-class misc_category : public asio::error_category
-{
-public:
-  const char* name() const ASIO_ERROR_CATEGORY_NOEXCEPT
-  {
-    return "asio.misc";
-  }
-
-  std::string message(int value) const
-  {
-    if (value == error::already_open)
-      return "Already open";
-    if (value == error::eof)
-      return "End of file";
-    if (value == error::not_found)
-      return "Element not found";
-    if (value == error::fd_set_failure)
-      return "The descriptor does not fit into the select call's fd_set";
-    return "asio.misc error";
-  }
-};
-
-} // namespace detail
-
-const asio::error_category& get_misc_category()
-{
-  static detail::misc_category instance;
-  return instance;
-}
-
-} // namespace error
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_IMPL_ERROR_IPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/impl/error_code.ipp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/impl/error_code.ipp
deleted file mode 100644
index ec0536ecc3cd..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/impl/error_code.ipp
+++ /dev/null
@@ -1,128 +0,0 @@
-//
-// impl/error_code.ipp
-// ~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_IMPL_ERROR_CODE_IPP
-#define ASIO_IMPL_ERROR_CODE_IPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#if defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-# include <winerror.h>
-#elif defined(ASIO_WINDOWS_RUNTIME)
-# include <windows.h>
-#else
-# include <cerrno>
-# include <cstring>
-# include <string>
-#endif
-#include "asio/detail/local_free_on_block_exit.hpp"
-#include "asio/detail/socket_types.hpp"
-#include "asio/error_code.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-class system_category : public error_category
-{
-public:
-  const char* name() const ASIO_ERROR_CATEGORY_NOEXCEPT
-  {
-    return "asio.system";
-  }
-
-  std::string message(int value) const
-  {
-#if defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-    char* msg = 0;
-    DWORD length = ::FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER
-        | FORMAT_MESSAGE_FROM_SYSTEM
-        | FORMAT_MESSAGE_IGNORE_INSERTS, 0, value,
-        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (char*)&msg, 0, 0);
-    detail::local_free_on_block_exit local_free_obj(msg);
-    if (length && msg[length - 1] == '\n')
-      msg[--length] = '\0';
-    if (length && msg[length - 1] == '\r')
-      msg[--length] = '\0';
-    if (length)
-      return msg;
-    else
-      return "asio.system error";
-#elif defined(ASIO_WINDOWS_RUNTIME)
-    std::wstring wmsg(128, wchar_t());
-    for (;;)
-    {
-      DWORD wlength = ::FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM
-          | FORMAT_MESSAGE_IGNORE_INSERTS, 0, value,
-          MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), &wmsg[0], wmsg.size(), 0);
-      if (wlength == 0 && ::GetLastError() == ERROR_INSUFFICIENT_BUFFER)
-      {
-        wmsg.resize(wmsg.size() + wmsg.size() / 2);
-        continue;
-      }
-      if (wlength && wmsg[wlength - 1] == '\n')
-        --wlength;
-      if (wlength && wmsg[wlength - 1] == '\r')
-        --wlength;
-      if (wlength)
-      {
-        std::string msg(wlength * 2, char());
-        int length = ::WideCharToMultiByte(CP_ACP, 0,
-            wmsg.c_str(), static_cast<int>(wlength),
-            &msg[0], static_cast<int>(wlength * 2), 0, 0);
-        if (length <= 0)
-          return "asio.system error";
-        msg.resize(static_cast<std::size_t>(length));
-        return msg;
-      }
-      else
-        return "asio.system error";
-    }
-#else // defined(ASIO_WINDOWS)
-#if !defined(__sun)
-    if (value == ECANCELED)
-      return "Operation aborted.";
-#endif // !defined(__sun)
-#if defined(__sun) || defined(__QNX__) || defined(__SYMBIAN32__)
-    using namespace std;
-    return strerror(value);
-#elif defined(__MACH__) && defined(__APPLE__) \
-  || defined(__NetBSD__) || defined(__FreeBSD__) || defined(__OpenBSD__) \
-  || defined(_AIX) || defined(__hpux) || defined(__osf__) \
-  || defined(__ANDROID__)
-    char buf[256] = "";
-    using namespace std;
-    strerror_r(value, buf, sizeof(buf));
-    return buf;
-#else
-    char buf[256] = "";
-    return strerror_r(value, buf, sizeof(buf));
-#endif
-#endif // defined(ASIO_WINDOWS)
-  }
-};
-
-} // namespace detail
-
-const error_category& system_category()
-{
-  static detail::system_category instance;
-  return instance;
-}
-
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_IMPL_ERROR_CODE_IPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/impl/handler_alloc_hook.ipp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/impl/handler_alloc_hook.ipp
deleted file mode 100644
index 8691ef52d48e..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/impl/handler_alloc_hook.ipp
+++ /dev/null
@@ -1,77 +0,0 @@
-//
-// impl/handler_alloc_hook.ipp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_IMPL_HANDLER_ALLOC_HOOK_IPP
-#define ASIO_IMPL_HANDLER_ALLOC_HOOK_IPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include "asio/detail/call_stack.hpp"
-#include "asio/handler_alloc_hook.hpp"
-
-#if !defined(ASIO_DISABLE_SMALL_BLOCK_RECYCLING)
-# if defined(ASIO_HAS_IOCP)
-#  include "asio/detail/win_iocp_thread_info.hpp"
-# else // defined(ASIO_HAS_IOCP)
-#  include "asio/detail/task_io_service_thread_info.hpp"
-# endif // defined(ASIO_HAS_IOCP)
-#endif // !defined(ASIO_DISABLE_SMALL_BLOCK_RECYCLING)
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-
-#if defined(ASIO_HAS_IOCP)
-namespace detail { class win_iocp_io_service; }
-#endif // defined(ASIO_HAS_IOCP)
-
-void* asio_handler_allocate(std::size_t size, ...)
-{
-#if !defined(ASIO_DISABLE_SMALL_BLOCK_RECYCLING)
-# if defined(ASIO_HAS_IOCP)
-  typedef detail::win_iocp_io_service io_service_impl;
-  typedef detail::win_iocp_thread_info thread_info;
-# else // defined(ASIO_HAS_IOCP)
-  typedef detail::task_io_service io_service_impl;
-  typedef detail::task_io_service_thread_info thread_info;
-# endif // defined(ASIO_HAS_IOCP)
-  typedef detail::call_stack<io_service_impl, thread_info> call_stack;
-  return thread_info::allocate(call_stack::top(), size);
-#else // !defined(ASIO_DISABLE_SMALL_BLOCK_RECYCLING)
-  return ::operator new(size);
-#endif // !defined(ASIO_DISABLE_SMALL_BLOCK_RECYCLING)
-}
-
-void asio_handler_deallocate(void* pointer, std::size_t size, ...)
-{
-#if !defined(ASIO_DISABLE_SMALL_BLOCK_RECYCLING)
-# if defined(ASIO_HAS_IOCP)
-  typedef detail::win_iocp_io_service io_service_impl;
-  typedef detail::win_iocp_thread_info thread_info;
-# else // defined(ASIO_HAS_IOCP)
-  typedef detail::task_io_service io_service_impl;
-  typedef detail::task_io_service_thread_info thread_info;
-# endif // defined(ASIO_HAS_IOCP)
-  typedef detail::call_stack<io_service_impl, thread_info> call_stack;
-  thread_info::deallocate(call_stack::top(), pointer, size);
-#else // !defined(ASIO_DISABLE_SMALL_BLOCK_RECYCLING)
-  (void)size;
-  ::operator delete(pointer);
-#endif // !defined(ASIO_DISABLE_SMALL_BLOCK_RECYCLING)
-}
-
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_IMPL_HANDLER_ALLOC_HOOK_IPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/impl/io_service.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/impl/io_service.hpp
deleted file mode 100644
index 6e590ace2d0f..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/impl/io_service.hpp
+++ /dev/null
@@ -1,152 +0,0 @@
-//
-// impl/io_service.hpp
-// ~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_IMPL_IO_SERVICE_HPP
-#define ASIO_IMPL_IO_SERVICE_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/handler_type_requirements.hpp"
-#include "asio/detail/service_registry.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-
-template <typename Service>
-inline Service& use_service(io_service& ios)
-{
-  // Check that Service meets the necessary type requirements.
-  (void)static_cast<io_service::service*>(static_cast<Service*>(0));
-  (void)static_cast<const io_service::id*>(&Service::id);
-
-  return ios.service_registry_->template use_service<Service>();
-}
-
-template <>
-inline detail::io_service_impl& use_service<detail::io_service_impl>(
-    io_service& ios)
-{
-  return ios.impl_;
-}
-
-template <typename Service>
-inline void add_service(io_service& ios, Service* svc)
-{
-  // Check that Service meets the necessary type requirements.
-  (void)static_cast<io_service::service*>(static_cast<Service*>(0));
-  (void)static_cast<const io_service::id*>(&Service::id);
-
-  ios.service_registry_->template add_service<Service>(svc);
-}
-
-template <typename Service>
-inline bool has_service(io_service& ios)
-{
-  // Check that Service meets the necessary type requirements.
-  (void)static_cast<io_service::service*>(static_cast<Service*>(0));
-  (void)static_cast<const io_service::id*>(&Service::id);
-
-  return ios.service_registry_->template has_service<Service>();
-}
-
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#if defined(ASIO_HAS_IOCP)
-# include "asio/detail/win_iocp_io_service.hpp"
-#else
-# include "asio/detail/task_io_service.hpp"
-#endif
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-
-template <typename CompletionHandler>
-inline ASIO_INITFN_RESULT_TYPE(CompletionHandler, void ())
-io_service::dispatch(ASIO_MOVE_ARG(CompletionHandler) handler)
-{
-  // If you get an error on the following line it means that your handler does
-  // not meet the documented type requirements for a CompletionHandler.
-  ASIO_COMPLETION_HANDLER_CHECK(CompletionHandler, handler) type_check;
-
-  detail::async_result_init<
-    CompletionHandler, void ()> init(
-      ASIO_MOVE_CAST(CompletionHandler)(handler));
-
-  impl_.dispatch(init.handler);
-
-  return init.result.get();
-}
-
-template <typename CompletionHandler>
-inline ASIO_INITFN_RESULT_TYPE(CompletionHandler, void ())
-io_service::post(ASIO_MOVE_ARG(CompletionHandler) handler)
-{
-  // If you get an error on the following line it means that your handler does
-  // not meet the documented type requirements for a CompletionHandler.
-  ASIO_COMPLETION_HANDLER_CHECK(CompletionHandler, handler) type_check;
-
-  detail::async_result_init<
-    CompletionHandler, void ()> init(
-      ASIO_MOVE_CAST(CompletionHandler)(handler));
-
-  impl_.post(init.handler);
-
-  return init.result.get();
-}
-
-template <typename Handler>
-#if defined(GENERATING_DOCUMENTATION)
-unspecified
-#else
-inline detail::wrapped_handler<io_service&, Handler>
-#endif
-io_service::wrap(Handler handler)
-{
-  return detail::wrapped_handler<io_service&, Handler>(*this, handler);
-}
-
-inline io_service::work::work(asio::io_service& io_service)
-  : io_service_impl_(io_service.impl_)
-{
-  io_service_impl_.work_started();
-}
-
-inline io_service::work::work(const work& other)
-  : io_service_impl_(other.io_service_impl_)
-{
-  io_service_impl_.work_started();
-}
-
-inline io_service::work::~work()
-{
-  io_service_impl_.work_finished();
-}
-
-inline asio::io_service& io_service::work::get_io_service()
-{
-  return io_service_impl_.get_io_service();
-}
-
-inline asio::io_service& io_service::service::get_io_service()
-{
-  return owner_;
-}
-
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_IMPL_IO_SERVICE_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/impl/io_service.ipp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/impl/io_service.ipp
deleted file mode 100644
index 4844ef3fbf8a..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/impl/io_service.ipp
+++ /dev/null
@@ -1,155 +0,0 @@
-//
-// impl/io_service.ipp
-// ~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_IMPL_IO_SERVICE_IPP
-#define ASIO_IMPL_IO_SERVICE_IPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include "asio/io_service.hpp"
-#include "asio/detail/limits.hpp"
-#include "asio/detail/scoped_ptr.hpp"
-#include "asio/detail/service_registry.hpp"
-#include "asio/detail/throw_error.hpp"
-
-#if defined(ASIO_HAS_IOCP)
-# include "asio/detail/win_iocp_io_service.hpp"
-#else
-# include "asio/detail/task_io_service.hpp"
-#endif
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-
-io_service::io_service()
-  : service_registry_(new asio::detail::service_registry(
-        *this, static_cast<impl_type*>(0),
-        (std::numeric_limits<std::size_t>::max)())),
-    impl_(service_registry_->first_service<impl_type>())
-{
-}
-
-io_service::io_service(std::size_t concurrency_hint)
-  : service_registry_(new asio::detail::service_registry(
-        *this, static_cast<impl_type*>(0), concurrency_hint)),
-    impl_(service_registry_->first_service<impl_type>())
-{
-}
-
-io_service::~io_service()
-{
-  delete service_registry_;
-}
-
-std::size_t io_service::run()
-{
-  asio::error_code ec;
-  std::size_t s = impl_.run(ec);
-  asio::detail::throw_error(ec);
-  return s;
-}
-
-std::size_t io_service::run(asio::error_code& ec)
-{
-  return impl_.run(ec);
-}
-
-std::size_t io_service::run_one()
-{
-  asio::error_code ec;
-  std::size_t s = impl_.run_one(ec);
-  asio::detail::throw_error(ec);
-  return s;
-}
-
-std::size_t io_service::run_one(asio::error_code& ec)
-{
-  return impl_.run_one(ec);
-}
-
-std::size_t io_service::poll()
-{
-  asio::error_code ec;
-  std::size_t s = impl_.poll(ec);
-  asio::detail::throw_error(ec);
-  return s;
-}
-
-std::size_t io_service::poll(asio::error_code& ec)
-{
-  return impl_.poll(ec);
-}
-
-std::size_t io_service::poll_one()
-{
-  asio::error_code ec;
-  std::size_t s = impl_.poll_one(ec);
-  asio::detail::throw_error(ec);
-  return s;
-}
-
-std::size_t io_service::poll_one(asio::error_code& ec)
-{
-  return impl_.poll_one(ec);
-}
-
-void io_service::stop()
-{
-  impl_.stop();
-}
-
-bool io_service::stopped() const
-{
-  return impl_.stopped();
-}
-
-void io_service::reset()
-{
-  impl_.reset();
-}
-
-void io_service::notify_fork(asio::io_service::fork_event event)
-{
-  service_registry_->notify_fork(event);
-}
-
-io_service::service::service(asio::io_service& owner)
-  : owner_(owner),
-    next_(0)
-{
-}
-
-io_service::service::~service()
-{
-}
-
-void io_service::service::fork_service(asio::io_service::fork_event)
-{
-}
-
-service_already_exists::service_already_exists()
-  : std::logic_error("Service already exists.")
-{
-}
-
-invalid_service_owner::invalid_service_owner()
-  : std::logic_error("Invalid service owner.")
-{
-}
-
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_IMPL_IO_SERVICE_IPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/impl/read.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/impl/read.hpp
deleted file mode 100644
index 63fba77e269a..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/impl/read.hpp
+++ /dev/null
@@ -1,753 +0,0 @@
-//
-// impl/read.hpp
-// ~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_IMPL_READ_HPP
-#define ASIO_IMPL_READ_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include <algorithm>
-#include "asio/buffer.hpp"
-#include "asio/completion_condition.hpp"
-#include "asio/detail/array_fwd.hpp"
-#include "asio/detail/base_from_completion_cond.hpp"
-#include "asio/detail/bind_handler.hpp"
-#include "asio/detail/consuming_buffers.hpp"
-#include "asio/detail/dependent_type.hpp"
-#include "asio/detail/handler_alloc_helpers.hpp"
-#include "asio/detail/handler_cont_helpers.hpp"
-#include "asio/detail/handler_invoke_helpers.hpp"
-#include "asio/detail/handler_type_requirements.hpp"
-#include "asio/detail/throw_error.hpp"
-#include "asio/error.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-
-template <typename SyncReadStream, typename MutableBufferSequence,
-    typename CompletionCondition>
-std::size_t read(SyncReadStream& s, const MutableBufferSequence& buffers,
-    CompletionCondition completion_condition, asio::error_code& ec)
-{
-  ec = asio::error_code();
-  asio::detail::consuming_buffers<
-    mutable_buffer, MutableBufferSequence> tmp(buffers);
-  std::size_t total_transferred = 0;
-  tmp.prepare(detail::adapt_completion_condition_result(
-        completion_condition(ec, total_transferred)));
-  while (tmp.begin() != tmp.end())
-  {
-    std::size_t bytes_transferred = s.read_some(tmp, ec);
-    tmp.consume(bytes_transferred);
-    total_transferred += bytes_transferred;
-    tmp.prepare(detail::adapt_completion_condition_result(
-          completion_condition(ec, total_transferred)));
-  }
-  return total_transferred;
-}
-
-template <typename SyncReadStream, typename MutableBufferSequence>
-inline std::size_t read(SyncReadStream& s, const MutableBufferSequence& buffers)
-{
-  asio::error_code ec;
-  std::size_t bytes_transferred = read(s, buffers, transfer_all(), ec);
-  asio::detail::throw_error(ec, "read");
-  return bytes_transferred;
-}
-
-template <typename SyncReadStream, typename MutableBufferSequence>
-inline std::size_t read(SyncReadStream& s, const MutableBufferSequence& buffers,
-    asio::error_code& ec)
-{
-  return read(s, buffers, transfer_all(), ec);
-}
-
-template <typename SyncReadStream, typename MutableBufferSequence,
-    typename CompletionCondition>
-inline std::size_t read(SyncReadStream& s, const MutableBufferSequence& buffers,
-    CompletionCondition completion_condition)
-{
-  asio::error_code ec;
-  std::size_t bytes_transferred = read(s, buffers, completion_condition, ec);
-  asio::detail::throw_error(ec, "read");
-  return bytes_transferred;
-}
-
-#if !defined(ASIO_NO_IOSTREAM)
-
-template <typename SyncReadStream, typename Allocator,
-    typename CompletionCondition>
-std::size_t read(SyncReadStream& s,
-    asio::basic_streambuf<Allocator>& b,
-    CompletionCondition completion_condition, asio::error_code& ec)
-{
-  ec = asio::error_code();
-  std::size_t total_transferred = 0;
-  std::size_t max_size = detail::adapt_completion_condition_result(
-        completion_condition(ec, total_transferred));
-  std::size_t bytes_available = read_size_helper(b, max_size);
-  while (bytes_available > 0)
-  {
-    std::size_t bytes_transferred = s.read_some(b.prepare(bytes_available), ec);
-    b.commit(bytes_transferred);
-    total_transferred += bytes_transferred;
-    max_size = detail::adapt_completion_condition_result(
-          completion_condition(ec, total_transferred));
-    bytes_available = read_size_helper(b, max_size);
-  }
-  return total_transferred;
-}
-
-template <typename SyncReadStream, typename Allocator>
-inline std::size_t read(SyncReadStream& s,
-    asio::basic_streambuf<Allocator>& b)
-{
-  asio::error_code ec;
-  std::size_t bytes_transferred = read(s, b, transfer_all(), ec);
-  asio::detail::throw_error(ec, "read");
-  return bytes_transferred;
-}
-
-template <typename SyncReadStream, typename Allocator>
-inline std::size_t read(SyncReadStream& s,
-    asio::basic_streambuf<Allocator>& b,
-    asio::error_code& ec)
-{
-  return read(s, b, transfer_all(), ec);
-}
-
-template <typename SyncReadStream, typename Allocator,
-    typename CompletionCondition>
-inline std::size_t read(SyncReadStream& s,
-    asio::basic_streambuf<Allocator>& b,
-    CompletionCondition completion_condition)
-{
-  asio::error_code ec;
-  std::size_t bytes_transferred = read(s, b, completion_condition, ec);
-  asio::detail::throw_error(ec, "read");
-  return bytes_transferred;
-}
-
-#endif // !defined(ASIO_NO_IOSTREAM)
-
-namespace detail
-{
-  template <typename AsyncReadStream, typename MutableBufferSequence,
-      typename CompletionCondition, typename ReadHandler>
-  class read_op
-    : detail::base_from_completion_cond<CompletionCondition>
-  {
-  public:
-    read_op(AsyncReadStream& stream, const MutableBufferSequence& buffers,
-        CompletionCondition completion_condition, ReadHandler& handler)
-      : detail::base_from_completion_cond<
-          CompletionCondition>(completion_condition),
-        stream_(stream),
-        buffers_(buffers),
-        start_(0),
-        total_transferred_(0),
-        handler_(ASIO_MOVE_CAST(ReadHandler)(handler))
-    {
-    }
-
-#if defined(ASIO_HAS_MOVE)
-    read_op(const read_op& other)
-      : detail::base_from_completion_cond<CompletionCondition>(other),
-        stream_(other.stream_),
-        buffers_(other.buffers_),
-        start_(other.start_),
-        total_transferred_(other.total_transferred_),
-        handler_(other.handler_)
-    {
-    }
-
-    read_op(read_op&& other)
-      : detail::base_from_completion_cond<CompletionCondition>(other),
-        stream_(other.stream_),
-        buffers_(other.buffers_),
-        start_(other.start_),
-        total_transferred_(other.total_transferred_),
-        handler_(ASIO_MOVE_CAST(ReadHandler)(other.handler_))
-    {
-    }
-#endif // defined(ASIO_HAS_MOVE)
-
-    void operator()(const asio::error_code& ec,
-        std::size_t bytes_transferred, int start = 0)
-    {
-      switch (start_ = start)
-      {
-        case 1:
-        buffers_.prepare(this->check_for_completion(ec, total_transferred_));
-        for (;;)
-        {
-          stream_.async_read_some(buffers_,
-              ASIO_MOVE_CAST(read_op)(*this));
-          return; default:
-          total_transferred_ += bytes_transferred;
-          buffers_.consume(bytes_transferred);
-          buffers_.prepare(this->check_for_completion(ec, total_transferred_));
-          if ((!ec && bytes_transferred == 0)
-              || buffers_.begin() == buffers_.end())
-            break;
-        }
-
-        handler_(ec, static_cast<const std::size_t&>(total_transferred_));
-      }
-    }
-
-  //private:
-    AsyncReadStream& stream_;
-    asio::detail::consuming_buffers<
-      mutable_buffer, MutableBufferSequence> buffers_;
-    int start_;
-    std::size_t total_transferred_;
-    ReadHandler handler_;
-  };
-
-  template <typename AsyncReadStream,
-      typename CompletionCondition, typename ReadHandler>
-  class read_op<AsyncReadStream, asio::mutable_buffers_1,
-      CompletionCondition, ReadHandler>
-    : detail::base_from_completion_cond<CompletionCondition>
-  {
-  public:
-    read_op(AsyncReadStream& stream,
-        const asio::mutable_buffers_1& buffers,
-        CompletionCondition completion_condition, ReadHandler& handler)
-      : detail::base_from_completion_cond<
-          CompletionCondition>(completion_condition),
-        stream_(stream),
-        buffer_(buffers),
-        start_(0),
-        total_transferred_(0),
-        handler_(ASIO_MOVE_CAST(ReadHandler)(handler))
-    {
-    }
-
-#if defined(ASIO_HAS_MOVE)
-    read_op(const read_op& other)
-      : detail::base_from_completion_cond<CompletionCondition>(other),
-        stream_(other.stream_),
-        buffer_(other.buffer_),
-        start_(other.start_),
-        total_transferred_(other.total_transferred_),
-        handler_(other.handler_)
-    {
-    }
-
-    read_op(read_op&& other)
-      : detail::base_from_completion_cond<CompletionCondition>(other),
-        stream_(other.stream_),
-        buffer_(other.buffer_),
-        start_(other.start_),
-        total_transferred_(other.total_transferred_),
-        handler_(ASIO_MOVE_CAST(ReadHandler)(other.handler_))
-    {
-    }
-#endif // defined(ASIO_HAS_MOVE)
-
-    void operator()(const asio::error_code& ec,
-        std::size_t bytes_transferred, int start = 0)
-    {
-      std::size_t n = 0;
-      switch (start_ = start)
-      {
-        case 1:
-        n = this->check_for_completion(ec, total_transferred_);
-        for (;;)
-        {
-          stream_.async_read_some(
-              asio::buffer(buffer_ + total_transferred_, n),
-              ASIO_MOVE_CAST(read_op)(*this));
-          return; default:
-          total_transferred_ += bytes_transferred;
-          if ((!ec && bytes_transferred == 0)
-              || (n = this->check_for_completion(ec, total_transferred_)) == 0
-              || total_transferred_ == asio::buffer_size(buffer_))
-            break;
-        }
-
-        handler_(ec, static_cast<const std::size_t&>(total_transferred_));
-      }
-    }
-
-  //private:
-    AsyncReadStream& stream_;
-    asio::mutable_buffer buffer_;
-    int start_;
-    std::size_t total_transferred_;
-    ReadHandler handler_;
-  };
-
-  template <typename AsyncReadStream, typename Elem,
-      typename CompletionCondition, typename ReadHandler>
-  class read_op<AsyncReadStream, boost::array<Elem, 2>,
-      CompletionCondition, ReadHandler>
-    : detail::base_from_completion_cond<CompletionCondition>
-  {
-  public:
-    read_op(AsyncReadStream& stream, const boost::array<Elem, 2>& buffers,
-        CompletionCondition completion_condition, ReadHandler& handler)
-      : detail::base_from_completion_cond<
-          CompletionCondition>(completion_condition),
-        stream_(stream),
-        buffers_(buffers),
-        start_(0),
-        total_transferred_(0),
-        handler_(ASIO_MOVE_CAST(ReadHandler)(handler))
-    {
-    }
-
-#if defined(ASIO_HAS_MOVE)
-    read_op(const read_op& other)
-      : detail::base_from_completion_cond<CompletionCondition>(other),
-        stream_(other.stream_),
-        buffers_(other.buffers_),
-        start_(other.start_),
-        total_transferred_(other.total_transferred_),
-        handler_(other.handler_)
-    {
-    }
-
-    read_op(read_op&& other)
-      : detail::base_from_completion_cond<CompletionCondition>(other),
-        stream_(other.stream_),
-        buffers_(other.buffers_),
-        start_(other.start_),
-        total_transferred_(other.total_transferred_),
-        handler_(ASIO_MOVE_CAST(ReadHandler)(other.handler_))
-    {
-    }
-#endif // defined(ASIO_HAS_MOVE)
-
-    void operator()(const asio::error_code& ec,
-        std::size_t bytes_transferred, int start = 0)
-    {
-      typename asio::detail::dependent_type<Elem,
-          boost::array<asio::mutable_buffer, 2> >::type bufs = {{
-        asio::mutable_buffer(buffers_[0]),
-        asio::mutable_buffer(buffers_[1]) }};
-      std::size_t buffer_size0 = asio::buffer_size(bufs[0]);
-      std::size_t buffer_size1 = asio::buffer_size(bufs[1]);
-      std::size_t n = 0;
-      switch (start_ = start)
-      {
-        case 1:
-        n = this->check_for_completion(ec, total_transferred_);
-        for (;;)
-        {
-          bufs[0] = asio::buffer(bufs[0] + total_transferred_, n);
-          bufs[1] = asio::buffer(
-              bufs[1] + (total_transferred_ < buffer_size0
-                ? 0 : total_transferred_ - buffer_size0),
-              n - asio::buffer_size(bufs[0]));
-          stream_.async_read_some(bufs, ASIO_MOVE_CAST(read_op)(*this));
-          return; default:
-          total_transferred_ += bytes_transferred;
-          if ((!ec && bytes_transferred == 0)
-              || (n = this->check_for_completion(ec, total_transferred_)) == 0
-              || total_transferred_ == buffer_size0 + buffer_size1)
-            break;
-        }
-
-        handler_(ec, static_cast<const std::size_t&>(total_transferred_));
-      }
-    }
-
-  //private:
-    AsyncReadStream& stream_;
-    boost::array<Elem, 2> buffers_;
-    int start_;
-    std::size_t total_transferred_;
-    ReadHandler handler_;
-  };
-
-#if defined(ASIO_HAS_STD_ARRAY)
-
-  template <typename AsyncReadStream, typename Elem,
-      typename CompletionCondition, typename ReadHandler>
-  class read_op<AsyncReadStream, std::array<Elem, 2>,
-      CompletionCondition, ReadHandler>
-    : detail::base_from_completion_cond<CompletionCondition>
-  {
-  public:
-    read_op(AsyncReadStream& stream, const std::array<Elem, 2>& buffers,
-        CompletionCondition completion_condition, ReadHandler& handler)
-      : detail::base_from_completion_cond<
-          CompletionCondition>(completion_condition),
-        stream_(stream),
-        buffers_(buffers),
-        start_(0),
-        total_transferred_(0),
-        handler_(ASIO_MOVE_CAST(ReadHandler)(handler))
-    {
-    }
-
-#if defined(ASIO_HAS_MOVE)
-    read_op(const read_op& other)
-      : detail::base_from_completion_cond<CompletionCondition>(other),
-        stream_(other.stream_),
-        buffers_(other.buffers_),
-        start_(other.start_),
-        total_transferred_(other.total_transferred_),
-        handler_(other.handler_)
-    {
-    }
-
-    read_op(read_op&& other)
-      : detail::base_from_completion_cond<CompletionCondition>(other),
-        stream_(other.stream_),
-        buffers_(other.buffers_),
-        start_(other.start_),
-        total_transferred_(other.total_transferred_),
-        handler_(ASIO_MOVE_CAST(ReadHandler)(other.handler_))
-    {
-    }
-#endif // defined(ASIO_HAS_MOVE)
-
-    void operator()(const asio::error_code& ec,
-        std::size_t bytes_transferred, int start = 0)
-    {
-      typename asio::detail::dependent_type<Elem,
-          std::array<asio::mutable_buffer, 2> >::type bufs = {{
-        asio::mutable_buffer(buffers_[0]),
-        asio::mutable_buffer(buffers_[1]) }};
-      std::size_t buffer_size0 = asio::buffer_size(bufs[0]);
-      std::size_t buffer_size1 = asio::buffer_size(bufs[1]);
-      std::size_t n = 0;
-      switch (start_ = start)
-      {
-        case 1:
-        n = this->check_for_completion(ec, total_transferred_);
-        for (;;)
-        {
-          bufs[0] = asio::buffer(bufs[0] + total_transferred_, n);
-          bufs[1] = asio::buffer(
-              bufs[1] + (total_transferred_ < buffer_size0
-                ? 0 : total_transferred_ - buffer_size0),
-              n - asio::buffer_size(bufs[0]));
-          stream_.async_read_some(bufs, ASIO_MOVE_CAST(read_op)(*this));
-          return; default:
-          total_transferred_ += bytes_transferred;
-          if ((!ec && bytes_transferred == 0)
-              || (n = this->check_for_completion(ec, total_transferred_)) == 0
-              || total_transferred_ == buffer_size0 + buffer_size1)
-            break;
-        }
-
-        handler_(ec, static_cast<const std::size_t&>(total_transferred_));
-      }
-    }
-
-  //private:
-    AsyncReadStream& stream_;
-    std::array<Elem, 2> buffers_;
-    int start_;
-    std::size_t total_transferred_;
-    ReadHandler handler_;
-  };
-
-#endif // defined(ASIO_HAS_STD_ARRAY)
-
-  template <typename AsyncReadStream, typename MutableBufferSequence,
-      typename CompletionCondition, typename ReadHandler>
-  inline void* asio_handler_allocate(std::size_t size,
-      read_op<AsyncReadStream, MutableBufferSequence,
-        CompletionCondition, ReadHandler>* this_handler)
-  {
-    return asio_handler_alloc_helpers::allocate(
-        size, this_handler->handler_);
-  }
-
-  template <typename AsyncReadStream, typename MutableBufferSequence,
-      typename CompletionCondition, typename ReadHandler>
-  inline void asio_handler_deallocate(void* pointer, std::size_t size,
-      read_op<AsyncReadStream, MutableBufferSequence,
-        CompletionCondition, ReadHandler>* this_handler)
-  {
-    asio_handler_alloc_helpers::deallocate(
-        pointer, size, this_handler->handler_);
-  }
-
-  template <typename AsyncReadStream, typename MutableBufferSequence,
-      typename CompletionCondition, typename ReadHandler>
-  inline bool asio_handler_is_continuation(
-      read_op<AsyncReadStream, MutableBufferSequence,
-        CompletionCondition, ReadHandler>* this_handler)
-  {
-    return this_handler->start_ == 0 ? true
-      : asio_handler_cont_helpers::is_continuation(
-          this_handler->handler_);
-  }
-
-  template <typename Function, typename AsyncReadStream,
-      typename MutableBufferSequence, typename CompletionCondition,
-      typename ReadHandler>
-  inline void asio_handler_invoke(Function& function,
-      read_op<AsyncReadStream, MutableBufferSequence,
-        CompletionCondition, ReadHandler>* this_handler)
-  {
-    asio_handler_invoke_helpers::invoke(
-        function, this_handler->handler_);
-  }
-
-  template <typename Function, typename AsyncReadStream,
-      typename MutableBufferSequence, typename CompletionCondition,
-      typename ReadHandler>
-  inline void asio_handler_invoke(const Function& function,
-      read_op<AsyncReadStream, MutableBufferSequence,
-        CompletionCondition, ReadHandler>* this_handler)
-  {
-    asio_handler_invoke_helpers::invoke(
-        function, this_handler->handler_);
-  }
-} // namespace detail
-
-template <typename AsyncReadStream, typename MutableBufferSequence,
-    typename CompletionCondition, typename ReadHandler>
-inline ASIO_INITFN_RESULT_TYPE(ReadHandler,
-    void (asio::error_code, std::size_t))
-async_read(AsyncReadStream& s, const MutableBufferSequence& buffers,
-    CompletionCondition completion_condition,
-    ASIO_MOVE_ARG(ReadHandler) handler)
-{
-  // If you get an error on the following line it means that your handler does
-  // not meet the documented type requirements for a ReadHandler.
-  ASIO_READ_HANDLER_CHECK(ReadHandler, handler) type_check;
-
-  detail::async_result_init<
-    ReadHandler, void (asio::error_code, std::size_t)> init(
-      ASIO_MOVE_CAST(ReadHandler)(handler));
-
-  detail::read_op<AsyncReadStream, MutableBufferSequence,
-    CompletionCondition, ASIO_HANDLER_TYPE(
-      ReadHandler, void (asio::error_code, std::size_t))>(
-        s, buffers, completion_condition, init.handler)(
-          asio::error_code(), 0, 1);
-
-  return init.result.get();
-}
-
-template <typename AsyncReadStream, typename MutableBufferSequence,
-    typename ReadHandler>
-inline ASIO_INITFN_RESULT_TYPE(ReadHandler,
-    void (asio::error_code, std::size_t))
-async_read(AsyncReadStream& s, const MutableBufferSequence& buffers,
-    ASIO_MOVE_ARG(ReadHandler) handler)
-{
-  // If you get an error on the following line it means that your handler does
-  // not meet the documented type requirements for a ReadHandler.
-  ASIO_READ_HANDLER_CHECK(ReadHandler, handler) type_check;
-
-  detail::async_result_init<
-    ReadHandler, void (asio::error_code, std::size_t)> init(
-      ASIO_MOVE_CAST(ReadHandler)(handler));
-
-  detail::read_op<AsyncReadStream, MutableBufferSequence,
-    detail::transfer_all_t, ASIO_HANDLER_TYPE(
-      ReadHandler, void (asio::error_code, std::size_t))>(
-        s, buffers, transfer_all(), init.handler)(
-          asio::error_code(), 0, 1);
-
-  return init.result.get();
-}
-
-#if !defined(ASIO_NO_IOSTREAM)
-
-namespace detail
-{
-  template <typename AsyncReadStream, typename Allocator,
-      typename CompletionCondition, typename ReadHandler>
-  class read_streambuf_op
-    : detail::base_from_completion_cond<CompletionCondition>
-  {
-  public:
-    read_streambuf_op(AsyncReadStream& stream,
-        basic_streambuf<Allocator>& streambuf,
-        CompletionCondition completion_condition, ReadHandler& handler)
-      : detail::base_from_completion_cond<
-          CompletionCondition>(completion_condition),
-        stream_(stream),
-        streambuf_(streambuf),
-        start_(0),
-        total_transferred_(0),
-        handler_(ASIO_MOVE_CAST(ReadHandler)(handler))
-    {
-    }
-
-#if defined(ASIO_HAS_MOVE)
-    read_streambuf_op(const read_streambuf_op& other)
-      : detail::base_from_completion_cond<CompletionCondition>(other),
-        stream_(other.stream_),
-        streambuf_(other.streambuf_),
-        start_(other.start_),
-        total_transferred_(other.total_transferred_),
-        handler_(other.handler_)
-    {
-    }
-
-    read_streambuf_op(read_streambuf_op&& other)
-      : detail::base_from_completion_cond<CompletionCondition>(other),
-        stream_(other.stream_),
-        streambuf_(other.streambuf_),
-        start_(other.start_),
-        total_transferred_(other.total_transferred_),
-        handler_(ASIO_MOVE_CAST(ReadHandler)(other.handler_))
-    {
-    }
-#endif // defined(ASIO_HAS_MOVE)
-
-    void operator()(const asio::error_code& ec,
-        std::size_t bytes_transferred, int start = 0)
-    {
-      std::size_t max_size, bytes_available;
-      switch (start_ = start)
-      {
-        case 1:
-        max_size = this->check_for_completion(ec, total_transferred_);
-        bytes_available = read_size_helper(streambuf_, max_size);
-        for (;;)
-        {
-          stream_.async_read_some(streambuf_.prepare(bytes_available),
-              ASIO_MOVE_CAST(read_streambuf_op)(*this));
-          return; default:
-          total_transferred_ += bytes_transferred;
-          streambuf_.commit(bytes_transferred);
-          max_size = this->check_for_completion(ec, total_transferred_);
-          bytes_available = read_size_helper(streambuf_, max_size);
-          if ((!ec && bytes_transferred == 0) || bytes_available == 0)
-            break;
-        }
-
-        handler_(ec, static_cast<const std::size_t&>(total_transferred_));
-      }
-    }
-
-  //private:
-    AsyncReadStream& stream_;
-    asio::basic_streambuf<Allocator>& streambuf_;
-    int start_;
-    std::size_t total_transferred_;
-    ReadHandler handler_;
-  };
-
-  template <typename AsyncReadStream, typename Allocator,
-      typename CompletionCondition, typename ReadHandler>
-  inline void* asio_handler_allocate(std::size_t size,
-      read_streambuf_op<AsyncReadStream, Allocator,
-        CompletionCondition, ReadHandler>* this_handler)
-  {
-    return asio_handler_alloc_helpers::allocate(
-        size, this_handler->handler_);
-  }
-
-  template <typename AsyncReadStream, typename Allocator,
-      typename CompletionCondition, typename ReadHandler>
-  inline void asio_handler_deallocate(void* pointer, std::size_t size,
-      read_streambuf_op<AsyncReadStream, Allocator,
-        CompletionCondition, ReadHandler>* this_handler)
-  {
-    asio_handler_alloc_helpers::deallocate(
-        pointer, size, this_handler->handler_);
-  }
-
-  template <typename AsyncReadStream, typename Allocator,
-      typename CompletionCondition, typename ReadHandler>
-  inline bool asio_handler_is_continuation(
-      read_streambuf_op<AsyncReadStream, Allocator,
-        CompletionCondition, ReadHandler>* this_handler)
-  {
-    return this_handler->start_ == 0 ? true
-      : asio_handler_cont_helpers::is_continuation(
-          this_handler->handler_);
-  }
-
-  template <typename Function, typename AsyncReadStream,
-      typename Allocator, typename CompletionCondition, typename ReadHandler>
-  inline void asio_handler_invoke(Function& function,
-      read_streambuf_op<AsyncReadStream, Allocator,
-        CompletionCondition, ReadHandler>* this_handler)
-  {
-    asio_handler_invoke_helpers::invoke(
-        function, this_handler->handler_);
-  }
-
-  template <typename Function, typename AsyncReadStream,
-      typename Allocator, typename CompletionCondition, typename ReadHandler>
-  inline void asio_handler_invoke(const Function& function,
-      read_streambuf_op<AsyncReadStream, Allocator,
-        CompletionCondition, ReadHandler>* this_handler)
-  {
-    asio_handler_invoke_helpers::invoke(
-        function, this_handler->handler_);
-  }
-} // namespace detail
-
-template <typename AsyncReadStream, typename Allocator,
-    typename CompletionCondition, typename ReadHandler>
-inline ASIO_INITFN_RESULT_TYPE(ReadHandler,
-    void (asio::error_code, std::size_t))
-async_read(AsyncReadStream& s,
-    asio::basic_streambuf<Allocator>& b,
-    CompletionCondition completion_condition,
-    ASIO_MOVE_ARG(ReadHandler) handler)
-{
-  // If you get an error on the following line it means that your handler does
-  // not meet the documented type requirements for a ReadHandler.
-  ASIO_READ_HANDLER_CHECK(ReadHandler, handler) type_check;
-
-  detail::async_result_init<
-    ReadHandler, void (asio::error_code, std::size_t)> init(
-      ASIO_MOVE_CAST(ReadHandler)(handler));
-
-  detail::read_streambuf_op<AsyncReadStream, Allocator,
-    CompletionCondition, ASIO_HANDLER_TYPE(
-      ReadHandler, void (asio::error_code, std::size_t))>(
-        s, b, completion_condition, init.handler)(
-          asio::error_code(), 0, 1);
-
-  return init.result.get();
-}
-
-template <typename AsyncReadStream, typename Allocator, typename ReadHandler>
-inline ASIO_INITFN_RESULT_TYPE(ReadHandler,
-    void (asio::error_code, std::size_t))
-async_read(AsyncReadStream& s,
-    asio::basic_streambuf<Allocator>& b,
-    ASIO_MOVE_ARG(ReadHandler) handler)
-{
-  // If you get an error on the following line it means that your handler does
-  // not meet the documented type requirements for a ReadHandler.
-  ASIO_READ_HANDLER_CHECK(ReadHandler, handler) type_check;
-
-  detail::async_result_init<
-    ReadHandler, void (asio::error_code, std::size_t)> init(
-      ASIO_MOVE_CAST(ReadHandler)(handler));
-
-  detail::read_streambuf_op<AsyncReadStream, Allocator,
-    detail::transfer_all_t, ASIO_HANDLER_TYPE(
-      ReadHandler, void (asio::error_code, std::size_t))>(
-        s, b, transfer_all(), init.handler)(
-          asio::error_code(), 0, 1);
-
-  return init.result.get();
-}
-
-#endif // !defined(ASIO_NO_IOSTREAM)
-
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_IMPL_READ_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/impl/read_at.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/impl/read_at.hpp
deleted file mode 100644
index 0ce36bc58e72..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/impl/read_at.hpp
+++ /dev/null
@@ -1,810 +0,0 @@
-//
-// impl/read_at.hpp
-// ~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_IMPL_READ_AT_HPP
-#define ASIO_IMPL_READ_AT_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include <algorithm>
-#include "asio/buffer.hpp"
-#include "asio/completion_condition.hpp"
-#include "asio/detail/array_fwd.hpp"
-#include "asio/detail/base_from_completion_cond.hpp"
-#include "asio/detail/bind_handler.hpp"
-#include "asio/detail/consuming_buffers.hpp"
-#include "asio/detail/dependent_type.hpp"
-#include "asio/detail/handler_alloc_helpers.hpp"
-#include "asio/detail/handler_cont_helpers.hpp"
-#include "asio/detail/handler_invoke_helpers.hpp"
-#include "asio/detail/handler_type_requirements.hpp"
-#include "asio/detail/throw_error.hpp"
-#include "asio/error.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-
-template <typename SyncRandomAccessReadDevice, typename MutableBufferSequence,
-    typename CompletionCondition>
-std::size_t read_at(SyncRandomAccessReadDevice& d,
-    uint64_t offset, const MutableBufferSequence& buffers,
-    CompletionCondition completion_condition, asio::error_code& ec)
-{
-  ec = asio::error_code();
-  asio::detail::consuming_buffers<
-    mutable_buffer, MutableBufferSequence> tmp(buffers);
-  std::size_t total_transferred = 0;
-  tmp.prepare(detail::adapt_completion_condition_result(
-        completion_condition(ec, total_transferred)));
-  while (tmp.begin() != tmp.end())
-  {
-    std::size_t bytes_transferred = d.read_some_at(
-        offset + total_transferred, tmp, ec);
-    tmp.consume(bytes_transferred);
-    total_transferred += bytes_transferred;
-    tmp.prepare(detail::adapt_completion_condition_result(
-          completion_condition(ec, total_transferred)));
-  }
-  return total_transferred;
-}
-
-template <typename SyncRandomAccessReadDevice, typename MutableBufferSequence>
-inline std::size_t read_at(SyncRandomAccessReadDevice& d,
-    uint64_t offset, const MutableBufferSequence& buffers)
-{
-  asio::error_code ec;
-  std::size_t bytes_transferred = read_at(
-      d, offset, buffers, transfer_all(), ec);
-  asio::detail::throw_error(ec, "read_at");
-  return bytes_transferred;
-}
-
-template <typename SyncRandomAccessReadDevice, typename MutableBufferSequence>
-inline std::size_t read_at(SyncRandomAccessReadDevice& d,
-    uint64_t offset, const MutableBufferSequence& buffers,
-    asio::error_code& ec)
-{
-  return read_at(d, offset, buffers, transfer_all(), ec);
-}
-
-template <typename SyncRandomAccessReadDevice, typename MutableBufferSequence,
-    typename CompletionCondition>
-inline std::size_t read_at(SyncRandomAccessReadDevice& d,
-    uint64_t offset, const MutableBufferSequence& buffers,
-    CompletionCondition completion_condition)
-{
-  asio::error_code ec;
-  std::size_t bytes_transferred = read_at(
-      d, offset, buffers, completion_condition, ec);
-  asio::detail::throw_error(ec, "read_at");
-  return bytes_transferred;
-}
-
-#if !defined(ASIO_NO_IOSTREAM)
-
-template <typename SyncRandomAccessReadDevice, typename Allocator,
-    typename CompletionCondition>
-std::size_t read_at(SyncRandomAccessReadDevice& d,
-    uint64_t offset, asio::basic_streambuf<Allocator>& b,
-    CompletionCondition completion_condition, asio::error_code& ec)
-{
-  ec = asio::error_code();
-  std::size_t total_transferred = 0;
-  std::size_t max_size = detail::adapt_completion_condition_result(
-        completion_condition(ec, total_transferred));
-  std::size_t bytes_available = read_size_helper(b, max_size);
-  while (bytes_available > 0)
-  {
-    std::size_t bytes_transferred = d.read_some_at(
-        offset + total_transferred, b.prepare(bytes_available), ec);
-    b.commit(bytes_transferred);
-    total_transferred += bytes_transferred;
-    max_size = detail::adapt_completion_condition_result(
-          completion_condition(ec, total_transferred));
-    bytes_available = read_size_helper(b, max_size);
-  }
-  return total_transferred;
-}
-
-template <typename SyncRandomAccessReadDevice, typename Allocator>
-inline std::size_t read_at(SyncRandomAccessReadDevice& d,
-    uint64_t offset, asio::basic_streambuf<Allocator>& b)
-{
-  asio::error_code ec;
-  std::size_t bytes_transferred = read_at(
-      d, offset, b, transfer_all(), ec);
-  asio::detail::throw_error(ec, "read_at");
-  return bytes_transferred;
-}
-
-template <typename SyncRandomAccessReadDevice, typename Allocator>
-inline std::size_t read_at(SyncRandomAccessReadDevice& d,
-    uint64_t offset, asio::basic_streambuf<Allocator>& b,
-    asio::error_code& ec)
-{
-  return read_at(d, offset, b, transfer_all(), ec);
-}
-
-template <typename SyncRandomAccessReadDevice, typename Allocator,
-    typename CompletionCondition>
-inline std::size_t read_at(SyncRandomAccessReadDevice& d,
-    uint64_t offset, asio::basic_streambuf<Allocator>& b,
-    CompletionCondition completion_condition)
-{
-  asio::error_code ec;
-  std::size_t bytes_transferred = read_at(
-      d, offset, b, completion_condition, ec);
-  asio::detail::throw_error(ec, "read_at");
-  return bytes_transferred;
-}
-
-#endif // !defined(ASIO_NO_IOSTREAM)
-
-namespace detail
-{
-  template <typename AsyncRandomAccessReadDevice,
-      typename MutableBufferSequence, typename CompletionCondition,
-      typename ReadHandler>
-  class read_at_op
-    : detail::base_from_completion_cond<CompletionCondition>
-  {
-  public:
-    read_at_op(AsyncRandomAccessReadDevice& device,
-        uint64_t offset, const MutableBufferSequence& buffers,
-        CompletionCondition completion_condition, ReadHandler& handler)
-      : detail::base_from_completion_cond<
-          CompletionCondition>(completion_condition),
-        device_(device),
-        offset_(offset),
-        buffers_(buffers),
-        start_(0),
-        total_transferred_(0),
-        handler_(ASIO_MOVE_CAST(ReadHandler)(handler))
-    {
-    }
-
-#if defined(ASIO_HAS_MOVE)
-    read_at_op(const read_at_op& other)
-      : detail::base_from_completion_cond<CompletionCondition>(other),
-        device_(other.device_),
-        offset_(other.offset_),
-        buffers_(other.buffers_),
-        start_(other.start_),
-        total_transferred_(other.total_transferred_),
-        handler_(other.handler_)
-    {
-    }
-
-    read_at_op(read_at_op&& other)
-      : detail::base_from_completion_cond<CompletionCondition>(other),
-        device_(other.device_),
-        offset_(other.offset_),
-        buffers_(other.buffers_),
-        start_(other.start_),
-        total_transferred_(other.total_transferred_),
-        handler_(ASIO_MOVE_CAST(ReadHandler)(other.handler_))
-    {
-    }
-#endif // defined(ASIO_HAS_MOVE)
-
-    void operator()(const asio::error_code& ec,
-        std::size_t bytes_transferred, int start = 0)
-    {
-      switch (start_ = start)
-      {
-        case 1:
-        buffers_.prepare(this->check_for_completion(ec, total_transferred_));
-        for (;;)
-        {
-          device_.async_read_some_at(offset_ + total_transferred_,
-              buffers_, ASIO_MOVE_CAST(read_at_op)(*this));
-          return; default:
-          total_transferred_ += bytes_transferred;
-          buffers_.consume(bytes_transferred);
-          buffers_.prepare(this->check_for_completion(ec, total_transferred_));
-          if ((!ec && bytes_transferred == 0)
-              || buffers_.begin() == buffers_.end())
-            break;
-        }
-
-        handler_(ec, static_cast<const std::size_t&>(total_transferred_));
-      }
-    }
-
-  //private:
-    AsyncRandomAccessReadDevice& device_;
-    uint64_t offset_;
-    asio::detail::consuming_buffers<
-      mutable_buffer, MutableBufferSequence> buffers_;
-    int start_;
-    std::size_t total_transferred_;
-    ReadHandler handler_;
-  };
-
-  template <typename AsyncRandomAccessReadDevice,
-      typename CompletionCondition, typename ReadHandler>
-  class read_at_op<AsyncRandomAccessReadDevice,
-      asio::mutable_buffers_1, CompletionCondition, ReadHandler>
-    : detail::base_from_completion_cond<CompletionCondition>
-  {
-  public:
-    read_at_op(AsyncRandomAccessReadDevice& device,
-        uint64_t offset, const asio::mutable_buffers_1& buffers,
-        CompletionCondition completion_condition, ReadHandler& handler)
-      : detail::base_from_completion_cond<
-          CompletionCondition>(completion_condition),
-        device_(device),
-        offset_(offset),
-        buffer_(buffers),
-        start_(0),
-        total_transferred_(0),
-        handler_(ASIO_MOVE_CAST(ReadHandler)(handler))
-    {
-    }
-
-#if defined(ASIO_HAS_MOVE)
-    read_at_op(const read_at_op& other)
-      : detail::base_from_completion_cond<CompletionCondition>(other),
-        device_(other.device_),
-        offset_(other.offset_),
-        buffer_(other.buffer_),
-        start_(other.start_),
-        total_transferred_(other.total_transferred_),
-        handler_(other.handler_)
-    {
-    }
-
-    read_at_op(read_at_op&& other)
-      : detail::base_from_completion_cond<CompletionCondition>(other),
-        device_(other.device_),
-        offset_(other.offset_),
-        buffer_(other.buffer_),
-        start_(other.start_),
-        total_transferred_(other.total_transferred_),
-        handler_(ASIO_MOVE_CAST(ReadHandler)(other.handler_))
-    {
-    }
-#endif // defined(ASIO_HAS_MOVE)
-
-    void operator()(const asio::error_code& ec,
-        std::size_t bytes_transferred, int start = 0)
-    {
-      std::size_t n = 0;
-      switch (start_ = start)
-      {
-        case 1:
-        n = this->check_for_completion(ec, total_transferred_);
-        for (;;)
-        {
-          device_.async_read_some_at(offset_ + total_transferred_,
-              asio::buffer(buffer_ + total_transferred_, n),
-              ASIO_MOVE_CAST(read_at_op)(*this));
-          return; default:
-          total_transferred_ += bytes_transferred;
-          if ((!ec && bytes_transferred == 0)
-              || (n = this->check_for_completion(ec, total_transferred_)) == 0
-              || total_transferred_ == asio::buffer_size(buffer_))
-            break;
-        }
-
-        handler_(ec, static_cast<const std::size_t&>(total_transferred_));
-      }
-    }
-
-  //private:
-    AsyncRandomAccessReadDevice& device_;
-    uint64_t offset_;
-    asio::mutable_buffer buffer_;
-    int start_;
-    std::size_t total_transferred_;
-    ReadHandler handler_;
-  };
-
-  template <typename AsyncRandomAccessReadDevice, typename Elem,
-      typename CompletionCondition, typename ReadHandler>
-  class read_at_op<AsyncRandomAccessReadDevice, boost::array<Elem, 2>,
-      CompletionCondition, ReadHandler>
-    : detail::base_from_completion_cond<CompletionCondition>
-  {
-  public:
-    read_at_op(AsyncRandomAccessReadDevice& device,
-        uint64_t offset, const boost::array<Elem, 2>& buffers,
-        CompletionCondition completion_condition, ReadHandler& handler)
-      : detail::base_from_completion_cond<
-          CompletionCondition>(completion_condition),
-        device_(device),
-        offset_(offset),
-        buffers_(buffers),
-        start_(0),
-        total_transferred_(0),
-        handler_(ASIO_MOVE_CAST(ReadHandler)(handler))
-    {
-    }
-
-#if defined(ASIO_HAS_MOVE)
-    read_at_op(const read_at_op& other)
-      : detail::base_from_completion_cond<CompletionCondition>(other),
-        device_(other.device_),
-        offset_(other.offset_),
-        buffers_(other.buffers_),
-        start_(other.start_),
-        total_transferred_(other.total_transferred_),
-        handler_(other.handler_)
-    {
-    }
-
-    read_at_op(read_at_op&& other)
-      : detail::base_from_completion_cond<CompletionCondition>(other),
-        device_(other.device_),
-        offset_(other.offset_),
-        buffers_(other.buffers_),
-        start_(other.start_),
-        total_transferred_(other.total_transferred_),
-        handler_(ASIO_MOVE_CAST(ReadHandler)(other.handler_))
-    {
-    }
-#endif // defined(ASIO_HAS_MOVE)
-
-    void operator()(const asio::error_code& ec,
-        std::size_t bytes_transferred, int start = 0)
-    {
-      typename asio::detail::dependent_type<Elem,
-          boost::array<asio::mutable_buffer, 2> >::type bufs = {{
-        asio::mutable_buffer(buffers_[0]),
-        asio::mutable_buffer(buffers_[1]) }};
-      std::size_t buffer_size0 = asio::buffer_size(bufs[0]);
-      std::size_t buffer_size1 = asio::buffer_size(bufs[1]);
-      std::size_t n = 0;
-      switch (start_ = start)
-      {
-        case 1:
-        n = this->check_for_completion(ec, total_transferred_);
-        for (;;)
-        {
-          bufs[0] = asio::buffer(bufs[0] + total_transferred_, n);
-          bufs[1] = asio::buffer(
-              bufs[1] + (total_transferred_ < buffer_size0
-                ? 0 : total_transferred_ - buffer_size0),
-              n - asio::buffer_size(bufs[0]));
-          device_.async_read_some_at(offset_ + total_transferred_,
-              bufs, ASIO_MOVE_CAST(read_at_op)(*this));
-          return; default:
-          total_transferred_ += bytes_transferred;
-          if ((!ec && bytes_transferred == 0)
-              || (n = this->check_for_completion(ec, total_transferred_)) == 0
-              || total_transferred_ == buffer_size0 + buffer_size1)
-            break;
-        }
-
-        handler_(ec, static_cast<const std::size_t&>(total_transferred_));
-      }
-    }
-
-  //private:
-    AsyncRandomAccessReadDevice& device_;
-    uint64_t offset_;
-    boost::array<Elem, 2> buffers_;
-    int start_;
-    std::size_t total_transferred_;
-    ReadHandler handler_;
-  };
-
-#if defined(ASIO_HAS_STD_ARRAY)
-
-  template <typename AsyncRandomAccessReadDevice, typename Elem,
-      typename CompletionCondition, typename ReadHandler>
-  class read_at_op<AsyncRandomAccessReadDevice, std::array<Elem, 2>,
-      CompletionCondition, ReadHandler>
-    : detail::base_from_completion_cond<CompletionCondition>
-  {
-  public:
-    read_at_op(AsyncRandomAccessReadDevice& device,
-        uint64_t offset, const std::array<Elem, 2>& buffers,
-        CompletionCondition completion_condition, ReadHandler& handler)
-      : detail::base_from_completion_cond<
-          CompletionCondition>(completion_condition),
-        device_(device),
-        offset_(offset),
-        buffers_(buffers),
-        start_(0),
-        total_transferred_(0),
-        handler_(ASIO_MOVE_CAST(ReadHandler)(handler))
-    {
-    }
-
-#if defined(ASIO_HAS_MOVE)
-    read_at_op(const read_at_op& other)
-      : detail::base_from_completion_cond<CompletionCondition>(other),
-        device_(other.device_),
-        offset_(other.offset_),
-        buffers_(other.buffers_),
-        start_(other.start_),
-        total_transferred_(other.total_transferred_),
-        handler_(other.handler_)
-    {
-    }
-
-    read_at_op(read_at_op&& other)
-      : detail::base_from_completion_cond<CompletionCondition>(other),
-        device_(other.device_),
-        offset_(other.offset_),
-        buffers_(other.buffers_),
-        start_(other.start_),
-        total_transferred_(other.total_transferred_),
-        handler_(ASIO_MOVE_CAST(ReadHandler)(other.handler_))
-    {
-    }
-#endif // defined(ASIO_HAS_MOVE)
-
-    void operator()(const asio::error_code& ec,
-        std::size_t bytes_transferred, int start = 0)
-    {
-      typename asio::detail::dependent_type<Elem,
-          std::array<asio::mutable_buffer, 2> >::type bufs = {{
-        asio::mutable_buffer(buffers_[0]),
-        asio::mutable_buffer(buffers_[1]) }};
-      std::size_t buffer_size0 = asio::buffer_size(bufs[0]);
-      std::size_t buffer_size1 = asio::buffer_size(bufs[1]);
-      std::size_t n = 0;
-      switch (start_ = start)
-      {
-        case 1:
-        n = this->check_for_completion(ec, total_transferred_);
-        for (;;)
-        {
-          bufs[0] = asio::buffer(bufs[0] + total_transferred_, n);
-          bufs[1] = asio::buffer(
-              bufs[1] + (total_transferred_ < buffer_size0
-                ? 0 : total_transferred_ - buffer_size0),
-              n - asio::buffer_size(bufs[0]));
-          device_.async_read_some_at(offset_ + total_transferred_,
-              bufs, ASIO_MOVE_CAST(read_at_op)(*this));
-          return; default:
-          total_transferred_ += bytes_transferred;
-          if ((!ec && bytes_transferred == 0)
-              || (n = this->check_for_completion(ec, total_transferred_)) == 0
-              || total_transferred_ == buffer_size0 + buffer_size1)
-            break;
-        }
-
-        handler_(ec, static_cast<const std::size_t&>(total_transferred_));
-      }
-    }
-
-  //private:
-    AsyncRandomAccessReadDevice& device_;
-    uint64_t offset_;
-    std::array<Elem, 2> buffers_;
-    int start_;
-    std::size_t total_transferred_;
-    ReadHandler handler_;
-  };
-
-#endif // defined(ASIO_HAS_STD_ARRAY)
-
-  template <typename AsyncRandomAccessReadDevice,
-      typename MutableBufferSequence, typename CompletionCondition,
-      typename ReadHandler>
-  inline void* asio_handler_allocate(std::size_t size,
-      read_at_op<AsyncRandomAccessReadDevice, MutableBufferSequence,
-        CompletionCondition, ReadHandler>* this_handler)
-  {
-    return asio_handler_alloc_helpers::allocate(
-        size, this_handler->handler_);
-  }
-
-  template <typename AsyncRandomAccessReadDevice,
-      typename MutableBufferSequence, typename CompletionCondition,
-      typename ReadHandler>
-  inline void asio_handler_deallocate(void* pointer, std::size_t size,
-      read_at_op<AsyncRandomAccessReadDevice, MutableBufferSequence,
-        CompletionCondition, ReadHandler>* this_handler)
-  {
-    asio_handler_alloc_helpers::deallocate(
-        pointer, size, this_handler->handler_);
-  }
-
-  template <typename AsyncRandomAccessReadDevice,
-      typename MutableBufferSequence, typename CompletionCondition,
-      typename ReadHandler>
-  inline bool asio_handler_is_continuation(
-      read_at_op<AsyncRandomAccessReadDevice, MutableBufferSequence,
-        CompletionCondition, ReadHandler>* this_handler)
-  {
-    return this_handler->start_ == 0 ? true
-      : asio_handler_cont_helpers::is_continuation(
-          this_handler->handler_);
-  }
-
-  template <typename Function, typename AsyncRandomAccessReadDevice,
-      typename MutableBufferSequence, typename CompletionCondition,
-      typename ReadHandler>
-  inline void asio_handler_invoke(Function& function,
-      read_at_op<AsyncRandomAccessReadDevice, MutableBufferSequence,
-        CompletionCondition, ReadHandler>* this_handler)
-  {
-    asio_handler_invoke_helpers::invoke(
-        function, this_handler->handler_);
-  }
-
-  template <typename Function, typename AsyncRandomAccessReadDevice,
-      typename MutableBufferSequence, typename CompletionCondition,
-      typename ReadHandler>
-  inline void asio_handler_invoke(const Function& function,
-      read_at_op<AsyncRandomAccessReadDevice, MutableBufferSequence,
-        CompletionCondition, ReadHandler>* this_handler)
-  {
-    asio_handler_invoke_helpers::invoke(
-        function, this_handler->handler_);
-  }
-
-  template <typename AsyncRandomAccessReadDevice,
-      typename MutableBufferSequence, typename CompletionCondition,
-      typename ReadHandler>
-  inline read_at_op<AsyncRandomAccessReadDevice,
-      MutableBufferSequence, CompletionCondition, ReadHandler>
-  make_read_at_op(AsyncRandomAccessReadDevice& d,
-      uint64_t offset, const MutableBufferSequence& buffers,
-      CompletionCondition completion_condition, ReadHandler handler)
-  {
-    return read_at_op<AsyncRandomAccessReadDevice,
-      MutableBufferSequence, CompletionCondition, ReadHandler>(
-        d, offset, buffers, completion_condition, handler);
-  }
-} // namespace detail
-
-template <typename AsyncRandomAccessReadDevice, typename MutableBufferSequence,
-    typename CompletionCondition, typename ReadHandler>
-inline ASIO_INITFN_RESULT_TYPE(ReadHandler,
-    void (asio::error_code, std::size_t))
-async_read_at(AsyncRandomAccessReadDevice& d,
-    uint64_t offset, const MutableBufferSequence& buffers,
-    CompletionCondition completion_condition,
-    ASIO_MOVE_ARG(ReadHandler) handler)
-{
-  // If you get an error on the following line it means that your handler does
-  // not meet the documented type requirements for a ReadHandler.
-  ASIO_READ_HANDLER_CHECK(ReadHandler, handler) type_check;
-
-  detail::async_result_init<
-    ReadHandler, void (asio::error_code, std::size_t)> init(
-      ASIO_MOVE_CAST(ReadHandler)(handler));
-
-  detail::read_at_op<AsyncRandomAccessReadDevice, MutableBufferSequence,
-    CompletionCondition, ASIO_HANDLER_TYPE(ReadHandler,
-      void (asio::error_code, std::size_t))>(
-        d, offset, buffers, completion_condition, init.handler)(
-          asio::error_code(), 0, 1);
-
-  return init.result.get();
-}
-
-template <typename AsyncRandomAccessReadDevice, typename MutableBufferSequence,
-    typename ReadHandler>
-inline ASIO_INITFN_RESULT_TYPE(ReadHandler,
-    void (asio::error_code, std::size_t))
-async_read_at(AsyncRandomAccessReadDevice& d,
-    uint64_t offset, const MutableBufferSequence& buffers,
-    ASIO_MOVE_ARG(ReadHandler) handler)
-{
-  // If you get an error on the following line it means that your handler does
-  // not meet the documented type requirements for a ReadHandler.
-  ASIO_READ_HANDLER_CHECK(ReadHandler, handler) type_check;
-
-  detail::async_result_init<
-    ReadHandler, void (asio::error_code, std::size_t)> init(
-      ASIO_MOVE_CAST(ReadHandler)(handler));
-
-  detail::read_at_op<AsyncRandomAccessReadDevice, MutableBufferSequence,
-    detail::transfer_all_t, ASIO_HANDLER_TYPE(ReadHandler,
-      void (asio::error_code, std::size_t))>(
-        d, offset, buffers, transfer_all(), init.handler)(
-          asio::error_code(), 0, 1);
-
-  return init.result.get();
-}
-
-#if !defined(ASIO_NO_IOSTREAM)
-
-namespace detail
-{
-  template <typename AsyncRandomAccessReadDevice, typename Allocator,
-      typename CompletionCondition, typename ReadHandler>
-  class read_at_streambuf_op
-    : detail::base_from_completion_cond<CompletionCondition>
-  {
-  public:
-    read_at_streambuf_op(AsyncRandomAccessReadDevice& device,
-        uint64_t offset, basic_streambuf<Allocator>& streambuf,
-        CompletionCondition completion_condition, ReadHandler& handler)
-      : detail::base_from_completion_cond<
-          CompletionCondition>(completion_condition),
-        device_(device),
-        offset_(offset),
-        streambuf_(streambuf),
-        start_(0),
-        total_transferred_(0),
-        handler_(ASIO_MOVE_CAST(ReadHandler)(handler))
-    {
-    }
-
-#if defined(ASIO_HAS_MOVE)
-    read_at_streambuf_op(const read_at_streambuf_op& other)
-      : detail::base_from_completion_cond<CompletionCondition>(other),
-        device_(other.device_),
-        offset_(other.offset_),
-        streambuf_(other.streambuf_),
-        start_(other.start_),
-        total_transferred_(other.total_transferred_),
-        handler_(other.handler_)
-    {
-    }
-
-    read_at_streambuf_op(read_at_streambuf_op&& other)
-      : detail::base_from_completion_cond<CompletionCondition>(other),
-        device_(other.device_),
-        offset_(other.offset_),
-        streambuf_(other.streambuf_),
-        start_(other.start_),
-        total_transferred_(other.total_transferred_),
-        handler_(ASIO_MOVE_CAST(ReadHandler)(other.handler_))
-    {
-    }
-#endif // defined(ASIO_HAS_MOVE)
-
-    void operator()(const asio::error_code& ec,
-        std::size_t bytes_transferred, int start = 0)
-    {
-      std::size_t max_size, bytes_available;
-      switch (start_ = start)
-      {
-        case 1:
-        max_size = this->check_for_completion(ec, total_transferred_);
-        bytes_available = read_size_helper(streambuf_, max_size);
-        for (;;)
-        {
-          device_.async_read_some_at(offset_ + total_transferred_,
-              streambuf_.prepare(bytes_available),
-              ASIO_MOVE_CAST(read_at_streambuf_op)(*this));
-          return; default:
-          total_transferred_ += bytes_transferred;
-          streambuf_.commit(bytes_transferred);
-          max_size = this->check_for_completion(ec, total_transferred_);
-          bytes_available = read_size_helper(streambuf_, max_size);
-          if ((!ec && bytes_transferred == 0) || bytes_available == 0)
-            break;
-        }
-
-        handler_(ec, static_cast<const std::size_t&>(total_transferred_));
-      }
-    }
-
-  //private:
-    AsyncRandomAccessReadDevice& device_;
-    uint64_t offset_;
-    asio::basic_streambuf<Allocator>& streambuf_;
-    int start_;
-    std::size_t total_transferred_;
-    ReadHandler handler_;
-  };
-
-  template <typename AsyncRandomAccessReadDevice, typename Allocator,
-      typename CompletionCondition, typename ReadHandler>
-  inline void* asio_handler_allocate(std::size_t size,
-      read_at_streambuf_op<AsyncRandomAccessReadDevice, Allocator,
-        CompletionCondition, ReadHandler>* this_handler)
-  {
-    return asio_handler_alloc_helpers::allocate(
-        size, this_handler->handler_);
-  }
-
-  template <typename AsyncRandomAccessReadDevice, typename Allocator,
-      typename CompletionCondition, typename ReadHandler>
-  inline void asio_handler_deallocate(void* pointer, std::size_t size,
-      read_at_streambuf_op<AsyncRandomAccessReadDevice, Allocator,
-        CompletionCondition, ReadHandler>* this_handler)
-  {
-    asio_handler_alloc_helpers::deallocate(
-        pointer, size, this_handler->handler_);
-  }
-
-  template <typename AsyncRandomAccessReadDevice, typename Allocator,
-      typename CompletionCondition, typename ReadHandler>
-  inline bool asio_handler_is_continuation(
-      read_at_streambuf_op<AsyncRandomAccessReadDevice, Allocator,
-        CompletionCondition, ReadHandler>* this_handler)
-  {
-    return this_handler->start_ == 0 ? true
-      : asio_handler_cont_helpers::is_continuation(
-          this_handler->handler_);
-  }
-
-  template <typename Function, typename AsyncRandomAccessReadDevice,
-      typename Allocator, typename CompletionCondition, typename ReadHandler>
-  inline void asio_handler_invoke(Function& function,
-      read_at_streambuf_op<AsyncRandomAccessReadDevice, Allocator,
-        CompletionCondition, ReadHandler>* this_handler)
-  {
-    asio_handler_invoke_helpers::invoke(
-        function, this_handler->handler_);
-  }
-
-  template <typename Function, typename AsyncRandomAccessReadDevice,
-      typename Allocator, typename CompletionCondition, typename ReadHandler>
-  inline void asio_handler_invoke(const Function& function,
-      read_at_streambuf_op<AsyncRandomAccessReadDevice, Allocator,
-        CompletionCondition, ReadHandler>* this_handler)
-  {
-    asio_handler_invoke_helpers::invoke(
-        function, this_handler->handler_);
-  }
-} // namespace detail
-
-template <typename AsyncRandomAccessReadDevice, typename Allocator,
-    typename CompletionCondition, typename ReadHandler>
-inline ASIO_INITFN_RESULT_TYPE(ReadHandler,
-    void (asio::error_code, std::size_t))
-async_read_at(AsyncRandomAccessReadDevice& d,
-    uint64_t offset, asio::basic_streambuf<Allocator>& b,
-    CompletionCondition completion_condition,
-    ASIO_MOVE_ARG(ReadHandler) handler)
-{
-  // If you get an error on the following line it means that your handler does
-  // not meet the documented type requirements for a ReadHandler.
-  ASIO_READ_HANDLER_CHECK(ReadHandler, handler) type_check;
-
-  detail::async_result_init<
-    ReadHandler, void (asio::error_code, std::size_t)> init(
-      ASIO_MOVE_CAST(ReadHandler)(handler));
-
-  detail::read_at_streambuf_op<AsyncRandomAccessReadDevice, Allocator,
-    CompletionCondition, ASIO_HANDLER_TYPE(ReadHandler,
-      void (asio::error_code, std::size_t))>(
-        d, offset, b, completion_condition, init.handler)(
-          asio::error_code(), 0, 1);
-
-  return init.result.get();
-}
-
-template <typename AsyncRandomAccessReadDevice, typename Allocator,
-    typename ReadHandler>
-inline ASIO_INITFN_RESULT_TYPE(ReadHandler,
-    void (asio::error_code, std::size_t))
-async_read_at(AsyncRandomAccessReadDevice& d,
-    uint64_t offset, asio::basic_streambuf<Allocator>& b,
-    ASIO_MOVE_ARG(ReadHandler) handler)
-{
-  // If you get an error on the following line it means that your handler does
-  // not meet the documented type requirements for a ReadHandler.
-  ASIO_READ_HANDLER_CHECK(ReadHandler, handler) type_check;
-
-  detail::async_result_init<
-    ReadHandler, void (asio::error_code, std::size_t)> init(
-      ASIO_MOVE_CAST(ReadHandler)(handler));
-
-  detail::read_at_streambuf_op<AsyncRandomAccessReadDevice, Allocator,
-    detail::transfer_all_t, ASIO_HANDLER_TYPE(ReadHandler,
-      void (asio::error_code, std::size_t))>(
-        d, offset, b, transfer_all(), init.handler)(
-          asio::error_code(), 0, 1);
-
-  return init.result.get();
-}
-
-#endif // !defined(ASIO_NO_IOSTREAM)
-
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_IMPL_READ_AT_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/impl/read_until.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/impl/read_until.hpp
deleted file mode 100644
index 88f3b50a33f0..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/impl/read_until.hpp
+++ /dev/null
@@ -1,1147 +0,0 @@
-//
-// impl/read_until.hpp
-// ~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_IMPL_READ_UNTIL_HPP
-#define ASIO_IMPL_READ_UNTIL_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include <algorithm>
-#include <string>
-#include <vector>
-#include <utility>
-#include "asio/buffer.hpp"
-#include "asio/buffers_iterator.hpp"
-#include "asio/detail/bind_handler.hpp"
-#include "asio/detail/handler_alloc_helpers.hpp"
-#include "asio/detail/handler_cont_helpers.hpp"
-#include "asio/detail/handler_invoke_helpers.hpp"
-#include "asio/detail/handler_type_requirements.hpp"
-#include "asio/detail/limits.hpp"
-#include "asio/detail/throw_error.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-
-template <typename SyncReadStream, typename Allocator>
-inline std::size_t read_until(SyncReadStream& s,
-    asio::basic_streambuf<Allocator>& b, char delim)
-{
-  asio::error_code ec;
-  std::size_t bytes_transferred = read_until(s, b, delim, ec);
-  asio::detail::throw_error(ec, "read_until");
-  return bytes_transferred;
-}
-
-template <typename SyncReadStream, typename Allocator>
-std::size_t read_until(SyncReadStream& s,
-    asio::basic_streambuf<Allocator>& b, char delim,
-    asio::error_code& ec)
-{
-  std::size_t search_position = 0;
-  for (;;)
-  {
-    // Determine the range of the data to be searched.
-    typedef typename asio::basic_streambuf<
-      Allocator>::const_buffers_type const_buffers_type;
-    typedef asio::buffers_iterator<const_buffers_type> iterator;
-    const_buffers_type buffers = b.data();
-    iterator begin = iterator::begin(buffers);
-    iterator start_pos = begin + search_position;
-    iterator end = iterator::end(buffers);
-
-    // Look for a match.
-    iterator iter = std::find(start_pos, end, delim);
-    if (iter != end)
-    {
-      // Found a match. We're done.
-      ec = asio::error_code();
-      return iter - begin + 1;
-    }
-    else
-    {
-      // No match. Next search can start with the new data.
-      search_position = end - begin;
-    }
-
-    // Check if buffer is full.
-    if (b.size() == b.max_size())
-    {
-      ec = error::not_found;
-      return 0;
-    }
-
-    // Need more data.
-    std::size_t bytes_to_read = read_size_helper(b, 65536);
-    b.commit(s.read_some(b.prepare(bytes_to_read), ec));
-    if (ec)
-      return 0;
-  }
-}
-
-template <typename SyncReadStream, typename Allocator>
-inline std::size_t read_until(SyncReadStream& s,
-    asio::basic_streambuf<Allocator>& b, const std::string& delim)
-{
-  asio::error_code ec;
-  std::size_t bytes_transferred = read_until(s, b, delim, ec);
-  asio::detail::throw_error(ec, "read_until");
-  return bytes_transferred;
-}
-
-namespace detail
-{
-  // Algorithm that finds a subsequence of equal values in a sequence. Returns
-  // (iterator,true) if a full match was found, in which case the iterator
-  // points to the beginning of the match. Returns (iterator,false) if a
-  // partial match was found at the end of the first sequence, in which case
-  // the iterator points to the beginning of the partial match. Returns
-  // (last1,false) if no full or partial match was found.
-  template <typename Iterator1, typename Iterator2>
-  std::pair<Iterator1, bool> partial_search(
-      Iterator1 first1, Iterator1 last1, Iterator2 first2, Iterator2 last2)
-  {
-    for (Iterator1 iter1 = first1; iter1 != last1; ++iter1)
-    {
-      Iterator1 test_iter1 = iter1;
-      Iterator2 test_iter2 = first2;
-      for (;; ++test_iter1, ++test_iter2)
-      {
-        if (test_iter2 == last2)
-          return std::make_pair(iter1, true);
-        if (test_iter1 == last1)
-        {
-          if (test_iter2 != first2)
-            return std::make_pair(iter1, false);
-          else
-            break;
-        }
-        if (*test_iter1 != *test_iter2)
-          break;
-      }
-    }
-    return std::make_pair(last1, false);
-  }
-} // namespace detail
-
-template <typename SyncReadStream, typename Allocator>
-std::size_t read_until(SyncReadStream& s,
-    asio::basic_streambuf<Allocator>& b, const std::string& delim,
-    asio::error_code& ec)
-{
-  std::size_t search_position = 0;
-  for (;;)
-  {
-    // Determine the range of the data to be searched.
-    typedef typename asio::basic_streambuf<
-      Allocator>::const_buffers_type const_buffers_type;
-    typedef asio::buffers_iterator<const_buffers_type> iterator;
-    const_buffers_type buffers = b.data();
-    iterator begin = iterator::begin(buffers);
-    iterator start_pos = begin + search_position;
-    iterator end = iterator::end(buffers);
-
-    // Look for a match.
-    std::pair<iterator, bool> result = detail::partial_search(
-        start_pos, end, delim.begin(), delim.end());
-    if (result.first != end)
-    {
-      if (result.second)
-      {
-        // Full match. We're done.
-        ec = asio::error_code();
-        return result.first - begin + delim.length();
-      }
-      else
-      {
-        // Partial match. Next search needs to start from beginning of match.
-        search_position = result.first - begin;
-      }
-    }
-    else
-    {
-      // No match. Next search can start with the new data.
-      search_position = end - begin;
-    }
-
-    // Check if buffer is full.
-    if (b.size() == b.max_size())
-    {
-      ec = error::not_found;
-      return 0;
-    }
-
-    // Need more data.
-    std::size_t bytes_to_read = read_size_helper(b, 65536);
-    b.commit(s.read_some(b.prepare(bytes_to_read), ec));
-    if (ec)
-      return 0;
-  }
-}
-
-#if defined(ASIO_HAS_BOOST_REGEX)
-
-template <typename SyncReadStream, typename Allocator>
-inline std::size_t read_until(SyncReadStream& s,
-    asio::basic_streambuf<Allocator>& b, const boost::regex& expr)
-{
-  asio::error_code ec;
-  std::size_t bytes_transferred = read_until(s, b, expr, ec);
-  asio::detail::throw_error(ec, "read_until");
-  return bytes_transferred;
-}
-
-template <typename SyncReadStream, typename Allocator>
-std::size_t read_until(SyncReadStream& s,
-    asio::basic_streambuf<Allocator>& b, const boost::regex& expr,
-    asio::error_code& ec)
-{
-  std::size_t search_position = 0;
-  for (;;)
-  {
-    // Determine the range of the data to be searched.
-    typedef typename asio::basic_streambuf<
-      Allocator>::const_buffers_type const_buffers_type;
-    typedef asio::buffers_iterator<const_buffers_type> iterator;
-    const_buffers_type buffers = b.data();
-    iterator begin = iterator::begin(buffers);
-    iterator start_pos = begin + search_position;
-    iterator end = iterator::end(buffers);
-
-    // Look for a match.
-    boost::match_results<iterator,
-      typename std::vector<boost::sub_match<iterator> >::allocator_type>
-        match_results;
-    if (regex_search(start_pos, end, match_results, expr,
-          boost::match_default | boost::match_partial))
-    {
-      if (match_results[0].matched)
-      {
-        // Full match. We're done.
-        ec = asio::error_code();
-        return match_results[0].second - begin;
-      }
-      else
-      {
-        // Partial match. Next search needs to start from beginning of match.
-        search_position = match_results[0].first - begin;
-      }
-    }
-    else
-    {
-      // No match. Next search can start with the new data.
-      search_position = end - begin;
-    }
-
-    // Check if buffer is full.
-    if (b.size() == b.max_size())
-    {
-      ec = error::not_found;
-      return 0;
-    }
-
-    // Need more data.
-    std::size_t bytes_to_read = read_size_helper(b, 65536);
-    b.commit(s.read_some(b.prepare(bytes_to_read), ec));
-    if (ec)
-      return 0;
-  }
-}
-
-#endif // defined(ASIO_HAS_BOOST_REGEX)
-
-template <typename SyncReadStream, typename Allocator, typename MatchCondition>
-std::size_t read_until(SyncReadStream& s,
-    asio::basic_streambuf<Allocator>& b,
-    MatchCondition match_condition, asio::error_code& ec,
-    typename enable_if<is_match_condition<MatchCondition>::value>::type*)
-{
-  std::size_t search_position = 0;
-  for (;;)
-  {
-    // Determine the range of the data to be searched.
-    typedef typename asio::basic_streambuf<
-      Allocator>::const_buffers_type const_buffers_type;
-    typedef asio::buffers_iterator<const_buffers_type> iterator;
-    const_buffers_type buffers = b.data();
-    iterator begin = iterator::begin(buffers);
-    iterator start_pos = begin + search_position;
-    iterator end = iterator::end(buffers);
-
-    // Look for a match.
-    std::pair<iterator, bool> result = match_condition(start_pos, end);
-    if (result.second)
-    {
-      // Full match. We're done.
-      ec = asio::error_code();
-      return result.first - begin;
-    }
-    else if (result.first != end)
-    {
-      // Partial match. Next search needs to start from beginning of match.
-      search_position = result.first - begin;
-    }
-    else
-    {
-      // No match. Next search can start with the new data.
-      search_position = end - begin;
-    }
-
-    // Check if buffer is full.
-    if (b.size() == b.max_size())
-    {
-      ec = error::not_found;
-      return 0;
-    }
-
-    // Need more data.
-    std::size_t bytes_to_read = read_size_helper(b, 65536);
-    b.commit(s.read_some(b.prepare(bytes_to_read), ec));
-    if (ec)
-      return 0;
-  }
-}
-
-template <typename SyncReadStream, typename Allocator, typename MatchCondition>
-inline std::size_t read_until(SyncReadStream& s,
-    asio::basic_streambuf<Allocator>& b, MatchCondition match_condition,
-    typename enable_if<is_match_condition<MatchCondition>::value>::type*)
-{
-  asio::error_code ec;
-  std::size_t bytes_transferred = read_until(s, b, match_condition, ec);
-  asio::detail::throw_error(ec, "read_until");
-  return bytes_transferred;
-}
-
-namespace detail
-{
-  template <typename AsyncReadStream, typename Allocator, typename ReadHandler>
-  class read_until_delim_op
-  {
-  public:
-    read_until_delim_op(AsyncReadStream& stream,
-        asio::basic_streambuf<Allocator>& streambuf,
-        char delim, ReadHandler& handler)
-      : stream_(stream),
-        streambuf_(streambuf),
-        delim_(delim),
-        start_(0),
-        search_position_(0),
-        handler_(ASIO_MOVE_CAST(ReadHandler)(handler))
-    {
-    }
-
-#if defined(ASIO_HAS_MOVE)
-    read_until_delim_op(const read_until_delim_op& other)
-      : stream_(other.stream_),
-        streambuf_(other.streambuf_),
-        delim_(other.delim_),
-        start_(other.start_),
-        search_position_(other.search_position_),
-        handler_(other.handler_)
-    {
-    }
-
-    read_until_delim_op(read_until_delim_op&& other)
-      : stream_(other.stream_),
-        streambuf_(other.streambuf_),
-        delim_(other.delim_),
-        start_(other.start_),
-        search_position_(other.search_position_),
-        handler_(ASIO_MOVE_CAST(ReadHandler)(other.handler_))
-    {
-    }
-#endif // defined(ASIO_HAS_MOVE)
-
-    void operator()(const asio::error_code& ec,
-        std::size_t bytes_transferred, int start = 0)
-    {
-      const std::size_t not_found = (std::numeric_limits<std::size_t>::max)();
-      std::size_t bytes_to_read;
-      switch (start_ = start)
-      {
-      case 1:
-        for (;;)
-        {
-          {
-            // Determine the range of the data to be searched.
-            typedef typename asio::basic_streambuf<
-              Allocator>::const_buffers_type const_buffers_type;
-            typedef asio::buffers_iterator<const_buffers_type> iterator;
-            const_buffers_type buffers = streambuf_.data();
-            iterator begin = iterator::begin(buffers);
-            iterator start_pos = begin + search_position_;
-            iterator end = iterator::end(buffers);
-
-            // Look for a match.
-            iterator iter = std::find(start_pos, end, delim_);
-            if (iter != end)
-            {
-              // Found a match. We're done.
-              search_position_ = iter - begin + 1;
-              bytes_to_read = 0;
-            }
-
-            // No match yet. Check if buffer is full.
-            else if (streambuf_.size() == streambuf_.max_size())
-            {
-              search_position_ = not_found;
-              bytes_to_read = 0;
-            }
-
-            // Need to read some more data.
-            else
-            {
-              // Next search can start with the new data.
-              search_position_ = end - begin;
-              bytes_to_read = read_size_helper(streambuf_, 65536);
-            }
-          }
-
-          // Check if we're done.
-          if (!start && bytes_to_read == 0)
-            break;
-
-          // Start a new asynchronous read operation to obtain more data.
-          stream_.async_read_some(streambuf_.prepare(bytes_to_read),
-              ASIO_MOVE_CAST(read_until_delim_op)(*this));
-          return; default:
-          streambuf_.commit(bytes_transferred);
-          if (ec || bytes_transferred == 0)
-            break;
-        }
-
-        const asio::error_code result_ec =
-          (search_position_ == not_found)
-          ? error::not_found : ec;
-
-        const std::size_t result_n =
-          (ec || search_position_ == not_found)
-          ? 0 : search_position_;
-
-        handler_(result_ec, result_n);
-      }
-    }
-
-  //private:
-    AsyncReadStream& stream_;
-    asio::basic_streambuf<Allocator>& streambuf_;
-    char delim_;
-    int start_;
-    std::size_t search_position_;
-    ReadHandler handler_;
-  };
-
-  template <typename AsyncReadStream, typename Allocator, typename ReadHandler>
-  inline void* asio_handler_allocate(std::size_t size,
-      read_until_delim_op<AsyncReadStream,
-        Allocator, ReadHandler>* this_handler)
-  {
-    return asio_handler_alloc_helpers::allocate(
-        size, this_handler->handler_);
-  }
-
-  template <typename AsyncReadStream, typename Allocator, typename ReadHandler>
-  inline void asio_handler_deallocate(void* pointer, std::size_t size,
-      read_until_delim_op<AsyncReadStream,
-        Allocator, ReadHandler>* this_handler)
-  {
-    asio_handler_alloc_helpers::deallocate(
-        pointer, size, this_handler->handler_);
-  }
-
-  template <typename AsyncReadStream, typename Allocator, typename ReadHandler>
-  inline bool asio_handler_is_continuation(
-      read_until_delim_op<AsyncReadStream,
-        Allocator, ReadHandler>* this_handler)
-  {
-    return this_handler->start_ == 0 ? true
-      : asio_handler_cont_helpers::is_continuation(
-          this_handler->handler_);
-  }
-
-  template <typename Function, typename AsyncReadStream, typename Allocator,
-      typename ReadHandler>
-  inline void asio_handler_invoke(Function& function,
-      read_until_delim_op<AsyncReadStream,
-        Allocator, ReadHandler>* this_handler)
-  {
-    asio_handler_invoke_helpers::invoke(
-        function, this_handler->handler_);
-  }
-
-  template <typename Function, typename AsyncReadStream, typename Allocator,
-      typename ReadHandler>
-  inline void asio_handler_invoke(const Function& function,
-      read_until_delim_op<AsyncReadStream,
-        Allocator, ReadHandler>* this_handler)
-  {
-    asio_handler_invoke_helpers::invoke(
-        function, this_handler->handler_);
-  }
-} // namespace detail
-
-template <typename AsyncReadStream, typename Allocator, typename ReadHandler>
-ASIO_INITFN_RESULT_TYPE(ReadHandler,
-    void (asio::error_code, std::size_t))
-async_read_until(AsyncReadStream& s,
-    asio::basic_streambuf<Allocator>& b, char delim,
-    ASIO_MOVE_ARG(ReadHandler) handler)
-{
-  // If you get an error on the following line it means that your handler does
-  // not meet the documented type requirements for a ReadHandler.
-  ASIO_READ_HANDLER_CHECK(ReadHandler, handler) type_check;
-
-  detail::async_result_init<
-    ReadHandler, void (asio::error_code, std::size_t)> init(
-      ASIO_MOVE_CAST(ReadHandler)(handler));
-
-  detail::read_until_delim_op<AsyncReadStream,
-    Allocator, ASIO_HANDLER_TYPE(ReadHandler,
-      void (asio::error_code, std::size_t))>(
-        s, b, delim, init.handler)(
-          asio::error_code(), 0, 1);
-
-  return init.result.get();
-}
-
-namespace detail
-{
-  template <typename AsyncReadStream, typename Allocator, typename ReadHandler>
-  class read_until_delim_string_op
-  {
-  public:
-    read_until_delim_string_op(AsyncReadStream& stream,
-        asio::basic_streambuf<Allocator>& streambuf,
-        const std::string& delim, ReadHandler& handler)
-      : stream_(stream),
-        streambuf_(streambuf),
-        delim_(delim),
-        start_(0),
-        search_position_(0),
-        handler_(ASIO_MOVE_CAST(ReadHandler)(handler))
-    {
-    }
-
-#if defined(ASIO_HAS_MOVE)
-    read_until_delim_string_op(const read_until_delim_string_op& other)
-      : stream_(other.stream_),
-        streambuf_(other.streambuf_),
-        delim_(other.delim_),
-        start_(other.start_),
-        search_position_(other.search_position_),
-        handler_(other.handler_)
-    {
-    }
-
-    read_until_delim_string_op(read_until_delim_string_op&& other)
-      : stream_(other.stream_),
-        streambuf_(other.streambuf_),
-        delim_(ASIO_MOVE_CAST(std::string)(other.delim_)),
-        start_(other.start_),
-        search_position_(other.search_position_),
-        handler_(ASIO_MOVE_CAST(ReadHandler)(other.handler_))
-    {
-    }
-#endif // defined(ASIO_HAS_MOVE)
-
-    void operator()(const asio::error_code& ec,
-        std::size_t bytes_transferred, int start = 0)
-    {
-      const std::size_t not_found = (std::numeric_limits<std::size_t>::max)();
-      std::size_t bytes_to_read;
-      switch (start_ = start)
-      {
-      case 1:
-        for (;;)
-        {
-          {
-            // Determine the range of the data to be searched.
-            typedef typename asio::basic_streambuf<
-              Allocator>::const_buffers_type const_buffers_type;
-            typedef asio::buffers_iterator<const_buffers_type> iterator;
-            const_buffers_type buffers = streambuf_.data();
-            iterator begin = iterator::begin(buffers);
-            iterator start_pos = begin + search_position_;
-            iterator end = iterator::end(buffers);
-
-            // Look for a match.
-            std::pair<iterator, bool> result = detail::partial_search(
-                start_pos, end, delim_.begin(), delim_.end());
-            if (result.first != end && result.second)
-            {
-              // Full match. We're done.
-              search_position_ = result.first - begin + delim_.length();
-              bytes_to_read = 0;
-            }
-
-            // No match yet. Check if buffer is full.
-            else if (streambuf_.size() == streambuf_.max_size())
-            {
-              search_position_ = not_found;
-              bytes_to_read = 0;
-            }
-
-            // Need to read some more data.
-            else
-            {
-              if (result.first != end)
-              {
-                // Partial match. Next search needs to start from beginning of
-                // match.
-                search_position_ = result.first - begin;
-              }
-              else
-              {
-                // Next search can start with the new data.
-                search_position_ = end - begin;
-              }
-
-              bytes_to_read = read_size_helper(streambuf_, 65536);
-            }
-          }
-
-          // Check if we're done.
-          if (!start && bytes_to_read == 0)
-            break;
-
-          // Start a new asynchronous read operation to obtain more data.
-          stream_.async_read_some(streambuf_.prepare(bytes_to_read),
-              ASIO_MOVE_CAST(read_until_delim_string_op)(*this));
-          return; default:
-          streambuf_.commit(bytes_transferred);
-          if (ec || bytes_transferred == 0)
-            break;
-        }
-
-        const asio::error_code result_ec =
-          (search_position_ == not_found)
-          ? error::not_found : ec;
-
-        const std::size_t result_n =
-          (ec || search_position_ == not_found)
-          ? 0 : search_position_;
-
-        handler_(result_ec, result_n);
-      }
-    }
-
-  //private:
-    AsyncReadStream& stream_;
-    asio::basic_streambuf<Allocator>& streambuf_;
-    std::string delim_;
-    int start_;
-    std::size_t search_position_;
-    ReadHandler handler_;
-  };
-
-  template <typename AsyncReadStream, typename Allocator, typename ReadHandler>
-  inline void* asio_handler_allocate(std::size_t size,
-      read_until_delim_string_op<AsyncReadStream,
-        Allocator, ReadHandler>* this_handler)
-  {
-    return asio_handler_alloc_helpers::allocate(
-        size, this_handler->handler_);
-  }
-
-  template <typename AsyncReadStream, typename Allocator, typename ReadHandler>
-  inline void asio_handler_deallocate(void* pointer, std::size_t size,
-      read_until_delim_string_op<AsyncReadStream,
-        Allocator, ReadHandler>* this_handler)
-  {
-    asio_handler_alloc_helpers::deallocate(
-        pointer, size, this_handler->handler_);
-  }
-
-  template <typename AsyncReadStream, typename Allocator, typename ReadHandler>
-  inline bool asio_handler_is_continuation(
-      read_until_delim_string_op<AsyncReadStream,
-        Allocator, ReadHandler>* this_handler)
-  {
-    return this_handler->start_ == 0 ? true
-      : asio_handler_cont_helpers::is_continuation(
-          this_handler->handler_);
-  }
-
-  template <typename Function, typename AsyncReadStream,
-      typename Allocator, typename ReadHandler>
-  inline void asio_handler_invoke(Function& function,
-      read_until_delim_string_op<AsyncReadStream,
-        Allocator, ReadHandler>* this_handler)
-  {
-    asio_handler_invoke_helpers::invoke(
-        function, this_handler->handler_);
-  }
-
-  template <typename Function, typename AsyncReadStream,
-      typename Allocator, typename ReadHandler>
-  inline void asio_handler_invoke(const Function& function,
-      read_until_delim_string_op<AsyncReadStream,
-        Allocator, ReadHandler>* this_handler)
-  {
-    asio_handler_invoke_helpers::invoke(
-        function, this_handler->handler_);
-  }
-} // namespace detail
-
-template <typename AsyncReadStream, typename Allocator, typename ReadHandler>
-ASIO_INITFN_RESULT_TYPE(ReadHandler,
-    void (asio::error_code, std::size_t))
-async_read_until(AsyncReadStream& s,
-    asio::basic_streambuf<Allocator>& b, const std::string& delim,
-    ASIO_MOVE_ARG(ReadHandler) handler)
-{
-  // If you get an error on the following line it means that your handler does
-  // not meet the documented type requirements for a ReadHandler.
-  ASIO_READ_HANDLER_CHECK(ReadHandler, handler) type_check;
-
-  detail::async_result_init<
-    ReadHandler, void (asio::error_code, std::size_t)> init(
-      ASIO_MOVE_CAST(ReadHandler)(handler));
-
-  detail::read_until_delim_string_op<AsyncReadStream,
-    Allocator, ASIO_HANDLER_TYPE(ReadHandler,
-      void (asio::error_code, std::size_t))>(
-        s, b, delim, init.handler)(
-          asio::error_code(), 0, 1);
-
-  return init.result.get();
-}
-
-#if defined(ASIO_HAS_BOOST_REGEX)
-
-namespace detail
-{
-  template <typename AsyncReadStream, typename Allocator,
-      typename RegEx, typename ReadHandler>
-  class read_until_expr_op
-  {
-  public:
-    read_until_expr_op(AsyncReadStream& stream,
-        asio::basic_streambuf<Allocator>& streambuf,
-        const boost::regex& expr, ReadHandler& handler)
-      : stream_(stream),
-        streambuf_(streambuf),
-        expr_(expr),
-        start_(0),
-        search_position_(0),
-        handler_(ASIO_MOVE_CAST(ReadHandler)(handler))
-    {
-    }
-
-#if defined(ASIO_HAS_MOVE)
-    read_until_expr_op(const read_until_expr_op& other)
-      : stream_(other.stream_),
-        streambuf_(other.streambuf_),
-        expr_(other.expr_),
-        start_(other.start_),
-        search_position_(other.search_position_),
-        handler_(other.handler_)
-    {
-    }
-
-    read_until_expr_op(read_until_expr_op&& other)
-      : stream_(other.stream_),
-        streambuf_(other.streambuf_),
-        expr_(other.expr_),
-        start_(other.start_),
-        search_position_(other.search_position_),
-        handler_(ASIO_MOVE_CAST(ReadHandler)(other.handler_))
-    {
-    }
-#endif // defined(ASIO_HAS_MOVE)
-
-    void operator()(const asio::error_code& ec,
-        std::size_t bytes_transferred, int start = 0)
-    {
-      const std::size_t not_found = (std::numeric_limits<std::size_t>::max)();
-      std::size_t bytes_to_read;
-      switch (start_ = start)
-      {
-      case 1:
-        for (;;)
-        {
-          {
-            // Determine the range of the data to be searched.
-            typedef typename asio::basic_streambuf<
-              Allocator>::const_buffers_type const_buffers_type;
-            typedef asio::buffers_iterator<const_buffers_type> iterator;
-            const_buffers_type buffers = streambuf_.data();
-            iterator begin = iterator::begin(buffers);
-            iterator start_pos = begin + search_position_;
-            iterator end = iterator::end(buffers);
-
-            // Look for a match.
-            boost::match_results<iterator,
-              typename std::vector<boost::sub_match<iterator> >::allocator_type>
-                match_results;
-            bool match = regex_search(start_pos, end, match_results, expr_,
-                boost::match_default | boost::match_partial);
-            if (match && match_results[0].matched)
-            {
-              // Full match. We're done.
-              search_position_ = match_results[0].second - begin;
-              bytes_to_read = 0;
-            }
-
-            // No match yet. Check if buffer is full.
-            else if (streambuf_.size() == streambuf_.max_size())
-            {
-              search_position_ = not_found;
-              bytes_to_read = 0;
-            }
-
-            // Need to read some more data.
-            else
-            {
-              if (match)
-              {
-                // Partial match. Next search needs to start from beginning of
-                // match.
-                search_position_ = match_results[0].first - begin;
-              }
-              else
-              {
-                // Next search can start with the new data.
-                search_position_ = end - begin;
-              }
-
-              bytes_to_read = read_size_helper(streambuf_, 65536);
-            }
-          }
-
-          // Check if we're done.
-          if (!start && bytes_to_read == 0)
-            break;
-
-          // Start a new asynchronous read operation to obtain more data.
-          stream_.async_read_some(streambuf_.prepare(bytes_to_read),
-              ASIO_MOVE_CAST(read_until_expr_op)(*this));
-          return; default:
-          streambuf_.commit(bytes_transferred);
-          if (ec || bytes_transferred == 0)
-            break;
-        }
-
-        const asio::error_code result_ec =
-          (search_position_ == not_found)
-          ? error::not_found : ec;
-
-        const std::size_t result_n =
-          (ec || search_position_ == not_found)
-          ? 0 : search_position_;
-
-        handler_(result_ec, result_n);
-      }
-    }
-
-  //private:
-    AsyncReadStream& stream_;
-    asio::basic_streambuf<Allocator>& streambuf_;
-    RegEx expr_;
-    int start_;
-    std::size_t search_position_;
-    ReadHandler handler_;
-  };
-
-  template <typename AsyncReadStream, typename Allocator,
-      typename RegEx, typename ReadHandler>
-  inline void* asio_handler_allocate(std::size_t size,
-      read_until_expr_op<AsyncReadStream,
-        Allocator, RegEx, ReadHandler>* this_handler)
-  {
-    return asio_handler_alloc_helpers::allocate(
-        size, this_handler->handler_);
-  }
-
-  template <typename AsyncReadStream, typename Allocator,
-      typename RegEx, typename ReadHandler>
-  inline void asio_handler_deallocate(void* pointer, std::size_t size,
-      read_until_expr_op<AsyncReadStream,
-        Allocator, RegEx, ReadHandler>* this_handler)
-  {
-    asio_handler_alloc_helpers::deallocate(
-        pointer, size, this_handler->handler_);
-  }
-
-  template <typename AsyncReadStream, typename Allocator,
-      typename RegEx, typename ReadHandler>
-  inline bool asio_handler_is_continuation(
-      read_until_expr_op<AsyncReadStream,
-        Allocator, RegEx, ReadHandler>* this_handler)
-  {
-    return this_handler->start_ == 0 ? true
-      : asio_handler_cont_helpers::is_continuation(
-          this_handler->handler_);
-  }
-
-  template <typename Function, typename AsyncReadStream, typename Allocator,
-      typename RegEx, typename ReadHandler>
-  inline void asio_handler_invoke(Function& function,
-      read_until_expr_op<AsyncReadStream,
-        Allocator, RegEx, ReadHandler>* this_handler)
-  {
-    asio_handler_invoke_helpers::invoke(
-        function, this_handler->handler_);
-  }
-
-  template <typename Function, typename AsyncReadStream, typename Allocator,
-      typename RegEx, typename ReadHandler>
-  inline void asio_handler_invoke(const Function& function,
-      read_until_expr_op<AsyncReadStream,
-        Allocator, RegEx, ReadHandler>* this_handler)
-  {
-    asio_handler_invoke_helpers::invoke(
-        function, this_handler->handler_);
-  }
-} // namespace detail
-
-template <typename AsyncReadStream, typename Allocator, typename ReadHandler>
-ASIO_INITFN_RESULT_TYPE(ReadHandler,
-    void (asio::error_code, std::size_t))
-async_read_until(AsyncReadStream& s,
-    asio::basic_streambuf<Allocator>& b, const boost::regex& expr,
-    ASIO_MOVE_ARG(ReadHandler) handler)
-{
-  // If you get an error on the following line it means that your handler does
-  // not meet the documented type requirements for a ReadHandler.
-  ASIO_READ_HANDLER_CHECK(ReadHandler, handler) type_check;
-
-  detail::async_result_init<
-    ReadHandler, void (asio::error_code, std::size_t)> init(
-      ASIO_MOVE_CAST(ReadHandler)(handler));
-
-  detail::read_until_expr_op<AsyncReadStream, Allocator,
-    boost::regex, ASIO_HANDLER_TYPE(ReadHandler,
-      void (asio::error_code, std::size_t))>(
-        s, b, expr, init.handler)(
-          asio::error_code(), 0, 1);
-
-  return init.result.get();
-}
-
-#endif // defined(ASIO_HAS_BOOST_REGEX)
-
-namespace detail
-{
-  template <typename AsyncReadStream, typename Allocator,
-      typename MatchCondition, typename ReadHandler>
-  class read_until_match_op
-  {
-  public:
-    read_until_match_op(AsyncReadStream& stream,
-        asio::basic_streambuf<Allocator>& streambuf,
-        MatchCondition match_condition, ReadHandler& handler)
-      : stream_(stream),
-        streambuf_(streambuf),
-        match_condition_(match_condition),
-        start_(0),
-        search_position_(0),
-        handler_(ASIO_MOVE_CAST(ReadHandler)(handler))
-    {
-    }
-
-#if defined(ASIO_HAS_MOVE)
-    read_until_match_op(const read_until_match_op& other)
-      : stream_(other.stream_),
-        streambuf_(other.streambuf_),
-        match_condition_(other.match_condition_),
-        start_(other.start_),
-        search_position_(other.search_position_),
-        handler_(other.handler_)
-    {
-    }
-
-    read_until_match_op(read_until_match_op&& other)
-      : stream_(other.stream_),
-        streambuf_(other.streambuf_),
-        match_condition_(other.match_condition_),
-        start_(other.start_),
-        search_position_(other.search_position_),
-        handler_(ASIO_MOVE_CAST(ReadHandler)(other.handler_))
-    {
-    }
-#endif // defined(ASIO_HAS_MOVE)
-
-    void operator()(const asio::error_code& ec,
-        std::size_t bytes_transferred, int start = 0)
-    {
-      const std::size_t not_found = (std::numeric_limits<std::size_t>::max)();
-      std::size_t bytes_to_read;
-      switch (start_ = start)
-      {
-      case 1:
-        for (;;)
-        {
-          {
-            // Determine the range of the data to be searched.
-            typedef typename asio::basic_streambuf<
-              Allocator>::const_buffers_type const_buffers_type;
-            typedef asio::buffers_iterator<const_buffers_type> iterator;
-            const_buffers_type buffers = streambuf_.data();
-            iterator begin = iterator::begin(buffers);
-            iterator start_pos = begin + search_position_;
-            iterator end = iterator::end(buffers);
-
-            // Look for a match.
-            std::pair<iterator, bool> result = match_condition_(start_pos, end);
-            if (result.second)
-            {
-              // Full match. We're done.
-              search_position_ = result.first - begin;
-              bytes_to_read = 0;
-            }
-
-            // No match yet. Check if buffer is full.
-            else if (streambuf_.size() == streambuf_.max_size())
-            {
-              search_position_ = not_found;
-              bytes_to_read = 0;
-            }
-
-            // Need to read some more data.
-            else
-            {
-              if (result.first != end)
-              {
-                // Partial match. Next search needs to start from beginning of
-                // match.
-                search_position_ = result.first - begin;
-              }
-              else
-              {
-                // Next search can start with the new data.
-                search_position_ = end - begin;
-              }
-
-              bytes_to_read = read_size_helper(streambuf_, 65536);
-            }
-          }
-
-          // Check if we're done.
-          if (!start && bytes_to_read == 0)
-            break;
-
-          // Start a new asynchronous read operation to obtain more data.
-          stream_.async_read_some(streambuf_.prepare(bytes_to_read),
-              ASIO_MOVE_CAST(read_until_match_op)(*this));
-          return; default:
-          streambuf_.commit(bytes_transferred);
-          if (ec || bytes_transferred == 0)
-            break;
-        }
-
-        const asio::error_code result_ec =
-          (search_position_ == not_found)
-          ? error::not_found : ec;
-
-        const std::size_t result_n =
-          (ec || search_position_ == not_found)
-          ? 0 : search_position_;
-
-        handler_(result_ec, result_n);
-      }
-    }
-
-  //private:
-    AsyncReadStream& stream_;
-    asio::basic_streambuf<Allocator>& streambuf_;
-    MatchCondition match_condition_;
-    int start_;
-    std::size_t search_position_;
-    ReadHandler handler_;
-  };
-
-  template <typename AsyncReadStream, typename Allocator,
-      typename MatchCondition, typename ReadHandler>
-  inline void* asio_handler_allocate(std::size_t size,
-      read_until_match_op<AsyncReadStream,
-        Allocator, MatchCondition, ReadHandler>* this_handler)
-  {
-    return asio_handler_alloc_helpers::allocate(
-        size, this_handler->handler_);
-  }
-
-  template <typename AsyncReadStream, typename Allocator,
-      typename MatchCondition, typename ReadHandler>
-  inline void asio_handler_deallocate(void* pointer, std::size_t size,
-      read_until_match_op<AsyncReadStream,
-        Allocator, MatchCondition, ReadHandler>* this_handler)
-  {
-    asio_handler_alloc_helpers::deallocate(
-        pointer, size, this_handler->handler_);
-  }
-
-  template <typename AsyncReadStream, typename Allocator,
-      typename MatchCondition, typename ReadHandler>
-  inline bool asio_handler_is_continuation(
-      read_until_match_op<AsyncReadStream,
-        Allocator, MatchCondition, ReadHandler>* this_handler)
-  {
-    return this_handler->start_ == 0 ? true
-      : asio_handler_cont_helpers::is_continuation(
-          this_handler->handler_);
-  }
-
-  template <typename Function, typename AsyncReadStream, typename Allocator,
-      typename MatchCondition, typename ReadHandler>
-  inline void asio_handler_invoke(Function& function,
-      read_until_match_op<AsyncReadStream,
-        Allocator, MatchCondition, ReadHandler>* this_handler)
-  {
-    asio_handler_invoke_helpers::invoke(
-        function, this_handler->handler_);
-  }
-
-  template <typename Function, typename AsyncReadStream, typename Allocator,
-      typename MatchCondition, typename ReadHandler>
-  inline void asio_handler_invoke(const Function& function,
-      read_until_match_op<AsyncReadStream,
-        Allocator, MatchCondition, ReadHandler>* this_handler)
-  {
-    asio_handler_invoke_helpers::invoke(
-        function, this_handler->handler_);
-  }
-} // namespace detail
-
-template <typename AsyncReadStream, typename Allocator,
-    typename MatchCondition, typename ReadHandler>
-ASIO_INITFN_RESULT_TYPE(ReadHandler,
-    void (asio::error_code, std::size_t))
-async_read_until(AsyncReadStream& s,
-    asio::basic_streambuf<Allocator>& b,
-    MatchCondition match_condition, ASIO_MOVE_ARG(ReadHandler) handler,
-    typename enable_if<is_match_condition<MatchCondition>::value>::type*)
-{
-  // If you get an error on the following line it means that your handler does
-  // not meet the documented type requirements for a ReadHandler.
-  ASIO_READ_HANDLER_CHECK(ReadHandler, handler) type_check;
-
-  detail::async_result_init<
-    ReadHandler, void (asio::error_code, std::size_t)> init(
-      ASIO_MOVE_CAST(ReadHandler)(handler));
-
-  detail::read_until_match_op<AsyncReadStream, Allocator,
-    MatchCondition, ASIO_HANDLER_TYPE(ReadHandler,
-      void (asio::error_code, std::size_t))>(
-        s, b, match_condition, init.handler)(
-          asio::error_code(), 0, 1);
-
-  return init.result.get();
-}
-
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_IMPL_READ_UNTIL_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/impl/serial_port_base.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/impl/serial_port_base.hpp
deleted file mode 100644
index bfdb08dd2e47..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/impl/serial_port_base.hpp
+++ /dev/null
@@ -1,59 +0,0 @@
-//
-// impl/serial_port_base.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-// Copyright (c) 2008 Rep Invariant Systems, Inc. (info@repinvariant.com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_IMPL_SERIAL_PORT_BASE_HPP
-#define ASIO_IMPL_SERIAL_PORT_BASE_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-
-inline serial_port_base::baud_rate::baud_rate(unsigned int rate)
-  : value_(rate)
-{
-}
-
-inline unsigned int serial_port_base::baud_rate::value() const
-{
-  return value_;
-}
-
-inline serial_port_base::flow_control::type
-serial_port_base::flow_control::value() const
-{
-  return value_;
-}
-
-inline serial_port_base::parity::type serial_port_base::parity::value() const
-{
-  return value_;
-}
-
-inline serial_port_base::stop_bits::type
-serial_port_base::stop_bits::value() const
-{
-  return value_;
-}
-
-inline unsigned int serial_port_base::character_size::value() const
-{
-  return value_;
-}
-
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_IMPL_SERIAL_PORT_BASE_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/impl/serial_port_base.ipp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/impl/serial_port_base.ipp
deleted file mode 100644
index 60bed7f65954..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/impl/serial_port_base.ipp
+++ /dev/null
@@ -1,554 +0,0 @@
-//
-// impl/serial_port_base.ipp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-// Copyright (c) 2008 Rep Invariant Systems, Inc. (info@repinvariant.com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_IMPL_SERIAL_PORT_BASE_IPP
-#define ASIO_IMPL_SERIAL_PORT_BASE_IPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_HAS_SERIAL_PORT)
-
-#include <stdexcept>
-#include "asio/error.hpp"
-#include "asio/serial_port_base.hpp"
-#include "asio/detail/throw_exception.hpp"
-
-#if defined(GENERATING_DOCUMENTATION)
-# define ASIO_OPTION_STORAGE implementation_defined
-#elif defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-# define ASIO_OPTION_STORAGE DCB
-#else
-# define ASIO_OPTION_STORAGE termios
-#endif
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-
-asio::error_code serial_port_base::baud_rate::store(
-    ASIO_OPTION_STORAGE& storage, asio::error_code& ec) const
-{
-#if defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-  storage.BaudRate = value_;
-#else
-  speed_t baud;
-  switch (value_)
-  {
-  // Do POSIX-specified rates first.
-  case 0: baud = B0; break;
-  case 50: baud = B50; break;
-  case 75: baud = B75; break;
-  case 110: baud = B110; break;
-  case 134: baud = B134; break;
-  case 150: baud = B150; break;
-  case 200: baud = B200; break;
-  case 300: baud = B300; break;
-  case 600: baud = B600; break;
-  case 1200: baud = B1200; break;
-  case 1800: baud = B1800; break;
-  case 2400: baud = B2400; break;
-  case 4800: baud = B4800; break;
-  case 9600: baud = B9600; break;
-  case 19200: baud = B19200; break;
-  case 38400: baud = B38400; break;
-  // And now the extended ones conditionally.
-# ifdef B7200
-  case 7200: baud = B7200; break;
-# endif
-# ifdef B14400
-  case 14400: baud = B14400; break;
-# endif
-# ifdef B57600
-  case 57600: baud = B57600; break;
-# endif
-# ifdef B115200
-  case 115200: baud = B115200; break;
-# endif
-# ifdef B230400
-  case 230400: baud = B230400; break;
-# endif
-# ifdef B460800
-  case 460800: baud = B460800; break;
-# endif
-# ifdef B500000
-  case 500000: baud = B500000; break;
-# endif
-# ifdef B576000
-  case 576000: baud = B576000; break;
-# endif
-# ifdef B921600
-  case 921600: baud = B921600; break;
-# endif
-# ifdef B1000000
-  case 1000000: baud = B1000000; break;
-# endif
-# ifdef B1152000
-  case 1152000: baud = B1152000; break;
-# endif
-# ifdef B2000000
-  case 2000000: baud = B2000000; break;
-# endif
-# ifdef B3000000
-  case 3000000: baud = B3000000; break;
-# endif
-# ifdef B3500000
-  case 3500000: baud = B3500000; break;
-# endif
-# ifdef B4000000
-  case 4000000: baud = B4000000; break;
-# endif
-  default:
-    ec = asio::error::invalid_argument;
-    return ec;
-  }
-# if defined(_BSD_SOURCE)
-  ::cfsetspeed(&storage, baud);
-# else
-  ::cfsetispeed(&storage, baud);
-  ::cfsetospeed(&storage, baud);
-# endif
-#endif
-  ec = asio::error_code();
-  return ec;
-}
-
-asio::error_code serial_port_base::baud_rate::load(
-    const ASIO_OPTION_STORAGE& storage, asio::error_code& ec)
-{
-#if defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-  value_ = storage.BaudRate;
-#else
-  speed_t baud = ::cfgetospeed(&storage);
-  switch (baud)
-  {
-  // First do those specified by POSIX.
-  case B0: value_ = 0; break;
-  case B50: value_ = 50; break;
-  case B75: value_ = 75; break;
-  case B110: value_ = 110; break;
-  case B134: value_ = 134; break;
-  case B150: value_ = 150; break;
-  case B200: value_ = 200; break;
-  case B300: value_ = 300; break;
-  case B600: value_ = 600; break;
-  case B1200: value_ = 1200; break;
-  case B1800: value_ = 1800; break;
-  case B2400: value_ = 2400; break;
-  case B4800: value_ = 4800; break;
-  case B9600: value_ = 9600; break;
-  case B19200: value_ = 19200; break;
-  case B38400: value_ = 38400; break;
-  // Now conditionally handle a bunch of extended rates.
-# ifdef B7200
-  case B7200: value_ = 7200; break;
-# endif
-# ifdef B14400
-  case B14400: value_ = 14400; break;
-# endif
-# ifdef B57600
-  case B57600: value_ = 57600; break;
-# endif
-# ifdef B115200
-  case B115200: value_ = 115200; break;
-# endif
-# ifdef B230400
-  case B230400: value_ = 230400; break;
-# endif
-# ifdef B460800
-  case B460800: value_ = 460800; break;
-# endif
-# ifdef B500000
-  case B500000: value_ = 500000; break;
-# endif
-# ifdef B576000
-  case B576000: value_ = 576000; break;
-# endif
-# ifdef B921600
-  case B921600: value_ = 921600; break;
-# endif
-# ifdef B1000000
-  case B1000000: value_ = 1000000; break;
-# endif
-# ifdef B1152000
-  case B1152000: value_ = 1152000; break;
-# endif
-# ifdef B2000000
-  case B2000000: value_ = 2000000; break;
-# endif
-# ifdef B3000000
-  case B3000000: value_ = 3000000; break;
-# endif
-# ifdef B3500000
-  case B3500000: value_ = 3500000; break;
-# endif
-# ifdef B4000000
-  case B4000000: value_ = 4000000; break;
-# endif
-  default:
-    value_ = 0;
-    ec = asio::error::invalid_argument;
-    return ec;
-  }
-#endif
-  ec = asio::error_code();
-  return ec;
-}
-
-serial_port_base::flow_control::flow_control(
-    serial_port_base::flow_control::type t)
-  : value_(t)
-{
-  if (t != none && t != software && t != hardware)
-  {
-    std::out_of_range ex("invalid flow_control value");
-    asio::detail::throw_exception(ex);
-  }
-}
-
-asio::error_code serial_port_base::flow_control::store(
-    ASIO_OPTION_STORAGE& storage, asio::error_code& ec) const
-{
-#if defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-  storage.fOutxCtsFlow = FALSE;
-  storage.fOutxDsrFlow = FALSE;
-  storage.fTXContinueOnXoff = TRUE;
-  storage.fDtrControl = DTR_CONTROL_ENABLE;
-  storage.fDsrSensitivity = FALSE;
-  storage.fOutX = FALSE;
-  storage.fInX = FALSE;
-  storage.fRtsControl = RTS_CONTROL_ENABLE;
-  switch (value_)
-  {
-  case none:
-    break;
-  case software:
-    storage.fOutX = TRUE;
-    storage.fInX = TRUE;
-    break;
-  case hardware:
-    storage.fOutxCtsFlow = TRUE;
-    storage.fRtsControl = RTS_CONTROL_HANDSHAKE;
-    break;
-  default:
-    break;
-  }
-#else
-  switch (value_)
-  {
-  case none:
-    storage.c_iflag &= ~(IXOFF | IXON);
-# if defined(_BSD_SOURCE)
-    storage.c_cflag &= ~CRTSCTS;
-# elif defined(__QNXNTO__)
-    storage.c_cflag &= ~(IHFLOW | OHFLOW);
-# endif
-    break;
-  case software:
-    storage.c_iflag |= IXOFF | IXON;
-# if defined(_BSD_SOURCE)
-    storage.c_cflag &= ~CRTSCTS;
-# elif defined(__QNXNTO__)
-    storage.c_cflag &= ~(IHFLOW | OHFLOW);
-# endif
-    break;
-  case hardware:
-# if defined(_BSD_SOURCE)
-    storage.c_iflag &= ~(IXOFF | IXON);
-    storage.c_cflag |= CRTSCTS;
-    break;
-# elif defined(__QNXNTO__)
-    storage.c_iflag &= ~(IXOFF | IXON);
-    storage.c_cflag |= (IHFLOW | OHFLOW);
-    break;
-# else
-    ec = asio::error::operation_not_supported;
-    return ec;
-# endif
-  default:
-    break;
-  }
-#endif
-  ec = asio::error_code();
-  return ec;
-}
-
-asio::error_code serial_port_base::flow_control::load(
-    const ASIO_OPTION_STORAGE& storage, asio::error_code& ec)
-{
-#if defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-  if (storage.fOutX && storage.fInX)
-  {
-    value_ = software;
-  }
-  else if (storage.fOutxCtsFlow && storage.fRtsControl == RTS_CONTROL_HANDSHAKE)
-  {
-    value_ = hardware;
-  }
-  else
-  {
-    value_ = none;
-  }
-#else
-  if (storage.c_iflag & (IXOFF | IXON))
-  {
-    value_ = software;
-  }
-# if defined(_BSD_SOURCE)
-  else if (storage.c_cflag & CRTSCTS)
-  {
-    value_ = hardware;
-  }
-# elif defined(__QNXNTO__)
-  else if (storage.c_cflag & IHFLOW && storage.c_cflag & OHFLOW)
-  {
-    value_ = hardware;
-  }
-# endif
-  else
-  {
-    value_ = none;
-  }
-#endif
-  ec = asio::error_code();
-  return ec;
-}
-
-serial_port_base::parity::parity(serial_port_base::parity::type t)
-  : value_(t)
-{
-  if (t != none && t != odd && t != even)
-  {
-    std::out_of_range ex("invalid parity value");
-    asio::detail::throw_exception(ex);
-  }
-}
-
-asio::error_code serial_port_base::parity::store(
-    ASIO_OPTION_STORAGE& storage, asio::error_code& ec) const
-{
-#if defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-  switch (value_)
-  {
-  case none:
-    storage.fParity = FALSE;
-    storage.Parity = NOPARITY;
-    break;
-  case odd:
-    storage.fParity = TRUE;
-    storage.Parity = ODDPARITY;
-    break;
-  case even:
-    storage.fParity = TRUE;
-    storage.Parity = EVENPARITY;
-    break;
-  default:
-    break;
-  }
-#else
-  switch (value_)
-  {
-  case none:
-    storage.c_iflag |= IGNPAR;
-    storage.c_cflag &= ~(PARENB | PARODD);
-    break;
-  case even:
-    storage.c_iflag &= ~(IGNPAR | PARMRK);
-    storage.c_iflag |= INPCK;
-    storage.c_cflag |= PARENB;
-    storage.c_cflag &= ~PARODD;
-    break;
-  case odd:
-    storage.c_iflag &= ~(IGNPAR | PARMRK);
-    storage.c_iflag |= INPCK;
-    storage.c_cflag |= (PARENB | PARODD);
-    break;
-  default:
-    break;
-  }
-#endif
-  ec = asio::error_code();
-  return ec;
-}
-
-asio::error_code serial_port_base::parity::load(
-    const ASIO_OPTION_STORAGE& storage, asio::error_code& ec)
-{
-#if defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-  if (storage.Parity == EVENPARITY)
-  {
-    value_ = even;
-  }
-  else if (storage.Parity == ODDPARITY)
-  {
-    value_ = odd;
-  }
-  else
-  {
-    value_ = none;
-  }
-#else
-  if (storage.c_cflag & PARENB)
-  {
-    if (storage.c_cflag & PARODD)
-    {
-      value_ = odd;
-    }
-    else
-    {
-      value_ = even;
-    }
-  }
-  else
-  {
-    value_ = none;
-  }
-#endif
-  ec = asio::error_code();
-  return ec;
-}
-
-serial_port_base::stop_bits::stop_bits(
-    serial_port_base::stop_bits::type t)
-  : value_(t)
-{
-  if (t != one && t != onepointfive && t != two)
-  {
-    std::out_of_range ex("invalid stop_bits value");
-    asio::detail::throw_exception(ex);
-  }
-}
-
-asio::error_code serial_port_base::stop_bits::store(
-    ASIO_OPTION_STORAGE& storage, asio::error_code& ec) const
-{
-#if defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-  switch (value_)
-  {
-  case one:
-    storage.StopBits = ONESTOPBIT;
-    break;
-  case onepointfive:
-    storage.StopBits = ONE5STOPBITS;
-    break;
-  case two:
-    storage.StopBits = TWOSTOPBITS;
-    break;
-  default:
-    break;
-  }
-#else
-  switch (value_)
-  {
-  case one:
-    storage.c_cflag &= ~CSTOPB;
-    break;
-  case two:
-    storage.c_cflag |= CSTOPB;
-    break;
-  default:
-    ec = asio::error::operation_not_supported;
-    return ec;
-  }
-#endif
-  ec = asio::error_code();
-  return ec;
-}
-
-asio::error_code serial_port_base::stop_bits::load(
-    const ASIO_OPTION_STORAGE& storage, asio::error_code& ec)
-{
-#if defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-  if (storage.StopBits == ONESTOPBIT)
-  {
-    value_ = one;
-  }
-  else if (storage.StopBits == ONE5STOPBITS)
-  {
-    value_ = onepointfive;
-  }
-  else if (storage.StopBits == TWOSTOPBITS)
-  {
-    value_ = two;
-  }
-  else
-  {
-    value_ = one;
-  }
-#else
-  value_ = (storage.c_cflag & CSTOPB) ? two : one;
-#endif
-  ec = asio::error_code();
-  return ec;
-}
-
-serial_port_base::character_size::character_size(unsigned int t)
-  : value_(t)
-{
-  if (t < 5 || t > 8)
-  {
-    std::out_of_range ex("invalid character_size value");
-    asio::detail::throw_exception(ex);
-  }
-}
-
-asio::error_code serial_port_base::character_size::store(
-    ASIO_OPTION_STORAGE& storage, asio::error_code& ec) const
-{
-#if defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-  storage.ByteSize = value_;
-#else
-  storage.c_cflag &= ~CSIZE;
-  switch (value_)
-  {
-  case 5: storage.c_cflag |= CS5; break;
-  case 6: storage.c_cflag |= CS6; break;
-  case 7: storage.c_cflag |= CS7; break;
-  case 8: storage.c_cflag |= CS8; break;
-  default: break;
-  }
-#endif
-  ec = asio::error_code();
-  return ec;
-}
-
-asio::error_code serial_port_base::character_size::load(
-    const ASIO_OPTION_STORAGE& storage, asio::error_code& ec)
-{
-#if defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-  value_ = storage.ByteSize;
-#else
-  if ((storage.c_cflag & CSIZE) == CS5) { value_ = 5; }
-  else if ((storage.c_cflag & CSIZE) == CS6) { value_ = 6; }
-  else if ((storage.c_cflag & CSIZE) == CS7) { value_ = 7; }
-  else if ((storage.c_cflag & CSIZE) == CS8) { value_ = 8; }
-  else
-  {
-    // Hmmm, use 8 for now.
-    value_ = 8;
-  }
-#endif
-  ec = asio::error_code();
-  return ec;
-}
-
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#undef ASIO_OPTION_STORAGE
-
-#endif // defined(ASIO_HAS_SERIAL_PORT)
-
-#endif // ASIO_IMPL_SERIAL_PORT_BASE_IPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/impl/spawn.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/impl/spawn.hpp
deleted file mode 100644
index f5a504eb37e8..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/impl/spawn.hpp
+++ /dev/null
@@ -1,336 +0,0 @@
-//
-// impl/spawn.hpp
-// ~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_IMPL_SPAWN_HPP
-#define ASIO_IMPL_SPAWN_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include "asio/async_result.hpp"
-#include "asio/detail/handler_alloc_helpers.hpp"
-#include "asio/detail/handler_cont_helpers.hpp"
-#include "asio/detail/handler_invoke_helpers.hpp"
-#include "asio/detail/noncopyable.hpp"
-#include "asio/detail/shared_ptr.hpp"
-#include "asio/handler_type.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-  template <typename Handler, typename T>
-  class coro_handler
-  {
-  public:
-    coro_handler(basic_yield_context<Handler> ctx)
-      : coro_(ctx.coro_.lock()),
-        ca_(ctx.ca_),
-        handler_(ctx.handler_),
-        ec_(ctx.ec_),
-        value_(0)
-    {
-    }
-
-    void operator()(T value)
-    {
-      *ec_ = asio::error_code();
-      *value_ = value;
-      (*coro_)();
-    }
-
-    void operator()(asio::error_code ec, T value)
-    {
-      *ec_ = ec;
-      *value_ = value;
-      (*coro_)();
-    }
-
-  //private:
-    shared_ptr<typename basic_yield_context<Handler>::callee_type> coro_;
-    typename basic_yield_context<Handler>::caller_type& ca_;
-    Handler& handler_;
-    asio::error_code* ec_;
-    T* value_;
-  };
-
-  template <typename Handler>
-  class coro_handler<Handler, void>
-  {
-  public:
-    coro_handler(basic_yield_context<Handler> ctx)
-      : coro_(ctx.coro_.lock()),
-        ca_(ctx.ca_),
-        handler_(ctx.handler_),
-        ec_(ctx.ec_)
-    {
-    }
-
-    void operator()()
-    {
-      *ec_ = asio::error_code();
-      (*coro_)();
-    }
-
-    void operator()(asio::error_code ec)
-    {
-      *ec_ = ec;
-      (*coro_)();
-    }
-
-  //private:
-    shared_ptr<typename basic_yield_context<Handler>::callee_type> coro_;
-    typename basic_yield_context<Handler>::caller_type& ca_;
-    Handler& handler_;
-    asio::error_code* ec_;
-  };
-
-  template <typename Handler, typename T>
-  inline void* asio_handler_allocate(std::size_t size,
-      coro_handler<Handler, T>* this_handler)
-  {
-    return asio_handler_alloc_helpers::allocate(
-        size, this_handler->handler_);
-  }
-
-  template <typename Handler, typename T>
-  inline void asio_handler_deallocate(void* pointer, std::size_t size,
-      coro_handler<Handler, T>* this_handler)
-  {
-    asio_handler_alloc_helpers::deallocate(
-        pointer, size, this_handler->handler_);
-  }
-
-  template <typename Handler, typename T>
-  inline bool asio_handler_is_continuation(coro_handler<Handler, T>*)
-  {
-    return true;
-  }
-
-  template <typename Function, typename Handler, typename T>
-  inline void asio_handler_invoke(Function& function,
-      coro_handler<Handler, T>* this_handler)
-  {
-    asio_handler_invoke_helpers::invoke(
-        function, this_handler->handler_);
-  }
-
-  template <typename Function, typename Handler, typename T>
-  inline void asio_handler_invoke(const Function& function,
-      coro_handler<Handler, T>* this_handler)
-  {
-    asio_handler_invoke_helpers::invoke(
-        function, this_handler->handler_);
-  }
-
-} // namespace detail
-
-#if !defined(GENERATING_DOCUMENTATION)
-
-template <typename Handler, typename ReturnType>
-struct handler_type<basic_yield_context<Handler>, ReturnType()>
-{
-  typedef detail::coro_handler<Handler, void> type;
-};
-
-template <typename Handler, typename ReturnType, typename Arg1>
-struct handler_type<basic_yield_context<Handler>, ReturnType(Arg1)>
-{
-  typedef detail::coro_handler<Handler, Arg1> type;
-};
-
-template <typename Handler, typename ReturnType>
-struct handler_type<basic_yield_context<Handler>,
-    ReturnType(asio::error_code)>
-{
-  typedef detail::coro_handler<Handler, void> type;
-};
-
-template <typename Handler, typename ReturnType, typename Arg2>
-struct handler_type<basic_yield_context<Handler>,
-    ReturnType(asio::error_code, Arg2)>
-{
-  typedef detail::coro_handler<Handler, Arg2> type;
-};
-
-template <typename Handler, typename T>
-class async_result<detail::coro_handler<Handler, T> >
-{
-public:
-  typedef T type;
-
-  explicit async_result(detail::coro_handler<Handler, T>& h)
-    : handler_(h),
-      ca_(h.ca_)
-  {
-    out_ec_ = h.ec_;
-    if (!out_ec_) h.ec_ = &ec_;
-    h.value_ = &value_;
-  }
-
-  type get()
-  {
-    handler_.coro_.reset(); // Must not hold shared_ptr to coro while suspended.
-    ca_();
-    if (!out_ec_ && ec_) throw asio::system_error(ec_);
-    return value_;
-  }
-
-private:
-  detail::coro_handler<Handler, T>& handler_;
-  typename basic_yield_context<Handler>::caller_type& ca_;
-  asio::error_code* out_ec_;
-  asio::error_code ec_;
-  type value_;
-};
-
-template <typename Handler>
-class async_result<detail::coro_handler<Handler, void> >
-{
-public:
-  typedef void type;
-
-  explicit async_result(detail::coro_handler<Handler, void>& h)
-    : handler_(h),
-      ca_(h.ca_)
-  {
-    out_ec_ = h.ec_;
-    if (!out_ec_) h.ec_ = &ec_;
-  }
-
-  void get()
-  {
-    handler_.coro_.reset(); // Must not hold shared_ptr to coro while suspended.
-    ca_();
-    if (!out_ec_ && ec_) throw asio::system_error(ec_);
-  }
-
-private:
-  detail::coro_handler<Handler, void>& handler_;
-  typename basic_yield_context<Handler>::caller_type& ca_;
-  asio::error_code* out_ec_;
-  asio::error_code ec_;
-};
-
-namespace detail {
-
-  template <typename Handler, typename Function>
-  struct spawn_data : private noncopyable
-  {
-    spawn_data(ASIO_MOVE_ARG(Handler) handler,
-        bool call_handler, ASIO_MOVE_ARG(Function) function)
-      : handler_(ASIO_MOVE_CAST(Handler)(handler)),
-        call_handler_(call_handler),
-        function_(ASIO_MOVE_CAST(Function)(function))
-    {
-    }
-
-    weak_ptr<typename basic_yield_context<Handler>::callee_type> coro_;
-    Handler handler_;
-    bool call_handler_;
-    Function function_;
-  };
-
-  template <typename Handler, typename Function>
-  struct coro_entry_point
-  {
-    void operator()(typename basic_yield_context<Handler>::caller_type& ca)
-    {
-      shared_ptr<spawn_data<Handler, Function> > data(data_);
-#if !defined(BOOST_COROUTINES_UNIDIRECT) && !defined(BOOST_COROUTINES_V2)
-      ca(); // Yield until coroutine pointer has been initialised.
-#endif // !defined(BOOST_COROUTINES_UNIDIRECT) && !defined(BOOST_COROUTINES_V2)
-      const basic_yield_context<Handler> yield(
-          data->coro_, ca, data->handler_);
-      (data->function_)(yield);
-      if (data->call_handler_)
-        (data->handler_)();
-    }
-
-    shared_ptr<spawn_data<Handler, Function> > data_;
-  };
-
-  template <typename Handler, typename Function>
-  struct spawn_helper
-  {
-    void operator()()
-    {
-      typedef typename basic_yield_context<Handler>::callee_type callee_type;
-      coro_entry_point<Handler, Function> entry_point = { data_ };
-      shared_ptr<callee_type> coro(new callee_type(entry_point, attributes_));
-      data_->coro_ = coro;
-      (*coro)();
-    }
-
-    shared_ptr<spawn_data<Handler, Function> > data_;
-    boost::coroutines::attributes attributes_;
-  };
-
-  inline void default_spawn_handler() {}
-
-} // namespace detail
-
-template <typename Handler, typename Function>
-void spawn(ASIO_MOVE_ARG(Handler) handler,
-    ASIO_MOVE_ARG(Function) function,
-    const boost::coroutines::attributes& attributes)
-{
-  detail::spawn_helper<Handler, Function> helper;
-  helper.data_.reset(
-      new detail::spawn_data<Handler, Function>(
-        ASIO_MOVE_CAST(Handler)(handler), true,
-        ASIO_MOVE_CAST(Function)(function)));
-  helper.attributes_ = attributes;
-  asio_handler_invoke_helpers::invoke(helper, helper.data_->handler_);
-}
-
-template <typename Handler, typename Function>
-void spawn(basic_yield_context<Handler> ctx,
-    ASIO_MOVE_ARG(Function) function,
-    const boost::coroutines::attributes& attributes)
-{
-  Handler handler(ctx.handler_); // Explicit copy that might be moved from.
-  detail::spawn_helper<Handler, Function> helper;
-  helper.data_.reset(
-      new detail::spawn_data<Handler, Function>(
-        ASIO_MOVE_CAST(Handler)(handler), false,
-        ASIO_MOVE_CAST(Function)(function)));
-  helper.attributes_ = attributes;
-  asio_handler_invoke_helpers::invoke(helper, helper.data_->handler_);
-}
-
-template <typename Function>
-void spawn(asio::io_service::strand strand,
-    ASIO_MOVE_ARG(Function) function,
-    const boost::coroutines::attributes& attributes)
-{
-  asio::spawn(strand.wrap(&detail::default_spawn_handler),
-      ASIO_MOVE_CAST(Function)(function), attributes);
-}
-
-template <typename Function>
-void spawn(asio::io_service& io_service,
-    ASIO_MOVE_ARG(Function) function,
-    const boost::coroutines::attributes& attributes)
-{
-  asio::spawn(asio::io_service::strand(io_service),
-      ASIO_MOVE_CAST(Function)(function), attributes);
-}
-
-#endif // !defined(GENERATING_DOCUMENTATION)
-
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_IMPL_SPAWN_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/impl/src.cpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/impl/src.cpp
deleted file mode 100644
index a1e26430315d..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/impl/src.cpp
+++ /dev/null
@@ -1,25 +0,0 @@
-//
-// impl/src.cpp
-// ~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#if defined(_MSC_VER) \
-  || defined(__BORLANDC__) \
-  || defined(__DMC__)
-# pragma message ( \
-    "This file is deprecated. " \
-    "Please #include <asio/impl/src.hpp> instead.")
-#elif defined(__GNUC__) \
-  || defined(__HP_aCC) \
-  || defined(__SUNPRO_CC) \
-  || defined(__IBMCPP__)
-# warning "This file is deprecated."
-# warning "Please #include <asio/impl/src.hpp> instead."
-#endif
-
-#include "asio/impl/src.hpp"
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/impl/src.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/impl/src.hpp
deleted file mode 100644
index 58b2a8892d82..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/impl/src.hpp
+++ /dev/null
@@ -1,74 +0,0 @@
-//
-// impl/src.hpp
-// ~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_IMPL_SRC_HPP
-#define ASIO_IMPL_SRC_HPP
-
-#define ASIO_SOURCE
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_HEADER_ONLY)
-# error Do not compile Asio library source with ASIO_HEADER_ONLY defined
-#endif
-
-#include "asio/impl/error.ipp"
-#include "asio/impl/error_code.ipp"
-#include "asio/impl/handler_alloc_hook.ipp"
-#include "asio/impl/io_service.ipp"
-#include "asio/impl/serial_port_base.ipp"
-#include "asio/detail/impl/buffer_sequence_adapter.ipp"
-#include "asio/detail/impl/descriptor_ops.ipp"
-#include "asio/detail/impl/dev_poll_reactor.ipp"
-#include "asio/detail/impl/epoll_reactor.ipp"
-#include "asio/detail/impl/eventfd_select_interrupter.ipp"
-#include "asio/detail/impl/handler_tracking.ipp"
-#include "asio/detail/impl/kqueue_reactor.ipp"
-#include "asio/detail/impl/pipe_select_interrupter.ipp"
-#include "asio/detail/impl/posix_event.ipp"
-#include "asio/detail/impl/posix_mutex.ipp"
-#include "asio/detail/impl/posix_thread.ipp"
-#include "asio/detail/impl/posix_tss_ptr.ipp"
-#include "asio/detail/impl/reactive_descriptor_service.ipp"
-#include "asio/detail/impl/reactive_serial_port_service.ipp"
-#include "asio/detail/impl/reactive_socket_service_base.ipp"
-#include "asio/detail/impl/resolver_service_base.ipp"
-#include "asio/detail/impl/select_reactor.ipp"
-#include "asio/detail/impl/service_registry.ipp"
-#include "asio/detail/impl/signal_set_service.ipp"
-#include "asio/detail/impl/socket_ops.ipp"
-#include "asio/detail/impl/socket_select_interrupter.ipp"
-#include "asio/detail/impl/strand_service.ipp"
-#include "asio/detail/impl/task_io_service.ipp"
-#include "asio/detail/impl/throw_error.ipp"
-#include "asio/detail/impl/timer_queue_ptime.ipp"
-#include "asio/detail/impl/timer_queue_set.ipp"
-#include "asio/detail/impl/win_iocp_handle_service.ipp"
-#include "asio/detail/impl/win_iocp_io_service.ipp"
-#include "asio/detail/impl/win_iocp_serial_port_service.ipp"
-#include "asio/detail/impl/win_iocp_socket_service_base.ipp"
-#include "asio/detail/impl/win_event.ipp"
-#include "asio/detail/impl/win_mutex.ipp"
-#include "asio/detail/impl/win_object_handle_service.ipp"
-#include "asio/detail/impl/win_static_mutex.ipp"
-#include "asio/detail/impl/win_thread.ipp"
-#include "asio/detail/impl/win_tss_ptr.ipp"
-#include "asio/detail/impl/winrt_ssocket_service_base.ipp"
-#include "asio/detail/impl/winrt_timer_scheduler.ipp"
-#include "asio/detail/impl/winsock_init.ipp"
-#include "asio/generic/detail/impl/endpoint.ipp"
-#include "asio/ip/impl/address.ipp"
-#include "asio/ip/impl/address_v4.ipp"
-#include "asio/ip/impl/address_v6.ipp"
-#include "asio/ip/impl/host_name.ipp"
-#include "asio/ip/detail/impl/endpoint.ipp"
-#include "asio/local/detail/impl/endpoint.ipp"
-
-#endif // ASIO_IMPL_SRC_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/impl/use_future.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/impl/use_future.hpp
deleted file mode 100644
index 5202df68c47d..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/impl/use_future.hpp
+++ /dev/null
@@ -1,172 +0,0 @@
-//
-// impl/use_future.hpp
-// ~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_IMPL_USE_FUTURE_HPP
-#define ASIO_IMPL_USE_FUTURE_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include <future>
-#include "asio/async_result.hpp"
-#include "asio/error_code.hpp"
-#include "asio/handler_type.hpp"
-#include "asio/system_error.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace detail {
-
-  // Completion handler to adapt a promise as a completion handler.
-  template <typename T>
-  class promise_handler
-  {
-  public:
-    // Construct from use_future special value.
-    template <typename Allocator>
-    promise_handler(use_future_t<Allocator> uf)
-      : promise_(std::allocate_shared<std::promise<T> >(
-            uf.get_allocator(), std::allocator_arg, uf.get_allocator()))
-    {
-    }
-
-    void operator()(T t)
-    {
-      promise_->set_value(t);
-    }
-
-    void operator()(const asio::error_code& ec, T t)
-    {
-      if (ec)
-        promise_->set_exception(
-            std::make_exception_ptr(
-              asio::system_error(ec)));
-      else
-        promise_->set_value(t);
-    }
-
-  //private:
-    std::shared_ptr<std::promise<T> > promise_;
-  };
-
-  // Completion handler to adapt a void promise as a completion handler.
-  template <>
-  class promise_handler<void>
-  {
-  public:
-    // Construct from use_future special value. Used during rebinding.
-    template <typename Allocator>
-    promise_handler(use_future_t<Allocator> uf)
-      : promise_(std::allocate_shared<std::promise<void> >(
-            uf.get_allocator(), std::allocator_arg, uf.get_allocator()))
-    {
-    }
-
-    void operator()()
-    {
-      promise_->set_value();
-    }
-
-    void operator()(const asio::error_code& ec)
-    {
-      if (ec)
-        promise_->set_exception(
-            std::make_exception_ptr(
-              asio::system_error(ec)));
-      else
-        promise_->set_value();
-    }
-
-  //private:
-    std::shared_ptr<std::promise<void> > promise_;
-  };
-
-  // Ensure any exceptions thrown from the handler are propagated back to the
-  // caller via the future.
-  template <typename Function, typename T>
-  void asio_handler_invoke(Function f, promise_handler<T>* h)
-  {
-    std::shared_ptr<std::promise<T> > p(h->promise_);
-    try
-    {
-      f();
-    }
-    catch (...)
-    {
-      p->set_exception(std::current_exception());
-    }
-  }
-
-} // namespace detail
-
-#if !defined(GENERATING_DOCUMENTATION)
-
-// Handler traits specialisation for promise_handler.
-template <typename T>
-class async_result<detail::promise_handler<T> >
-{
-public:
-  // The initiating function will return a future.
-  typedef std::future<T> type;
-
-  // Constructor creates a new promise for the async operation, and obtains the
-  // corresponding future.
-  explicit async_result(detail::promise_handler<T>& h)
-  {
-    value_ = h.promise_->get_future();
-  }
-
-  // Obtain the future to be returned from the initiating function.
-  type get() { return std::move(value_); }
-
-private:
-  type value_;
-};
-
-// Handler type specialisation for use_future.
-template <typename Allocator, typename ReturnType>
-struct handler_type<use_future_t<Allocator>, ReturnType()>
-{
-  typedef detail::promise_handler<void> type;
-};
-
-// Handler type specialisation for use_future.
-template <typename Allocator, typename ReturnType, typename Arg1>
-struct handler_type<use_future_t<Allocator>, ReturnType(Arg1)>
-{
-  typedef detail::promise_handler<Arg1> type;
-};
-
-// Handler type specialisation for use_future.
-template <typename Allocator, typename ReturnType>
-struct handler_type<use_future_t<Allocator>,
-    ReturnType(asio::error_code)>
-{
-  typedef detail::promise_handler<void> type;
-};
-
-// Handler type specialisation for use_future.
-template <typename Allocator, typename ReturnType, typename Arg2>
-struct handler_type<use_future_t<Allocator>,
-    ReturnType(asio::error_code, Arg2)>
-{
-  typedef detail::promise_handler<Arg2> type;
-};
-
-#endif // !defined(GENERATING_DOCUMENTATION)
-
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_IMPL_USE_FUTURE_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/impl/write.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/impl/write.hpp
deleted file mode 100644
index 77ddebe79b35..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/impl/write.hpp
+++ /dev/null
@@ -1,765 +0,0 @@
-//
-// impl/write.hpp
-// ~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_IMPL_WRITE_HPP
-#define ASIO_IMPL_WRITE_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/buffer.hpp"
-#include "asio/completion_condition.hpp"
-#include "asio/detail/array_fwd.hpp"
-#include "asio/detail/base_from_completion_cond.hpp"
-#include "asio/detail/bind_handler.hpp"
-#include "asio/detail/consuming_buffers.hpp"
-#include "asio/detail/dependent_type.hpp"
-#include "asio/detail/handler_alloc_helpers.hpp"
-#include "asio/detail/handler_cont_helpers.hpp"
-#include "asio/detail/handler_invoke_helpers.hpp"
-#include "asio/detail/handler_type_requirements.hpp"
-#include "asio/detail/throw_error.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-
-template <typename SyncWriteStream, typename ConstBufferSequence,
-    typename CompletionCondition>
-std::size_t write(SyncWriteStream& s, const ConstBufferSequence& buffers,
-    CompletionCondition completion_condition, asio::error_code& ec)
-{
-  ec = asio::error_code();
-  asio::detail::consuming_buffers<
-    const_buffer, ConstBufferSequence> tmp(buffers);
-  std::size_t total_transferred = 0;
-  tmp.prepare(detail::adapt_completion_condition_result(
-        completion_condition(ec, total_transferred)));
-  while (tmp.begin() != tmp.end())
-  {
-    std::size_t bytes_transferred = s.write_some(tmp, ec);
-    tmp.consume(bytes_transferred);
-    total_transferred += bytes_transferred;
-    tmp.prepare(detail::adapt_completion_condition_result(
-          completion_condition(ec, total_transferred)));
-  }
-  return total_transferred;
-}
-
-template <typename SyncWriteStream, typename ConstBufferSequence>
-inline std::size_t write(SyncWriteStream& s, const ConstBufferSequence& buffers)
-{
-  asio::error_code ec;
-  std::size_t bytes_transferred = write(s, buffers, transfer_all(), ec);
-  asio::detail::throw_error(ec, "write");
-  return bytes_transferred;
-}
-
-template <typename SyncWriteStream, typename ConstBufferSequence>
-inline std::size_t write(SyncWriteStream& s, const ConstBufferSequence& buffers,
-    asio::error_code& ec)
-{
-  return write(s, buffers, transfer_all(), ec);
-}
-
-template <typename SyncWriteStream, typename ConstBufferSequence,
-    typename CompletionCondition>
-inline std::size_t write(SyncWriteStream& s, const ConstBufferSequence& buffers,
-    CompletionCondition completion_condition)
-{
-  asio::error_code ec;
-  std::size_t bytes_transferred = write(s, buffers, completion_condition, ec);
-  asio::detail::throw_error(ec, "write");
-  return bytes_transferred;
-}
-
-#if !defined(ASIO_NO_IOSTREAM)
-
-template <typename SyncWriteStream, typename Allocator,
-    typename CompletionCondition>
-std::size_t write(SyncWriteStream& s,
-    asio::basic_streambuf<Allocator>& b,
-    CompletionCondition completion_condition, asio::error_code& ec)
-{
-  std::size_t bytes_transferred = write(s, b.data(), completion_condition, ec);
-  b.consume(bytes_transferred);
-  return bytes_transferred;
-}
-
-template <typename SyncWriteStream, typename Allocator>
-inline std::size_t write(SyncWriteStream& s,
-    asio::basic_streambuf<Allocator>& b)
-{
-  asio::error_code ec;
-  std::size_t bytes_transferred = write(s, b, transfer_all(), ec);
-  asio::detail::throw_error(ec, "write");
-  return bytes_transferred;
-}
-
-template <typename SyncWriteStream, typename Allocator>
-inline std::size_t write(SyncWriteStream& s,
-    asio::basic_streambuf<Allocator>& b,
-    asio::error_code& ec)
-{
-  return write(s, b, transfer_all(), ec);
-}
-
-template <typename SyncWriteStream, typename Allocator,
-    typename CompletionCondition>
-inline std::size_t write(SyncWriteStream& s,
-    asio::basic_streambuf<Allocator>& b,
-    CompletionCondition completion_condition)
-{
-  asio::error_code ec;
-  std::size_t bytes_transferred = write(s, b, completion_condition, ec);
-  asio::detail::throw_error(ec, "write");
-  return bytes_transferred;
-}
-
-#endif // !defined(ASIO_NO_IOSTREAM)
-
-namespace detail
-{
-  template <typename AsyncWriteStream, typename ConstBufferSequence,
-      typename CompletionCondition, typename WriteHandler>
-  class write_op
-    : detail::base_from_completion_cond<CompletionCondition>
-  {
-  public:
-    write_op(AsyncWriteStream& stream, const ConstBufferSequence& buffers,
-        CompletionCondition completion_condition, WriteHandler& handler)
-      : detail::base_from_completion_cond<
-          CompletionCondition>(completion_condition),
-        stream_(stream),
-        buffers_(buffers),
-        start_(0),
-        total_transferred_(0),
-        handler_(ASIO_MOVE_CAST(WriteHandler)(handler))
-    {
-    }
-
-#if defined(ASIO_HAS_MOVE)
-    write_op(const write_op& other)
-      : detail::base_from_completion_cond<CompletionCondition>(other),
-        stream_(other.stream_),
-        buffers_(other.buffers_),
-        start_(other.start_),
-        total_transferred_(other.total_transferred_),
-        handler_(other.handler_)
-    {
-    }
-
-    write_op(write_op&& other)
-      : detail::base_from_completion_cond<CompletionCondition>(other),
-        stream_(other.stream_),
-        buffers_(other.buffers_),
-        start_(other.start_),
-        total_transferred_(other.total_transferred_),
-        handler_(ASIO_MOVE_CAST(WriteHandler)(other.handler_))
-    {
-    }
-#endif // defined(ASIO_HAS_MOVE)
-
-    void operator()(const asio::error_code& ec,
-        std::size_t bytes_transferred, int start = 0)
-    {
-      switch (start_ = start)
-      {
-        case 1:
-        buffers_.prepare(this->check_for_completion(ec, total_transferred_));
-        for (;;)
-        {
-          stream_.async_write_some(buffers_,
-              ASIO_MOVE_CAST(write_op)(*this));
-          return; default:
-          total_transferred_ += bytes_transferred;
-          buffers_.consume(bytes_transferred);
-          buffers_.prepare(this->check_for_completion(ec, total_transferred_));
-          if ((!ec && bytes_transferred == 0)
-              || buffers_.begin() == buffers_.end())
-            break;
-        }
-
-        handler_(ec, static_cast<const std::size_t&>(total_transferred_));
-      }
-    }
-
-  //private:
-    AsyncWriteStream& stream_;
-    asio::detail::consuming_buffers<
-      const_buffer, ConstBufferSequence> buffers_;
-    int start_;
-    std::size_t total_transferred_;
-    WriteHandler handler_;
-  };
-
-  template <typename AsyncWriteStream,
-      typename CompletionCondition, typename WriteHandler>
-  class write_op<AsyncWriteStream, asio::mutable_buffers_1,
-      CompletionCondition, WriteHandler>
-    : detail::base_from_completion_cond<CompletionCondition>
-  {
-  public:
-    write_op(AsyncWriteStream& stream,
-        const asio::mutable_buffers_1& buffers,
-        CompletionCondition completion_condition,
-        WriteHandler& handler)
-      : detail::base_from_completion_cond<
-          CompletionCondition>(completion_condition),
-        stream_(stream),
-        buffer_(buffers),
-        start_(0),
-        total_transferred_(0),
-        handler_(ASIO_MOVE_CAST(WriteHandler)(handler))
-    {
-    }
-
-#if defined(ASIO_HAS_MOVE)
-    write_op(const write_op& other)
-      : detail::base_from_completion_cond<CompletionCondition>(other),
-        stream_(other.stream_),
-        buffer_(other.buffer_),
-        start_(other.start_),
-        total_transferred_(other.total_transferred_),
-        handler_(other.handler_)
-    {
-    }
-
-    write_op(write_op&& other)
-      : detail::base_from_completion_cond<CompletionCondition>(other),
-        stream_(other.stream_),
-        buffer_(other.buffer_),
-        start_(other.start_),
-        total_transferred_(other.total_transferred_),
-        handler_(ASIO_MOVE_CAST(WriteHandler)(other.handler_))
-    {
-    }
-#endif // defined(ASIO_HAS_MOVE)
-
-    void operator()(const asio::error_code& ec,
-        std::size_t bytes_transferred, int start = 0)
-    {
-      std::size_t n = 0;
-      switch (start_ = start)
-      {
-        case 1:
-        n = this->check_for_completion(ec, total_transferred_);
-        for (;;)
-        {
-          stream_.async_write_some(
-              asio::buffer(buffer_ + total_transferred_, n),
-              ASIO_MOVE_CAST(write_op)(*this));
-          return; default:
-          total_transferred_ += bytes_transferred;
-          if ((!ec && bytes_transferred == 0)
-              || (n = this->check_for_completion(ec, total_transferred_)) == 0
-              || total_transferred_ == asio::buffer_size(buffer_))
-            break;
-        }
-
-        handler_(ec, static_cast<const std::size_t&>(total_transferred_));
-      }
-    }
-
-  //private:
-    AsyncWriteStream& stream_;
-    asio::mutable_buffer buffer_;
-    int start_;
-    std::size_t total_transferred_;
-    WriteHandler handler_;
-  };
-
-  template <typename AsyncWriteStream,
-      typename CompletionCondition, typename WriteHandler>
-  class write_op<AsyncWriteStream, asio::const_buffers_1,
-      CompletionCondition, WriteHandler>
-    : detail::base_from_completion_cond<CompletionCondition>
-  {
-  public:
-    write_op(AsyncWriteStream& stream,
-        const asio::const_buffers_1& buffers,
-        CompletionCondition completion_condition,
-        WriteHandler& handler)
-      : detail::base_from_completion_cond<
-          CompletionCondition>(completion_condition),
-        stream_(stream),
-        buffer_(buffers),
-        start_(0),
-        total_transferred_(0),
-        handler_(ASIO_MOVE_CAST(WriteHandler)(handler))
-    {
-    }
-
-#if defined(ASIO_HAS_MOVE)
-    write_op(const write_op& other)
-      : detail::base_from_completion_cond<CompletionCondition>(other),
-        stream_(other.stream_),
-        buffer_(other.buffer_),
-        start_(other.start_),
-        total_transferred_(other.total_transferred_),
-        handler_(other.handler_)
-    {
-    }
-
-    write_op(write_op&& other)
-      : detail::base_from_completion_cond<CompletionCondition>(other),
-        stream_(other.stream_),
-        buffer_(other.buffer_),
-        start_(other.start_),
-        total_transferred_(other.total_transferred_),
-        handler_(ASIO_MOVE_CAST(WriteHandler)(other.handler_))
-    {
-    }
-#endif // defined(ASIO_HAS_MOVE)
-
-    void operator()(const asio::error_code& ec,
-        std::size_t bytes_transferred, int start = 0)
-    {
-      std::size_t n = 0;
-      switch (start_ = start)
-      {
-        case 1:
-        n = this->check_for_completion(ec, total_transferred_);
-        for (;;)
-        {
-          stream_.async_write_some(
-              asio::buffer(buffer_ + total_transferred_, n),
-              ASIO_MOVE_CAST(write_op)(*this));
-          return; default:
-          total_transferred_ += bytes_transferred;
-          if ((!ec && bytes_transferred == 0)
-              || (n = this->check_for_completion(ec, total_transferred_)) == 0
-              || total_transferred_ == asio::buffer_size(buffer_))
-            break;
-        }
-
-        handler_(ec, static_cast<const std::size_t&>(total_transferred_));
-      }
-    }
-
-  //private:
-    AsyncWriteStream& stream_;
-    asio::const_buffer buffer_;
-    int start_;
-    std::size_t total_transferred_;
-    WriteHandler handler_;
-  };
-
-  template <typename AsyncWriteStream, typename Elem,
-      typename CompletionCondition, typename WriteHandler>
-  class write_op<AsyncWriteStream, boost::array<Elem, 2>,
-      CompletionCondition, WriteHandler>
-    : detail::base_from_completion_cond<CompletionCondition>
-  {
-  public:
-    write_op(AsyncWriteStream& stream, const boost::array<Elem, 2>& buffers,
-        CompletionCondition completion_condition, WriteHandler& handler)
-      : detail::base_from_completion_cond<
-          CompletionCondition>(completion_condition),
-        stream_(stream),
-        buffers_(buffers),
-        start_(0),
-        total_transferred_(0),
-        handler_(ASIO_MOVE_CAST(WriteHandler)(handler))
-    {
-    }
-
-#if defined(ASIO_HAS_MOVE)
-    write_op(const write_op& other)
-      : detail::base_from_completion_cond<CompletionCondition>(other),
-        stream_(other.stream_),
-        buffers_(other.buffers_),
-        start_(other.start_),
-        total_transferred_(other.total_transferred_),
-        handler_(other.handler_)
-    {
-    }
-
-    write_op(write_op&& other)
-      : detail::base_from_completion_cond<CompletionCondition>(other),
-        stream_(other.stream_),
-        buffers_(other.buffers_),
-        start_(other.start_),
-        total_transferred_(other.total_transferred_),
-        handler_(ASIO_MOVE_CAST(WriteHandler)(other.handler_))
-    {
-    }
-#endif // defined(ASIO_HAS_MOVE)
-
-    void operator()(const asio::error_code& ec,
-        std::size_t bytes_transferred, int start = 0)
-    {
-      typename asio::detail::dependent_type<Elem,
-          boost::array<asio::const_buffer, 2> >::type bufs = {{
-        asio::const_buffer(buffers_[0]),
-        asio::const_buffer(buffers_[1]) }};
-      std::size_t buffer_size0 = asio::buffer_size(bufs[0]);
-      std::size_t buffer_size1 = asio::buffer_size(bufs[1]);
-      std::size_t n = 0;
-      switch (start_ = start)
-      {
-        case 1:
-        n = this->check_for_completion(ec, total_transferred_);
-        for (;;)
-        {
-          bufs[0] = asio::buffer(bufs[0] + total_transferred_, n);
-          bufs[1] = asio::buffer(
-              bufs[1] + (total_transferred_ < buffer_size0
-                ? 0 : total_transferred_ - buffer_size0),
-              n - asio::buffer_size(bufs[0]));
-          stream_.async_write_some(bufs, ASIO_MOVE_CAST(write_op)(*this));
-          return; default:
-          total_transferred_ += bytes_transferred;
-          if ((!ec && bytes_transferred == 0)
-              || (n = this->check_for_completion(ec, total_transferred_)) == 0
-              || total_transferred_ == buffer_size0 + buffer_size1)
-            break;
-        }
-
-        handler_(ec, static_cast<const std::size_t&>(total_transferred_));
-      }
-    }
-
-  //private:
-    AsyncWriteStream& stream_;
-    boost::array<Elem, 2> buffers_;
-    int start_;
-    std::size_t total_transferred_;
-    WriteHandler handler_;
-  };
-
-#if defined(ASIO_HAS_STD_ARRAY)
-
-  template <typename AsyncWriteStream, typename Elem,
-      typename CompletionCondition, typename WriteHandler>
-  class write_op<AsyncWriteStream, std::array<Elem, 2>,
-      CompletionCondition, WriteHandler>
-    : detail::base_from_completion_cond<CompletionCondition>
-  {
-  public:
-    write_op(AsyncWriteStream& stream, const std::array<Elem, 2>& buffers,
-        CompletionCondition completion_condition, WriteHandler& handler)
-      : detail::base_from_completion_cond<
-          CompletionCondition>(completion_condition),
-        stream_(stream),
-        buffers_(buffers),
-        start_(0),
-        total_transferred_(0),
-        handler_(ASIO_MOVE_CAST(WriteHandler)(handler))
-    {
-    }
-
-#if defined(ASIO_HAS_MOVE)
-    write_op(const write_op& other)
-      : detail::base_from_completion_cond<CompletionCondition>(other),
-        stream_(other.stream_),
-        buffers_(other.buffers_),
-        start_(other.start_),
-        total_transferred_(other.total_transferred_),
-        handler_(other.handler_)
-    {
-    }
-
-    write_op(write_op&& other)
-      : detail::base_from_completion_cond<CompletionCondition>(other),
-        stream_(other.stream_),
-        buffers_(other.buffers_),
-        start_(other.start_),
-        total_transferred_(other.total_transferred_),
-        handler_(ASIO_MOVE_CAST(WriteHandler)(other.handler_))
-    {
-    }
-#endif // defined(ASIO_HAS_MOVE)
-
-    void operator()(const asio::error_code& ec,
-        std::size_t bytes_transferred, int start = 0)
-    {
-      typename asio::detail::dependent_type<Elem,
-          std::array<asio::const_buffer, 2> >::type bufs = {{
-        asio::const_buffer(buffers_[0]),
-        asio::const_buffer(buffers_[1]) }};
-      std::size_t buffer_size0 = asio::buffer_size(bufs[0]);
-      std::size_t buffer_size1 = asio::buffer_size(bufs[1]);
-      std::size_t n = 0;
-      switch (start_ = start)
-      {
-        case 1:
-        n = this->check_for_completion(ec, total_transferred_);
-        for (;;)
-        {
-          bufs[0] = asio::buffer(bufs[0] + total_transferred_, n);
-          bufs[1] = asio::buffer(
-              bufs[1] + (total_transferred_ < buffer_size0
-                ? 0 : total_transferred_ - buffer_size0),
-              n - asio::buffer_size(bufs[0]));
-          stream_.async_write_some(bufs, ASIO_MOVE_CAST(write_op)(*this));
-          return; default:
-          total_transferred_ += bytes_transferred;
-          if ((!ec && bytes_transferred == 0)
-              || (n = this->check_for_completion(ec, total_transferred_)) == 0
-              || total_transferred_ == buffer_size0 + buffer_size1)
-            break;
-        }
-
-        handler_(ec, static_cast<const std::size_t&>(total_transferred_));
-      }
-    }
-
-  //private:
-    AsyncWriteStream& stream_;
-    std::array<Elem, 2> buffers_;
-    int start_;
-    std::size_t total_transferred_;
-    WriteHandler handler_;
-  };
-
-#endif // defined(ASIO_HAS_STD_ARRAY)
-
-  template <typename AsyncWriteStream, typename ConstBufferSequence,
-      typename CompletionCondition, typename WriteHandler>
-  inline void* asio_handler_allocate(std::size_t size,
-      write_op<AsyncWriteStream, ConstBufferSequence,
-        CompletionCondition, WriteHandler>* this_handler)
-  {
-    return asio_handler_alloc_helpers::allocate(
-        size, this_handler->handler_);
-  }
-
-  template <typename AsyncWriteStream, typename ConstBufferSequence,
-      typename CompletionCondition, typename WriteHandler>
-  inline void asio_handler_deallocate(void* pointer, std::size_t size,
-      write_op<AsyncWriteStream, ConstBufferSequence,
-        CompletionCondition, WriteHandler>* this_handler)
-  {
-    asio_handler_alloc_helpers::deallocate(
-        pointer, size, this_handler->handler_);
-  }
-
-  template <typename AsyncWriteStream, typename ConstBufferSequence,
-      typename CompletionCondition, typename WriteHandler>
-  inline bool asio_handler_is_continuation(
-      write_op<AsyncWriteStream, ConstBufferSequence,
-        CompletionCondition, WriteHandler>* this_handler)
-  {
-    return this_handler->start_ == 0 ? true
-      : asio_handler_cont_helpers::is_continuation(
-          this_handler->handler_);
-  }
-
-  template <typename Function, typename AsyncWriteStream,
-      typename ConstBufferSequence, typename CompletionCondition,
-      typename WriteHandler>
-  inline void asio_handler_invoke(Function& function,
-      write_op<AsyncWriteStream, ConstBufferSequence,
-        CompletionCondition, WriteHandler>* this_handler)
-  {
-    asio_handler_invoke_helpers::invoke(
-        function, this_handler->handler_);
-  }
-
-  template <typename Function, typename AsyncWriteStream,
-      typename ConstBufferSequence, typename CompletionCondition,
-      typename WriteHandler>
-  inline void asio_handler_invoke(const Function& function,
-      write_op<AsyncWriteStream, ConstBufferSequence,
-        CompletionCondition, WriteHandler>* this_handler)
-  {
-    asio_handler_invoke_helpers::invoke(
-        function, this_handler->handler_);
-  }
-} // namespace detail
-
-template <typename AsyncWriteStream, typename ConstBufferSequence,
-  typename CompletionCondition, typename WriteHandler>
-inline ASIO_INITFN_RESULT_TYPE(WriteHandler,
-    void (asio::error_code, std::size_t))
-async_write(AsyncWriteStream& s, const ConstBufferSequence& buffers,
-    CompletionCondition completion_condition,
-    ASIO_MOVE_ARG(WriteHandler) handler)
-{
-  // If you get an error on the following line it means that your handler does
-  // not meet the documented type requirements for a WriteHandler.
-  ASIO_WRITE_HANDLER_CHECK(WriteHandler, handler) type_check;
-
-  detail::async_result_init<
-    WriteHandler, void (asio::error_code, std::size_t)> init(
-      ASIO_MOVE_CAST(WriteHandler)(handler));
-
-  detail::write_op<AsyncWriteStream, ConstBufferSequence,
-    CompletionCondition, ASIO_HANDLER_TYPE(
-      WriteHandler, void (asio::error_code, std::size_t))>(
-        s, buffers, completion_condition, init.handler)(
-          asio::error_code(), 0, 1);
-
-  return init.result.get();
-}
-
-template <typename AsyncWriteStream, typename ConstBufferSequence,
-    typename WriteHandler>
-inline ASIO_INITFN_RESULT_TYPE(WriteHandler,
-    void (asio::error_code, std::size_t))
-async_write(AsyncWriteStream& s, const ConstBufferSequence& buffers,
-    ASIO_MOVE_ARG(WriteHandler) handler)
-{
-  // If you get an error on the following line it means that your handler does
-  // not meet the documented type requirements for a WriteHandler.
-  ASIO_WRITE_HANDLER_CHECK(WriteHandler, handler) type_check;
-
-  detail::async_result_init<
-    WriteHandler, void (asio::error_code, std::size_t)> init(
-      ASIO_MOVE_CAST(WriteHandler)(handler));
-
-  detail::write_op<AsyncWriteStream, ConstBufferSequence,
-    detail::transfer_all_t, ASIO_HANDLER_TYPE(
-      WriteHandler, void (asio::error_code, std::size_t))>(
-        s, buffers, transfer_all(), init.handler)(
-          asio::error_code(), 0, 1);
-
-  return init.result.get();
-}
-
-#if !defined(ASIO_NO_IOSTREAM)
-
-namespace detail
-{
-  template <typename Allocator, typename WriteHandler>
-  class write_streambuf_handler
-  {
-  public:
-    write_streambuf_handler(asio::basic_streambuf<Allocator>& streambuf,
-        WriteHandler& handler)
-      : streambuf_(streambuf),
-        handler_(ASIO_MOVE_CAST(WriteHandler)(handler))
-    {
-    }
-
-#if defined(ASIO_HAS_MOVE)
-    write_streambuf_handler(const write_streambuf_handler& other)
-      : streambuf_(other.streambuf_),
-        handler_(other.handler_)
-    {
-    }
-
-    write_streambuf_handler(write_streambuf_handler&& other)
-      : streambuf_(other.streambuf_),
-        handler_(ASIO_MOVE_CAST(WriteHandler)(other.handler_))
-    {
-    }
-#endif // defined(ASIO_HAS_MOVE)
-
-    void operator()(const asio::error_code& ec,
-        const std::size_t bytes_transferred)
-    {
-      streambuf_.consume(bytes_transferred);
-      handler_(ec, bytes_transferred);
-    }
-
-  //private:
-    asio::basic_streambuf<Allocator>& streambuf_;
-    WriteHandler handler_;
-  };
-
-  template <typename Allocator, typename WriteHandler>
-  inline void* asio_handler_allocate(std::size_t size,
-      write_streambuf_handler<Allocator, WriteHandler>* this_handler)
-  {
-    return asio_handler_alloc_helpers::allocate(
-        size, this_handler->handler_);
-  }
-
-  template <typename Allocator, typename WriteHandler>
-  inline void asio_handler_deallocate(void* pointer, std::size_t size,
-      write_streambuf_handler<Allocator, WriteHandler>* this_handler)
-  {
-    asio_handler_alloc_helpers::deallocate(
-        pointer, size, this_handler->handler_);
-  }
-
-  template <typename Allocator, typename WriteHandler>
-  inline bool asio_handler_is_continuation(
-      write_streambuf_handler<Allocator, WriteHandler>* this_handler)
-  {
-    return asio_handler_cont_helpers::is_continuation(
-        this_handler->handler_);
-  }
-
-  template <typename Function, typename Allocator, typename WriteHandler>
-  inline void asio_handler_invoke(Function& function,
-      write_streambuf_handler<Allocator, WriteHandler>* this_handler)
-  {
-    asio_handler_invoke_helpers::invoke(
-        function, this_handler->handler_);
-  }
-
-  template <typename Function, typename Allocator, typename WriteHandler>
-  inline void asio_handler_invoke(const Function& function,
-      write_streambuf_handler<Allocator, WriteHandler>* this_handler)
-  {
-    asio_handler_invoke_helpers::invoke(
-        function, this_handler->handler_);
-  }
-} // namespace detail
-
-template <typename AsyncWriteStream, typename Allocator,
-    typename CompletionCondition, typename WriteHandler>
-inline ASIO_INITFN_RESULT_TYPE(WriteHandler,
-    void (asio::error_code, std::size_t))
-async_write(AsyncWriteStream& s,
-    asio::basic_streambuf<Allocator>& b,
-    CompletionCondition completion_condition,
-    ASIO_MOVE_ARG(WriteHandler) handler)
-{
-  // If you get an error on the following line it means that your handler does
-  // not meet the documented type requirements for a WriteHandler.
-  ASIO_WRITE_HANDLER_CHECK(WriteHandler, handler) type_check;
-
-  detail::async_result_init<
-    WriteHandler, void (asio::error_code, std::size_t)> init(
-      ASIO_MOVE_CAST(WriteHandler)(handler));
-
-  async_write(s, b.data(), completion_condition,
-    detail::write_streambuf_handler<Allocator, ASIO_HANDLER_TYPE(
-      WriteHandler, void (asio::error_code, std::size_t))>(
-        b, init.handler));
-
-  return init.result.get();
-}
-
-template <typename AsyncWriteStream, typename Allocator, typename WriteHandler>
-inline ASIO_INITFN_RESULT_TYPE(WriteHandler,
-    void (asio::error_code, std::size_t))
-async_write(AsyncWriteStream& s,
-    asio::basic_streambuf<Allocator>& b,
-    ASIO_MOVE_ARG(WriteHandler) handler)
-{
-  // If you get an error on the following line it means that your handler does
-  // not meet the documented type requirements for a WriteHandler.
-  ASIO_WRITE_HANDLER_CHECK(WriteHandler, handler) type_check;
-
-  detail::async_result_init<
-    WriteHandler, void (asio::error_code, std::size_t)> init(
-      ASIO_MOVE_CAST(WriteHandler)(handler));
-
-  async_write(s, b.data(), transfer_all(),
-    detail::write_streambuf_handler<Allocator, ASIO_HANDLER_TYPE(
-      WriteHandler, void (asio::error_code, std::size_t))>(
-        b, init.handler));
-
-  return init.result.get();
-}
-
-#endif // !defined(ASIO_NO_IOSTREAM)
-
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_IMPL_WRITE_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/impl/write_at.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/impl/write_at.hpp
deleted file mode 100644
index 6c9e405cd01e..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/impl/write_at.hpp
+++ /dev/null
@@ -1,825 +0,0 @@
-//
-// impl/write_at.hpp
-// ~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_IMPL_WRITE_AT_HPP
-#define ASIO_IMPL_WRITE_AT_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/buffer.hpp"
-#include "asio/completion_condition.hpp"
-#include "asio/detail/array_fwd.hpp"
-#include "asio/detail/base_from_completion_cond.hpp"
-#include "asio/detail/bind_handler.hpp"
-#include "asio/detail/consuming_buffers.hpp"
-#include "asio/detail/dependent_type.hpp"
-#include "asio/detail/handler_alloc_helpers.hpp"
-#include "asio/detail/handler_cont_helpers.hpp"
-#include "asio/detail/handler_invoke_helpers.hpp"
-#include "asio/detail/handler_type_requirements.hpp"
-#include "asio/detail/throw_error.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-
-template <typename SyncRandomAccessWriteDevice, typename ConstBufferSequence,
-    typename CompletionCondition>
-std::size_t write_at(SyncRandomAccessWriteDevice& d,
-    uint64_t offset, const ConstBufferSequence& buffers,
-    CompletionCondition completion_condition, asio::error_code& ec)
-{
-  ec = asio::error_code();
-  asio::detail::consuming_buffers<
-    const_buffer, ConstBufferSequence> tmp(buffers);
-  std::size_t total_transferred = 0;
-  tmp.prepare(detail::adapt_completion_condition_result(
-        completion_condition(ec, total_transferred)));
-  while (tmp.begin() != tmp.end())
-  {
-    std::size_t bytes_transferred = d.write_some_at(
-        offset + total_transferred, tmp, ec);
-    tmp.consume(bytes_transferred);
-    total_transferred += bytes_transferred;
-    tmp.prepare(detail::adapt_completion_condition_result(
-          completion_condition(ec, total_transferred)));
-  }
-  return total_transferred;
-}
-
-template <typename SyncRandomAccessWriteDevice, typename ConstBufferSequence>
-inline std::size_t write_at(SyncRandomAccessWriteDevice& d,
-    uint64_t offset, const ConstBufferSequence& buffers)
-{
-  asio::error_code ec;
-  std::size_t bytes_transferred = write_at(
-      d, offset, buffers, transfer_all(), ec);
-  asio::detail::throw_error(ec, "write_at");
-  return bytes_transferred;
-}
-
-template <typename SyncRandomAccessWriteDevice, typename ConstBufferSequence>
-inline std::size_t write_at(SyncRandomAccessWriteDevice& d,
-    uint64_t offset, const ConstBufferSequence& buffers,
-    asio::error_code& ec)
-{
-  return write_at(d, offset, buffers, transfer_all(), ec);
-}
-
-template <typename SyncRandomAccessWriteDevice, typename ConstBufferSequence,
-    typename CompletionCondition>
-inline std::size_t write_at(SyncRandomAccessWriteDevice& d,
-    uint64_t offset, const ConstBufferSequence& buffers,
-    CompletionCondition completion_condition)
-{
-  asio::error_code ec;
-  std::size_t bytes_transferred = write_at(
-      d, offset, buffers, completion_condition, ec);
-  asio::detail::throw_error(ec, "write_at");
-  return bytes_transferred;
-}
-
-#if !defined(ASIO_NO_IOSTREAM)
-
-template <typename SyncRandomAccessWriteDevice, typename Allocator,
-    typename CompletionCondition>
-std::size_t write_at(SyncRandomAccessWriteDevice& d,
-    uint64_t offset, asio::basic_streambuf<Allocator>& b,
-    CompletionCondition completion_condition, asio::error_code& ec)
-{
-  std::size_t bytes_transferred = write_at(
-      d, offset, b.data(), completion_condition, ec);
-  b.consume(bytes_transferred);
-  return bytes_transferred;
-}
-
-template <typename SyncRandomAccessWriteDevice, typename Allocator>
-inline std::size_t write_at(SyncRandomAccessWriteDevice& d,
-    uint64_t offset, asio::basic_streambuf<Allocator>& b)
-{
-  asio::error_code ec;
-  std::size_t bytes_transferred = write_at(d, offset, b, transfer_all(), ec);
-  asio::detail::throw_error(ec, "write_at");
-  return bytes_transferred;
-}
-
-template <typename SyncRandomAccessWriteDevice, typename Allocator>
-inline std::size_t write_at(SyncRandomAccessWriteDevice& d,
-    uint64_t offset, asio::basic_streambuf<Allocator>& b,
-    asio::error_code& ec)
-{
-  return write_at(d, offset, b, transfer_all(), ec);
-}
-
-template <typename SyncRandomAccessWriteDevice, typename Allocator,
-    typename CompletionCondition>
-inline std::size_t write_at(SyncRandomAccessWriteDevice& d,
-    uint64_t offset, asio::basic_streambuf<Allocator>& b,
-    CompletionCondition completion_condition)
-{
-  asio::error_code ec;
-  std::size_t bytes_transferred = write_at(
-      d, offset, b, completion_condition, ec);
-  asio::detail::throw_error(ec, "write_at");
-  return bytes_transferred;
-}
-
-#endif // !defined(ASIO_NO_IOSTREAM)
-
-namespace detail
-{
-  template <typename AsyncRandomAccessWriteDevice, typename ConstBufferSequence,
-      typename CompletionCondition, typename WriteHandler>
-  class write_at_op
-    : detail::base_from_completion_cond<CompletionCondition>
-  {
-  public:
-    write_at_op(AsyncRandomAccessWriteDevice& device,
-        uint64_t offset, const ConstBufferSequence& buffers,
-        CompletionCondition completion_condition, WriteHandler& handler)
-      : detail::base_from_completion_cond<
-          CompletionCondition>(completion_condition),
-        device_(device),
-        offset_(offset),
-        buffers_(buffers),
-        start_(0),
-        total_transferred_(0),
-        handler_(ASIO_MOVE_CAST(WriteHandler)(handler))
-    {
-    }
-
-#if defined(ASIO_HAS_MOVE)
-    write_at_op(const write_at_op& other)
-      : detail::base_from_completion_cond<CompletionCondition>(other),
-        device_(other.device_),
-        offset_(other.offset_),
-        buffers_(other.buffers_),
-        start_(other.start_),
-        total_transferred_(other.total_transferred_),
-        handler_(other.handler_)
-    {
-    }
-
-    write_at_op(write_at_op&& other)
-      : detail::base_from_completion_cond<CompletionCondition>(other),
-        device_(other.device_),
-        offset_(other.offset_),
-        buffers_(other.buffers_),
-        start_(other.start_),
-        total_transferred_(other.total_transferred_),
-        handler_(ASIO_MOVE_CAST(WriteHandler)(other.handler_))
-    {
-    }
-#endif // defined(ASIO_HAS_MOVE)
-
-    void operator()(const asio::error_code& ec,
-        std::size_t bytes_transferred, int start = 0)
-    {
-      switch (start_ = start)
-      {
-        case 1:
-        buffers_.prepare(this->check_for_completion(ec, total_transferred_));
-        for (;;)
-        {
-          device_.async_write_some_at(
-              offset_ + total_transferred_, buffers_,
-              ASIO_MOVE_CAST(write_at_op)(*this));
-          return; default:
-          total_transferred_ += bytes_transferred;
-          buffers_.consume(bytes_transferred);
-          buffers_.prepare(this->check_for_completion(ec, total_transferred_));
-          if ((!ec && bytes_transferred == 0)
-              || buffers_.begin() == buffers_.end())
-            break;
-        }
-
-        handler_(ec, static_cast<const std::size_t&>(total_transferred_));
-      }
-    }
-
-  //private:
-    AsyncRandomAccessWriteDevice& device_;
-    uint64_t offset_;
-    asio::detail::consuming_buffers<
-      const_buffer, ConstBufferSequence> buffers_;
-    int start_;
-    std::size_t total_transferred_;
-    WriteHandler handler_;
-  };
-
-  template <typename AsyncRandomAccessWriteDevice,
-      typename CompletionCondition, typename WriteHandler>
-  class write_at_op<AsyncRandomAccessWriteDevice,
-      asio::mutable_buffers_1, CompletionCondition, WriteHandler>
-    : detail::base_from_completion_cond<CompletionCondition>
-  {
-  public:
-    write_at_op(AsyncRandomAccessWriteDevice& device,
-        uint64_t offset, const asio::mutable_buffers_1& buffers,
-        CompletionCondition completion_condition,
-        WriteHandler& handler)
-      : detail::base_from_completion_cond<
-          CompletionCondition>(completion_condition),
-        device_(device),
-        offset_(offset),
-        buffer_(buffers),
-        start_(0),
-        total_transferred_(0),
-        handler_(ASIO_MOVE_CAST(WriteHandler)(handler))
-    {
-    }
-
-#if defined(ASIO_HAS_MOVE)
-    write_at_op(const write_at_op& other)
-      : detail::base_from_completion_cond<CompletionCondition>(other),
-        device_(other.device_),
-        offset_(other.offset_),
-        buffer_(other.buffer_),
-        start_(other.start_),
-        total_transferred_(other.total_transferred_),
-        handler_(other.handler_)
-    {
-    }
-
-    write_at_op(write_at_op&& other)
-      : detail::base_from_completion_cond<CompletionCondition>(other),
-        device_(other.device_),
-        offset_(other.offset_),
-        buffer_(other.buffer_),
-        start_(other.start_),
-        total_transferred_(other.total_transferred_),
-        handler_(ASIO_MOVE_CAST(WriteHandler)(other.handler_))
-    {
-    }
-#endif // defined(ASIO_HAS_MOVE)
-
-    void operator()(const asio::error_code& ec,
-        std::size_t bytes_transferred, int start = 0)
-    {
-      std::size_t n = 0;
-      switch (start_ = start)
-      {
-        case 1:
-        n = this->check_for_completion(ec, total_transferred_);
-        for (;;)
-        {
-          device_.async_write_some_at(offset_ + total_transferred_,
-              asio::buffer(buffer_ + total_transferred_, n),
-              ASIO_MOVE_CAST(write_at_op)(*this));
-          return; default:
-          total_transferred_ += bytes_transferred;
-          if ((!ec && bytes_transferred == 0)
-              || (n = this->check_for_completion(ec, total_transferred_)) == 0
-              || total_transferred_ == asio::buffer_size(buffer_))
-            break;
-        }
-
-        handler_(ec, static_cast<const std::size_t&>(total_transferred_));
-      }
-    }
-
-  //private:
-    AsyncRandomAccessWriteDevice& device_;
-    uint64_t offset_;
-    asio::mutable_buffer buffer_;
-    int start_;
-    std::size_t total_transferred_;
-    WriteHandler handler_;
-  };
-
-  template <typename AsyncRandomAccessWriteDevice,
-      typename CompletionCondition, typename WriteHandler>
-  class write_at_op<AsyncRandomAccessWriteDevice, asio::const_buffers_1,
-      CompletionCondition, WriteHandler>
-    : detail::base_from_completion_cond<CompletionCondition>
-  {
-  public:
-    write_at_op(AsyncRandomAccessWriteDevice& device,
-        uint64_t offset, const asio::const_buffers_1& buffers,
-        CompletionCondition completion_condition,
-        WriteHandler& handler)
-      : detail::base_from_completion_cond<
-          CompletionCondition>(completion_condition),
-        device_(device),
-        offset_(offset),
-        buffer_(buffers),
-        start_(0),
-        total_transferred_(0),
-        handler_(ASIO_MOVE_CAST(WriteHandler)(handler))
-    {
-    }
-
-#if defined(ASIO_HAS_MOVE)
-    write_at_op(const write_at_op& other)
-      : detail::base_from_completion_cond<CompletionCondition>(other),
-        device_(other.device_),
-        offset_(other.offset_),
-        buffer_(other.buffer_),
-        start_(other.start_),
-        total_transferred_(other.total_transferred_),
-        handler_(other.handler_)
-    {
-    }
-
-    write_at_op(write_at_op&& other)
-      : detail::base_from_completion_cond<CompletionCondition>(other),
-        device_(other.device_),
-        offset_(other.offset_),
-        buffer_(other.buffer_),
-        start_(other.start_),
-        total_transferred_(other.total_transferred_),
-        handler_(ASIO_MOVE_CAST(WriteHandler)(other.handler_))
-    {
-    }
-#endif // defined(ASIO_HAS_MOVE)
-
-    void operator()(const asio::error_code& ec,
-        std::size_t bytes_transferred, int start = 0)
-    {
-      std::size_t n = 0;
-      switch (start_ = start)
-      {
-        case 1:
-        n = this->check_for_completion(ec, total_transferred_);
-        for (;;)
-        {
-          device_.async_write_some_at(offset_ + total_transferred_,
-              asio::buffer(buffer_ + total_transferred_, n),
-              ASIO_MOVE_CAST(write_at_op)(*this));
-          return; default:
-          total_transferred_ += bytes_transferred;
-          if ((!ec && bytes_transferred == 0)
-              || (n = this->check_for_completion(ec, total_transferred_)) == 0
-              || total_transferred_ == asio::buffer_size(buffer_))
-            break;
-        }
-
-        handler_(ec, static_cast<const std::size_t&>(total_transferred_));
-      }
-    }
-
-  //private:
-    AsyncRandomAccessWriteDevice& device_;
-    uint64_t offset_;
-    asio::const_buffer buffer_;
-    int start_;
-    std::size_t total_transferred_;
-    WriteHandler handler_;
-  };
-
-  template <typename AsyncRandomAccessWriteDevice, typename Elem,
-      typename CompletionCondition, typename WriteHandler>
-  class write_at_op<AsyncRandomAccessWriteDevice, boost::array<Elem, 2>,
-      CompletionCondition, WriteHandler>
-    : detail::base_from_completion_cond<CompletionCondition>
-  {
-  public:
-    write_at_op(AsyncRandomAccessWriteDevice& device,
-        uint64_t offset, const boost::array<Elem, 2>& buffers,
-        CompletionCondition completion_condition, WriteHandler& handler)
-      : detail::base_from_completion_cond<
-          CompletionCondition>(completion_condition),
-        device_(device),
-        offset_(offset),
-        buffers_(buffers),
-        start_(0),
-        total_transferred_(0),
-        handler_(ASIO_MOVE_CAST(WriteHandler)(handler))
-    {
-    }
-
-#if defined(ASIO_HAS_MOVE)
-    write_at_op(const write_at_op& other)
-      : detail::base_from_completion_cond<CompletionCondition>(other),
-        device_(other.device_),
-        offset_(other.offset_),
-        buffers_(other.buffers_),
-        start_(other.start_),
-        total_transferred_(other.total_transferred_),
-        handler_(other.handler_)
-    {
-    }
-
-    write_at_op(write_at_op&& other)
-      : detail::base_from_completion_cond<CompletionCondition>(other),
-        device_(other.device_),
-        offset_(other.offset_),
-        buffers_(other.buffers_),
-        start_(other.start_),
-        total_transferred_(other.total_transferred_),
-        handler_(ASIO_MOVE_CAST(WriteHandler)(other.handler_))
-    {
-    }
-#endif // defined(ASIO_HAS_MOVE)
-
-    void operator()(const asio::error_code& ec,
-        std::size_t bytes_transferred, int start = 0)
-    {
-      typename asio::detail::dependent_type<Elem,
-          boost::array<asio::const_buffer, 2> >::type bufs = {{
-        asio::const_buffer(buffers_[0]),
-        asio::const_buffer(buffers_[1]) }};
-      std::size_t buffer_size0 = asio::buffer_size(bufs[0]);
-      std::size_t buffer_size1 = asio::buffer_size(bufs[1]);
-      std::size_t n = 0;
-      switch (start_ = start)
-      {
-        case 1:
-        n = this->check_for_completion(ec, total_transferred_);
-        for (;;)
-        {
-          bufs[0] = asio::buffer(bufs[0] + total_transferred_, n);
-          bufs[1] = asio::buffer(
-              bufs[1] + (total_transferred_ < buffer_size0
-                ? 0 : total_transferred_ - buffer_size0),
-              n - asio::buffer_size(bufs[0]));
-          device_.async_write_some_at(offset_ + total_transferred_,
-              bufs, ASIO_MOVE_CAST(write_at_op)(*this));
-          return; default:
-          total_transferred_ += bytes_transferred;
-          if ((!ec && bytes_transferred == 0)
-              || (n = this->check_for_completion(ec, total_transferred_)) == 0
-              || total_transferred_ == buffer_size0 + buffer_size1)
-            break;
-        }
-
-        handler_(ec, static_cast<const std::size_t&>(total_transferred_));
-      }
-    }
-
-  //private:
-    AsyncRandomAccessWriteDevice& device_;
-    uint64_t offset_;
-    boost::array<Elem, 2> buffers_;
-    int start_;
-    std::size_t total_transferred_;
-    WriteHandler handler_;
-  };
-
-#if defined(ASIO_HAS_STD_ARRAY)
-
-  template <typename AsyncRandomAccessWriteDevice, typename Elem,
-      typename CompletionCondition, typename WriteHandler>
-  class write_at_op<AsyncRandomAccessWriteDevice, std::array<Elem, 2>,
-      CompletionCondition, WriteHandler>
-    : detail::base_from_completion_cond<CompletionCondition>
-  {
-  public:
-    write_at_op(AsyncRandomAccessWriteDevice& device,
-        uint64_t offset, const std::array<Elem, 2>& buffers,
-        CompletionCondition completion_condition, WriteHandler& handler)
-      : detail::base_from_completion_cond<
-          CompletionCondition>(completion_condition),
-        device_(device),
-        offset_(offset),
-        buffers_(buffers),
-        start_(0),
-        total_transferred_(0),
-        handler_(ASIO_MOVE_CAST(WriteHandler)(handler))
-    {
-    }
-
-#if defined(ASIO_HAS_MOVE)
-    write_at_op(const write_at_op& other)
-      : detail::base_from_completion_cond<CompletionCondition>(other),
-        device_(other.device_),
-        offset_(other.offset_),
-        buffers_(other.buffers_),
-        start_(other.start_),
-        total_transferred_(other.total_transferred_),
-        handler_(other.handler_)
-    {
-    }
-
-    write_at_op(write_at_op&& other)
-      : detail::base_from_completion_cond<CompletionCondition>(other),
-        device_(other.device_),
-        offset_(other.offset_),
-        buffers_(other.buffers_),
-        start_(other.start_),
-        total_transferred_(other.total_transferred_),
-        handler_(ASIO_MOVE_CAST(WriteHandler)(other.handler_))
-    {
-    }
-#endif // defined(ASIO_HAS_MOVE)
-
-    void operator()(const asio::error_code& ec,
-        std::size_t bytes_transferred, int start = 0)
-    {
-      typename asio::detail::dependent_type<Elem,
-          std::array<asio::const_buffer, 2> >::type bufs = {{
-        asio::const_buffer(buffers_[0]),
-        asio::const_buffer(buffers_[1]) }};
-      std::size_t buffer_size0 = asio::buffer_size(bufs[0]);
-      std::size_t buffer_size1 = asio::buffer_size(bufs[1]);
-      std::size_t n = 0;
-      switch (start_ = start)
-      {
-        case 1:
-        n = this->check_for_completion(ec, total_transferred_);
-        for (;;)
-        {
-          bufs[0] = asio::buffer(bufs[0] + total_transferred_, n);
-          bufs[1] = asio::buffer(
-              bufs[1] + (total_transferred_ < buffer_size0
-                ? 0 : total_transferred_ - buffer_size0),
-              n - asio::buffer_size(bufs[0]));
-          device_.async_write_some_at(offset_ + total_transferred_,
-              bufs, ASIO_MOVE_CAST(write_at_op)(*this));
-          return; default:
-          total_transferred_ += bytes_transferred;
-          if ((!ec && bytes_transferred == 0)
-              || (n = this->check_for_completion(ec, total_transferred_)) == 0
-              || total_transferred_ == buffer_size0 + buffer_size1)
-            break;
-        }
-
-        handler_(ec, static_cast<const std::size_t&>(total_transferred_));
-      }
-    }
-
-  //private:
-    AsyncRandomAccessWriteDevice& device_;
-    uint64_t offset_;
-    std::array<Elem, 2> buffers_;
-    int start_;
-    std::size_t total_transferred_;
-    WriteHandler handler_;
-  };
-
-#endif // defined(ASIO_HAS_STD_ARRAY)
-
-  template <typename AsyncRandomAccessWriteDevice, typename ConstBufferSequence,
-      typename CompletionCondition, typename WriteHandler>
-  inline void* asio_handler_allocate(std::size_t size,
-      write_at_op<AsyncRandomAccessWriteDevice, ConstBufferSequence,
-        CompletionCondition, WriteHandler>* this_handler)
-  {
-    return asio_handler_alloc_helpers::allocate(
-        size, this_handler->handler_);
-  }
-
-  template <typename AsyncRandomAccessWriteDevice, typename ConstBufferSequence,
-      typename CompletionCondition, typename WriteHandler>
-  inline void asio_handler_deallocate(void* pointer, std::size_t size,
-      write_at_op<AsyncRandomAccessWriteDevice, ConstBufferSequence,
-        CompletionCondition, WriteHandler>* this_handler)
-  {
-    asio_handler_alloc_helpers::deallocate(
-        pointer, size, this_handler->handler_);
-  }
-
-  template <typename AsyncRandomAccessWriteDevice, typename ConstBufferSequence,
-      typename CompletionCondition, typename WriteHandler>
-  inline bool asio_handler_is_continuation(
-      write_at_op<AsyncRandomAccessWriteDevice, ConstBufferSequence,
-        CompletionCondition, WriteHandler>* this_handler)
-  {
-    return this_handler->start_ == 0 ? true
-      : asio_handler_cont_helpers::is_continuation(
-          this_handler->handler_);
-  }
-
-  template <typename Function, typename AsyncRandomAccessWriteDevice,
-      typename ConstBufferSequence, typename CompletionCondition,
-      typename WriteHandler>
-  inline void asio_handler_invoke(Function& function,
-      write_at_op<AsyncRandomAccessWriteDevice, ConstBufferSequence,
-        CompletionCondition, WriteHandler>* this_handler)
-  {
-    asio_handler_invoke_helpers::invoke(
-        function, this_handler->handler_);
-  }
-
-  template <typename Function, typename AsyncRandomAccessWriteDevice,
-      typename ConstBufferSequence, typename CompletionCondition,
-      typename WriteHandler>
-  inline void asio_handler_invoke(const Function& function,
-      write_at_op<AsyncRandomAccessWriteDevice, ConstBufferSequence,
-        CompletionCondition, WriteHandler>* this_handler)
-  {
-    asio_handler_invoke_helpers::invoke(
-        function, this_handler->handler_);
-  }
-
-  template <typename AsyncRandomAccessWriteDevice, typename ConstBufferSequence,
-      typename CompletionCondition, typename WriteHandler>
-  inline write_at_op<AsyncRandomAccessWriteDevice,
-      ConstBufferSequence, CompletionCondition, WriteHandler>
-  make_write_at_op(AsyncRandomAccessWriteDevice& d,
-      uint64_t offset, const ConstBufferSequence& buffers,
-      CompletionCondition completion_condition, WriteHandler handler)
-  {
-    return write_at_op<AsyncRandomAccessWriteDevice,
-      ConstBufferSequence, CompletionCondition, WriteHandler>(
-        d, offset, buffers, completion_condition, handler);
-  }
-} // namespace detail
-
-template <typename AsyncRandomAccessWriteDevice, typename ConstBufferSequence,
-    typename CompletionCondition, typename WriteHandler>
-inline ASIO_INITFN_RESULT_TYPE(WriteHandler,
-    void (asio::error_code, std::size_t))
-async_write_at(AsyncRandomAccessWriteDevice& d,
-    uint64_t offset, const ConstBufferSequence& buffers,
-    CompletionCondition completion_condition,
-    ASIO_MOVE_ARG(WriteHandler) handler)
-{
-  // If you get an error on the following line it means that your handler does
-  // not meet the documented type requirements for a WriteHandler.
-  ASIO_WRITE_HANDLER_CHECK(WriteHandler, handler) type_check;
-
-  detail::async_result_init<
-    WriteHandler, void (asio::error_code, std::size_t)> init(
-      ASIO_MOVE_CAST(WriteHandler)(handler));
-
-  detail::write_at_op<AsyncRandomAccessWriteDevice, ConstBufferSequence,
-    CompletionCondition, ASIO_HANDLER_TYPE(
-      WriteHandler, void (asio::error_code, std::size_t))>(
-        d, offset, buffers, completion_condition, init.handler)(
-          asio::error_code(), 0, 1);
-
-  return init.result.get();
-}
-
-template <typename AsyncRandomAccessWriteDevice, typename ConstBufferSequence,
-    typename WriteHandler>
-inline ASIO_INITFN_RESULT_TYPE(WriteHandler,
-    void (asio::error_code, std::size_t))
-async_write_at(AsyncRandomAccessWriteDevice& d,
-    uint64_t offset, const ConstBufferSequence& buffers,
-    ASIO_MOVE_ARG(WriteHandler) handler)
-{
-  // If you get an error on the following line it means that your handler does
-  // not meet the documented type requirements for a WriteHandler.
-  ASIO_WRITE_HANDLER_CHECK(WriteHandler, handler) type_check;
-
-  detail::async_result_init<
-    WriteHandler, void (asio::error_code, std::size_t)> init(
-      ASIO_MOVE_CAST(WriteHandler)(handler));
-
-  detail::write_at_op<AsyncRandomAccessWriteDevice, ConstBufferSequence,
-    detail::transfer_all_t, ASIO_HANDLER_TYPE(
-      WriteHandler, void (asio::error_code, std::size_t))>(
-        d, offset, buffers, transfer_all(), init.handler)(
-          asio::error_code(), 0, 1);
-
-  return init.result.get();
-}
-
-#if !defined(ASIO_NO_IOSTREAM)
-
-namespace detail
-{
-  template <typename Allocator, typename WriteHandler>
-  class write_at_streambuf_op
-  {
-  public:
-    write_at_streambuf_op(
-        asio::basic_streambuf<Allocator>& streambuf,
-        WriteHandler& handler)
-      : streambuf_(streambuf),
-        handler_(ASIO_MOVE_CAST(WriteHandler)(handler))
-    {
-    }
-
-#if defined(ASIO_HAS_MOVE)
-    write_at_streambuf_op(const write_at_streambuf_op& other)
-      : streambuf_(other.streambuf_),
-        handler_(other.handler_)
-    {
-    }
-
-    write_at_streambuf_op(write_at_streambuf_op&& other)
-      : streambuf_(other.streambuf_),
-        handler_(ASIO_MOVE_CAST(WriteHandler)(other.handler_))
-    {
-    }
-#endif // defined(ASIO_HAS_MOVE)
-
-    void operator()(const asio::error_code& ec,
-        const std::size_t bytes_transferred)
-    {
-      streambuf_.consume(bytes_transferred);
-      handler_(ec, bytes_transferred);
-    }
-
-  //private:
-    asio::basic_streambuf<Allocator>& streambuf_;
-    WriteHandler handler_;
-  };
-
-  template <typename Allocator, typename WriteHandler>
-  inline void* asio_handler_allocate(std::size_t size,
-      write_at_streambuf_op<Allocator, WriteHandler>* this_handler)
-  {
-    return asio_handler_alloc_helpers::allocate(
-        size, this_handler->handler_);
-  }
-
-  template <typename Allocator, typename WriteHandler>
-  inline void asio_handler_deallocate(void* pointer, std::size_t size,
-      write_at_streambuf_op<Allocator, WriteHandler>* this_handler)
-  {
-    asio_handler_alloc_helpers::deallocate(
-        pointer, size, this_handler->handler_);
-  }
-
-  template <typename Allocator, typename WriteHandler>
-  inline bool asio_handler_is_continuation(
-      write_at_streambuf_op<Allocator, WriteHandler>* this_handler)
-  {
-    return asio_handler_cont_helpers::is_continuation(
-        this_handler->handler_);
-  }
-
-  template <typename Function, typename Allocator, typename WriteHandler>
-  inline void asio_handler_invoke(Function& function,
-      write_at_streambuf_op<Allocator, WriteHandler>* this_handler)
-  {
-    asio_handler_invoke_helpers::invoke(
-        function, this_handler->handler_);
-  }
-
-  template <typename Function, typename Allocator, typename WriteHandler>
-  inline void asio_handler_invoke(const Function& function,
-      write_at_streambuf_op<Allocator, WriteHandler>* this_handler)
-  {
-    asio_handler_invoke_helpers::invoke(
-        function, this_handler->handler_);
-  }
-
-  template <typename Allocator, typename WriteHandler>
-  inline write_at_streambuf_op<Allocator, WriteHandler>
-  make_write_at_streambuf_op(
-      asio::basic_streambuf<Allocator>& b, WriteHandler handler)
-  {
-    return write_at_streambuf_op<Allocator, WriteHandler>(b, handler);
-  }
-} // namespace detail
-
-template <typename AsyncRandomAccessWriteDevice, typename Allocator,
-    typename CompletionCondition, typename WriteHandler>
-inline ASIO_INITFN_RESULT_TYPE(WriteHandler,
-    void (asio::error_code, std::size_t))
-async_write_at(AsyncRandomAccessWriteDevice& d,
-    uint64_t offset, asio::basic_streambuf<Allocator>& b,
-    CompletionCondition completion_condition,
-    ASIO_MOVE_ARG(WriteHandler) handler)
-{
-  // If you get an error on the following line it means that your handler does
-  // not meet the documented type requirements for a WriteHandler.
-  ASIO_WRITE_HANDLER_CHECK(WriteHandler, handler) type_check;
-
-  detail::async_result_init<
-    WriteHandler, void (asio::error_code, std::size_t)> init(
-      ASIO_MOVE_CAST(WriteHandler)(handler));
-
-  async_write_at(d, offset, b.data(), completion_condition,
-    detail::write_at_streambuf_op<Allocator, ASIO_HANDLER_TYPE(
-      WriteHandler, void (asio::error_code, std::size_t))>(
-        b, init.handler));
-
-  return init.result.get();
-}
-
-template <typename AsyncRandomAccessWriteDevice, typename Allocator,
-    typename WriteHandler>
-inline ASIO_INITFN_RESULT_TYPE(WriteHandler,
-    void (asio::error_code, std::size_t))
-async_write_at(AsyncRandomAccessWriteDevice& d,
-    uint64_t offset, asio::basic_streambuf<Allocator>& b,
-    ASIO_MOVE_ARG(WriteHandler) handler)
-{
-  // If you get an error on the following line it means that your handler does
-  // not meet the documented type requirements for a WriteHandler.
-  ASIO_WRITE_HANDLER_CHECK(WriteHandler, handler) type_check;
-
-  detail::async_result_init<
-    WriteHandler, void (asio::error_code, std::size_t)> init(
-      ASIO_MOVE_CAST(WriteHandler)(handler));
-
-  async_write_at(d, offset, b.data(), transfer_all(),
-    detail::write_at_streambuf_op<Allocator, ASIO_HANDLER_TYPE(
-      WriteHandler, void (asio::error_code, std::size_t))>(
-        b, init.handler));
-
-  return init.result.get();
-}
-
-#endif // !defined(ASIO_NO_IOSTREAM)
-
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_IMPL_WRITE_AT_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/io_service.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/io_service.hpp
deleted file mode 100644
index 28f24340ae6c..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/io_service.hpp
+++ /dev/null
@@ -1,770 +0,0 @@
-//
-// io_service.hpp
-// ~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_IO_SERVICE_HPP
-#define ASIO_IO_SERVICE_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include <cstddef>
-#include <stdexcept>
-#include <typeinfo>
-#include "asio/async_result.hpp"
-#include "asio/detail/noncopyable.hpp"
-#include "asio/detail/wrapped_handler.hpp"
-#include "asio/error_code.hpp"
-
-#if defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-# include "asio/detail/winsock_init.hpp"
-#elif defined(__sun) || defined(__QNX__) || defined(__hpux) || defined(_AIX) \
-  || defined(__osf__)
-# include "asio/detail/signal_init.hpp"
-#endif
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-
-class io_service;
-template <typename Service> Service& use_service(io_service& ios);
-template <typename Service> void add_service(io_service& ios, Service* svc);
-template <typename Service> bool has_service(io_service& ios);
-
-namespace detail {
-#if defined(ASIO_HAS_IOCP)
-  typedef class win_iocp_io_service io_service_impl;
-  class win_iocp_overlapped_ptr;
-#else
-  typedef class task_io_service io_service_impl;
-#endif
-  class service_registry;
-} // namespace detail
-
-/// Provides core I/O functionality.
-/**
- * The io_service class provides the core I/O functionality for users of the
- * asynchronous I/O objects, including:
- *
- * @li asio::ip::tcp::socket
- * @li asio::ip::tcp::acceptor
- * @li asio::ip::udp::socket
- * @li asio::deadline_timer.
- *
- * The io_service class also includes facilities intended for developers of
- * custom asynchronous services.
- *
- * @par Thread Safety
- * @e Distinct @e objects: Safe.@n
- * @e Shared @e objects: Safe, with the specific exceptions of the reset() and
- * notify_fork() functions. Calling reset() while there are unfinished run(),
- * run_one(), poll() or poll_one() calls results in undefined behaviour. The
- * notify_fork() function should not be called while any io_service function,
- * or any function on an I/O object that is associated with the io_service, is
- * being called in another thread.
- *
- * @par Concepts:
- * Dispatcher.
- *
- * @par Synchronous and asynchronous operations
- *
- * Synchronous operations on I/O objects implicitly run the io_service object
- * for an individual operation. The io_service functions run(), run_one(),
- * poll() or poll_one() must be called for the io_service to perform
- * asynchronous operations on behalf of a C++ program. Notification that an
- * asynchronous operation has completed is delivered by invocation of the
- * associated handler. Handlers are invoked only by a thread that is currently
- * calling any overload of run(), run_one(), poll() or poll_one() for the
- * io_service.
- *
- * @par Effect of exceptions thrown from handlers
- *
- * If an exception is thrown from a handler, the exception is allowed to
- * propagate through the throwing thread's invocation of run(), run_one(),
- * poll() or poll_one(). No other threads that are calling any of these
- * functions are affected. It is then the responsibility of the application to
- * catch the exception.
- *
- * After the exception has been caught, the run(), run_one(), poll() or
- * poll_one() call may be restarted @em without the need for an intervening
- * call to reset(). This allows the thread to rejoin the io_service object's
- * thread pool without impacting any other threads in the pool.
- *
- * For example:
- *
- * @code
- * asio::io_service io_service;
- * ...
- * for (;;)
- * {
- *   try
- *   {
- *     io_service.run();
- *     break; // run() exited normally
- *   }
- *   catch (my_exception& e)
- *   {
- *     // Deal with exception as appropriate.
- *   }
- * }
- * @endcode
- *
- * @par Stopping the io_service from running out of work
- *
- * Some applications may need to prevent an io_service object's run() call from
- * returning when there is no more work to do. For example, the io_service may
- * be being run in a background thread that is launched prior to the
- * application's asynchronous operations. The run() call may be kept running by
- * creating an object of type asio::io_service::work:
- *
- * @code asio::io_service io_service;
- * asio::io_service::work work(io_service);
- * ... @endcode
- *
- * To effect a shutdown, the application will then need to call the io_service
- * object's stop() member function. This will cause the io_service run() call
- * to return as soon as possible, abandoning unfinished operations and without
- * permitting ready handlers to be dispatched.
- *
- * Alternatively, if the application requires that all operations and handlers
- * be allowed to finish normally, the work object may be explicitly destroyed.
- *
- * @code asio::io_service io_service;
- * auto_ptr<asio::io_service::work> work(
- *     new asio::io_service::work(io_service));
- * ...
- * work.reset(); // Allow run() to exit. @endcode
- *
- * @par The io_service class and I/O services
- *
- * Class io_service implements an extensible, type-safe, polymorphic set of I/O
- * services, indexed by service type. An object of class io_service must be
- * initialised before I/O objects such as sockets, resolvers and timers can be
- * used. These I/O objects are distinguished by having constructors that accept
- * an @c io_service& parameter.
- *
- * I/O services exist to manage the logical interface to the operating system on
- * behalf of the I/O objects. In particular, there are resources that are shared
- * across a class of I/O objects. For example, timers may be implemented in
- * terms of a single timer queue. The I/O services manage these shared
- * resources.
- *
- * Access to the services of an io_service is via three function templates,
- * use_service(), add_service() and has_service().
- *
- * In a call to @c use_service<Service>(), the type argument chooses a service,
- * making available all members of the named type. If @c Service is not present
- * in an io_service, an object of type @c Service is created and added to the
- * io_service. A C++ program can check if an io_service implements a
- * particular service with the function template @c has_service<Service>().
- *
- * Service objects may be explicitly added to an io_service using the function
- * template @c add_service<Service>(). If the @c Service is already present, the
- * service_already_exists exception is thrown. If the owner of the service is
- * not the same object as the io_service parameter, the invalid_service_owner
- * exception is thrown.
- *
- * Once a service reference is obtained from an io_service object by calling
- * use_service(), that reference remains usable as long as the owning io_service
- * object exists.
- *
- * All I/O service implementations have io_service::service as a public base
- * class. Custom I/O services may be implemented by deriving from this class and
- * then added to an io_service using the facilities described above.
- */
-class io_service
-  : private noncopyable
-{
-private:
-  typedef detail::io_service_impl impl_type;
-#if defined(ASIO_HAS_IOCP)
-  friend class detail::win_iocp_overlapped_ptr;
-#endif
-
-public:
-  class work;
-  friend class work;
-
-  class id;
-
-  class service;
-
-  class strand;
-
-  /// Constructor.
-  ASIO_DECL io_service();
-
-  /// Constructor.
-  /**
-   * Construct with a hint about the required level of concurrency.
-   *
-   * @param concurrency_hint A suggestion to the implementation on how many
-   * threads it should allow to run simultaneously.
-   */
-  ASIO_DECL explicit io_service(std::size_t concurrency_hint);
-
-  /// Destructor.
-  /**
-   * On destruction, the io_service performs the following sequence of
-   * operations:
-   *
-   * @li For each service object @c svc in the io_service set, in reverse order
-   * of the beginning of service object lifetime, performs
-   * @c svc->shutdown_service().
-   *
-   * @li Uninvoked handler objects that were scheduled for deferred invocation
-   * on the io_service, or any associated strand, are destroyed.
-   *
-   * @li For each service object @c svc in the io_service set, in reverse order
-   * of the beginning of service object lifetime, performs
-   * <tt>delete static_cast<io_service::service*>(svc)</tt>.
-   *
-   * @note The destruction sequence described above permits programs to
-   * simplify their resource management by using @c shared_ptr<>. Where an
-   * object's lifetime is tied to the lifetime of a connection (or some other
-   * sequence of asynchronous operations), a @c shared_ptr to the object would
-   * be bound into the handlers for all asynchronous operations associated with
-   * it. This works as follows:
-   *
-   * @li When a single connection ends, all associated asynchronous operations
-   * complete. The corresponding handler objects are destroyed, and all
-   * @c shared_ptr references to the objects are destroyed.
-   *
-   * @li To shut down the whole program, the io_service function stop() is
-   * called to terminate any run() calls as soon as possible. The io_service
-   * destructor defined above destroys all handlers, causing all @c shared_ptr
-   * references to all connection objects to be destroyed.
-   */
-  ASIO_DECL ~io_service();
-
-  /// Run the io_service object's event processing loop.
-  /**
-   * The run() function blocks until all work has finished and there are no
-   * more handlers to be dispatched, or until the io_service has been stopped.
-   *
-   * Multiple threads may call the run() function to set up a pool of threads
-   * from which the io_service may execute handlers. All threads that are
-   * waiting in the pool are equivalent and the io_service may choose any one
-   * of them to invoke a handler.
-   *
-   * A normal exit from the run() function implies that the io_service object
-   * is stopped (the stopped() function returns @c true). Subsequent calls to
-   * run(), run_one(), poll() or poll_one() will return immediately unless there
-   * is a prior call to reset().
-   *
-   * @return The number of handlers that were executed.
-   *
-   * @throws asio::system_error Thrown on failure.
-   *
-   * @note The run() function must not be called from a thread that is currently
-   * calling one of run(), run_one(), poll() or poll_one() on the same
-   * io_service object.
-   *
-   * The poll() function may also be used to dispatch ready handlers, but
-   * without blocking.
-   */
-  ASIO_DECL std::size_t run();
-
-  /// Run the io_service object's event processing loop.
-  /**
-   * The run() function blocks until all work has finished and there are no
-   * more handlers to be dispatched, or until the io_service has been stopped.
-   *
-   * Multiple threads may call the run() function to set up a pool of threads
-   * from which the io_service may execute handlers. All threads that are
-   * waiting in the pool are equivalent and the io_service may choose any one
-   * of them to invoke a handler.
-   *
-   * A normal exit from the run() function implies that the io_service object
-   * is stopped (the stopped() function returns @c true). Subsequent calls to
-   * run(), run_one(), poll() or poll_one() will return immediately unless there
-   * is a prior call to reset().
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   *
-   * @return The number of handlers that were executed.
-   *
-   * @note The run() function must not be called from a thread that is currently
-   * calling one of run(), run_one(), poll() or poll_one() on the same
-   * io_service object.
-   *
-   * The poll() function may also be used to dispatch ready handlers, but
-   * without blocking.
-   */
-  ASIO_DECL std::size_t run(asio::error_code& ec);
-
-  /// Run the io_service object's event processing loop to execute at most one
-  /// handler.
-  /**
-   * The run_one() function blocks until one handler has been dispatched, or
-   * until the io_service has been stopped.
-   *
-   * @return The number of handlers that were executed. A zero return value
-   * implies that the io_service object is stopped (the stopped() function
-   * returns @c true). Subsequent calls to run(), run_one(), poll() or
-   * poll_one() will return immediately unless there is a prior call to
-   * reset().
-   *
-   * @throws asio::system_error Thrown on failure.
-   */
-  ASIO_DECL std::size_t run_one();
-
-  /// Run the io_service object's event processing loop to execute at most one
-  /// handler.
-  /**
-   * The run_one() function blocks until one handler has been dispatched, or
-   * until the io_service has been stopped.
-   *
-   * @return The number of handlers that were executed. A zero return value
-   * implies that the io_service object is stopped (the stopped() function
-   * returns @c true). Subsequent calls to run(), run_one(), poll() or
-   * poll_one() will return immediately unless there is a prior call to
-   * reset().
-   *
-   * @return The number of handlers that were executed.
-   */
-  ASIO_DECL std::size_t run_one(asio::error_code& ec);
-
-  /// Run the io_service object's event processing loop to execute ready
-  /// handlers.
-  /**
-   * The poll() function runs handlers that are ready to run, without blocking,
-   * until the io_service has been stopped or there are no more ready handlers.
-   *
-   * @return The number of handlers that were executed.
-   *
-   * @throws asio::system_error Thrown on failure.
-   */
-  ASIO_DECL std::size_t poll();
-
-  /// Run the io_service object's event processing loop to execute ready
-  /// handlers.
-  /**
-   * The poll() function runs handlers that are ready to run, without blocking,
-   * until the io_service has been stopped or there are no more ready handlers.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   *
-   * @return The number of handlers that were executed.
-   */
-  ASIO_DECL std::size_t poll(asio::error_code& ec);
-
-  /// Run the io_service object's event processing loop to execute one ready
-  /// handler.
-  /**
-   * The poll_one() function runs at most one handler that is ready to run,
-   * without blocking.
-   *
-   * @return The number of handlers that were executed.
-   *
-   * @throws asio::system_error Thrown on failure.
-   */
-  ASIO_DECL std::size_t poll_one();
-
-  /// Run the io_service object's event processing loop to execute one ready
-  /// handler.
-  /**
-   * The poll_one() function runs at most one handler that is ready to run,
-   * without blocking.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   *
-   * @return The number of handlers that were executed.
-   */
-  ASIO_DECL std::size_t poll_one(asio::error_code& ec);
-
-  /// Stop the io_service object's event processing loop.
-  /**
-   * This function does not block, but instead simply signals the io_service to
-   * stop. All invocations of its run() or run_one() member functions should
-   * return as soon as possible. Subsequent calls to run(), run_one(), poll()
-   * or poll_one() will return immediately until reset() is called.
-   */
-  ASIO_DECL void stop();
-
-  /// Determine whether the io_service object has been stopped.
-  /**
-   * This function is used to determine whether an io_service object has been
-   * stopped, either through an explicit call to stop(), or due to running out
-   * of work. When an io_service object is stopped, calls to run(), run_one(),
-   * poll() or poll_one() will return immediately without invoking any
-   * handlers.
-   *
-   * @return @c true if the io_service object is stopped, otherwise @c false.
-   */
-  ASIO_DECL bool stopped() const;
-
-  /// Reset the io_service in preparation for a subsequent run() invocation.
-  /**
-   * This function must be called prior to any second or later set of
-   * invocations of the run(), run_one(), poll() or poll_one() functions when a
-   * previous invocation of these functions returned due to the io_service
-   * being stopped or running out of work. After a call to reset(), the
-   * io_service object's stopped() function will return @c false.
-   *
-   * This function must not be called while there are any unfinished calls to
-   * the run(), run_one(), poll() or poll_one() functions.
-   */
-  ASIO_DECL void reset();
-
-  /// Request the io_service to invoke the given handler.
-  /**
-   * This function is used to ask the io_service to execute the given handler.
-   *
-   * The io_service guarantees that the handler will only be called in a thread
-   * in which the run(), run_one(), poll() or poll_one() member functions is
-   * currently being invoked. The handler may be executed inside this function
-   * if the guarantee can be met.
-   *
-   * @param handler The handler to be called. The io_service will make
-   * a copy of the handler object as required. The function signature of the
-   * handler must be: @code void handler(); @endcode
-   *
-   * @note This function throws an exception only if:
-   *
-   * @li the handler's @c asio_handler_allocate function; or
-   *
-   * @li the handler's copy constructor
-   *
-   * throws an exception.
-   */
-  template <typename CompletionHandler>
-  ASIO_INITFN_RESULT_TYPE(CompletionHandler, void ())
-  dispatch(ASIO_MOVE_ARG(CompletionHandler) handler);
-
-  /// Request the io_service to invoke the given handler and return immediately.
-  /**
-   * This function is used to ask the io_service to execute the given handler,
-   * but without allowing the io_service to call the handler from inside this
-   * function.
-   *
-   * The io_service guarantees that the handler will only be called in a thread
-   * in which the run(), run_one(), poll() or poll_one() member functions is
-   * currently being invoked.
-   *
-   * @param handler The handler to be called. The io_service will make
-   * a copy of the handler object as required. The function signature of the
-   * handler must be: @code void handler(); @endcode
-   *
-   * @note This function throws an exception only if:
-   *
-   * @li the handler's @c asio_handler_allocate function; or
-   *
-   * @li the handler's copy constructor
-   *
-   * throws an exception.
-   */
-  template <typename CompletionHandler>
-  ASIO_INITFN_RESULT_TYPE(CompletionHandler, void ())
-  post(ASIO_MOVE_ARG(CompletionHandler) handler);
-
-  /// Create a new handler that automatically dispatches the wrapped handler
-  /// on the io_service.
-  /**
-   * This function is used to create a new handler function object that, when
-   * invoked, will automatically pass the wrapped handler to the io_service
-   * object's dispatch function.
-   *
-   * @param handler The handler to be wrapped. The io_service will make a copy
-   * of the handler object as required. The function signature of the handler
-   * must be: @code void handler(A1 a1, ... An an); @endcode
-   *
-   * @return A function object that, when invoked, passes the wrapped handler to
-   * the io_service object's dispatch function. Given a function object with the
-   * signature:
-   * @code R f(A1 a1, ... An an); @endcode
-   * If this function object is passed to the wrap function like so:
-   * @code io_service.wrap(f); @endcode
-   * then the return value is a function object with the signature
-   * @code void g(A1 a1, ... An an); @endcode
-   * that, when invoked, executes code equivalent to:
-   * @code io_service.dispatch(boost::bind(f, a1, ... an)); @endcode
-   */
-  template <typename Handler>
-#if defined(GENERATING_DOCUMENTATION)
-  unspecified
-#else
-  detail::wrapped_handler<io_service&, Handler>
-#endif
-  wrap(Handler handler);
-
-  /// Fork-related event notifications.
-  enum fork_event
-  {
-    /// Notify the io_service that the process is about to fork.
-    fork_prepare,
-
-    /// Notify the io_service that the process has forked and is the parent.
-    fork_parent,
-
-    /// Notify the io_service that the process has forked and is the child.
-    fork_child
-  };
-
-  /// Notify the io_service of a fork-related event.
-  /**
-   * This function is used to inform the io_service that the process is about
-   * to fork, or has just forked. This allows the io_service, and the services
-   * it contains, to perform any necessary housekeeping to ensure correct
-   * operation following a fork.
-   *
-   * This function must not be called while any other io_service function, or
-   * any function on an I/O object associated with the io_service, is being
-   * called in another thread. It is, however, safe to call this function from
-   * within a completion handler, provided no other thread is accessing the
-   * io_service.
-   *
-   * @param event A fork-related event.
-   *
-   * @throws asio::system_error Thrown on failure. If the notification
-   * fails the io_service object should no longer be used and should be
-   * destroyed.
-   *
-   * @par Example
-   * The following code illustrates how to incorporate the notify_fork()
-   * function:
-   * @code my_io_service.notify_fork(asio::io_service::fork_prepare);
-   * if (fork() == 0)
-   * {
-   *   // This is the child process.
-   *   my_io_service.notify_fork(asio::io_service::fork_child);
-   * }
-   * else
-   * {
-   *   // This is the parent process.
-   *   my_io_service.notify_fork(asio::io_service::fork_parent);
-   * } @endcode
-   *
-   * @note For each service object @c svc in the io_service set, performs
-   * <tt>svc->fork_service();</tt>. When processing the fork_prepare event,
-   * services are visited in reverse order of the beginning of service object
-   * lifetime. Otherwise, services are visited in order of the beginning of
-   * service object lifetime.
-   */
-  ASIO_DECL void notify_fork(asio::io_service::fork_event event);
-
-  /// Obtain the service object corresponding to the given type.
-  /**
-   * This function is used to locate a service object that corresponds to
-   * the given service type. If there is no existing implementation of the
-   * service, then the io_service will create a new instance of the service.
-   *
-   * @param ios The io_service object that owns the service.
-   *
-   * @return The service interface implementing the specified service type.
-   * Ownership of the service interface is not transferred to the caller.
-   */
-  template <typename Service>
-  friend Service& use_service(io_service& ios);
-
-  /// Add a service object to the io_service.
-  /**
-   * This function is used to add a service to the io_service.
-   *
-   * @param ios The io_service object that owns the service.
-   *
-   * @param svc The service object. On success, ownership of the service object
-   * is transferred to the io_service. When the io_service object is destroyed,
-   * it will destroy the service object by performing:
-   * @code delete static_cast<io_service::service*>(svc) @endcode
-   *
-   * @throws asio::service_already_exists Thrown if a service of the
-   * given type is already present in the io_service.
-   *
-   * @throws asio::invalid_service_owner Thrown if the service's owning
-   * io_service is not the io_service object specified by the ios parameter.
-   */
-  template <typename Service>
-  friend void add_service(io_service& ios, Service* svc);
-
-  /// Determine if an io_service contains a specified service type.
-  /**
-   * This function is used to determine whether the io_service contains a
-   * service object corresponding to the given service type.
-   *
-   * @param ios The io_service object that owns the service.
-   *
-   * @return A boolean indicating whether the io_service contains the service.
-   */
-  template <typename Service>
-  friend bool has_service(io_service& ios);
-
-private:
-#if defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-  detail::winsock_init<> init_;
-#elif defined(__sun) || defined(__QNX__) || defined(__hpux) || defined(_AIX) \
-  || defined(__osf__)
-  detail::signal_init<> init_;
-#endif
-
-  // The service registry.
-  asio::detail::service_registry* service_registry_;
-
-  // The implementation.
-  impl_type& impl_;
-};
-
-/// Class to inform the io_service when it has work to do.
-/**
- * The work class is used to inform the io_service when work starts and
- * finishes. This ensures that the io_service object's run() function will not
- * exit while work is underway, and that it does exit when there is no
- * unfinished work remaining.
- *
- * The work class is copy-constructible so that it may be used as a data member
- * in a handler class. It is not assignable.
- */
-class io_service::work
-{
-public:
-  /// Constructor notifies the io_service that work is starting.
-  /**
-   * The constructor is used to inform the io_service that some work has begun.
-   * This ensures that the io_service object's run() function will not exit
-   * while the work is underway.
-   */
-  explicit work(asio::io_service& io_service);
-
-  /// Copy constructor notifies the io_service that work is starting.
-  /**
-   * The constructor is used to inform the io_service that some work has begun.
-   * This ensures that the io_service object's run() function will not exit
-   * while the work is underway.
-   */
-  work(const work& other);
-
-  /// Destructor notifies the io_service that the work is complete.
-  /**
-   * The destructor is used to inform the io_service that some work has
-   * finished. Once the count of unfinished work reaches zero, the io_service
-   * object's run() function is permitted to exit.
-   */
-  ~work();
-
-  /// Get the io_service associated with the work.
-  asio::io_service& get_io_service();
-
-private:
-  // Prevent assignment.
-  void operator=(const work& other);
-
-  // The io_service implementation.
-  detail::io_service_impl& io_service_impl_;
-};
-
-/// Class used to uniquely identify a service.
-class io_service::id
-  : private noncopyable
-{
-public:
-  /// Constructor.
-  id() {}
-};
-
-/// Base class for all io_service services.
-class io_service::service
-  : private noncopyable
-{
-public:
-  /// Get the io_service object that owns the service.
-  asio::io_service& get_io_service();
-
-protected:
-  /// Constructor.
-  /**
-   * @param owner The io_service object that owns the service.
-   */
-  ASIO_DECL service(asio::io_service& owner);
-
-  /// Destructor.
-  ASIO_DECL virtual ~service();
-
-private:
-  /// Destroy all user-defined handler objects owned by the service.
-  virtual void shutdown_service() = 0;
-
-  /// Handle notification of a fork-related event to perform any necessary
-  /// housekeeping.
-  /**
-   * This function is not a pure virtual so that services only have to
-   * implement it if necessary. The default implementation does nothing.
-   */
-  ASIO_DECL virtual void fork_service(
-      asio::io_service::fork_event event);
-
-  friend class asio::detail::service_registry;
-  struct key
-  {
-    key() : type_info_(0), id_(0) {}
-    const std::type_info* type_info_;
-    const asio::io_service::id* id_;
-  } key_;
-
-  asio::io_service& owner_;
-  service* next_;
-};
-
-/// Exception thrown when trying to add a duplicate service to an io_service.
-class service_already_exists
-  : public std::logic_error
-{
-public:
-  ASIO_DECL service_already_exists();
-};
-
-/// Exception thrown when trying to add a service object to an io_service where
-/// the service has a different owner.
-class invalid_service_owner
-  : public std::logic_error
-{
-public:
-  ASIO_DECL invalid_service_owner();
-};
-
-namespace detail {
-
-// Special derived service id type to keep classes header-file only.
-template <typename Type>
-class service_id
-  : public asio::io_service::id
-{
-};
-
-// Special service base class to keep classes header-file only.
-template <typename Type>
-class service_base
-  : public asio::io_service::service
-{
-public:
-  static asio::detail::service_id<Type> id;
-
-  // Constructor.
-  service_base(asio::io_service& io_service)
-    : asio::io_service::service(io_service)
-  {
-  }
-};
-
-template <typename Type>
-asio::detail::service_id<Type> service_base<Type>::id;
-
-} // namespace detail
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#include "asio/impl/io_service.hpp"
-#if defined(ASIO_HEADER_ONLY)
-# include "asio/impl/io_service.ipp"
-#endif // defined(ASIO_HEADER_ONLY)
-
-#endif // ASIO_IO_SERVICE_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ip/address.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ip/address.hpp
deleted file mode 100644
index 952a9543cd39..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ip/address.hpp
+++ /dev/null
@@ -1,200 +0,0 @@
-//
-// ip/address.hpp
-// ~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_IP_ADDRESS_HPP
-#define ASIO_IP_ADDRESS_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include <string>
-#include "asio/error_code.hpp"
-#include "asio/ip/address_v4.hpp"
-#include "asio/ip/address_v6.hpp"
-
-#if !defined(ASIO_NO_IOSTREAM)
-# include <iosfwd>
-#endif // !defined(ASIO_NO_IOSTREAM)
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace ip {
-
-/// Implements version-independent IP addresses.
-/**
- * The asio::ip::address class provides the ability to use either IP
- * version 4 or version 6 addresses.
- *
- * @par Thread Safety
- * @e Distinct @e objects: Safe.@n
- * @e Shared @e objects: Unsafe.
- */
-class address
-{
-public:
-  /// Default constructor.
-  ASIO_DECL address();
-
-  /// Construct an address from an IPv4 address.
-  ASIO_DECL address(const asio::ip::address_v4& ipv4_address);
-
-  /// Construct an address from an IPv6 address.
-  ASIO_DECL address(const asio::ip::address_v6& ipv6_address);
-
-  /// Copy constructor.
-  ASIO_DECL address(const address& other);
-
-#if defined(ASIO_HAS_MOVE)
-  /// Move constructor.
-  ASIO_DECL address(address&& other);
-#endif // defined(ASIO_HAS_MOVE)
-
-  /// Assign from another address.
-  ASIO_DECL address& operator=(const address& other);
-
-#if defined(ASIO_HAS_MOVE)
-  /// Move-assign from another address.
-  ASIO_DECL address& operator=(address&& other);
-#endif // defined(ASIO_HAS_MOVE)
-
-  /// Assign from an IPv4 address.
-  ASIO_DECL address& operator=(
-      const asio::ip::address_v4& ipv4_address);
-
-  /// Assign from an IPv6 address.
-  ASIO_DECL address& operator=(
-      const asio::ip::address_v6& ipv6_address);
-
-  /// Get whether the address is an IP version 4 address.
-  bool is_v4() const
-  {
-    return type_ == ipv4;
-  }
-
-  /// Get whether the address is an IP version 6 address.
-  bool is_v6() const
-  {
-    return type_ == ipv6;
-  }
-
-  /// Get the address as an IP version 4 address.
-  ASIO_DECL asio::ip::address_v4 to_v4() const;
-
-  /// Get the address as an IP version 6 address.
-  ASIO_DECL asio::ip::address_v6 to_v6() const;
-
-  /// Get the address as a string in dotted decimal format.
-  ASIO_DECL std::string to_string() const;
-
-  /// Get the address as a string in dotted decimal format.
-  ASIO_DECL std::string to_string(asio::error_code& ec) const;
-
-  /// Create an address from an IPv4 address string in dotted decimal form,
-  /// or from an IPv6 address in hexadecimal notation.
-  ASIO_DECL static address from_string(const char* str);
-
-  /// Create an address from an IPv4 address string in dotted decimal form,
-  /// or from an IPv6 address in hexadecimal notation.
-  ASIO_DECL static address from_string(
-      const char* str, asio::error_code& ec);
-
-  /// Create an address from an IPv4 address string in dotted decimal form,
-  /// or from an IPv6 address in hexadecimal notation.
-  ASIO_DECL static address from_string(const std::string& str);
-
-  /// Create an address from an IPv4 address string in dotted decimal form,
-  /// or from an IPv6 address in hexadecimal notation.
-  ASIO_DECL static address from_string(
-      const std::string& str, asio::error_code& ec);
-
-  /// Determine whether the address is a loopback address.
-  ASIO_DECL bool is_loopback() const;
-
-  /// Determine whether the address is unspecified.
-  ASIO_DECL bool is_unspecified() const;
-
-  /// Determine whether the address is a multicast address.
-  ASIO_DECL bool is_multicast() const;
-
-  /// Compare two addresses for equality.
-  ASIO_DECL friend bool operator==(const address& a1, const address& a2);
-
-  /// Compare two addresses for inequality.
-  friend bool operator!=(const address& a1, const address& a2)
-  {
-    return !(a1 == a2);
-  }
-
-  /// Compare addresses for ordering.
-  ASIO_DECL friend bool operator<(const address& a1, const address& a2);
-
-  /// Compare addresses for ordering.
-  friend bool operator>(const address& a1, const address& a2)
-  {
-    return a2 < a1;
-  }
-
-  /// Compare addresses for ordering.
-  friend bool operator<=(const address& a1, const address& a2)
-  {
-    return !(a2 < a1);
-  }
-
-  /// Compare addresses for ordering.
-  friend bool operator>=(const address& a1, const address& a2)
-  {
-    return !(a1 < a2);
-  }
-
-private:
-  // The type of the address.
-  enum { ipv4, ipv6 } type_;
-
-  // The underlying IPv4 address.
-  asio::ip::address_v4 ipv4_address_;
-
-  // The underlying IPv6 address.
-  asio::ip::address_v6 ipv6_address_;
-};
-
-#if !defined(ASIO_NO_IOSTREAM)
-
-/// Output an address as a string.
-/**
- * Used to output a human-readable string for a specified address.
- *
- * @param os The output stream to which the string will be written.
- *
- * @param addr The address to be written.
- *
- * @return The output stream.
- *
- * @relates asio::ip::address
- */
-template <typename Elem, typename Traits>
-std::basic_ostream<Elem, Traits>& operator<<(
-    std::basic_ostream<Elem, Traits>& os, const address& addr);
-
-#endif // !defined(ASIO_NO_IOSTREAM)
-
-} // namespace ip
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#include "asio/ip/impl/address.hpp"
-#if defined(ASIO_HEADER_ONLY)
-# include "asio/ip/impl/address.ipp"
-#endif // defined(ASIO_HEADER_ONLY)
-
-#endif // ASIO_IP_ADDRESS_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ip/address_v4.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ip/address_v4.hpp
deleted file mode 100644
index d6c81aff8dae..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ip/address_v4.hpp
+++ /dev/null
@@ -1,241 +0,0 @@
-//
-// ip/address_v4.hpp
-// ~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_IP_ADDRESS_V4_HPP
-#define ASIO_IP_ADDRESS_V4_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include <string>
-#include "asio/detail/array.hpp"
-#include "asio/detail/socket_types.hpp"
-#include "asio/detail/winsock_init.hpp"
-#include "asio/error_code.hpp"
-
-#if !defined(ASIO_NO_IOSTREAM)
-# include <iosfwd>
-#endif // !defined(ASIO_NO_IOSTREAM)
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace ip {
-
-/// Implements IP version 4 style addresses.
-/**
- * The asio::ip::address_v4 class provides the ability to use and
- * manipulate IP version 4 addresses.
- *
- * @par Thread Safety
- * @e Distinct @e objects: Safe.@n
- * @e Shared @e objects: Unsafe.
- */
-class address_v4
-{
-public:
-  /// The type used to represent an address as an array of bytes.
-  /**
-   * @note This type is defined in terms of the C++0x template @c std::array
-   * when it is available. Otherwise, it uses @c boost:array.
-   */
-#if defined(GENERATING_DOCUMENTATION)
-  typedef array<unsigned char, 4> bytes_type;
-#else
-  typedef asio::detail::array<unsigned char, 4> bytes_type;
-#endif
-
-  /// Default constructor.
-  address_v4()
-  {
-    addr_.s_addr = 0;
-  }
-
-  /// Construct an address from raw bytes.
-  ASIO_DECL explicit address_v4(const bytes_type& bytes);
-
-  /// Construct an address from a unsigned long in host byte order.
-  ASIO_DECL explicit address_v4(unsigned long addr);
-
-  /// Copy constructor.
-  address_v4(const address_v4& other)
-    : addr_(other.addr_)
-  {
-  }
-
-#if defined(ASIO_HAS_MOVE)
-  /// Move constructor.
-  address_v4(address_v4&& other)
-    : addr_(other.addr_)
-  {
-  }
-#endif // defined(ASIO_HAS_MOVE)
-
-  /// Assign from another address.
-  address_v4& operator=(const address_v4& other)
-  {
-    addr_ = other.addr_;
-    return *this;
-  }
-
-#if defined(ASIO_HAS_MOVE)
-  /// Move-assign from another address.
-  address_v4& operator=(address_v4&& other)
-  {
-    addr_ = other.addr_;
-    return *this;
-  }
-#endif // defined(ASIO_HAS_MOVE)
-
-  /// Get the address in bytes, in network byte order.
-  ASIO_DECL bytes_type to_bytes() const;
-
-  /// Get the address as an unsigned long in host byte order
-  ASIO_DECL unsigned long to_ulong() const;
-
-  /// Get the address as a string in dotted decimal format.
-  ASIO_DECL std::string to_string() const;
-
-  /// Get the address as a string in dotted decimal format.
-  ASIO_DECL std::string to_string(asio::error_code& ec) const;
-
-  /// Create an address from an IP address string in dotted decimal form.
-  ASIO_DECL static address_v4 from_string(const char* str);
-
-  /// Create an address from an IP address string in dotted decimal form.
-  ASIO_DECL static address_v4 from_string(
-      const char* str, asio::error_code& ec);
-
-  /// Create an address from an IP address string in dotted decimal form.
-  ASIO_DECL static address_v4 from_string(const std::string& str);
-
-  /// Create an address from an IP address string in dotted decimal form.
-  ASIO_DECL static address_v4 from_string(
-      const std::string& str, asio::error_code& ec);
-
-  /// Determine whether the address is a loopback address.
-  ASIO_DECL bool is_loopback() const;
-
-  /// Determine whether the address is unspecified.
-  ASIO_DECL bool is_unspecified() const;
-
-  /// Determine whether the address is a class A address.
-  ASIO_DECL bool is_class_a() const;
-
-  /// Determine whether the address is a class B address.
-  ASIO_DECL bool is_class_b() const;
-
-  /// Determine whether the address is a class C address.
-  ASIO_DECL bool is_class_c() const;
-
-  /// Determine whether the address is a multicast address.
-  ASIO_DECL bool is_multicast() const;
-
-  /// Compare two addresses for equality.
-  friend bool operator==(const address_v4& a1, const address_v4& a2)
-  {
-    return a1.addr_.s_addr == a2.addr_.s_addr;
-  }
-
-  /// Compare two addresses for inequality.
-  friend bool operator!=(const address_v4& a1, const address_v4& a2)
-  {
-    return a1.addr_.s_addr != a2.addr_.s_addr;
-  }
-
-  /// Compare addresses for ordering.
-  friend bool operator<(const address_v4& a1, const address_v4& a2)
-  {
-    return a1.to_ulong() < a2.to_ulong();
-  }
-
-  /// Compare addresses for ordering.
-  friend bool operator>(const address_v4& a1, const address_v4& a2)
-  {
-    return a1.to_ulong() > a2.to_ulong();
-  }
-
-  /// Compare addresses for ordering.
-  friend bool operator<=(const address_v4& a1, const address_v4& a2)
-  {
-    return a1.to_ulong() <= a2.to_ulong();
-  }
-
-  /// Compare addresses for ordering.
-  friend bool operator>=(const address_v4& a1, const address_v4& a2)
-  {
-    return a1.to_ulong() >= a2.to_ulong();
-  }
-
-  /// Obtain an address object that represents any address.
-  static address_v4 any()
-  {
-    return address_v4();
-  }
-
-  /// Obtain an address object that represents the loopback address.
-  static address_v4 loopback()
-  {
-    return address_v4(0x7F000001);
-  }
-
-  /// Obtain an address object that represents the broadcast address.
-  static address_v4 broadcast()
-  {
-    return address_v4(0xFFFFFFFF);
-  }
-
-  /// Obtain an address object that represents the broadcast address that
-  /// corresponds to the specified address and netmask.
-  ASIO_DECL static address_v4 broadcast(
-      const address_v4& addr, const address_v4& mask);
-
-  /// Obtain the netmask that corresponds to the address, based on its address
-  /// class.
-  ASIO_DECL static address_v4 netmask(const address_v4& addr);
-
-private:
-  // The underlying IPv4 address.
-  asio::detail::in4_addr_type addr_;
-};
-
-#if !defined(ASIO_NO_IOSTREAM)
-
-/// Output an address as a string.
-/**
- * Used to output a human-readable string for a specified address.
- *
- * @param os The output stream to which the string will be written.
- *
- * @param addr The address to be written.
- *
- * @return The output stream.
- *
- * @relates asio::ip::address_v4
- */
-template <typename Elem, typename Traits>
-std::basic_ostream<Elem, Traits>& operator<<(
-    std::basic_ostream<Elem, Traits>& os, const address_v4& addr);
-
-#endif // !defined(ASIO_NO_IOSTREAM)
-
-} // namespace ip
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#include "asio/ip/impl/address_v4.hpp"
-#if defined(ASIO_HEADER_ONLY)
-# include "asio/ip/impl/address_v4.ipp"
-#endif // defined(ASIO_HEADER_ONLY)
-
-#endif // ASIO_IP_ADDRESS_V4_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ip/address_v6.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ip/address_v6.hpp
deleted file mode 100644
index 712386a08554..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ip/address_v6.hpp
+++ /dev/null
@@ -1,246 +0,0 @@
-//
-// ip/address_v6.hpp
-// ~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_IP_ADDRESS_V6_HPP
-#define ASIO_IP_ADDRESS_V6_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include <string>
-#include "asio/detail/array.hpp"
-#include "asio/detail/socket_types.hpp"
-#include "asio/detail/winsock_init.hpp"
-#include "asio/error_code.hpp"
-#include "asio/ip/address_v4.hpp"
-
-#if !defined(ASIO_NO_IOSTREAM)
-# include <iosfwd>
-#endif // !defined(ASIO_NO_IOSTREAM)
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace ip {
-
-/// Implements IP version 6 style addresses.
-/**
- * The asio::ip::address_v6 class provides the ability to use and
- * manipulate IP version 6 addresses.
- *
- * @par Thread Safety
- * @e Distinct @e objects: Safe.@n
- * @e Shared @e objects: Unsafe.
- */
-class address_v6
-{
-public:
-  /// The type used to represent an address as an array of bytes.
-  /**
-   * @note This type is defined in terms of the C++0x template @c std::array
-   * when it is available. Otherwise, it uses @c boost:array.
-   */
-#if defined(GENERATING_DOCUMENTATION)
-  typedef array<unsigned char, 16> bytes_type;
-#else
-  typedef asio::detail::array<unsigned char, 16> bytes_type;
-#endif
-
-  /// Default constructor.
-  ASIO_DECL address_v6();
-
-  /// Construct an address from raw bytes and scope ID.
-  ASIO_DECL explicit address_v6(const bytes_type& bytes,
-      unsigned long scope_id = 0);
-
-  /// Copy constructor.
-  ASIO_DECL address_v6(const address_v6& other);
-
-#if defined(ASIO_HAS_MOVE)
-  /// Move constructor.
-  ASIO_DECL address_v6(address_v6&& other);
-#endif // defined(ASIO_HAS_MOVE)
-
-  /// Assign from another address.
-  ASIO_DECL address_v6& operator=(const address_v6& other);
-
-#if defined(ASIO_HAS_MOVE)
-  /// Move-assign from another address.
-  ASIO_DECL address_v6& operator=(address_v6&& other);
-#endif // defined(ASIO_HAS_MOVE)
-
-  /// The scope ID of the address.
-  /**
-   * Returns the scope ID associated with the IPv6 address.
-   */
-  unsigned long scope_id() const
-  {
-    return scope_id_;
-  }
-
-  /// The scope ID of the address.
-  /**
-   * Modifies the scope ID associated with the IPv6 address.
-   */
-  void scope_id(unsigned long id)
-  {
-    scope_id_ = id;
-  }
-
-  /// Get the address in bytes, in network byte order.
-  ASIO_DECL bytes_type to_bytes() const;
-
-  /// Get the address as a string.
-  ASIO_DECL std::string to_string() const;
-
-  /// Get the address as a string.
-  ASIO_DECL std::string to_string(asio::error_code& ec) const;
-
-  /// Create an address from an IP address string.
-  ASIO_DECL static address_v6 from_string(const char* str);
-
-  /// Create an address from an IP address string.
-  ASIO_DECL static address_v6 from_string(
-      const char* str, asio::error_code& ec);
-
-  /// Create an address from an IP address string.
-  ASIO_DECL static address_v6 from_string(const std::string& str);
-
-  /// Create an address from an IP address string.
-  ASIO_DECL static address_v6 from_string(
-      const std::string& str, asio::error_code& ec);
-
-  /// Converts an IPv4-mapped or IPv4-compatible address to an IPv4 address.
-  ASIO_DECL address_v4 to_v4() const;
-
-  /// Determine whether the address is a loopback address.
-  ASIO_DECL bool is_loopback() const;
-
-  /// Determine whether the address is unspecified.
-  ASIO_DECL bool is_unspecified() const;
-
-  /// Determine whether the address is link local.
-  ASIO_DECL bool is_link_local() const;
-
-  /// Determine whether the address is site local.
-  ASIO_DECL bool is_site_local() const;
-
-  /// Determine whether the address is a mapped IPv4 address.
-  ASIO_DECL bool is_v4_mapped() const;
-
-  /// Determine whether the address is an IPv4-compatible address.
-  ASIO_DECL bool is_v4_compatible() const;
-
-  /// Determine whether the address is a multicast address.
-  ASIO_DECL bool is_multicast() const;
-
-  /// Determine whether the address is a global multicast address.
-  ASIO_DECL bool is_multicast_global() const;
-
-  /// Determine whether the address is a link-local multicast address.
-  ASIO_DECL bool is_multicast_link_local() const;
-
-  /// Determine whether the address is a node-local multicast address.
-  ASIO_DECL bool is_multicast_node_local() const;
-
-  /// Determine whether the address is a org-local multicast address.
-  ASIO_DECL bool is_multicast_org_local() const;
-
-  /// Determine whether the address is a site-local multicast address.
-  ASIO_DECL bool is_multicast_site_local() const;
-
-  /// Compare two addresses for equality.
-  ASIO_DECL friend bool operator==(
-      const address_v6& a1, const address_v6& a2);
-
-  /// Compare two addresses for inequality.
-  friend bool operator!=(const address_v6& a1, const address_v6& a2)
-  {
-    return !(a1 == a2);
-  }
-
-  /// Compare addresses for ordering.
-  ASIO_DECL friend bool operator<(
-      const address_v6& a1, const address_v6& a2);
-
-  /// Compare addresses for ordering.
-  friend bool operator>(const address_v6& a1, const address_v6& a2)
-  {
-    return a2 < a1;
-  }
-
-  /// Compare addresses for ordering.
-  friend bool operator<=(const address_v6& a1, const address_v6& a2)
-  {
-    return !(a2 < a1);
-  }
-
-  /// Compare addresses for ordering.
-  friend bool operator>=(const address_v6& a1, const address_v6& a2)
-  {
-    return !(a1 < a2);
-  }
-
-  /// Obtain an address object that represents any address.
-  static address_v6 any()
-  {
-    return address_v6();
-  }
-
-  /// Obtain an address object that represents the loopback address.
-  ASIO_DECL static address_v6 loopback();
-
-  /// Create an IPv4-mapped IPv6 address.
-  ASIO_DECL static address_v6 v4_mapped(const address_v4& addr);
-
-  /// Create an IPv4-compatible IPv6 address.
-  ASIO_DECL static address_v6 v4_compatible(const address_v4& addr);
-
-private:
-  // The underlying IPv6 address.
-  asio::detail::in6_addr_type addr_;
-
-  // The scope ID associated with the address.
-  unsigned long scope_id_;
-};
-
-#if !defined(ASIO_NO_IOSTREAM)
-
-/// Output an address as a string.
-/**
- * Used to output a human-readable string for a specified address.
- *
- * @param os The output stream to which the string will be written.
- *
- * @param addr The address to be written.
- *
- * @return The output stream.
- *
- * @relates asio::ip::address_v6
- */
-template <typename Elem, typename Traits>
-std::basic_ostream<Elem, Traits>& operator<<(
-    std::basic_ostream<Elem, Traits>& os, const address_v6& addr);
-
-#endif // !defined(ASIO_NO_IOSTREAM)
-
-} // namespace ip
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#include "asio/ip/impl/address_v6.hpp"
-#if defined(ASIO_HEADER_ONLY)
-# include "asio/ip/impl/address_v6.ipp"
-#endif // defined(ASIO_HEADER_ONLY)
-
-#endif // ASIO_IP_ADDRESS_V6_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ip/basic_endpoint.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ip/basic_endpoint.hpp
deleted file mode 100644
index 60dcbfad4016..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ip/basic_endpoint.hpp
+++ /dev/null
@@ -1,263 +0,0 @@
-//
-// ip/basic_endpoint.hpp
-// ~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_IP_BASIC_ENDPOINT_HPP
-#define ASIO_IP_BASIC_ENDPOINT_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include "asio/ip/address.hpp"
-#include "asio/ip/detail/endpoint.hpp"
-
-#if !defined(ASIO_NO_IOSTREAM)
-# include <iosfwd>
-#endif // !defined(ASIO_NO_IOSTREAM)
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace ip {
-
-/// Describes an endpoint for a version-independent IP socket.
-/**
- * The asio::ip::basic_endpoint class template describes an endpoint that
- * may be associated with a particular socket.
- *
- * @par Thread Safety
- * @e Distinct @e objects: Safe.@n
- * @e Shared @e objects: Unsafe.
- *
- * @par Concepts:
- * Endpoint.
- */
-template <typename InternetProtocol>
-class basic_endpoint
-{
-public:
-  /// The protocol type associated with the endpoint.
-  typedef InternetProtocol protocol_type;
-
-  /// The type of the endpoint structure. This type is dependent on the
-  /// underlying implementation of the socket layer.
-#if defined(GENERATING_DOCUMENTATION)
-  typedef implementation_defined data_type;
-#else
-  typedef asio::detail::socket_addr_type data_type;
-#endif
-
-  /// Default constructor.
-  basic_endpoint()
-    : impl_()
-  {
-  }
-
-  /// Construct an endpoint using a port number, specified in the host's byte
-  /// order. The IP address will be the any address (i.e. INADDR_ANY or
-  /// in6addr_any). This constructor would typically be used for accepting new
-  /// connections.
-  /**
-   * @par Examples
-   * To initialise an IPv4 TCP endpoint for port 1234, use:
-   * @code
-   * asio::ip::tcp::endpoint ep(asio::ip::tcp::v4(), 1234);
-   * @endcode
-   *
-   * To specify an IPv6 UDP endpoint for port 9876, use:
-   * @code
-   * asio::ip::udp::endpoint ep(asio::ip::udp::v6(), 9876);
-   * @endcode
-   */
-  basic_endpoint(const InternetProtocol& internet_protocol,
-      unsigned short port_num)
-    : impl_(internet_protocol.family(), port_num)
-  {
-  }
-
-  /// Construct an endpoint using a port number and an IP address. This
-  /// constructor may be used for accepting connections on a specific interface
-  /// or for making a connection to a remote endpoint.
-  basic_endpoint(const asio::ip::address& addr, unsigned short port_num)
-    : impl_(addr, port_num)
-  {
-  }
-
-  /// Copy constructor.
-  basic_endpoint(const basic_endpoint& other)
-    : impl_(other.impl_)
-  {
-  }
-
-#if defined(ASIO_HAS_MOVE)
-  /// Move constructor.
-  basic_endpoint(basic_endpoint&& other)
-    : impl_(other.impl_)
-  {
-  }
-#endif // defined(ASIO_HAS_MOVE)
-
-  /// Assign from another endpoint.
-  basic_endpoint& operator=(const basic_endpoint& other)
-  {
-    impl_ = other.impl_;
-    return *this;
-  }
-
-#if defined(ASIO_HAS_MOVE)
-  /// Move-assign from another endpoint.
-  basic_endpoint& operator=(basic_endpoint&& other)
-  {
-    impl_ = other.impl_;
-    return *this;
-  }
-#endif // defined(ASIO_HAS_MOVE)
-
-  /// The protocol associated with the endpoint.
-  protocol_type protocol() const
-  {
-    if (impl_.is_v4())
-      return InternetProtocol::v4();
-    return InternetProtocol::v6();
-  }
-
-  /// Get the underlying endpoint in the native type.
-  data_type* data()
-  {
-    return impl_.data();
-  }
-
-  /// Get the underlying endpoint in the native type.
-  const data_type* data() const
-  {
-    return impl_.data();
-  }
-
-  /// Get the underlying size of the endpoint in the native type.
-  std::size_t size() const
-  {
-    return impl_.size();
-  }
-
-  /// Set the underlying size of the endpoint in the native type.
-  void resize(std::size_t new_size)
-  {
-    impl_.resize(new_size);
-  }
-
-  /// Get the capacity of the endpoint in the native type.
-  std::size_t capacity() const
-  {
-    return impl_.capacity();
-  }
-
-  /// Get the port associated with the endpoint. The port number is always in
-  /// the host's byte order.
-  unsigned short port() const
-  {
-    return impl_.port();
-  }
-
-  /// Set the port associated with the endpoint. The port number is always in
-  /// the host's byte order.
-  void port(unsigned short port_num)
-  {
-    impl_.port(port_num);
-  }
-
-  /// Get the IP address associated with the endpoint.
-  asio::ip::address address() const
-  {
-    return impl_.address();
-  }
-
-  /// Set the IP address associated with the endpoint.
-  void address(const asio::ip::address& addr)
-  {
-    impl_.address(addr);
-  }
-
-  /// Compare two endpoints for equality.
-  friend bool operator==(const basic_endpoint<InternetProtocol>& e1,
-      const basic_endpoint<InternetProtocol>& e2)
-  {
-    return e1.impl_ == e2.impl_;
-  }
-
-  /// Compare two endpoints for inequality.
-  friend bool operator!=(const basic_endpoint<InternetProtocol>& e1,
-      const basic_endpoint<InternetProtocol>& e2)
-  {
-    return !(e1 == e2);
-  }
-
-  /// Compare endpoints for ordering.
-  friend bool operator<(const basic_endpoint<InternetProtocol>& e1,
-      const basic_endpoint<InternetProtocol>& e2)
-  {
-    return e1.impl_ < e2.impl_;
-  }
-
-  /// Compare endpoints for ordering.
-  friend bool operator>(const basic_endpoint<InternetProtocol>& e1,
-      const basic_endpoint<InternetProtocol>& e2)
-  {
-    return e2.impl_ < e1.impl_;
-  }
-
-  /// Compare endpoints for ordering.
-  friend bool operator<=(const basic_endpoint<InternetProtocol>& e1,
-      const basic_endpoint<InternetProtocol>& e2)
-  {
-    return !(e2 < e1);
-  }
-
-  /// Compare endpoints for ordering.
-  friend bool operator>=(const basic_endpoint<InternetProtocol>& e1,
-      const basic_endpoint<InternetProtocol>& e2)
-  {
-    return !(e1 < e2);
-  }
-
-private:
-  // The underlying IP endpoint.
-  asio::ip::detail::endpoint impl_;
-};
-
-#if !defined(ASIO_NO_IOSTREAM)
-
-/// Output an endpoint as a string.
-/**
- * Used to output a human-readable string for a specified endpoint.
- *
- * @param os The output stream to which the string will be written.
- *
- * @param endpoint The endpoint to be written.
- *
- * @return The output stream.
- *
- * @relates asio::ip::basic_endpoint
- */
-template <typename Elem, typename Traits, typename InternetProtocol>
-std::basic_ostream<Elem, Traits>& operator<<(
-    std::basic_ostream<Elem, Traits>& os,
-    const basic_endpoint<InternetProtocol>& endpoint);
-
-#endif // !defined(ASIO_NO_IOSTREAM)
-
-} // namespace ip
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#include "asio/ip/impl/basic_endpoint.hpp"
-
-#endif // ASIO_IP_BASIC_ENDPOINT_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ip/basic_resolver.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ip/basic_resolver.hpp
deleted file mode 100644
index 7d75d58817ef..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ip/basic_resolver.hpp
+++ /dev/null
@@ -1,268 +0,0 @@
-//
-// ip/basic_resolver.hpp
-// ~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_IP_BASIC_RESOLVER_HPP
-#define ASIO_IP_BASIC_RESOLVER_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include "asio/basic_io_object.hpp"
-#include "asio/detail/handler_type_requirements.hpp"
-#include "asio/detail/throw_error.hpp"
-#include "asio/error.hpp"
-#include "asio/ip/basic_resolver_iterator.hpp"
-#include "asio/ip/basic_resolver_query.hpp"
-#include "asio/ip/resolver_service.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace ip {
-
-/// Provides endpoint resolution functionality.
-/**
- * The basic_resolver class template provides the ability to resolve a query
- * to a list of endpoints.
- *
- * @par Thread Safety
- * @e Distinct @e objects: Safe.@n
- * @e Shared @e objects: Unsafe.
- */
-template <typename InternetProtocol,
-    typename ResolverService = resolver_service<InternetProtocol> >
-class basic_resolver
-  : public basic_io_object<ResolverService>
-{
-public:
-  /// The protocol type.
-  typedef InternetProtocol protocol_type;
-
-  /// The endpoint type.
-  typedef typename InternetProtocol::endpoint endpoint_type;
-
-  /// The query type.
-  typedef basic_resolver_query<InternetProtocol> query;
-
-  /// The iterator type.
-  typedef basic_resolver_iterator<InternetProtocol> iterator;
-
-  /// Constructor.
-  /**
-   * This constructor creates a basic_resolver.
-   *
-   * @param io_service The io_service object that the resolver will use to
-   * dispatch handlers for any asynchronous operations performed on the timer.
-   */
-  explicit basic_resolver(asio::io_service& io_service)
-    : basic_io_object<ResolverService>(io_service)
-  {
-  }
-
-  /// Cancel any asynchronous operations that are waiting on the resolver.
-  /**
-   * This function forces the completion of any pending asynchronous
-   * operations on the host resolver. The handler for each cancelled operation
-   * will be invoked with the asio::error::operation_aborted error code.
-   */
-  void cancel()
-  {
-    return this->service.cancel(this->implementation);
-  }
-
-  /// Perform forward resolution of a query to a list of entries.
-  /**
-   * This function is used to resolve a query into a list of endpoint entries.
-   *
-   * @param q A query object that determines what endpoints will be returned.
-   *
-   * @returns A forward-only iterator that can be used to traverse the list
-   * of endpoint entries.
-   *
-   * @throws asio::system_error Thrown on failure.
-   *
-   * @note A default constructed iterator represents the end of the list.
-   *
-   * A successful call to this function is guaranteed to return at least one
-   * entry.
-   */
-  iterator resolve(const query& q)
-  {
-    asio::error_code ec;
-    iterator i = this->service.resolve(this->implementation, q, ec);
-    asio::detail::throw_error(ec, "resolve");
-    return i;
-  }
-
-  /// Perform forward resolution of a query to a list of entries.
-  /**
-   * This function is used to resolve a query into a list of endpoint entries.
-   *
-   * @param q A query object that determines what endpoints will be returned.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   *
-   * @returns A forward-only iterator that can be used to traverse the list
-   * of endpoint entries. Returns a default constructed iterator if an error
-   * occurs.
-   *
-   * @note A default constructed iterator represents the end of the list.
-   *
-   * A successful call to this function is guaranteed to return at least one
-   * entry.
-   */
-  iterator resolve(const query& q, asio::error_code& ec)
-  {
-    return this->service.resolve(this->implementation, q, ec);
-  }
-
-  /// Asynchronously perform forward resolution of a query to a list of entries.
-  /**
-   * This function is used to asynchronously resolve a query into a list of
-   * endpoint entries.
-   *
-   * @param q A query object that determines what endpoints will be returned.
-   *
-   * @param handler The handler to be called when the resolve operation
-   * completes. Copies will be made of the handler as required. The function
-   * signature of the handler must be:
-   * @code void handler(
-   *   const asio::error_code& error, // Result of operation.
-   *   resolver::iterator iterator             // Forward-only iterator that can
-   *                                           // be used to traverse the list
-   *                                           // of endpoint entries.
-   * ); @endcode
-   * Regardless of whether the asynchronous operation completes immediately or
-   * not, the handler will not be invoked from within this function. Invocation
-   * of the handler will be performed in a manner equivalent to using
-   * asio::io_service::post().
-   *
-   * @note A default constructed iterator represents the end of the list.
-   *
-   * A successful resolve operation is guaranteed to pass at least one entry to
-   * the handler.
-   */
-  template <typename ResolveHandler>
-  ASIO_INITFN_RESULT_TYPE(ResolveHandler,
-      void (asio::error_code, iterator))
-  async_resolve(const query& q,
-      ASIO_MOVE_ARG(ResolveHandler) handler)
-  {
-    // If you get an error on the following line it means that your handler does
-    // not meet the documented type requirements for a ResolveHandler.
-    ASIO_RESOLVE_HANDLER_CHECK(
-        ResolveHandler, handler, iterator) type_check;
-
-    return this->service.async_resolve(this->implementation, q,
-        ASIO_MOVE_CAST(ResolveHandler)(handler));
-  }
-
-  /// Perform reverse resolution of an endpoint to a list of entries.
-  /**
-   * This function is used to resolve an endpoint into a list of endpoint
-   * entries.
-   *
-   * @param e An endpoint object that determines what endpoints will be
-   * returned.
-   *
-   * @returns A forward-only iterator that can be used to traverse the list
-   * of endpoint entries.
-   *
-   * @throws asio::system_error Thrown on failure.
-   *
-   * @note A default constructed iterator represents the end of the list.
-   *
-   * A successful call to this function is guaranteed to return at least one
-   * entry.
-   */
-  iterator resolve(const endpoint_type& e)
-  {
-    asio::error_code ec;
-    iterator i = this->service.resolve(this->implementation, e, ec);
-    asio::detail::throw_error(ec, "resolve");
-    return i;
-  }
-
-  /// Perform reverse resolution of an endpoint to a list of entries.
-  /**
-   * This function is used to resolve an endpoint into a list of endpoint
-   * entries.
-   *
-   * @param e An endpoint object that determines what endpoints will be
-   * returned.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   *
-   * @returns A forward-only iterator that can be used to traverse the list
-   * of endpoint entries. Returns a default constructed iterator if an error
-   * occurs.
-   *
-   * @note A default constructed iterator represents the end of the list.
-   *
-   * A successful call to this function is guaranteed to return at least one
-   * entry.
-   */
-  iterator resolve(const endpoint_type& e, asio::error_code& ec)
-  {
-    return this->service.resolve(this->implementation, e, ec);
-  }
-
-  /// Asynchronously perform reverse resolution of an endpoint to a list of
-  /// entries.
-  /**
-   * This function is used to asynchronously resolve an endpoint into a list of
-   * endpoint entries.
-   *
-   * @param e An endpoint object that determines what endpoints will be
-   * returned.
-   *
-   * @param handler The handler to be called when the resolve operation
-   * completes. Copies will be made of the handler as required. The function
-   * signature of the handler must be:
-   * @code void handler(
-   *   const asio::error_code& error, // Result of operation.
-   *   resolver::iterator iterator             // Forward-only iterator that can
-   *                                           // be used to traverse the list
-   *                                           // of endpoint entries.
-   * ); @endcode
-   * Regardless of whether the asynchronous operation completes immediately or
-   * not, the handler will not be invoked from within this function. Invocation
-   * of the handler will be performed in a manner equivalent to using
-   * asio::io_service::post().
-   *
-   * @note A default constructed iterator represents the end of the list.
-   *
-   * A successful resolve operation is guaranteed to pass at least one entry to
-   * the handler.
-   */
-  template <typename ResolveHandler>
-  ASIO_INITFN_RESULT_TYPE(ResolveHandler,
-      void (asio::error_code, iterator))
-  async_resolve(const endpoint_type& e,
-      ASIO_MOVE_ARG(ResolveHandler) handler)
-  {
-    // If you get an error on the following line it means that your handler does
-    // not meet the documented type requirements for a ResolveHandler.
-    ASIO_RESOLVE_HANDLER_CHECK(
-        ResolveHandler, handler, iterator) type_check;
-
-    return this->service.async_resolve(this->implementation, e,
-        ASIO_MOVE_CAST(ResolveHandler)(handler));
-  }
-};
-
-} // namespace ip
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_IP_BASIC_RESOLVER_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ip/basic_resolver_entry.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ip/basic_resolver_entry.hpp
deleted file mode 100644
index 13644f3beb32..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ip/basic_resolver_entry.hpp
+++ /dev/null
@@ -1,94 +0,0 @@
-//
-// ip/basic_resolver_entry.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_IP_BASIC_RESOLVER_ENTRY_HPP
-#define ASIO_IP_BASIC_RESOLVER_ENTRY_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include <string>
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace ip {
-
-/// An entry produced by a resolver.
-/**
- * The asio::ip::basic_resolver_entry class template describes an entry
- * as returned by a resolver.
- *
- * @par Thread Safety
- * @e Distinct @e objects: Safe.@n
- * @e Shared @e objects: Unsafe.
- */
-template <typename InternetProtocol>
-class basic_resolver_entry
-{
-public:
-  /// The protocol type associated with the endpoint entry.
-  typedef InternetProtocol protocol_type;
-
-  /// The endpoint type associated with the endpoint entry.
-  typedef typename InternetProtocol::endpoint endpoint_type;
-
-  /// Default constructor.
-  basic_resolver_entry()
-  {
-  }
-
-  /// Construct with specified endpoint, host name and service name.
-  basic_resolver_entry(const endpoint_type& ep,
-      const std::string& host, const std::string& service)
-    : endpoint_(ep),
-      host_name_(host),
-      service_name_(service)
-  {
-  }
-
-  /// Get the endpoint associated with the entry.
-  endpoint_type endpoint() const
-  {
-    return endpoint_;
-  }
-
-  /// Convert to the endpoint associated with the entry.
-  operator endpoint_type() const
-  {
-    return endpoint_;
-  }
-
-  /// Get the host name associated with the entry.
-  std::string host_name() const
-  {
-    return host_name_;
-  }
-
-  /// Get the service name associated with the entry.
-  std::string service_name() const
-  {
-    return service_name_;
-  }
-
-private:
-  endpoint_type endpoint_;
-  std::string host_name_;
-  std::string service_name_;
-};
-
-} // namespace ip
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_IP_BASIC_RESOLVER_ENTRY_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ip/basic_resolver_iterator.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ip/basic_resolver_iterator.hpp
deleted file mode 100644
index 4c8b0d9d3c77..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ip/basic_resolver_iterator.hpp
+++ /dev/null
@@ -1,260 +0,0 @@
-//
-// ip/basic_resolver_iterator.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_IP_BASIC_RESOLVER_ITERATOR_HPP
-#define ASIO_IP_BASIC_RESOLVER_ITERATOR_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include <cstddef>
-#include <cstring>
-#include <iterator>
-#include <string>
-#include <vector>
-#include "asio/detail/shared_ptr.hpp"
-#include "asio/detail/socket_ops.hpp"
-#include "asio/detail/socket_types.hpp"
-#include "asio/ip/basic_resolver_entry.hpp"
-
-#if defined(ASIO_WINDOWS_RUNTIME)
-# include "asio/detail/winrt_utils.hpp"
-#endif // defined(ASIO_WINDOWS_RUNTIME)
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace ip {
-
-/// An iterator over the entries produced by a resolver.
-/**
- * The asio::ip::basic_resolver_iterator class template is used to define
- * iterators over the results returned by a resolver.
- *
- * The iterator's value_type, obtained when the iterator is dereferenced, is:
- * @code const basic_resolver_entry<InternetProtocol> @endcode
- *
- * @par Thread Safety
- * @e Distinct @e objects: Safe.@n
- * @e Shared @e objects: Unsafe.
- */
-template <typename InternetProtocol>
-class basic_resolver_iterator
-{
-public:
-  /// The type used for the distance between two iterators.
-  typedef std::ptrdiff_t difference_type;
-
-  /// The type of the value pointed to by the iterator.
-  typedef basic_resolver_entry<InternetProtocol> value_type;
-
-  /// The type of the result of applying operator->() to the iterator.
-  typedef const basic_resolver_entry<InternetProtocol>* pointer;
-
-  /// The type of the result of applying operator*() to the iterator.
-  typedef const basic_resolver_entry<InternetProtocol>& reference;
-
-  /// The iterator category.
-  typedef std::forward_iterator_tag iterator_category;
-
-  /// Default constructor creates an end iterator.
-  basic_resolver_iterator()
-    : index_(0)
-  {
-  }
-
-  /// Create an iterator from an addrinfo list returned by getaddrinfo.
-  static basic_resolver_iterator create(
-      asio::detail::addrinfo_type* address_info,
-      const std::string& host_name, const std::string& service_name)
-  {
-    basic_resolver_iterator iter;
-    if (!address_info)
-      return iter;
-
-    std::string actual_host_name = host_name;
-    if (address_info->ai_canonname)
-      actual_host_name = address_info->ai_canonname;
-
-    iter.values_.reset(new values_type);
-
-    while (address_info)
-    {
-      if (address_info->ai_family == ASIO_OS_DEF(AF_INET)
-          || address_info->ai_family == ASIO_OS_DEF(AF_INET6))
-      {
-        using namespace std; // For memcpy.
-        typename InternetProtocol::endpoint endpoint;
-        endpoint.resize(static_cast<std::size_t>(address_info->ai_addrlen));
-        memcpy(endpoint.data(), address_info->ai_addr,
-            address_info->ai_addrlen);
-        iter.values_->push_back(
-            basic_resolver_entry<InternetProtocol>(endpoint,
-              actual_host_name, service_name));
-      }
-      address_info = address_info->ai_next;
-    }
-
-    return iter;
-  }
-
-  /// Create an iterator from an endpoint, host name and service name.
-  static basic_resolver_iterator create(
-      const typename InternetProtocol::endpoint& endpoint,
-      const std::string& host_name, const std::string& service_name)
-  {
-    basic_resolver_iterator iter;
-    iter.values_.reset(new values_type);
-    iter.values_->push_back(
-        basic_resolver_entry<InternetProtocol>(
-          endpoint, host_name, service_name));
-    return iter;
-  }
-
-  /// Create an iterator from a sequence of endpoints, host and service name.
-  template <typename EndpointIterator>
-  static basic_resolver_iterator create(
-      EndpointIterator begin, EndpointIterator end,
-      const std::string& host_name, const std::string& service_name)
-  {
-    basic_resolver_iterator iter;
-    if (begin != end)
-    {
-      iter.values_.reset(new values_type);
-      for (EndpointIterator ep_iter = begin; ep_iter != end; ++ep_iter)
-      {
-        iter.values_->push_back(
-            basic_resolver_entry<InternetProtocol>(
-              *ep_iter, host_name, service_name));
-      }
-    }
-    return iter;
-  }
-
-#if defined(ASIO_WINDOWS_RUNTIME)
-  /// Create an iterator from a Windows Runtime list of EndpointPair objects.
-  static basic_resolver_iterator create(
-      Windows::Foundation::Collections::IVectorView<
-        Windows::Networking::EndpointPair^>^ endpoints,
-      const asio::detail::addrinfo_type& hints,
-      const std::string& host_name, const std::string& service_name)
-  {
-    basic_resolver_iterator iter;
-    if (endpoints->Size)
-    {
-      iter.values_.reset(new values_type);
-      for (unsigned int i = 0; i < endpoints->Size; ++i)
-      {
-        auto pair = endpoints->GetAt(i);
-
-        if (hints.ai_family == ASIO_OS_DEF(AF_INET)
-            && pair->RemoteHostName->Type
-              != Windows::Networking::HostNameType::Ipv4)
-          continue;
-
-        if (hints.ai_family == ASIO_OS_DEF(AF_INET6)
-            && pair->RemoteHostName->Type
-              != Windows::Networking::HostNameType::Ipv6)
-          continue;
-
-        iter.values_->push_back(
-            basic_resolver_entry<InternetProtocol>(
-              typename InternetProtocol::endpoint(
-                ip::address::from_string(
-                  asio::detail::winrt_utils::string(
-                    pair->RemoteHostName->CanonicalName)),
-                asio::detail::winrt_utils::integer(
-                  pair->RemoteServiceName)),
-              host_name, service_name));
-      }
-    }
-    return iter;
-  }
-#endif // defined(ASIO_WINDOWS_RUNTIME)
-
-  /// Dereference an iterator.
-  const basic_resolver_entry<InternetProtocol>& operator*() const
-  {
-    return dereference();
-  }
-
-  /// Dereference an iterator.
-  const basic_resolver_entry<InternetProtocol>* operator->() const
-  {
-    return &dereference();
-  }
-
-  /// Increment operator (prefix).
-  basic_resolver_iterator& operator++()
-  {
-    increment();
-    return *this;
-  }
-
-  /// Increment operator (postfix).
-  basic_resolver_iterator operator++(int)
-  {
-    basic_resolver_iterator tmp(*this);
-    ++*this;
-    return tmp;
-  }
-
-  /// Test two iterators for equality.
-  friend bool operator==(const basic_resolver_iterator& a,
-      const basic_resolver_iterator& b)
-  {
-    return a.equal(b);
-  }
-
-  /// Test two iterators for inequality.
-  friend bool operator!=(const basic_resolver_iterator& a,
-      const basic_resolver_iterator& b)
-  {
-    return !a.equal(b);
-  }
-
-private:
-  void increment()
-  {
-    if (++index_ == values_->size())
-    {
-      // Reset state to match a default constructed end iterator.
-      values_.reset();
-      index_ = 0;
-    }
-  }
-
-  bool equal(const basic_resolver_iterator& other) const
-  {
-    if (!values_ && !other.values_)
-      return true;
-    if (values_ != other.values_)
-      return false;
-    return index_ == other.index_;
-  }
-
-  const basic_resolver_entry<InternetProtocol>& dereference() const
-  {
-    return (*values_)[index_];
-  }
-
-  typedef std::vector<basic_resolver_entry<InternetProtocol> > values_type;
-  asio::detail::shared_ptr<values_type> values_;
-  std::size_t index_;
-};
-
-} // namespace ip
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_IP_BASIC_RESOLVER_ITERATOR_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ip/basic_resolver_query.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ip/basic_resolver_query.hpp
deleted file mode 100644
index ce9e43758bf9..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ip/basic_resolver_query.hpp
+++ /dev/null
@@ -1,244 +0,0 @@
-//
-// ip/basic_resolver_query.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_IP_BASIC_RESOLVER_QUERY_HPP
-#define ASIO_IP_BASIC_RESOLVER_QUERY_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include <string>
-#include "asio/detail/socket_ops.hpp"
-#include "asio/ip/resolver_query_base.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace ip {
-
-/// An query to be passed to a resolver.
-/**
- * The asio::ip::basic_resolver_query class template describes a query
- * that can be passed to a resolver.
- *
- * @par Thread Safety
- * @e Distinct @e objects: Safe.@n
- * @e Shared @e objects: Unsafe.
- */
-template <typename InternetProtocol>
-class basic_resolver_query
-  : public resolver_query_base
-{
-public:
-  /// The protocol type associated with the endpoint query.
-  typedef InternetProtocol protocol_type;
-
-  /// Construct with specified service name for any protocol.
-  /**
-   * This constructor is typically used to perform name resolution for local
-   * service binding.
-   *
-   * @param service A string identifying the requested service. This may be a
-   * descriptive name or a numeric string corresponding to a port number.
-   *
-   * @param resolve_flags A set of flags that determine how name resolution
-   * should be performed. The default flags are suitable for local service
-   * binding.
-   *
-   * @note On POSIX systems, service names are typically defined in the file
-   * <tt>/etc/services</tt>. On Windows, service names may be found in the file
-   * <tt>c:\\windows\\system32\\drivers\\etc\\services</tt>. Operating systems
-   * may use additional locations when resolving service names.
-   */
-  basic_resolver_query(const std::string& service,
-      resolver_query_base::flags resolve_flags = passive | address_configured)
-    : hints_(),
-      host_name_(),
-      service_name_(service)
-  {
-    typename InternetProtocol::endpoint endpoint;
-    hints_.ai_flags = static_cast<int>(resolve_flags);
-    hints_.ai_family = PF_UNSPEC;
-    hints_.ai_socktype = endpoint.protocol().type();
-    hints_.ai_protocol = endpoint.protocol().protocol();
-    hints_.ai_addrlen = 0;
-    hints_.ai_canonname = 0;
-    hints_.ai_addr = 0;
-    hints_.ai_next = 0;
-  }
-
-  /// Construct with specified service name for a given protocol.
-  /**
-   * This constructor is typically used to perform name resolution for local
-   * service binding with a specific protocol version.
-   *
-   * @param protocol A protocol object, normally representing either the IPv4 or
-   * IPv6 version of an internet protocol.
-   *
-   * @param service A string identifying the requested service. This may be a
-   * descriptive name or a numeric string corresponding to a port number.
-   *
-   * @param resolve_flags A set of flags that determine how name resolution
-   * should be performed. The default flags are suitable for local service
-   * binding.
-   *
-   * @note On POSIX systems, service names are typically defined in the file
-   * <tt>/etc/services</tt>. On Windows, service names may be found in the file
-   * <tt>c:\\windows\\system32\\drivers\\etc\\services</tt>. Operating systems
-   * may use additional locations when resolving service names.
-   */
-  basic_resolver_query(const protocol_type& protocol,
-      const std::string& service,
-      resolver_query_base::flags resolve_flags = passive | address_configured)
-    : hints_(),
-      host_name_(),
-      service_name_(service)
-  {
-    hints_.ai_flags = static_cast<int>(resolve_flags);
-    hints_.ai_family = protocol.family();
-    hints_.ai_socktype = protocol.type();
-    hints_.ai_protocol = protocol.protocol();
-    hints_.ai_addrlen = 0;
-    hints_.ai_canonname = 0;
-    hints_.ai_addr = 0;
-    hints_.ai_next = 0;
-  }
-
-  /// Construct with specified host name and service name for any protocol.
-  /**
-   * This constructor is typically used to perform name resolution for
-   * communication with remote hosts.
-   *
-   * @param host A string identifying a location. May be a descriptive name or
-   * a numeric address string. If an empty string and the passive flag has been
-   * specified, the resolved endpoints are suitable for local service binding.
-   * If an empty string and passive is not specified, the resolved endpoints
-   * will use the loopback address.
-   *
-   * @param service A string identifying the requested service. This may be a
-   * descriptive name or a numeric string corresponding to a port number. May
-   * be an empty string, in which case all resolved endpoints will have a port
-   * number of 0.
-   *
-   * @param resolve_flags A set of flags that determine how name resolution
-   * should be performed. The default flags are suitable for communication with
-   * remote hosts.
-   *
-   * @note On POSIX systems, host names may be locally defined in the file
-   * <tt>/etc/hosts</tt>. On Windows, host names may be defined in the file
-   * <tt>c:\\windows\\system32\\drivers\\etc\\hosts</tt>. Remote host name
-   * resolution is performed using DNS. Operating systems may use additional
-   * locations when resolving host names (such as NETBIOS names on Windows).
-   *
-   * On POSIX systems, service names are typically defined in the file
-   * <tt>/etc/services</tt>. On Windows, service names may be found in the file
-   * <tt>c:\\windows\\system32\\drivers\\etc\\services</tt>. Operating systems
-   * may use additional locations when resolving service names.
-   */
-  basic_resolver_query(const std::string& host, const std::string& service,
-      resolver_query_base::flags resolve_flags = address_configured)
-    : hints_(),
-      host_name_(host),
-      service_name_(service)
-  {
-    typename InternetProtocol::endpoint endpoint;
-    hints_.ai_flags = static_cast<int>(resolve_flags);
-    hints_.ai_family = ASIO_OS_DEF(AF_UNSPEC);
-    hints_.ai_socktype = endpoint.protocol().type();
-    hints_.ai_protocol = endpoint.protocol().protocol();
-    hints_.ai_addrlen = 0;
-    hints_.ai_canonname = 0;
-    hints_.ai_addr = 0;
-    hints_.ai_next = 0;
-  }
-
-  /// Construct with specified host name and service name for a given protocol.
-  /**
-   * This constructor is typically used to perform name resolution for
-   * communication with remote hosts.
-   *
-   * @param protocol A protocol object, normally representing either the IPv4 or
-   * IPv6 version of an internet protocol.
-   *
-   * @param host A string identifying a location. May be a descriptive name or
-   * a numeric address string. If an empty string and the passive flag has been
-   * specified, the resolved endpoints are suitable for local service binding.
-   * If an empty string and passive is not specified, the resolved endpoints
-   * will use the loopback address.
-   *
-   * @param service A string identifying the requested service. This may be a
-   * descriptive name or a numeric string corresponding to a port number. May
-   * be an empty string, in which case all resolved endpoints will have a port
-   * number of 0.
-   *
-   * @param resolve_flags A set of flags that determine how name resolution
-   * should be performed. The default flags are suitable for communication with
-   * remote hosts.
-   *
-   * @note On POSIX systems, host names may be locally defined in the file
-   * <tt>/etc/hosts</tt>. On Windows, host names may be defined in the file
-   * <tt>c:\\windows\\system32\\drivers\\etc\\hosts</tt>. Remote host name
-   * resolution is performed using DNS. Operating systems may use additional
-   * locations when resolving host names (such as NETBIOS names on Windows).
-   *
-   * On POSIX systems, service names are typically defined in the file
-   * <tt>/etc/services</tt>. On Windows, service names may be found in the file
-   * <tt>c:\\windows\\system32\\drivers\\etc\\services</tt>. Operating systems
-   * may use additional locations when resolving service names.
-   */
-  basic_resolver_query(const protocol_type& protocol,
-      const std::string& host, const std::string& service,
-      resolver_query_base::flags resolve_flags = address_configured)
-    : hints_(),
-      host_name_(host),
-      service_name_(service)
-  {
-    hints_.ai_flags = static_cast<int>(resolve_flags);
-    hints_.ai_family = protocol.family();
-    hints_.ai_socktype = protocol.type();
-    hints_.ai_protocol = protocol.protocol();
-    hints_.ai_addrlen = 0;
-    hints_.ai_canonname = 0;
-    hints_.ai_addr = 0;
-    hints_.ai_next = 0;
-  }
-
-  /// Get the hints associated with the query.
-  const asio::detail::addrinfo_type& hints() const
-  {
-    return hints_;
-  }
-
-  /// Get the host name associated with the query.
-  std::string host_name() const
-  {
-    return host_name_;
-  }
-
-  /// Get the service name associated with the query.
-  std::string service_name() const
-  {
-    return service_name_;
-  }
-
-private:
-  asio::detail::addrinfo_type hints_;
-  std::string host_name_;
-  std::string service_name_;
-};
-
-} // namespace ip
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_IP_BASIC_RESOLVER_QUERY_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ip/detail/endpoint.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ip/detail/endpoint.hpp
deleted file mode 100644
index 630908fc0478..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ip/detail/endpoint.hpp
+++ /dev/null
@@ -1,139 +0,0 @@
-//
-// ip/detail/endpoint.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_IP_DETAIL_ENDPOINT_HPP
-#define ASIO_IP_DETAIL_ENDPOINT_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include <string>
-#include "asio/detail/socket_types.hpp"
-#include "asio/detail/winsock_init.hpp"
-#include "asio/error_code.hpp"
-#include "asio/ip/address.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace ip {
-namespace detail {
-
-// Helper class for implementating an IP endpoint.
-class endpoint
-{
-public:
-  // Default constructor.
-  ASIO_DECL endpoint();
-
-  // Construct an endpoint using a family and port number.
-  ASIO_DECL endpoint(int family, unsigned short port_num);
-
-  // Construct an endpoint using an address and port number.
-  ASIO_DECL endpoint(const asio::ip::address& addr,
-      unsigned short port_num);
-
-  // Copy constructor.
-  endpoint(const endpoint& other)
-    : data_(other.data_)
-  {
-  }
-
-  // Assign from another endpoint.
-  endpoint& operator=(const endpoint& other)
-  {
-    data_ = other.data_;
-    return *this;
-  }
-
-  // Get the underlying endpoint in the native type.
-  asio::detail::socket_addr_type* data()
-  {
-    return &data_.base;
-  }
-
-  // Get the underlying endpoint in the native type.
-  const asio::detail::socket_addr_type* data() const
-  {
-    return &data_.base;
-  }
-
-  // Get the underlying size of the endpoint in the native type.
-  std::size_t size() const
-  {
-    if (is_v4())
-      return sizeof(asio::detail::sockaddr_in4_type);
-    else
-      return sizeof(asio::detail::sockaddr_in6_type);
-  }
-
-  // Set the underlying size of the endpoint in the native type.
-  ASIO_DECL void resize(std::size_t new_size);
-
-  // Get the capacity of the endpoint in the native type.
-  std::size_t capacity() const
-  {
-    return sizeof(data_);
-  }
-
-  // Get the port associated with the endpoint.
-  ASIO_DECL unsigned short port() const;
-
-  // Set the port associated with the endpoint.
-  ASIO_DECL void port(unsigned short port_num);
-
-  // Get the IP address associated with the endpoint.
-  ASIO_DECL asio::ip::address address() const;
-
-  // Set the IP address associated with the endpoint.
-  ASIO_DECL void address(const asio::ip::address& addr);
-
-  // Compare two endpoints for equality.
-  ASIO_DECL friend bool operator==(
-      const endpoint& e1, const endpoint& e2);
-
-  // Compare endpoints for ordering.
-  ASIO_DECL friend bool operator<(
-      const endpoint& e1, const endpoint& e2);
-
-  // Determine whether the endpoint is IPv4.
-  bool is_v4() const
-  {
-    return data_.base.sa_family == ASIO_OS_DEF(AF_INET);
-  }
-
-#if !defined(ASIO_NO_IOSTREAM)
-  // Convert to a string.
-  ASIO_DECL std::string to_string(asio::error_code& ec) const;
-#endif // !defined(ASIO_NO_IOSTREAM)
-
-private:
-  // The underlying IP socket address.
-  union data_union
-  {
-    asio::detail::socket_addr_type base;
-    asio::detail::sockaddr_in4_type v4;
-    asio::detail::sockaddr_in6_type v6;
-  } data_;
-};
-
-} // namespace detail
-} // namespace ip
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#if defined(ASIO_HEADER_ONLY)
-# include "asio/ip/detail/impl/endpoint.ipp"
-#endif // defined(ASIO_HEADER_ONLY)
-
-#endif // ASIO_IP_DETAIL_ENDPOINT_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ip/detail/impl/endpoint.ipp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ip/detail/impl/endpoint.ipp
deleted file mode 100644
index d18d5e00aaf0..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ip/detail/impl/endpoint.ipp
+++ /dev/null
@@ -1,204 +0,0 @@
-//
-// ip/detail/impl/endpoint.ipp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_IP_DETAIL_IMPL_ENDPOINT_IPP
-#define ASIO_IP_DETAIL_IMPL_ENDPOINT_IPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include <cstring>
-#if !defined(ASIO_NO_IOSTREAM)
-# include <sstream>
-#endif // !defined(ASIO_NO_IOSTREAM)
-#include "asio/detail/socket_ops.hpp"
-#include "asio/detail/throw_error.hpp"
-#include "asio/error.hpp"
-#include "asio/ip/detail/endpoint.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace ip {
-namespace detail {
-
-endpoint::endpoint()
-  : data_()
-{
-  data_.v4.sin_family = ASIO_OS_DEF(AF_INET);
-  data_.v4.sin_port = 0;
-  data_.v4.sin_addr.s_addr = ASIO_OS_DEF(INADDR_ANY);
-}
-
-endpoint::endpoint(int family, unsigned short port_num)
-  : data_()
-{
-  using namespace std; // For memcpy.
-  if (family == ASIO_OS_DEF(AF_INET))
-  {
-    data_.v4.sin_family = ASIO_OS_DEF(AF_INET);
-    data_.v4.sin_port =
-      asio::detail::socket_ops::host_to_network_short(port_num);
-    data_.v4.sin_addr.s_addr = ASIO_OS_DEF(INADDR_ANY);
-  }
-  else
-  {
-    data_.v6.sin6_family = ASIO_OS_DEF(AF_INET6);
-    data_.v6.sin6_port =
-      asio::detail::socket_ops::host_to_network_short(port_num);
-    data_.v6.sin6_flowinfo = 0;
-    data_.v6.sin6_addr.s6_addr[0] = 0; data_.v6.sin6_addr.s6_addr[1] = 0;
-    data_.v6.sin6_addr.s6_addr[2] = 0, data_.v6.sin6_addr.s6_addr[3] = 0;
-    data_.v6.sin6_addr.s6_addr[4] = 0, data_.v6.sin6_addr.s6_addr[5] = 0;
-    data_.v6.sin6_addr.s6_addr[6] = 0, data_.v6.sin6_addr.s6_addr[7] = 0;
-    data_.v6.sin6_addr.s6_addr[8] = 0, data_.v6.sin6_addr.s6_addr[9] = 0;
-    data_.v6.sin6_addr.s6_addr[10] = 0, data_.v6.sin6_addr.s6_addr[11] = 0;
-    data_.v6.sin6_addr.s6_addr[12] = 0, data_.v6.sin6_addr.s6_addr[13] = 0;
-    data_.v6.sin6_addr.s6_addr[14] = 0, data_.v6.sin6_addr.s6_addr[15] = 0;
-    data_.v6.sin6_scope_id = 0;
-  }
-}
-
-endpoint::endpoint(const asio::ip::address& addr,
-    unsigned short port_num)
-  : data_()
-{
-  using namespace std; // For memcpy.
-  if (addr.is_v4())
-  {
-    data_.v4.sin_family = ASIO_OS_DEF(AF_INET);
-    data_.v4.sin_port =
-      asio::detail::socket_ops::host_to_network_short(port_num);
-    data_.v4.sin_addr.s_addr =
-      asio::detail::socket_ops::host_to_network_long(
-          static_cast<asio::detail::u_long_type>(
-            addr.to_v4().to_ulong()));
-  }
-  else
-  {
-    data_.v6.sin6_family = ASIO_OS_DEF(AF_INET6);
-    data_.v6.sin6_port =
-      asio::detail::socket_ops::host_to_network_short(port_num);
-    data_.v6.sin6_flowinfo = 0;
-    asio::ip::address_v6 v6_addr = addr.to_v6();
-    asio::ip::address_v6::bytes_type bytes = v6_addr.to_bytes();
-    memcpy(data_.v6.sin6_addr.s6_addr, bytes.data(), 16);
-    data_.v6.sin6_scope_id =
-      static_cast<asio::detail::u_long_type>(
-        v6_addr.scope_id());
-  }
-}
-
-void endpoint::resize(std::size_t new_size)
-{
-  if (new_size > sizeof(asio::detail::sockaddr_storage_type))
-  {
-    asio::error_code ec(asio::error::invalid_argument);
-    asio::detail::throw_error(ec);
-  }
-}
-
-unsigned short endpoint::port() const
-{
-  if (is_v4())
-  {
-    return asio::detail::socket_ops::network_to_host_short(
-        data_.v4.sin_port);
-  }
-  else
-  {
-    return asio::detail::socket_ops::network_to_host_short(
-        data_.v6.sin6_port);
-  }
-}
-
-void endpoint::port(unsigned short port_num)
-{
-  if (is_v4())
-  {
-    data_.v4.sin_port
-      = asio::detail::socket_ops::host_to_network_short(port_num);
-  }
-  else
-  {
-    data_.v6.sin6_port
-      = asio::detail::socket_ops::host_to_network_short(port_num);
-  }
-}
-
-asio::ip::address endpoint::address() const
-{
-  using namespace std; // For memcpy.
-  if (is_v4())
-  {
-    return asio::ip::address_v4(
-        asio::detail::socket_ops::network_to_host_long(
-          data_.v4.sin_addr.s_addr));
-  }
-  else
-  {
-    asio::ip::address_v6::bytes_type bytes;
-#if defined(ASIO_HAS_STD_ARRAY)
-    memcpy(bytes.data(), data_.v6.sin6_addr.s6_addr, 16);
-#else // defined(ASIO_HAS_STD_ARRAY)
-    memcpy(bytes.elems, data_.v6.sin6_addr.s6_addr, 16);
-#endif // defined(ASIO_HAS_STD_ARRAY)
-    return asio::ip::address_v6(bytes, data_.v6.sin6_scope_id);
-  }
-}
-
-void endpoint::address(const asio::ip::address& addr)
-{
-  endpoint tmp_endpoint(addr, port());
-  data_ = tmp_endpoint.data_;
-}
-
-bool operator==(const endpoint& e1, const endpoint& e2)
-{
-  return e1.address() == e2.address() && e1.port() == e2.port();
-}
-
-bool operator<(const endpoint& e1, const endpoint& e2)
-{
-  if (e1.address() < e2.address())
-    return true;
-  if (e1.address() != e2.address())
-    return false;
-  return e1.port() < e2.port();
-}
-
-#if !defined(ASIO_NO_IOSTREAM)
-std::string endpoint::to_string(asio::error_code& ec) const
-{
-  std::string a = address().to_string(ec);
-  if (ec)
-    return std::string();
-
-  std::ostringstream tmp_os;
-  tmp_os.imbue(std::locale::classic());
-  if (is_v4())
-    tmp_os << a;
-  else
-    tmp_os << '[' << a << ']';
-  tmp_os << ':' << port();
-
-  return tmp_os.str();
-}
-#endif // !defined(ASIO_NO_IOSTREAM)
-
-} // namespace detail
-} // namespace ip
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_IP_DETAIL_IMPL_ENDPOINT_IPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ip/detail/socket_option.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ip/detail/socket_option.hpp
deleted file mode 100644
index 1619ff2b95ae..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ip/detail/socket_option.hpp
+++ /dev/null
@@ -1,569 +0,0 @@
-//
-// detail/socket_option.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_IP_DETAIL_SOCKET_OPTION_HPP
-#define ASIO_IP_DETAIL_SOCKET_OPTION_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include <cstddef>
-#include <cstring>
-#include <stdexcept>
-#include "asio/detail/socket_ops.hpp"
-#include "asio/detail/socket_types.hpp"
-#include "asio/detail/throw_exception.hpp"
-#include "asio/ip/address.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace ip {
-namespace detail {
-namespace socket_option {
-
-// Helper template for implementing multicast enable loopback options.
-template <int IPv4_Level, int IPv4_Name, int IPv6_Level, int IPv6_Name>
-class multicast_enable_loopback
-{
-public:
-#if defined(__sun) || defined(__osf__)
-  typedef unsigned char ipv4_value_type;
-  typedef unsigned char ipv6_value_type;
-#elif defined(_AIX) || defined(__hpux) || defined(__QNXNTO__) 
-  typedef unsigned char ipv4_value_type;
-  typedef unsigned int ipv6_value_type;
-#else
-  typedef int ipv4_value_type;
-  typedef int ipv6_value_type;
-#endif
-
-  // Default constructor.
-  multicast_enable_loopback()
-    : ipv4_value_(0),
-      ipv6_value_(0)
-  {
-  }
-
-  // Construct with a specific option value.
-  explicit multicast_enable_loopback(bool v)
-    : ipv4_value_(v ? 1 : 0),
-      ipv6_value_(v ? 1 : 0)
-  {
-  }
-
-  // Set the value of the boolean.
-  multicast_enable_loopback& operator=(bool v)
-  {
-    ipv4_value_ = v ? 1 : 0;
-    ipv6_value_ = v ? 1 : 0;
-    return *this;
-  }
-
-  // Get the current value of the boolean.
-  bool value() const
-  {
-    return !!ipv4_value_;
-  }
-
-  // Convert to bool.
-  operator bool() const
-  {
-    return !!ipv4_value_;
-  }
-
-  // Test for false.
-  bool operator!() const
-  {
-    return !ipv4_value_;
-  }
-
-  // Get the level of the socket option.
-  template <typename Protocol>
-  int level(const Protocol& protocol) const
-  {
-    if (protocol.family() == PF_INET6)
-      return IPv6_Level;
-    return IPv4_Level;
-  }
-
-  // Get the name of the socket option.
-  template <typename Protocol>
-  int name(const Protocol& protocol) const
-  {
-    if (protocol.family() == PF_INET6)
-      return IPv6_Name;
-    return IPv4_Name;
-  }
-
-  // Get the address of the boolean data.
-  template <typename Protocol>
-  void* data(const Protocol& protocol)
-  {
-    if (protocol.family() == PF_INET6)
-      return &ipv6_value_;
-    return &ipv4_value_;
-  }
-
-  // Get the address of the boolean data.
-  template <typename Protocol>
-  const void* data(const Protocol& protocol) const
-  {
-    if (protocol.family() == PF_INET6)
-      return &ipv6_value_;
-    return &ipv4_value_;
-  }
-
-  // Get the size of the boolean data.
-  template <typename Protocol>
-  std::size_t size(const Protocol& protocol) const
-  {
-    if (protocol.family() == PF_INET6)
-      return sizeof(ipv6_value_);
-    return sizeof(ipv4_value_);
-  }
-
-  // Set the size of the boolean data.
-  template <typename Protocol>
-  void resize(const Protocol& protocol, std::size_t s)
-  {
-    if (protocol.family() == PF_INET6)
-    {
-      if (s != sizeof(ipv6_value_))
-      {
-        std::length_error ex("multicast_enable_loopback socket option resize");
-        asio::detail::throw_exception(ex);
-      }
-      ipv4_value_ = ipv6_value_ ? 1 : 0;
-    }
-    else
-    {
-      if (s != sizeof(ipv4_value_))
-      {
-        std::length_error ex("multicast_enable_loopback socket option resize");
-        asio::detail::throw_exception(ex);
-      }
-      ipv6_value_ = ipv4_value_ ? 1 : 0;
-    }
-  }
-
-private:
-  ipv4_value_type ipv4_value_;
-  ipv6_value_type ipv6_value_;
-};
-
-// Helper template for implementing unicast hops options.
-template <int IPv4_Level, int IPv4_Name, int IPv6_Level, int IPv6_Name>
-class unicast_hops
-{
-public:
-  // Default constructor.
-  unicast_hops()
-    : value_(0)
-  {
-  }
-
-  // Construct with a specific option value.
-  explicit unicast_hops(int v)
-    : value_(v)
-  {
-  }
-
-  // Set the value of the option.
-  unicast_hops& operator=(int v)
-  {
-    value_ = v;
-    return *this;
-  }
-
-  // Get the current value of the option.
-  int value() const
-  {
-    return value_;
-  }
-
-  // Get the level of the socket option.
-  template <typename Protocol>
-  int level(const Protocol& protocol) const
-  {
-    if (protocol.family() == PF_INET6)
-      return IPv6_Level;
-    return IPv4_Level;
-  }
-
-  // Get the name of the socket option.
-  template <typename Protocol>
-  int name(const Protocol& protocol) const
-  {
-    if (protocol.family() == PF_INET6)
-      return IPv6_Name;
-    return IPv4_Name;
-  }
-
-  // Get the address of the data.
-  template <typename Protocol>
-  int* data(const Protocol&)
-  {
-    return &value_;
-  }
-
-  // Get the address of the data.
-  template <typename Protocol>
-  const int* data(const Protocol&) const
-  {
-    return &value_;
-  }
-
-  // Get the size of the data.
-  template <typename Protocol>
-  std::size_t size(const Protocol&) const
-  {
-    return sizeof(value_);
-  }
-
-  // Set the size of the data.
-  template <typename Protocol>
-  void resize(const Protocol&, std::size_t s)
-  {
-    if (s != sizeof(value_))
-    {
-      std::length_error ex("unicast hops socket option resize");
-      asio::detail::throw_exception(ex);
-    }
-#if defined(__hpux)
-    if (value_ < 0)
-      value_ = value_ & 0xFF;
-#endif
-  }
-
-private:
-  int value_;
-};
-
-// Helper template for implementing multicast hops options.
-template <int IPv4_Level, int IPv4_Name, int IPv6_Level, int IPv6_Name>
-class multicast_hops
-{
-public:
-#if defined(ASIO_WINDOWS) && defined(UNDER_CE)
-  typedef int ipv4_value_type;
-#else
-  typedef unsigned char ipv4_value_type;
-#endif
-  typedef int ipv6_value_type;
-
-  // Default constructor.
-  multicast_hops()
-    : ipv4_value_(0),
-      ipv6_value_(0)
-  {
-  }
-
-  // Construct with a specific option value.
-  explicit multicast_hops(int v)
-  {
-    if (v < 0 || v > 255)
-    {
-      std::out_of_range ex("multicast hops value out of range");
-      asio::detail::throw_exception(ex);
-    }
-    ipv4_value_ = (ipv4_value_type)v;
-    ipv6_value_ = v;
-  }
-
-  // Set the value of the option.
-  multicast_hops& operator=(int v)
-  {
-    if (v < 0 || v > 255)
-    {
-      std::out_of_range ex("multicast hops value out of range");
-      asio::detail::throw_exception(ex);
-    }
-    ipv4_value_ = (ipv4_value_type)v;
-    ipv6_value_ = v;
-    return *this;
-  }
-
-  // Get the current value of the option.
-  int value() const
-  {
-    return ipv6_value_;
-  }
-
-  // Get the level of the socket option.
-  template <typename Protocol>
-  int level(const Protocol& protocol) const
-  {
-    if (protocol.family() == PF_INET6)
-      return IPv6_Level;
-    return IPv4_Level;
-  }
-
-  // Get the name of the socket option.
-  template <typename Protocol>
-  int name(const Protocol& protocol) const
-  {
-    if (protocol.family() == PF_INET6)
-      return IPv6_Name;
-    return IPv4_Name;
-  }
-
-  // Get the address of the data.
-  template <typename Protocol>
-  void* data(const Protocol& protocol)
-  {
-    if (protocol.family() == PF_INET6)
-      return &ipv6_value_;
-    return &ipv4_value_;
-  }
-
-  // Get the address of the data.
-  template <typename Protocol>
-  const void* data(const Protocol& protocol) const
-  {
-    if (protocol.family() == PF_INET6)
-      return &ipv6_value_;
-    return &ipv4_value_;
-  }
-
-  // Get the size of the data.
-  template <typename Protocol>
-  std::size_t size(const Protocol& protocol) const
-  {
-    if (protocol.family() == PF_INET6)
-      return sizeof(ipv6_value_);
-    return sizeof(ipv4_value_);
-  }
-
-  // Set the size of the data.
-  template <typename Protocol>
-  void resize(const Protocol& protocol, std::size_t s)
-  {
-    if (protocol.family() == PF_INET6)
-    {
-      if (s != sizeof(ipv6_value_))
-      {
-        std::length_error ex("multicast hops socket option resize");
-        asio::detail::throw_exception(ex);
-      }
-      if (ipv6_value_ < 0)
-        ipv4_value_ = 0;
-      else if (ipv6_value_ > 255)
-        ipv4_value_ = 255;
-      else
-        ipv4_value_ = (ipv4_value_type)ipv6_value_;
-    }
-    else
-    {
-      if (s != sizeof(ipv4_value_))
-      {
-        std::length_error ex("multicast hops socket option resize");
-        asio::detail::throw_exception(ex);
-      }
-      ipv6_value_ = ipv4_value_;
-    }
-  }
-
-private:
-  ipv4_value_type ipv4_value_;
-  ipv6_value_type ipv6_value_;
-};
-
-// Helper template for implementing ip_mreq-based options.
-template <int IPv4_Level, int IPv4_Name, int IPv6_Level, int IPv6_Name>
-class multicast_request
-{
-public:
-  // Default constructor.
-  multicast_request()
-    : ipv4_value_(), // Zero-initialisation gives the "any" address.
-      ipv6_value_() // Zero-initialisation gives the "any" address.
-  {
-  }
-
-  // Construct with multicast address only.
-  explicit multicast_request(const asio::ip::address& multicast_address)
-    : ipv4_value_(), // Zero-initialisation gives the "any" address.
-      ipv6_value_() // Zero-initialisation gives the "any" address.
-  {
-    if (multicast_address.is_v6())
-    {
-      using namespace std; // For memcpy.
-      asio::ip::address_v6 ipv6_address = multicast_address.to_v6();
-      asio::ip::address_v6::bytes_type bytes = ipv6_address.to_bytes();
-      memcpy(ipv6_value_.ipv6mr_multiaddr.s6_addr, bytes.data(), 16);
-      ipv6_value_.ipv6mr_interface = ipv6_address.scope_id();
-    }
-    else
-    {
-      ipv4_value_.imr_multiaddr.s_addr =
-        asio::detail::socket_ops::host_to_network_long(
-            multicast_address.to_v4().to_ulong());
-      ipv4_value_.imr_interface.s_addr =
-        asio::detail::socket_ops::host_to_network_long(
-            asio::ip::address_v4::any().to_ulong());
-    }
-  }
-
-  // Construct with multicast address and IPv4 address specifying an interface.
-  explicit multicast_request(
-      const asio::ip::address_v4& multicast_address,
-      const asio::ip::address_v4& network_interface
-        = asio::ip::address_v4::any())
-    : ipv6_value_() // Zero-initialisation gives the "any" address.
-  {
-    ipv4_value_.imr_multiaddr.s_addr =
-      asio::detail::socket_ops::host_to_network_long(
-          multicast_address.to_ulong());
-    ipv4_value_.imr_interface.s_addr =
-      asio::detail::socket_ops::host_to_network_long(
-          network_interface.to_ulong());
-  }
-
-  // Construct with multicast address and IPv6 network interface index.
-  explicit multicast_request(
-      const asio::ip::address_v6& multicast_address,
-      unsigned long network_interface = 0)
-    : ipv4_value_() // Zero-initialisation gives the "any" address.
-  {
-    using namespace std; // For memcpy.
-    asio::ip::address_v6::bytes_type bytes =
-      multicast_address.to_bytes();
-    memcpy(ipv6_value_.ipv6mr_multiaddr.s6_addr, bytes.data(), 16);
-    if (network_interface)
-      ipv6_value_.ipv6mr_interface = network_interface;
-    else
-      ipv6_value_.ipv6mr_interface = multicast_address.scope_id();
-  }
-
-  // Get the level of the socket option.
-  template <typename Protocol>
-  int level(const Protocol& protocol) const
-  {
-    if (protocol.family() == PF_INET6)
-      return IPv6_Level;
-    return IPv4_Level;
-  }
-
-  // Get the name of the socket option.
-  template <typename Protocol>
-  int name(const Protocol& protocol) const
-  {
-    if (protocol.family() == PF_INET6)
-      return IPv6_Name;
-    return IPv4_Name;
-  }
-
-  // Get the address of the option data.
-  template <typename Protocol>
-  const void* data(const Protocol& protocol) const
-  {
-    if (protocol.family() == PF_INET6)
-      return &ipv6_value_;
-    return &ipv4_value_;
-  }
-
-  // Get the size of the option data.
-  template <typename Protocol>
-  std::size_t size(const Protocol& protocol) const
-  {
-    if (protocol.family() == PF_INET6)
-      return sizeof(ipv6_value_);
-    return sizeof(ipv4_value_);
-  }
-
-private:
-  asio::detail::in4_mreq_type ipv4_value_;
-  asio::detail::in6_mreq_type ipv6_value_;
-};
-
-// Helper template for implementing options that specify a network interface.
-template <int IPv4_Level, int IPv4_Name, int IPv6_Level, int IPv6_Name>
-class network_interface
-{
-public:
-  // Default constructor.
-  network_interface()
-  {
-    ipv4_value_.s_addr =
-      asio::detail::socket_ops::host_to_network_long(
-          asio::ip::address_v4::any().to_ulong());
-    ipv6_value_ = 0;
-  }
-
-  // Construct with IPv4 interface.
-  explicit network_interface(const asio::ip::address_v4& ipv4_interface)
-  {
-    ipv4_value_.s_addr =
-      asio::detail::socket_ops::host_to_network_long(
-          ipv4_interface.to_ulong());
-    ipv6_value_ = 0;
-  }
-
-  // Construct with IPv6 interface.
-  explicit network_interface(unsigned int ipv6_interface)
-  {
-    ipv4_value_.s_addr =
-      asio::detail::socket_ops::host_to_network_long(
-          asio::ip::address_v4::any().to_ulong());
-    ipv6_value_ = ipv6_interface;
-  }
-
-  // Get the level of the socket option.
-  template <typename Protocol>
-  int level(const Protocol& protocol) const
-  {
-    if (protocol.family() == PF_INET6)
-      return IPv6_Level;
-    return IPv4_Level;
-  }
-
-  // Get the name of the socket option.
-  template <typename Protocol>
-  int name(const Protocol& protocol) const
-  {
-    if (protocol.family() == PF_INET6)
-      return IPv6_Name;
-    return IPv4_Name;
-  }
-
-  // Get the address of the option data.
-  template <typename Protocol>
-  const void* data(const Protocol& protocol) const
-  {
-    if (protocol.family() == PF_INET6)
-      return &ipv6_value_;
-    return &ipv4_value_;
-  }
-
-  // Get the size of the option data.
-  template <typename Protocol>
-  std::size_t size(const Protocol& protocol) const
-  {
-    if (protocol.family() == PF_INET6)
-      return sizeof(ipv6_value_);
-    return sizeof(ipv4_value_);
-  }
-
-private:
-  asio::detail::in4_addr_type ipv4_value_;
-  unsigned int ipv6_value_;
-};
-
-} // namespace socket_option
-} // namespace detail
-} // namespace ip
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_IP_DETAIL_SOCKET_OPTION_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ip/host_name.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ip/host_name.hpp
deleted file mode 100644
index db38b37de8e6..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ip/host_name.hpp
+++ /dev/null
@@ -1,42 +0,0 @@
-//
-// ip/host_name.hpp
-// ~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_IP_HOST_NAME_HPP
-#define ASIO_IP_HOST_NAME_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include <string>
-#include "asio/error_code.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace ip {
-
-/// Get the current host name.
-ASIO_DECL std::string host_name();
-
-/// Get the current host name.
-ASIO_DECL std::string host_name(asio::error_code& ec);
-
-} // namespace ip
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#if defined(ASIO_HEADER_ONLY)
-# include "asio/ip/impl/host_name.ipp"
-#endif // defined(ASIO_HEADER_ONLY)
-
-#endif // ASIO_IP_HOST_NAME_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ip/icmp.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ip/icmp.hpp
deleted file mode 100644
index 530affc122ec..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ip/icmp.hpp
+++ /dev/null
@@ -1,115 +0,0 @@
-//
-// ip/icmp.hpp
-// ~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_IP_ICMP_HPP
-#define ASIO_IP_ICMP_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include "asio/detail/socket_types.hpp"
-#include "asio/basic_raw_socket.hpp"
-#include "asio/ip/basic_endpoint.hpp"
-#include "asio/ip/basic_resolver.hpp"
-#include "asio/ip/basic_resolver_iterator.hpp"
-#include "asio/ip/basic_resolver_query.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace ip {
-
-/// Encapsulates the flags needed for ICMP.
-/**
- * The asio::ip::icmp class contains flags necessary for ICMP sockets.
- *
- * @par Thread Safety
- * @e Distinct @e objects: Safe.@n
- * @e Shared @e objects: Safe.
- *
- * @par Concepts:
- * Protocol, InternetProtocol.
- */
-class icmp
-{
-public:
-  /// The type of a ICMP endpoint.
-  typedef basic_endpoint<icmp> endpoint;
-
-  /// Construct to represent the IPv4 ICMP protocol.
-  static icmp v4()
-  {
-    return icmp(ASIO_OS_DEF(IPPROTO_ICMP),
-        ASIO_OS_DEF(AF_INET));
-  }
-
-  /// Construct to represent the IPv6 ICMP protocol.
-  static icmp v6()
-  {
-    return icmp(ASIO_OS_DEF(IPPROTO_ICMPV6),
-        ASIO_OS_DEF(AF_INET6));
-  }
-
-  /// Obtain an identifier for the type of the protocol.
-  int type() const
-  {
-    return ASIO_OS_DEF(SOCK_RAW);
-  }
-
-  /// Obtain an identifier for the protocol.
-  int protocol() const
-  {
-    return protocol_;
-  }
-
-  /// Obtain an identifier for the protocol family.
-  int family() const
-  {
-    return family_;
-  }
-
-  /// The ICMP socket type.
-  typedef basic_raw_socket<icmp> socket;
-
-  /// The ICMP resolver type.
-  typedef basic_resolver<icmp> resolver;
-
-  /// Compare two protocols for equality.
-  friend bool operator==(const icmp& p1, const icmp& p2)
-  {
-    return p1.protocol_ == p2.protocol_ && p1.family_ == p2.family_;
-  }
-
-  /// Compare two protocols for inequality.
-  friend bool operator!=(const icmp& p1, const icmp& p2)
-  {
-    return p1.protocol_ != p2.protocol_ || p1.family_ != p2.family_;
-  }
-
-private:
-  // Construct with a specific family.
-  explicit icmp(int protocol_id, int protocol_family)
-    : protocol_(protocol_id),
-      family_(protocol_family)
-  {
-  }
-
-  int protocol_;
-  int family_;
-};
-
-} // namespace ip
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_IP_ICMP_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ip/impl/address.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ip/impl/address.hpp
deleted file mode 100644
index b5600167fe7f..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ip/impl/address.hpp
+++ /dev/null
@@ -1,53 +0,0 @@
-//
-// ip/impl/address.hpp
-// ~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_IP_IMPL_ADDRESS_HPP
-#define ASIO_IP_IMPL_ADDRESS_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#if !defined(ASIO_NO_IOSTREAM)
-
-#include "asio/detail/throw_error.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace ip {
-
-template <typename Elem, typename Traits>
-std::basic_ostream<Elem, Traits>& operator<<(
-    std::basic_ostream<Elem, Traits>& os, const address& addr)
-{
-  asio::error_code ec;
-  std::string s = addr.to_string(ec);
-  if (ec)
-  {
-    if (os.exceptions() & std::basic_ostream<Elem, Traits>::failbit)
-      asio::detail::throw_error(ec);
-    else
-      os.setstate(std::basic_ostream<Elem, Traits>::failbit);
-  }
-  else
-    for (std::string::iterator i = s.begin(); i != s.end(); ++i)
-      os << os.widen(*i);
-  return os;
-}
-
-} // namespace ip
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // !defined(ASIO_NO_IOSTREAM)
-
-#endif // ASIO_IP_IMPL_ADDRESS_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ip/impl/address.ipp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ip/impl/address.ipp
deleted file mode 100644
index a67b1b69f9bf..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ip/impl/address.ipp
+++ /dev/null
@@ -1,226 +0,0 @@
-//
-// ip/impl/address.ipp
-// ~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_IP_IMPL_ADDRESS_IPP
-#define ASIO_IP_IMPL_ADDRESS_IPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include <typeinfo>
-#include "asio/detail/throw_error.hpp"
-#include "asio/detail/throw_exception.hpp"
-#include "asio/error.hpp"
-#include "asio/ip/address.hpp"
-#include "asio/system_error.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace ip {
-
-address::address()
-  : type_(ipv4),
-    ipv4_address_(),
-    ipv6_address_()
-{
-}
-
-address::address(const asio::ip::address_v4& ipv4_address)
-  : type_(ipv4),
-    ipv4_address_(ipv4_address),
-    ipv6_address_()
-{
-}
-
-address::address(const asio::ip::address_v6& ipv6_address)
-  : type_(ipv6),
-    ipv4_address_(),
-    ipv6_address_(ipv6_address)
-{
-}
-
-address::address(const address& other)
-  : type_(other.type_),
-    ipv4_address_(other.ipv4_address_),
-    ipv6_address_(other.ipv6_address_)
-{
-}
-
-#if defined(ASIO_HAS_MOVE)
-address::address(address&& other)
-  : type_(other.type_),
-    ipv4_address_(other.ipv4_address_),
-    ipv6_address_(other.ipv6_address_)
-{
-}
-#endif // defined(ASIO_HAS_MOVE)
-
-address& address::operator=(const address& other)
-{
-  type_ = other.type_;
-  ipv4_address_ = other.ipv4_address_;
-  ipv6_address_ = other.ipv6_address_;
-  return *this;
-}
-
-#if defined(ASIO_HAS_MOVE)
-address& address::operator=(address&& other)
-{
-  type_ = other.type_;
-  ipv4_address_ = other.ipv4_address_;
-  ipv6_address_ = other.ipv6_address_;
-  return *this;
-}
-#endif // defined(ASIO_HAS_MOVE)
-
-address& address::operator=(const asio::ip::address_v4& ipv4_address)
-{
-  type_ = ipv4;
-  ipv4_address_ = ipv4_address;
-  ipv6_address_ = asio::ip::address_v6();
-  return *this;
-}
-
-address& address::operator=(const asio::ip::address_v6& ipv6_address)
-{
-  type_ = ipv6;
-  ipv4_address_ = asio::ip::address_v4();
-  ipv6_address_ = ipv6_address;
-  return *this;
-}
-
-asio::ip::address_v4 address::to_v4() const
-{
-  if (type_ != ipv4)
-  {
-    std::bad_cast ex;
-    asio::detail::throw_exception(ex);
-  }
-  return ipv4_address_;
-}
-
-asio::ip::address_v6 address::to_v6() const
-{
-  if (type_ != ipv6)
-  {
-    std::bad_cast ex;
-    asio::detail::throw_exception(ex);
-  }
-  return ipv6_address_;
-}
-
-std::string address::to_string() const
-{
-  if (type_ == ipv6)
-    return ipv6_address_.to_string();
-  return ipv4_address_.to_string();
-}
-
-std::string address::to_string(asio::error_code& ec) const
-{
-  if (type_ == ipv6)
-    return ipv6_address_.to_string(ec);
-  return ipv4_address_.to_string(ec);
-}
-
-address address::from_string(const char* str)
-{
-  asio::error_code ec;
-  address addr = from_string(str, ec);
-  asio::detail::throw_error(ec);
-  return addr;
-}
-
-address address::from_string(const char* str, asio::error_code& ec)
-{
-  asio::ip::address_v6 ipv6_address =
-    asio::ip::address_v6::from_string(str, ec);
-  if (!ec)
-  {
-    address tmp;
-    tmp.type_ = ipv6;
-    tmp.ipv6_address_ = ipv6_address;
-    return tmp;
-  }
-
-  asio::ip::address_v4 ipv4_address =
-    asio::ip::address_v4::from_string(str, ec);
-  if (!ec)
-  {
-    address tmp;
-    tmp.type_ = ipv4;
-    tmp.ipv4_address_ = ipv4_address;
-    return tmp;
-  }
-
-  return address();
-}
-
-address address::from_string(const std::string& str)
-{
-  return from_string(str.c_str());
-}
-
-address address::from_string(const std::string& str,
-    asio::error_code& ec)
-{
-  return from_string(str.c_str(), ec);
-}
-
-bool address::is_loopback() const
-{
-  return (type_ == ipv4)
-    ? ipv4_address_.is_loopback()
-    : ipv6_address_.is_loopback();
-}
-
-bool address::is_unspecified() const
-{
-  return (type_ == ipv4)
-    ? ipv4_address_.is_unspecified()
-    : ipv6_address_.is_unspecified();
-}
-
-bool address::is_multicast() const
-{
-  return (type_ == ipv4)
-    ? ipv4_address_.is_multicast()
-    : ipv6_address_.is_multicast();
-}
-
-bool operator==(const address& a1, const address& a2)
-{
-  if (a1.type_ != a2.type_)
-    return false;
-  if (a1.type_ == address::ipv6)
-    return a1.ipv6_address_ == a2.ipv6_address_;
-  return a1.ipv4_address_ == a2.ipv4_address_;
-}
-
-bool operator<(const address& a1, const address& a2)
-{
-  if (a1.type_ < a2.type_)
-    return true;
-  if (a1.type_ > a2.type_)
-    return false;
-  if (a1.type_ == address::ipv6)
-    return a1.ipv6_address_ < a2.ipv6_address_;
-  return a1.ipv4_address_ < a2.ipv4_address_;
-}
-
-} // namespace ip
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_IP_IMPL_ADDRESS_IPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ip/impl/address_v4.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ip/impl/address_v4.hpp
deleted file mode 100644
index d82bb59ab7ac..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ip/impl/address_v4.hpp
+++ /dev/null
@@ -1,53 +0,0 @@
-//
-// ip/impl/address_v4.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_IP_IMPL_ADDRESS_V4_HPP
-#define ASIO_IP_IMPL_ADDRESS_V4_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#if !defined(ASIO_NO_IOSTREAM)
-
-#include "asio/detail/throw_error.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace ip {
-
-template <typename Elem, typename Traits>
-std::basic_ostream<Elem, Traits>& operator<<(
-    std::basic_ostream<Elem, Traits>& os, const address_v4& addr)
-{
-  asio::error_code ec;
-  std::string s = addr.to_string(ec);
-  if (ec)
-  {
-    if (os.exceptions() & std::basic_ostream<Elem, Traits>::failbit)
-      asio::detail::throw_error(ec);
-    else
-      os.setstate(std::basic_ostream<Elem, Traits>::failbit);
-  }
-  else
-    for (std::string::iterator i = s.begin(); i != s.end(); ++i)
-      os << os.widen(*i);
-  return os;
-}
-
-} // namespace ip
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // !defined(ASIO_NO_IOSTREAM)
-
-#endif // ASIO_IP_IMPL_ADDRESS_V4_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ip/impl/address_v4.ipp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ip/impl/address_v4.ipp
deleted file mode 100644
index 112ecbd3dfb3..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ip/impl/address_v4.ipp
+++ /dev/null
@@ -1,178 +0,0 @@
-//
-// ip/impl/address_v4.ipp
-// ~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_IP_IMPL_ADDRESS_V4_IPP
-#define ASIO_IP_IMPL_ADDRESS_V4_IPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include <climits>
-#include <stdexcept>
-#include "asio/error.hpp"
-#include "asio/detail/socket_ops.hpp"
-#include "asio/detail/throw_error.hpp"
-#include "asio/detail/throw_exception.hpp"
-#include "asio/ip/address_v4.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace ip {
-
-address_v4::address_v4(const address_v4::bytes_type& bytes)
-{
-#if UCHAR_MAX > 0xFF
-  if (bytes[0] > 0xFF || bytes[1] > 0xFF
-      || bytes[2] > 0xFF || bytes[3] > 0xFF)
-  {
-    std::out_of_range ex("address_v4 from bytes_type");
-    asio::detail::throw_exception(ex);
-  }
-#endif // UCHAR_MAX > 0xFF
-
-  using namespace std; // For memcpy.
-  memcpy(&addr_.s_addr, bytes.data(), 4);
-}
-
-address_v4::address_v4(unsigned long addr)
-{
-#if ULONG_MAX > 0xFFFFFFFF
-  if (addr > 0xFFFFFFFF)
-  {
-    std::out_of_range ex("address_v4 from unsigned long");
-    asio::detail::throw_exception(ex);
-  }
-#endif // ULONG_MAX > 0xFFFFFFFF
-
-  addr_.s_addr = asio::detail::socket_ops::host_to_network_long(
-      static_cast<asio::detail::u_long_type>(addr));
-}
-
-address_v4::bytes_type address_v4::to_bytes() const
-{
-  using namespace std; // For memcpy.
-  bytes_type bytes;
-#if defined(ASIO_HAS_STD_ARRAY)
-  memcpy(bytes.data(), &addr_.s_addr, 4);
-#else // defined(ASIO_HAS_STD_ARRAY)
-  memcpy(bytes.elems, &addr_.s_addr, 4);
-#endif // defined(ASIO_HAS_STD_ARRAY)
-  return bytes;
-}
-
-unsigned long address_v4::to_ulong() const
-{
-  return asio::detail::socket_ops::network_to_host_long(addr_.s_addr);
-}
-
-std::string address_v4::to_string() const
-{
-  asio::error_code ec;
-  std::string addr = to_string(ec);
-  asio::detail::throw_error(ec);
-  return addr;
-}
-
-std::string address_v4::to_string(asio::error_code& ec) const
-{
-  char addr_str[asio::detail::max_addr_v4_str_len];
-  const char* addr =
-    asio::detail::socket_ops::inet_ntop(
-        ASIO_OS_DEF(AF_INET), &addr_, addr_str,
-        asio::detail::max_addr_v4_str_len, 0, ec);
-  if (addr == 0)
-    return std::string();
-  return addr;
-}
-
-address_v4 address_v4::from_string(const char* str)
-{
-  asio::error_code ec;
-  address_v4 addr = from_string(str, ec);
-  asio::detail::throw_error(ec);
-  return addr;
-}
-
-address_v4 address_v4::from_string(
-    const char* str, asio::error_code& ec)
-{
-  address_v4 tmp;
-  if (asio::detail::socket_ops::inet_pton(
-        ASIO_OS_DEF(AF_INET), str, &tmp.addr_, 0, ec) <= 0)
-    return address_v4();
-  return tmp;
-}
-
-address_v4 address_v4::from_string(const std::string& str)
-{
-  return from_string(str.c_str());
-}
-
-address_v4 address_v4::from_string(
-    const std::string& str, asio::error_code& ec)
-{
-  return from_string(str.c_str(), ec);
-}
-
-bool address_v4::is_loopback() const
-{
-  return (to_ulong() & 0xFF000000) == 0x7F000000;
-}
-
-bool address_v4::is_unspecified() const
-{
-  return to_ulong() == 0;
-}
-
-bool address_v4::is_class_a() const
-{
-  return (to_ulong() & 0x80000000) == 0;
-}
-
-bool address_v4::is_class_b() const
-{
-  return (to_ulong() & 0xC0000000) == 0x80000000;
-}
-
-bool address_v4::is_class_c() const
-{
-  return (to_ulong() & 0xE0000000) == 0xC0000000;
-}
-
-bool address_v4::is_multicast() const
-{
-  return (to_ulong() & 0xF0000000) == 0xE0000000;
-}
-
-address_v4 address_v4::broadcast(const address_v4& addr, const address_v4& mask)
-{
-  return address_v4(addr.to_ulong() | (mask.to_ulong() ^ 0xFFFFFFFF));
-}
-
-address_v4 address_v4::netmask(const address_v4& addr)
-{
-  if (addr.is_class_a())
-    return address_v4(0xFF000000);
-  if (addr.is_class_b())
-    return address_v4(0xFFFF0000);
-  if (addr.is_class_c())
-    return address_v4(0xFFFFFF00);
-  return address_v4(0xFFFFFFFF);
-}
-
-} // namespace ip
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_IP_IMPL_ADDRESS_V4_IPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ip/impl/address_v6.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ip/impl/address_v6.hpp
deleted file mode 100644
index 21455af631ac..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ip/impl/address_v6.hpp
+++ /dev/null
@@ -1,53 +0,0 @@
-//
-// ip/impl/address_v6.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_IP_IMPL_ADDRESS_V6_HPP
-#define ASIO_IP_IMPL_ADDRESS_V6_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#if !defined(ASIO_NO_IOSTREAM)
-
-#include "asio/detail/throw_error.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace ip {
-
-template <typename Elem, typename Traits>
-std::basic_ostream<Elem, Traits>& operator<<(
-    std::basic_ostream<Elem, Traits>& os, const address_v6& addr)
-{
-  asio::error_code ec;
-  std::string s = addr.to_string(ec);
-  if (ec)
-  {
-    if (os.exceptions() & std::basic_ostream<Elem, Traits>::failbit)
-      asio::detail::throw_error(ec);
-    else
-      os.setstate(std::basic_ostream<Elem, Traits>::failbit);
-  }
-  else
-    for (std::string::iterator i = s.begin(); i != s.end(); ++i)
-      os << os.widen(*i);
-  return os;
-}
-
-} // namespace ip
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // !defined(ASIO_NO_IOSTREAM)
-
-#endif // ASIO_IP_IMPL_ADDRESS_V6_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ip/impl/address_v6.ipp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ip/impl/address_v6.ipp
deleted file mode 100644
index 996420a50e2b..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ip/impl/address_v6.ipp
+++ /dev/null
@@ -1,298 +0,0 @@
-//
-// ip/impl/address_v6.ipp
-// ~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_IP_IMPL_ADDRESS_V6_IPP
-#define ASIO_IP_IMPL_ADDRESS_V6_IPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include <cstring>
-#include <stdexcept>
-#include <typeinfo>
-#include "asio/detail/socket_ops.hpp"
-#include "asio/detail/throw_error.hpp"
-#include "asio/detail/throw_exception.hpp"
-#include "asio/error.hpp"
-#include "asio/ip/address_v6.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace ip {
-
-address_v6::address_v6()
-  : addr_(),
-    scope_id_(0)
-{
-}
-
-address_v6::address_v6(const address_v6::bytes_type& bytes,
-    unsigned long scope)
-  : scope_id_(scope)
-{
-#if UCHAR_MAX > 0xFF
-  for (std::size_t i = 0; i < bytes.size(); ++i)
-  {
-    if (bytes[i] > 0xFF)
-    {
-      std::out_of_range ex("address_v6 from bytes_type");
-      asio::detail::throw_exception(ex);
-    }
-  }
-#endif // UCHAR_MAX > 0xFF
-
-  using namespace std; // For memcpy.
-  memcpy(addr_.s6_addr, bytes.data(), 16);
-}
-
-address_v6::address_v6(const address_v6& other)
-  : addr_(other.addr_),
-    scope_id_(other.scope_id_)
-{
-}
-
-#if defined(ASIO_HAS_MOVE)
-address_v6::address_v6(address_v6&& other)
-  : addr_(other.addr_),
-    scope_id_(other.scope_id_)
-{
-}
-#endif // defined(ASIO_HAS_MOVE)
-
-address_v6& address_v6::operator=(const address_v6& other)
-{
-  addr_ = other.addr_;
-  scope_id_ = other.scope_id_;
-  return *this;
-}
-
-#if defined(ASIO_HAS_MOVE)
-address_v6& address_v6::operator=(address_v6&& other)
-{
-  addr_ = other.addr_;
-  scope_id_ = other.scope_id_;
-  return *this;
-}
-#endif // defined(ASIO_HAS_MOVE)
-
-address_v6::bytes_type address_v6::to_bytes() const
-{
-  using namespace std; // For memcpy.
-  bytes_type bytes;
-#if defined(ASIO_HAS_STD_ARRAY)
-  memcpy(bytes.data(), addr_.s6_addr, 16);
-#else // defined(ASIO_HAS_STD_ARRAY)
-  memcpy(bytes.elems, addr_.s6_addr, 16);
-#endif // defined(ASIO_HAS_STD_ARRAY)
-  return bytes;
-}
-
-std::string address_v6::to_string() const
-{
-  asio::error_code ec;
-  std::string addr = to_string(ec);
-  asio::detail::throw_error(ec);
-  return addr;
-}
-
-std::string address_v6::to_string(asio::error_code& ec) const
-{
-  char addr_str[asio::detail::max_addr_v6_str_len];
-  const char* addr =
-    asio::detail::socket_ops::inet_ntop(
-        ASIO_OS_DEF(AF_INET6), &addr_, addr_str,
-        asio::detail::max_addr_v6_str_len, scope_id_, ec);
-  if (addr == 0)
-    return std::string();
-  return addr;
-}
-
-address_v6 address_v6::from_string(const char* str)
-{
-  asio::error_code ec;
-  address_v6 addr = from_string(str, ec);
-  asio::detail::throw_error(ec);
-  return addr;
-}
-
-address_v6 address_v6::from_string(
-    const char* str, asio::error_code& ec)
-{
-  address_v6 tmp;
-  if (asio::detail::socket_ops::inet_pton(
-        ASIO_OS_DEF(AF_INET6), str, &tmp.addr_, &tmp.scope_id_, ec) <= 0)
-    return address_v6();
-  return tmp;
-}
-
-address_v6 address_v6::from_string(const std::string& str)
-{
-  return from_string(str.c_str());
-}
-
-address_v6 address_v6::from_string(
-    const std::string& str, asio::error_code& ec)
-{
-  return from_string(str.c_str(), ec);
-}
-
-address_v4 address_v6::to_v4() const
-{
-  if (!is_v4_mapped() && !is_v4_compatible())
-  {
-    std::bad_cast ex;
-    asio::detail::throw_exception(ex);
-  }
-
-  address_v4::bytes_type v4_bytes = { { addr_.s6_addr[12],
-    addr_.s6_addr[13], addr_.s6_addr[14], addr_.s6_addr[15] } };
-  return address_v4(v4_bytes);
-}
-
-bool address_v6::is_loopback() const
-{
-  return ((addr_.s6_addr[0] == 0) && (addr_.s6_addr[1] == 0)
-      && (addr_.s6_addr[2] == 0) && (addr_.s6_addr[3] == 0)
-      && (addr_.s6_addr[4] == 0) && (addr_.s6_addr[5] == 0)
-      && (addr_.s6_addr[6] == 0) && (addr_.s6_addr[7] == 0)
-      && (addr_.s6_addr[8] == 0) && (addr_.s6_addr[9] == 0)
-      && (addr_.s6_addr[10] == 0) && (addr_.s6_addr[11] == 0)
-      && (addr_.s6_addr[12] == 0) && (addr_.s6_addr[13] == 0)
-      && (addr_.s6_addr[14] == 0) && (addr_.s6_addr[15] == 1));
-}
-
-bool address_v6::is_unspecified() const
-{
-  return ((addr_.s6_addr[0] == 0) && (addr_.s6_addr[1] == 0)
-      && (addr_.s6_addr[2] == 0) && (addr_.s6_addr[3] == 0)
-      && (addr_.s6_addr[4] == 0) && (addr_.s6_addr[5] == 0)
-      && (addr_.s6_addr[6] == 0) && (addr_.s6_addr[7] == 0)
-      && (addr_.s6_addr[8] == 0) && (addr_.s6_addr[9] == 0)
-      && (addr_.s6_addr[10] == 0) && (addr_.s6_addr[11] == 0)
-      && (addr_.s6_addr[12] == 0) && (addr_.s6_addr[13] == 0)
-      && (addr_.s6_addr[14] == 0) && (addr_.s6_addr[15] == 0));
-}
-
-bool address_v6::is_link_local() const
-{
-  return ((addr_.s6_addr[0] == 0xfe) && ((addr_.s6_addr[1] & 0xc0) == 0x80));
-}
-
-bool address_v6::is_site_local() const
-{
-  return ((addr_.s6_addr[0] == 0xfe) && ((addr_.s6_addr[1] & 0xc0) == 0xc0));
-}
-
-bool address_v6::is_v4_mapped() const
-{
-  return ((addr_.s6_addr[0] == 0) && (addr_.s6_addr[1] == 0)
-      && (addr_.s6_addr[2] == 0) && (addr_.s6_addr[3] == 0)
-      && (addr_.s6_addr[4] == 0) && (addr_.s6_addr[5] == 0)
-      && (addr_.s6_addr[6] == 0) && (addr_.s6_addr[7] == 0)
-      && (addr_.s6_addr[8] == 0) && (addr_.s6_addr[9] == 0)
-      && (addr_.s6_addr[10] == 0xff) && (addr_.s6_addr[11] == 0xff));
-}
-
-bool address_v6::is_v4_compatible() const
-{
-  return ((addr_.s6_addr[0] == 0) && (addr_.s6_addr[1] == 0)
-      && (addr_.s6_addr[2] == 0) && (addr_.s6_addr[3] == 0)
-      && (addr_.s6_addr[4] == 0) && (addr_.s6_addr[5] == 0)
-      && (addr_.s6_addr[6] == 0) && (addr_.s6_addr[7] == 0)
-      && (addr_.s6_addr[8] == 0) && (addr_.s6_addr[9] == 0)
-      && (addr_.s6_addr[10] == 0) && (addr_.s6_addr[11] == 0)
-      && !((addr_.s6_addr[12] == 0)
-        && (addr_.s6_addr[13] == 0)
-        && (addr_.s6_addr[14] == 0)
-        && ((addr_.s6_addr[15] == 0) || (addr_.s6_addr[15] == 1))));
-}
-
-bool address_v6::is_multicast() const
-{
-  return (addr_.s6_addr[0] == 0xff);
-}
-
-bool address_v6::is_multicast_global() const
-{
-  return ((addr_.s6_addr[0] == 0xff) && ((addr_.s6_addr[1] & 0x0f) == 0x0e));
-}
-
-bool address_v6::is_multicast_link_local() const
-{
-  return ((addr_.s6_addr[0] == 0xff) && ((addr_.s6_addr[1] & 0x0f) == 0x02));
-}
-
-bool address_v6::is_multicast_node_local() const
-{
-  return ((addr_.s6_addr[0] == 0xff) && ((addr_.s6_addr[1] & 0x0f) == 0x01));
-}
-
-bool address_v6::is_multicast_org_local() const
-{
-  return ((addr_.s6_addr[0] == 0xff) && ((addr_.s6_addr[1] & 0x0f) == 0x08));
-}
-
-bool address_v6::is_multicast_site_local() const
-{
-  return ((addr_.s6_addr[0] == 0xff) && ((addr_.s6_addr[1] & 0x0f) == 0x05));
-}
-
-bool operator==(const address_v6& a1, const address_v6& a2)
-{
-  using namespace std; // For memcmp.
-  return memcmp(&a1.addr_, &a2.addr_,
-      sizeof(asio::detail::in6_addr_type)) == 0
-    && a1.scope_id_ == a2.scope_id_;
-}
-
-bool operator<(const address_v6& a1, const address_v6& a2)
-{
-  using namespace std; // For memcmp.
-  int memcmp_result = memcmp(&a1.addr_, &a2.addr_,
-      sizeof(asio::detail::in6_addr_type));
-  if (memcmp_result < 0)
-    return true;
-  if (memcmp_result > 0)
-    return false;
-  return a1.scope_id_ < a2.scope_id_;
-}
-
-address_v6 address_v6::loopback()
-{
-  address_v6 tmp;
-  tmp.addr_.s6_addr[15] = 1;
-  return tmp;
-}
-
-address_v6 address_v6::v4_mapped(const address_v4& addr)
-{
-  address_v4::bytes_type v4_bytes = addr.to_bytes();
-  bytes_type v6_bytes = { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xFF, 0xFF,
-    v4_bytes[0], v4_bytes[1], v4_bytes[2], v4_bytes[3] } };
-  return address_v6(v6_bytes);
-}
-
-address_v6 address_v6::v4_compatible(const address_v4& addr)
-{
-  address_v4::bytes_type v4_bytes = addr.to_bytes();
-  bytes_type v6_bytes = { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-    v4_bytes[0], v4_bytes[1], v4_bytes[2], v4_bytes[3] } };
-  return address_v6(v6_bytes);
-}
-
-} // namespace ip
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_IP_IMPL_ADDRESS_V6_IPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ip/impl/basic_endpoint.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ip/impl/basic_endpoint.hpp
deleted file mode 100644
index 569ce3f3bb73..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ip/impl/basic_endpoint.hpp
+++ /dev/null
@@ -1,55 +0,0 @@
-//
-// ip/impl/basic_endpoint.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_IP_IMPL_BASIC_ENDPOINT_HPP
-#define ASIO_IP_IMPL_BASIC_ENDPOINT_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#if !defined(ASIO_NO_IOSTREAM)
-
-#include "asio/detail/throw_error.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace ip {
-
-template <typename Elem, typename Traits, typename InternetProtocol>
-std::basic_ostream<Elem, Traits>& operator<<(
-    std::basic_ostream<Elem, Traits>& os,
-    const basic_endpoint<InternetProtocol>& endpoint)
-{
-  asio::ip::detail::endpoint tmp_ep(endpoint.address(), endpoint.port());
-  asio::error_code ec;
-  std::string s = tmp_ep.to_string(ec);
-  if (ec)
-  {
-    if (os.exceptions() & std::basic_ostream<Elem, Traits>::failbit)
-      asio::detail::throw_error(ec);
-    else
-      os.setstate(std::basic_ostream<Elem, Traits>::failbit);
-  }
-  else
-    for (std::string::iterator i = s.begin(); i != s.end(); ++i)
-      os << os.widen(*i);
-  return os;
-}
-
-} // namespace ip
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // !defined(ASIO_NO_IOSTREAM)
-
-#endif // ASIO_IP_IMPL_BASIC_ENDPOINT_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ip/impl/host_name.ipp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ip/impl/host_name.ipp
deleted file mode 100644
index ab2c445ac3fd..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ip/impl/host_name.ipp
+++ /dev/null
@@ -1,54 +0,0 @@
-//
-// ip/impl/host_name.ipp
-// ~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_IP_IMPL_HOST_NAME_IPP
-#define ASIO_IP_IMPL_HOST_NAME_IPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include "asio/detail/socket_ops.hpp"
-#include "asio/detail/throw_error.hpp"
-#include "asio/detail/winsock_init.hpp"
-#include "asio/ip/host_name.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace ip {
-
-std::string host_name()
-{
-  char name[1024];
-  asio::error_code ec;
-  if (asio::detail::socket_ops::gethostname(name, sizeof(name), ec) != 0)
-  {
-    asio::detail::throw_error(ec);
-    return std::string();
-  }
-  return std::string(name);
-}
-
-std::string host_name(asio::error_code& ec)
-{
-  char name[1024];
-  if (asio::detail::socket_ops::gethostname(name, sizeof(name), ec) != 0)
-    return std::string();
-  return std::string(name);
-}
-
-} // namespace ip
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_IP_IMPL_HOST_NAME_IPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ip/multicast.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ip/multicast.hpp
deleted file mode 100644
index 512ce9bd12f6..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ip/multicast.hpp
+++ /dev/null
@@ -1,191 +0,0 @@
-//
-// ip/multicast.hpp
-// ~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_IP_MULTICAST_HPP
-#define ASIO_IP_MULTICAST_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include <cstddef>
-#include "asio/ip/detail/socket_option.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace ip {
-namespace multicast {
-
-/// Socket option to join a multicast group on a specified interface.
-/**
- * Implements the IPPROTO_IP/IP_ADD_MEMBERSHIP socket option.
- *
- * @par Examples
- * Setting the option to join a multicast group:
- * @code
- * asio::ip::udp::socket socket(io_service); 
- * ...
- * asio::ip::address multicast_address =
- *   asio::ip::address::from_string("225.0.0.1");
- * asio::ip::multicast::join_group option(multicast_address);
- * socket.set_option(option);
- * @endcode
- *
- * @par Concepts:
- * SettableSocketOption.
- */
-#if defined(GENERATING_DOCUMENTATION)
-typedef implementation_defined join_group;
-#else
-typedef asio::ip::detail::socket_option::multicast_request<
-  ASIO_OS_DEF(IPPROTO_IP),
-  ASIO_OS_DEF(IP_ADD_MEMBERSHIP),
-  ASIO_OS_DEF(IPPROTO_IPV6),
-  ASIO_OS_DEF(IPV6_JOIN_GROUP)> join_group;
-#endif
-
-/// Socket option to leave a multicast group on a specified interface.
-/**
- * Implements the IPPROTO_IP/IP_DROP_MEMBERSHIP socket option.
- *
- * @par Examples
- * Setting the option to leave a multicast group:
- * @code
- * asio::ip::udp::socket socket(io_service); 
- * ...
- * asio::ip::address multicast_address =
- *   asio::ip::address::from_string("225.0.0.1");
- * asio::ip::multicast::leave_group option(multicast_address);
- * socket.set_option(option);
- * @endcode
- *
- * @par Concepts:
- * SettableSocketOption.
- */
-#if defined(GENERATING_DOCUMENTATION)
-typedef implementation_defined leave_group;
-#else
-typedef asio::ip::detail::socket_option::multicast_request<
-  ASIO_OS_DEF(IPPROTO_IP),
-  ASIO_OS_DEF(IP_DROP_MEMBERSHIP),
-  ASIO_OS_DEF(IPPROTO_IPV6),
-  ASIO_OS_DEF(IPV6_LEAVE_GROUP)> leave_group;
-#endif
-
-/// Socket option for local interface to use for outgoing multicast packets.
-/**
- * Implements the IPPROTO_IP/IP_MULTICAST_IF socket option.
- *
- * @par Examples
- * Setting the option:
- * @code
- * asio::ip::udp::socket socket(io_service); 
- * ...
- * asio::ip::address_v4 local_interface =
- *   asio::ip::address_v4::from_string("1.2.3.4");
- * asio::ip::multicast::outbound_interface option(local_interface);
- * socket.set_option(option);
- * @endcode
- *
- * @par Concepts:
- * SettableSocketOption.
- */
-#if defined(GENERATING_DOCUMENTATION)
-typedef implementation_defined outbound_interface;
-#else
-typedef asio::ip::detail::socket_option::network_interface<
-  ASIO_OS_DEF(IPPROTO_IP),
-  ASIO_OS_DEF(IP_MULTICAST_IF),
-  ASIO_OS_DEF(IPPROTO_IPV6),
-  ASIO_OS_DEF(IPV6_MULTICAST_IF)> outbound_interface;
-#endif
-
-/// Socket option for time-to-live associated with outgoing multicast packets.
-/**
- * Implements the IPPROTO_IP/IP_MULTICAST_TTL socket option.
- *
- * @par Examples
- * Setting the option:
- * @code
- * asio::ip::udp::socket socket(io_service); 
- * ...
- * asio::ip::multicast::hops option(4);
- * socket.set_option(option);
- * @endcode
- *
- * @par
- * Getting the current option value:
- * @code
- * asio::ip::udp::socket socket(io_service); 
- * ...
- * asio::ip::multicast::hops option;
- * socket.get_option(option);
- * int ttl = option.value();
- * @endcode
- *
- * @par Concepts:
- * GettableSocketOption, SettableSocketOption.
- */
-#if defined(GENERATING_DOCUMENTATION)
-typedef implementation_defined hops;
-#else
-typedef asio::ip::detail::socket_option::multicast_hops<
-  ASIO_OS_DEF(IPPROTO_IP),
-  ASIO_OS_DEF(IP_MULTICAST_TTL),
-  ASIO_OS_DEF(IPPROTO_IPV6),
-  ASIO_OS_DEF(IPV6_MULTICAST_HOPS)> hops;
-#endif
-
-/// Socket option determining whether outgoing multicast packets will be
-/// received on the same socket if it is a member of the multicast group.
-/**
- * Implements the IPPROTO_IP/IP_MULTICAST_LOOP socket option.
- *
- * @par Examples
- * Setting the option:
- * @code
- * asio::ip::udp::socket socket(io_service); 
- * ...
- * asio::ip::multicast::enable_loopback option(true);
- * socket.set_option(option);
- * @endcode
- *
- * @par
- * Getting the current option value:
- * @code
- * asio::ip::udp::socket socket(io_service); 
- * ...
- * asio::ip::multicast::enable_loopback option;
- * socket.get_option(option);
- * bool is_set = option.value();
- * @endcode
- *
- * @par Concepts:
- * GettableSocketOption, SettableSocketOption.
- */
-#if defined(GENERATING_DOCUMENTATION)
-typedef implementation_defined enable_loopback;
-#else
-typedef asio::ip::detail::socket_option::multicast_enable_loopback<
-  ASIO_OS_DEF(IPPROTO_IP),
-  ASIO_OS_DEF(IP_MULTICAST_LOOP),
-  ASIO_OS_DEF(IPPROTO_IPV6),
-  ASIO_OS_DEF(IPV6_MULTICAST_LOOP)> enable_loopback;
-#endif
-
-} // namespace multicast
-} // namespace ip
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_IP_MULTICAST_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ip/resolver_query_base.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ip/resolver_query_base.hpp
deleted file mode 100644
index 6b96928f1934..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ip/resolver_query_base.hpp
+++ /dev/null
@@ -1,130 +0,0 @@
-//
-// ip/resolver_query_base.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_IP_RESOLVER_QUERY_BASE_HPP
-#define ASIO_IP_RESOLVER_QUERY_BASE_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include "asio/detail/socket_types.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace ip {
-
-/// The resolver_query_base class is used as a base for the
-/// basic_resolver_query class templates to provide a common place to define
-/// the flag constants.
-class resolver_query_base
-{
-public:
-#if defined(GENERATING_DOCUMENTATION)
-  /// A bitmask type (C++ Std [lib.bitmask.types]).
-  typedef unspecified flags;
-
-  /// Determine the canonical name of the host specified in the query.
-  static const flags canonical_name = implementation_defined;
-
-  /// Indicate that returned endpoint is intended for use as a locally bound
-  /// socket endpoint.
-  static const flags passive = implementation_defined;
-
-  /// Host name should be treated as a numeric string defining an IPv4 or IPv6
-  /// address and no name resolution should be attempted.
-  static const flags numeric_host = implementation_defined;
-
-  /// Service name should be treated as a numeric string defining a port number
-  /// and no name resolution should be attempted.
-  static const flags numeric_service = implementation_defined;
-
-  /// If the query protocol family is specified as IPv6, return IPv4-mapped
-  /// IPv6 addresses on finding no IPv6 addresses.
-  static const flags v4_mapped = implementation_defined;
-
-  /// If used with v4_mapped, return all matching IPv6 and IPv4 addresses.
-  static const flags all_matching = implementation_defined;
-
-  /// Only return IPv4 addresses if a non-loopback IPv4 address is configured
-  /// for the system. Only return IPv6 addresses if a non-loopback IPv6 address
-  /// is configured for the system.
-  static const flags address_configured = implementation_defined;
-#else
-  enum flags
-  {
-    canonical_name = ASIO_OS_DEF(AI_CANONNAME),
-    passive = ASIO_OS_DEF(AI_PASSIVE),
-    numeric_host = ASIO_OS_DEF(AI_NUMERICHOST),
-    numeric_service = ASIO_OS_DEF(AI_NUMERICSERV),
-    v4_mapped = ASIO_OS_DEF(AI_V4MAPPED),
-    all_matching = ASIO_OS_DEF(AI_ALL),
-    address_configured = ASIO_OS_DEF(AI_ADDRCONFIG)
-  };
-
-  // Implement bitmask operations as shown in C++ Std [lib.bitmask.types].
-
-  friend flags operator&(flags x, flags y)
-  {
-    return static_cast<flags>(
-        static_cast<unsigned int>(x) & static_cast<unsigned int>(y));
-  }
-
-  friend flags operator|(flags x, flags y)
-  {
-    return static_cast<flags>(
-        static_cast<unsigned int>(x) | static_cast<unsigned int>(y));
-  }
-
-  friend flags operator^(flags x, flags y)
-  {
-    return static_cast<flags>(
-        static_cast<unsigned int>(x) ^ static_cast<unsigned int>(y));
-  }
-
-  friend flags operator~(flags x)
-  {
-    return static_cast<flags>(~static_cast<unsigned int>(x));
-  }
-
-  friend flags& operator&=(flags& x, flags y)
-  {
-    x = x & y;
-    return x;
-  }
-
-  friend flags& operator|=(flags& x, flags y)
-  {
-    x = x | y;
-    return x;
-  }
-
-  friend flags& operator^=(flags& x, flags y)
-  {
-    x = x ^ y;
-    return x;
-  }
-#endif
-
-protected:
-  /// Protected destructor to prevent deletion through this type.
-  ~resolver_query_base()
-  {
-  }
-};
-
-} // namespace ip
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_IP_RESOLVER_QUERY_BASE_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ip/resolver_service.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ip/resolver_service.hpp
deleted file mode 100644
index 32682f6bb79f..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ip/resolver_service.hpp
+++ /dev/null
@@ -1,176 +0,0 @@
-//
-// ip/resolver_service.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_IP_RESOLVER_SERVICE_HPP
-#define ASIO_IP_RESOLVER_SERVICE_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include "asio/async_result.hpp"
-#include "asio/error_code.hpp"
-#include "asio/io_service.hpp"
-#include "asio/ip/basic_resolver_iterator.hpp"
-#include "asio/ip/basic_resolver_query.hpp"
-
-#if defined(ASIO_WINDOWS_RUNTIME)
-# include "asio/detail/winrt_resolver_service.hpp"
-#else
-# include "asio/detail/resolver_service.hpp"
-#endif
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace ip {
-
-/// Default service implementation for a resolver.
-template <typename InternetProtocol>
-class resolver_service
-#if defined(GENERATING_DOCUMENTATION)
-  : public asio::io_service::service
-#else
-  : public asio::detail::service_base<
-      resolver_service<InternetProtocol> >
-#endif
-{
-public:
-#if defined(GENERATING_DOCUMENTATION)
-  /// The unique service identifier.
-  static asio::io_service::id id;
-#endif
-
-  /// The protocol type.
-  typedef InternetProtocol protocol_type;
-
-  /// The endpoint type.
-  typedef typename InternetProtocol::endpoint endpoint_type;
-
-  /// The query type.
-  typedef basic_resolver_query<InternetProtocol> query_type;
-
-  /// The iterator type.
-  typedef basic_resolver_iterator<InternetProtocol> iterator_type;
-
-private:
-  // The type of the platform-specific implementation.
-#if defined(ASIO_WINDOWS_RUNTIME)
-  typedef asio::detail::winrt_resolver_service<InternetProtocol>
-    service_impl_type;
-#else
-  typedef asio::detail::resolver_service<InternetProtocol>
-    service_impl_type;
-#endif
-
-public:
-  /// The type of a resolver implementation.
-#if defined(GENERATING_DOCUMENTATION)
-  typedef implementation_defined implementation_type;
-#else
-  typedef typename service_impl_type::implementation_type implementation_type;
-#endif
-
-  /// Construct a new resolver service for the specified io_service.
-  explicit resolver_service(asio::io_service& io_service)
-    : asio::detail::service_base<
-        resolver_service<InternetProtocol> >(io_service),
-      service_impl_(io_service)
-  {
-  }
-
-  /// Construct a new resolver implementation.
-  void construct(implementation_type& impl)
-  {
-    service_impl_.construct(impl);
-  }
-
-  /// Destroy a resolver implementation.
-  void destroy(implementation_type& impl)
-  {
-    service_impl_.destroy(impl);
-  }
-
-  /// Cancel pending asynchronous operations.
-  void cancel(implementation_type& impl)
-  {
-    service_impl_.cancel(impl);
-  }
-
-  /// Resolve a query to a list of entries.
-  iterator_type resolve(implementation_type& impl, const query_type& query,
-      asio::error_code& ec)
-  {
-    return service_impl_.resolve(impl, query, ec);
-  }
-
-  /// Asynchronously resolve a query to a list of entries.
-  template <typename ResolveHandler>
-  ASIO_INITFN_RESULT_TYPE(ResolveHandler,
-      void (asio::error_code, iterator_type))
-  async_resolve(implementation_type& impl, const query_type& query,
-      ASIO_MOVE_ARG(ResolveHandler) handler)
-  {
-    asio::detail::async_result_init<
-      ResolveHandler, void (asio::error_code, iterator_type)> init(
-        ASIO_MOVE_CAST(ResolveHandler)(handler));
-
-    service_impl_.async_resolve(impl, query, init.handler);
-
-    return init.result.get();
-  }
-
-  /// Resolve an endpoint to a list of entries.
-  iterator_type resolve(implementation_type& impl,
-      const endpoint_type& endpoint, asio::error_code& ec)
-  {
-    return service_impl_.resolve(impl, endpoint, ec);
-  }
-
-  /// Asynchronously resolve an endpoint to a list of entries.
-  template <typename ResolveHandler>
-  ASIO_INITFN_RESULT_TYPE(ResolveHandler,
-      void (asio::error_code, iterator_type))
-  async_resolve(implementation_type& impl, const endpoint_type& endpoint,
-      ASIO_MOVE_ARG(ResolveHandler) handler)
-  {
-    asio::detail::async_result_init<
-      ResolveHandler, void (asio::error_code, iterator_type)> init(
-        ASIO_MOVE_CAST(ResolveHandler)(handler));
-
-    service_impl_.async_resolve(impl, endpoint, init.handler);
-
-    return init.result.get();
-  }
-
-private:
-  // Destroy all user-defined handler objects owned by the service.
-  void shutdown_service()
-  {
-    service_impl_.shutdown_service();
-  }
-
-  // Perform any fork-related housekeeping.
-  void fork_service(asio::io_service::fork_event event)
-  {
-    service_impl_.fork_service(event);
-  }
-
-  // The platform-specific implementation.
-  service_impl_type service_impl_;
-};
-
-} // namespace ip
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_IP_RESOLVER_SERVICE_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ip/tcp.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ip/tcp.hpp
deleted file mode 100644
index f90a55c2c231..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ip/tcp.hpp
+++ /dev/null
@@ -1,155 +0,0 @@
-//
-// ip/tcp.hpp
-// ~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_IP_TCP_HPP
-#define ASIO_IP_TCP_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include "asio/basic_socket_acceptor.hpp"
-#include "asio/basic_socket_iostream.hpp"
-#include "asio/basic_stream_socket.hpp"
-#include "asio/detail/socket_option.hpp"
-#include "asio/detail/socket_types.hpp"
-#include "asio/ip/basic_endpoint.hpp"
-#include "asio/ip/basic_resolver.hpp"
-#include "asio/ip/basic_resolver_iterator.hpp"
-#include "asio/ip/basic_resolver_query.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace ip {
-
-/// Encapsulates the flags needed for TCP.
-/**
- * The asio::ip::tcp class contains flags necessary for TCP sockets.
- *
- * @par Thread Safety
- * @e Distinct @e objects: Safe.@n
- * @e Shared @e objects: Safe.
- *
- * @par Concepts:
- * Protocol, InternetProtocol.
- */
-class tcp
-{
-public:
-  /// The type of a TCP endpoint.
-  typedef basic_endpoint<tcp> endpoint;
-
-  /// Construct to represent the IPv4 TCP protocol.
-  static tcp v4()
-  {
-    return tcp(ASIO_OS_DEF(AF_INET));
-  }
-
-  /// Construct to represent the IPv6 TCP protocol.
-  static tcp v6()
-  {
-    return tcp(ASIO_OS_DEF(AF_INET6));
-  }
-
-  /// Obtain an identifier for the type of the protocol.
-  int type() const
-  {
-    return ASIO_OS_DEF(SOCK_STREAM);
-  }
-
-  /// Obtain an identifier for the protocol.
-  int protocol() const
-  {
-    return ASIO_OS_DEF(IPPROTO_TCP);
-  }
-
-  /// Obtain an identifier for the protocol family.
-  int family() const
-  {
-    return family_;
-  }
-
-  /// The TCP socket type.
-  typedef basic_stream_socket<tcp> socket;
-
-  /// The TCP acceptor type.
-  typedef basic_socket_acceptor<tcp> acceptor;
-
-  /// The TCP resolver type.
-  typedef basic_resolver<tcp> resolver;
-
-#if !defined(ASIO_NO_IOSTREAM)
-  /// The TCP iostream type.
-  typedef basic_socket_iostream<tcp> iostream;
-#endif // !defined(ASIO_NO_IOSTREAM)
-
-  /// Socket option for disabling the Nagle algorithm.
-  /**
-   * Implements the IPPROTO_TCP/TCP_NODELAY socket option.
-   *
-   * @par Examples
-   * Setting the option:
-   * @code
-   * asio::ip::tcp::socket socket(io_service); 
-   * ...
-   * asio::ip::tcp::no_delay option(true);
-   * socket.set_option(option);
-   * @endcode
-   *
-   * @par
-   * Getting the current option value:
-   * @code
-   * asio::ip::tcp::socket socket(io_service); 
-   * ...
-   * asio::ip::tcp::no_delay option;
-   * socket.get_option(option);
-   * bool is_set = option.value();
-   * @endcode
-   *
-   * @par Concepts:
-   * Socket_Option, Boolean_Socket_Option.
-   */
-#if defined(GENERATING_DOCUMENTATION)
-  typedef implementation_defined no_delay;
-#else
-  typedef asio::detail::socket_option::boolean<
-    ASIO_OS_DEF(IPPROTO_TCP), ASIO_OS_DEF(TCP_NODELAY)> no_delay;
-#endif
-
-  /// Compare two protocols for equality.
-  friend bool operator==(const tcp& p1, const tcp& p2)
-  {
-    return p1.family_ == p2.family_;
-  }
-
-  /// Compare two protocols for inequality.
-  friend bool operator!=(const tcp& p1, const tcp& p2)
-  {
-    return p1.family_ != p2.family_;
-  }
-
-private:
-  // Construct with a specific family.
-  explicit tcp(int protocol_family)
-    : family_(protocol_family)
-  {
-  }
-
-  int family_;
-};
-
-} // namespace ip
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_IP_TCP_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ip/udp.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ip/udp.hpp
deleted file mode 100644
index dd2d27d2de4a..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ip/udp.hpp
+++ /dev/null
@@ -1,111 +0,0 @@
-//
-// ip/udp.hpp
-// ~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_IP_UDP_HPP
-#define ASIO_IP_UDP_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include "asio/basic_datagram_socket.hpp"
-#include "asio/detail/socket_types.hpp"
-#include "asio/ip/basic_endpoint.hpp"
-#include "asio/ip/basic_resolver.hpp"
-#include "asio/ip/basic_resolver_iterator.hpp"
-#include "asio/ip/basic_resolver_query.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace ip {
-
-/// Encapsulates the flags needed for UDP.
-/**
- * The asio::ip::udp class contains flags necessary for UDP sockets.
- *
- * @par Thread Safety
- * @e Distinct @e objects: Safe.@n
- * @e Shared @e objects: Safe.
- *
- * @par Concepts:
- * Protocol, InternetProtocol.
- */
-class udp
-{
-public:
-  /// The type of a UDP endpoint.
-  typedef basic_endpoint<udp> endpoint;
-
-  /// Construct to represent the IPv4 UDP protocol.
-  static udp v4()
-  {
-    return udp(ASIO_OS_DEF(AF_INET));
-  }
-
-  /// Construct to represent the IPv6 UDP protocol.
-  static udp v6()
-  {
-    return udp(ASIO_OS_DEF(AF_INET6));
-  }
-
-  /// Obtain an identifier for the type of the protocol.
-  int type() const
-  {
-    return ASIO_OS_DEF(SOCK_DGRAM);
-  }
-
-  /// Obtain an identifier for the protocol.
-  int protocol() const
-  {
-    return ASIO_OS_DEF(IPPROTO_UDP);
-  }
-
-  /// Obtain an identifier for the protocol family.
-  int family() const
-  {
-    return family_;
-  }
-
-  /// The UDP socket type.
-  typedef basic_datagram_socket<udp> socket;
-
-  /// The UDP resolver type.
-  typedef basic_resolver<udp> resolver;
-
-  /// Compare two protocols for equality.
-  friend bool operator==(const udp& p1, const udp& p2)
-  {
-    return p1.family_ == p2.family_;
-  }
-
-  /// Compare two protocols for inequality.
-  friend bool operator!=(const udp& p1, const udp& p2)
-  {
-    return p1.family_ != p2.family_;
-  }
-
-private:
-  // Construct with a specific family.
-  explicit udp(int protocol_family)
-    : family_(protocol_family)
-  {
-  }
-
-  int family_;
-};
-
-} // namespace ip
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_IP_UDP_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ip/unicast.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ip/unicast.hpp
deleted file mode 100644
index 130e664d3813..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ip/unicast.hpp
+++ /dev/null
@@ -1,70 +0,0 @@
-//
-// ip/unicast.hpp
-// ~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_IP_UNICAST_HPP
-#define ASIO_IP_UNICAST_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include <cstddef>
-#include "asio/ip/detail/socket_option.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace ip {
-namespace unicast {
-
-/// Socket option for time-to-live associated with outgoing unicast packets.
-/**
- * Implements the IPPROTO_IP/IP_UNICAST_TTL socket option.
- *
- * @par Examples
- * Setting the option:
- * @code
- * asio::ip::udp::socket socket(io_service); 
- * ...
- * asio::ip::unicast::hops option(4);
- * socket.set_option(option);
- * @endcode
- *
- * @par
- * Getting the current option value:
- * @code
- * asio::ip::udp::socket socket(io_service); 
- * ...
- * asio::ip::unicast::hops option;
- * socket.get_option(option);
- * int ttl = option.value();
- * @endcode
- *
- * @par Concepts:
- * GettableSocketOption, SettableSocketOption.
- */
-#if defined(GENERATING_DOCUMENTATION)
-typedef implementation_defined hops;
-#else
-typedef asio::ip::detail::socket_option::unicast_hops<
-  ASIO_OS_DEF(IPPROTO_IP),
-  ASIO_OS_DEF(IP_TTL),
-  ASIO_OS_DEF(IPPROTO_IPV6),
-  ASIO_OS_DEF(IPV6_UNICAST_HOPS)> hops;
-#endif
-
-} // namespace unicast
-} // namespace ip
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_IP_UNICAST_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ip/v6_only.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ip/v6_only.hpp
deleted file mode 100644
index 5be8c1c25114..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ip/v6_only.hpp
+++ /dev/null
@@ -1,69 +0,0 @@
-//
-// ip/v6_only.hpp
-// ~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_IP_V6_ONLY_HPP
-#define ASIO_IP_V6_ONLY_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include "asio/detail/socket_option.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace ip {
-
-/// Socket option for determining whether an IPv6 socket supports IPv6
-/// communication only.
-/**
- * Implements the IPPROTO_IPV6/IP_V6ONLY socket option.
- *
- * @par Examples
- * Setting the option:
- * @code
- * asio::ip::tcp::socket socket(io_service); 
- * ...
- * asio::ip::v6_only option(true);
- * socket.set_option(option);
- * @endcode
- *
- * @par
- * Getting the current option value:
- * @code
- * asio::ip::tcp::socket socket(io_service); 
- * ...
- * asio::ip::v6_only option;
- * socket.get_option(option);
- * bool v6_only = option.value();
- * @endcode
- *
- * @par Concepts:
- * GettableSocketOption, SettableSocketOption.
- */
-#if defined(GENERATING_DOCUMENTATION)
-typedef implementation_defined v6_only;
-#elif defined(IPV6_V6ONLY)
-typedef asio::detail::socket_option::boolean<
-    IPPROTO_IPV6, IPV6_V6ONLY> v6_only;
-#else
-typedef asio::detail::socket_option::boolean<
-    asio::detail::custom_socket_option_level,
-    asio::detail::always_fail_option> v6_only;
-#endif
-
-} // namespace ip
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_IP_V6_ONLY_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/is_read_buffered.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/is_read_buffered.hpp
deleted file mode 100644
index 3f08ce0a803c..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/is_read_buffered.hpp
+++ /dev/null
@@ -1,59 +0,0 @@
-//
-// is_read_buffered.hpp
-// ~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_IS_READ_BUFFERED_HPP
-#define ASIO_IS_READ_BUFFERED_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include "asio/buffered_read_stream_fwd.hpp"
-#include "asio/buffered_stream_fwd.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-
-namespace detail {
-
-template <typename Stream>
-char is_read_buffered_helper(buffered_stream<Stream>* s);
-
-template <typename Stream>
-char is_read_buffered_helper(buffered_read_stream<Stream>* s);
-
-struct is_read_buffered_big_type { char data[10]; };
-is_read_buffered_big_type is_read_buffered_helper(...);
-
-} // namespace detail
-
-/// The is_read_buffered class is a traits class that may be used to determine
-/// whether a stream type supports buffering of read data.
-template <typename Stream>
-class is_read_buffered
-{
-public:
-#if defined(GENERATING_DOCUMENTATION)
-  /// The value member is true only if the Stream type supports buffering of
-  /// read data.
-  static const bool value;
-#else
-  ASIO_STATIC_CONSTANT(bool,
-      value = sizeof(detail::is_read_buffered_helper((Stream*)0)) == 1);
-#endif
-};
-
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_IS_READ_BUFFERED_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/is_write_buffered.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/is_write_buffered.hpp
deleted file mode 100644
index 8204d9066809..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/is_write_buffered.hpp
+++ /dev/null
@@ -1,59 +0,0 @@
-//
-// is_write_buffered.hpp
-// ~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_IS_WRITE_BUFFERED_HPP
-#define ASIO_IS_WRITE_BUFFERED_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include "asio/buffered_stream_fwd.hpp"
-#include "asio/buffered_write_stream_fwd.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-
-namespace detail {
-
-template <typename Stream>
-char is_write_buffered_helper(buffered_stream<Stream>* s);
-
-template <typename Stream>
-char is_write_buffered_helper(buffered_write_stream<Stream>* s);
-
-struct is_write_buffered_big_type { char data[10]; };
-is_write_buffered_big_type is_write_buffered_helper(...);
-
-} // namespace detail
-
-/// The is_write_buffered class is a traits class that may be used to determine
-/// whether a stream type supports buffering of written data.
-template <typename Stream>
-class is_write_buffered
-{
-public:
-#if defined(GENERATING_DOCUMENTATION)
-  /// The value member is true only if the Stream type supports buffering of
-  /// written data.
-  static const bool value;
-#else
-  ASIO_STATIC_CONSTANT(bool,
-      value = sizeof(detail::is_write_buffered_helper((Stream*)0)) == 1);
-#endif
-};
-
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_IS_WRITE_BUFFERED_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/local/basic_endpoint.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/local/basic_endpoint.hpp
deleted file mode 100644
index cce3f4ad0acb..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/local/basic_endpoint.hpp
+++ /dev/null
@@ -1,239 +0,0 @@
-//
-// local/basic_endpoint.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-// Derived from a public domain implementation written by Daniel Casimiro.
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_LOCAL_BASIC_ENDPOINT_HPP
-#define ASIO_LOCAL_BASIC_ENDPOINT_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_HAS_LOCAL_SOCKETS) \
-  || defined(GENERATING_DOCUMENTATION)
-
-#include "asio/local/detail/endpoint.hpp"
-
-#if !defined(ASIO_NO_IOSTREAM)
-# include <iosfwd>
-#endif // !defined(ASIO_NO_IOSTREAM)
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace local {
-
-/// Describes an endpoint for a UNIX socket.
-/**
- * The asio::local::basic_endpoint class template describes an endpoint
- * that may be associated with a particular UNIX socket.
- *
- * @par Thread Safety
- * @e Distinct @e objects: Safe.@n
- * @e Shared @e objects: Unsafe.
- *
- * @par Concepts:
- * Endpoint.
- */
-template <typename Protocol>
-class basic_endpoint
-{
-public:
-  /// The protocol type associated with the endpoint.
-  typedef Protocol protocol_type;
-
-  /// The type of the endpoint structure. This type is dependent on the
-  /// underlying implementation of the socket layer.
-#if defined(GENERATING_DOCUMENTATION)
-  typedef implementation_defined data_type;
-#else
-  typedef asio::detail::socket_addr_type data_type;
-#endif
-
-  /// Default constructor.
-  basic_endpoint()
-  {
-  }
-
-  /// Construct an endpoint using the specified path name.
-  basic_endpoint(const char* path_name)
-    : impl_(path_name)
-  {
-  }
-
-  /// Construct an endpoint using the specified path name.
-  basic_endpoint(const std::string& path_name)
-    : impl_(path_name)
-  {
-  }
-
-  /// Copy constructor.
-  basic_endpoint(const basic_endpoint& other)
-    : impl_(other.impl_)
-  {
-  }
-
-#if defined(ASIO_HAS_MOVE)
-  /// Move constructor.
-  basic_endpoint(basic_endpoint&& other)
-    : impl_(other.impl_)
-  {
-  }
-#endif // defined(ASIO_HAS_MOVE)
-
-  /// Assign from another endpoint.
-  basic_endpoint& operator=(const basic_endpoint& other)
-  {
-    impl_ = other.impl_;
-    return *this;
-  }
-
-#if defined(ASIO_HAS_MOVE)
-  /// Move-assign from another endpoint.
-  basic_endpoint& operator=(basic_endpoint&& other)
-  {
-    impl_ = other.impl_;
-    return *this;
-  }
-#endif // defined(ASIO_HAS_MOVE)
-
-  /// The protocol associated with the endpoint.
-  protocol_type protocol() const
-  {
-    return protocol_type();
-  }
-
-  /// Get the underlying endpoint in the native type.
-  data_type* data()
-  {
-    return impl_.data();
-  }
-
-  /// Get the underlying endpoint in the native type.
-  const data_type* data() const
-  {
-    return impl_.data();
-  }
-
-  /// Get the underlying size of the endpoint in the native type.
-  std::size_t size() const
-  {
-    return impl_.size();
-  }
-
-  /// Set the underlying size of the endpoint in the native type.
-  void resize(std::size_t new_size)
-  {
-    impl_.resize(new_size);
-  }
-
-  /// Get the capacity of the endpoint in the native type.
-  std::size_t capacity() const
-  {
-    return impl_.capacity();
-  }
-
-  /// Get the path associated with the endpoint.
-  std::string path() const
-  {
-    return impl_.path();
-  }
-
-  /// Set the path associated with the endpoint.
-  void path(const char* p)
-  {
-    impl_.path(p);
-  }
-
-  /// Set the path associated with the endpoint.
-  void path(const std::string& p)
-  {
-    impl_.path(p);
-  }
-
-  /// Compare two endpoints for equality.
-  friend bool operator==(const basic_endpoint<Protocol>& e1,
-      const basic_endpoint<Protocol>& e2)
-  {
-    return e1.impl_ == e2.impl_;
-  }
-
-  /// Compare two endpoints for inequality.
-  friend bool operator!=(const basic_endpoint<Protocol>& e1,
-      const basic_endpoint<Protocol>& e2)
-  {
-    return !(e1.impl_ == e2.impl_);
-  }
-
-  /// Compare endpoints for ordering.
-  friend bool operator<(const basic_endpoint<Protocol>& e1,
-      const basic_endpoint<Protocol>& e2)
-  {
-    return e1.impl_ < e2.impl_;
-  }
-
-  /// Compare endpoints for ordering.
-  friend bool operator>(const basic_endpoint<Protocol>& e1,
-      const basic_endpoint<Protocol>& e2)
-  {
-    return e2.impl_ < e1.impl_;
-  }
-
-  /// Compare endpoints for ordering.
-  friend bool operator<=(const basic_endpoint<Protocol>& e1,
-      const basic_endpoint<Protocol>& e2)
-  {
-    return !(e2 < e1);
-  }
-
-  /// Compare endpoints for ordering.
-  friend bool operator>=(const basic_endpoint<Protocol>& e1,
-      const basic_endpoint<Protocol>& e2)
-  {
-    return !(e1 < e2);
-  }
-
-private:
-  // The underlying UNIX domain endpoint.
-  asio::local::detail::endpoint impl_;
-};
-
-/// Output an endpoint as a string.
-/**
- * Used to output a human-readable string for a specified endpoint.
- *
- * @param os The output stream to which the string will be written.
- *
- * @param endpoint The endpoint to be written.
- *
- * @return The output stream.
- *
- * @relates asio::local::basic_endpoint
- */
-template <typename Elem, typename Traits, typename Protocol>
-std::basic_ostream<Elem, Traits>& operator<<(
-    std::basic_ostream<Elem, Traits>& os,
-    const basic_endpoint<Protocol>& endpoint)
-{
-  os << endpoint.path();
-  return os;
-}
-
-} // namespace local
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // defined(ASIO_HAS_LOCAL_SOCKETS)
-       //   || defined(GENERATING_DOCUMENTATION)
-
-#endif // ASIO_LOCAL_BASIC_ENDPOINT_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/local/connect_pair.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/local/connect_pair.hpp
deleted file mode 100644
index 45a3de0a9ecc..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/local/connect_pair.hpp
+++ /dev/null
@@ -1,104 +0,0 @@
-//
-// local/connect_pair.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_LOCAL_CONNECT_PAIR_HPP
-#define ASIO_LOCAL_CONNECT_PAIR_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_HAS_LOCAL_SOCKETS) \
-  || defined(GENERATING_DOCUMENTATION)
-
-#include "asio/basic_socket.hpp"
-#include "asio/detail/socket_ops.hpp"
-#include "asio/detail/throw_error.hpp"
-#include "asio/error.hpp"
-#include "asio/local/basic_endpoint.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace local {
-
-/// Create a pair of connected sockets.
-template <typename Protocol, typename SocketService1, typename SocketService2>
-void connect_pair(
-    basic_socket<Protocol, SocketService1>& socket1,
-    basic_socket<Protocol, SocketService2>& socket2);
-
-/// Create a pair of connected sockets.
-template <typename Protocol, typename SocketService1, typename SocketService2>
-asio::error_code connect_pair(
-    basic_socket<Protocol, SocketService1>& socket1,
-    basic_socket<Protocol, SocketService2>& socket2,
-    asio::error_code& ec);
-
-template <typename Protocol, typename SocketService1, typename SocketService2>
-inline void connect_pair(
-    basic_socket<Protocol, SocketService1>& socket1,
-    basic_socket<Protocol, SocketService2>& socket2)
-{
-  asio::error_code ec;
-  connect_pair(socket1, socket2, ec);
-  asio::detail::throw_error(ec, "connect_pair");
-}
-
-template <typename Protocol, typename SocketService1, typename SocketService2>
-inline asio::error_code connect_pair(
-    basic_socket<Protocol, SocketService1>& socket1,
-    basic_socket<Protocol, SocketService2>& socket2,
-    asio::error_code& ec)
-{
-  // Check that this function is only being used with a UNIX domain socket.
-  asio::local::basic_endpoint<Protocol>* tmp
-    = static_cast<typename Protocol::endpoint*>(0);
-  (void)tmp;
-
-  Protocol protocol;
-  asio::detail::socket_type sv[2];
-  if (asio::detail::socket_ops::socketpair(protocol.family(),
-        protocol.type(), protocol.protocol(), sv, ec)
-      == asio::detail::socket_error_retval)
-    return ec;
-
-  if (socket1.assign(protocol, sv[0], ec))
-  {
-    asio::error_code temp_ec;
-    asio::detail::socket_ops::state_type state[2] = { 0, 0 };
-    asio::detail::socket_ops::close(sv[0], state[0], true, temp_ec);
-    asio::detail::socket_ops::close(sv[1], state[1], true, temp_ec);
-    return ec;
-  }
-
-  if (socket2.assign(protocol, sv[1], ec))
-  {
-    asio::error_code temp_ec;
-    socket1.close(temp_ec);
-    asio::detail::socket_ops::state_type state = 0;
-    asio::detail::socket_ops::close(sv[1], state, true, temp_ec);
-    return ec;
-  }
-
-  return ec;
-}
-
-} // namespace local
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // defined(ASIO_HAS_LOCAL_SOCKETS)
-       //   || defined(GENERATING_DOCUMENTATION)
-
-#endif // ASIO_LOCAL_CONNECT_PAIR_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/local/datagram_protocol.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/local/datagram_protocol.hpp
deleted file mode 100644
index 8d5790367458..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/local/datagram_protocol.hpp
+++ /dev/null
@@ -1,80 +0,0 @@
-//
-// local/datagram_protocol.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_LOCAL_DATAGRAM_PROTOCOL_HPP
-#define ASIO_LOCAL_DATAGRAM_PROTOCOL_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_HAS_LOCAL_SOCKETS) \
-  || defined(GENERATING_DOCUMENTATION)
-
-#include "asio/basic_datagram_socket.hpp"
-#include "asio/detail/socket_types.hpp"
-#include "asio/local/basic_endpoint.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace local {
-
-/// Encapsulates the flags needed for datagram-oriented UNIX sockets.
-/**
- * The asio::local::datagram_protocol class contains flags necessary for
- * datagram-oriented UNIX domain sockets.
- *
- * @par Thread Safety
- * @e Distinct @e objects: Safe.@n
- * @e Shared @e objects: Safe.
- *
- * @par Concepts:
- * Protocol.
- */
-class datagram_protocol
-{
-public:
-  /// Obtain an identifier for the type of the protocol.
-  int type() const
-  {
-    return SOCK_DGRAM;
-  }
-
-  /// Obtain an identifier for the protocol.
-  int protocol() const
-  {
-    return 0;
-  }
-
-  /// Obtain an identifier for the protocol family.
-  int family() const
-  {
-    return AF_UNIX;
-  }
-
-  /// The type of a UNIX domain endpoint.
-  typedef basic_endpoint<datagram_protocol> endpoint;
-
-  /// The UNIX domain socket type.
-  typedef basic_datagram_socket<datagram_protocol> socket;
-};
-
-} // namespace local
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // defined(ASIO_HAS_LOCAL_SOCKETS)
-       //   || defined(GENERATING_DOCUMENTATION)
-
-#endif // ASIO_LOCAL_DATAGRAM_PROTOCOL_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/local/detail/endpoint.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/local/detail/endpoint.hpp
deleted file mode 100644
index 66c72dac804b..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/local/detail/endpoint.hpp
+++ /dev/null
@@ -1,133 +0,0 @@
-//
-// local/detail/endpoint.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-// Derived from a public domain implementation written by Daniel Casimiro.
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_LOCAL_DETAIL_ENDPOINT_HPP
-#define ASIO_LOCAL_DETAIL_ENDPOINT_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_HAS_LOCAL_SOCKETS)
-
-#include <cstddef>
-#include <string>
-#include "asio/detail/socket_types.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace local {
-namespace detail {
-
-// Helper class for implementing a UNIX domain endpoint.
-class endpoint
-{
-public:
-  // Default constructor.
-  ASIO_DECL endpoint();
-
-  // Construct an endpoint using the specified path name.
-  ASIO_DECL endpoint(const char* path_name);
-
-  // Construct an endpoint using the specified path name.
-  ASIO_DECL endpoint(const std::string& path_name);
-
-  // Copy constructor.
-  endpoint(const endpoint& other)
-    : data_(other.data_),
-      path_length_(other.path_length_)
-  {
-  }
-
-  // Assign from another endpoint.
-  endpoint& operator=(const endpoint& other)
-  {
-    data_ = other.data_;
-    path_length_ = other.path_length_;
-    return *this;
-  }
-
-  // Get the underlying endpoint in the native type.
-  asio::detail::socket_addr_type* data()
-  {
-    return &data_.base;
-  }
-
-  // Get the underlying endpoint in the native type.
-  const asio::detail::socket_addr_type* data() const
-  {
-    return &data_.base;
-  }
-
-  // Get the underlying size of the endpoint in the native type.
-  std::size_t size() const
-  {
-    return path_length_
-      + offsetof(asio::detail::sockaddr_un_type, sun_path);
-  }
-
-  // Set the underlying size of the endpoint in the native type.
-  ASIO_DECL void resize(std::size_t size);
-
-  // Get the capacity of the endpoint in the native type.
-  std::size_t capacity() const
-  {
-    return sizeof(asio::detail::sockaddr_un_type);
-  }
-
-  // Get the path associated with the endpoint.
-  ASIO_DECL std::string path() const;
-
-  // Set the path associated with the endpoint.
-  ASIO_DECL void path(const char* p);
-
-  // Set the path associated with the endpoint.
-  ASIO_DECL void path(const std::string& p);
-
-  // Compare two endpoints for equality.
-  ASIO_DECL friend bool operator==(
-      const endpoint& e1, const endpoint& e2);
-
-  // Compare endpoints for ordering.
-  ASIO_DECL friend bool operator<(
-      const endpoint& e1, const endpoint& e2);
-
-private:
-  // The underlying UNIX socket address.
-  union data_union
-  {
-    asio::detail::socket_addr_type base;
-    asio::detail::sockaddr_un_type local;
-  } data_;
-
-  // The length of the path associated with the endpoint.
-  std::size_t path_length_;
-
-  // Initialise with a specified path.
-  ASIO_DECL void init(const char* path, std::size_t path_length);
-};
-
-} // namespace detail
-} // namespace local
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#if defined(ASIO_HEADER_ONLY)
-# include "asio/local/detail/impl/endpoint.ipp"
-#endif // defined(ASIO_HEADER_ONLY)
-
-#endif // defined(ASIO_HAS_LOCAL_SOCKETS)
-
-#endif // ASIO_LOCAL_DETAIL_ENDPOINT_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/local/detail/impl/endpoint.ipp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/local/detail/impl/endpoint.ipp
deleted file mode 100644
index c625ab235e96..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/local/detail/impl/endpoint.ipp
+++ /dev/null
@@ -1,128 +0,0 @@
-//
-// local/detail/impl/endpoint.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-// Derived from a public domain implementation written by Daniel Casimiro.
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_LOCAL_DETAIL_IMPL_ENDPOINT_IPP
-#define ASIO_LOCAL_DETAIL_IMPL_ENDPOINT_IPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_HAS_LOCAL_SOCKETS)
-
-#include <cstring>
-#include "asio/detail/socket_ops.hpp"
-#include "asio/detail/throw_error.hpp"
-#include "asio/error.hpp"
-#include "asio/local/detail/endpoint.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace local {
-namespace detail {
-
-endpoint::endpoint()
-{
-  init("", 0);
-}
-
-endpoint::endpoint(const char* path_name)
-{
-  using namespace std; // For strlen.
-  init(path_name, strlen(path_name));
-}
-
-endpoint::endpoint(const std::string& path_name)
-{
-  init(path_name.data(), path_name.length());
-}
-
-void endpoint::resize(std::size_t new_size)
-{
-  if (new_size > sizeof(asio::detail::sockaddr_un_type))
-  {
-    asio::error_code ec(asio::error::invalid_argument);
-    asio::detail::throw_error(ec);
-  }
-  else if (new_size == 0)
-  {
-    path_length_ = 0;
-  }
-  else
-  {
-    path_length_ = new_size
-      - offsetof(asio::detail::sockaddr_un_type, sun_path);
-
-    // The path returned by the operating system may be NUL-terminated.
-    if (path_length_ > 0 && data_.local.sun_path[path_length_ - 1] == 0)
-      --path_length_;
-  }
-}
-
-std::string endpoint::path() const
-{
-  return std::string(data_.local.sun_path, path_length_);
-}
-
-void endpoint::path(const char* p)
-{
-  using namespace std; // For strlen.
-  init(p, strlen(p));
-}
-
-void endpoint::path(const std::string& p)
-{
-  init(p.data(), p.length());
-}
-
-bool operator==(const endpoint& e1, const endpoint& e2)
-{
-  return e1.path() == e2.path();
-}
-
-bool operator<(const endpoint& e1, const endpoint& e2)
-{
-  return e1.path() < e2.path();
-}
-
-void endpoint::init(const char* path_name, std::size_t path_length)
-{
-  if (path_length > sizeof(data_.local.sun_path) - 1)
-  {
-    // The buffer is not large enough to store this address.
-    asio::error_code ec(asio::error::name_too_long);
-    asio::detail::throw_error(ec);
-  }
-
-  using namespace std; // For memcpy.
-  data_.local = asio::detail::sockaddr_un_type();
-  data_.local.sun_family = AF_UNIX;
-  memcpy(data_.local.sun_path, path_name, path_length);
-  path_length_ = path_length;
-
-  // NUL-terminate normal path names. Names that start with a NUL are in the
-  // UNIX domain protocol's "abstract namespace" and are not NUL-terminated.
-  if (path_length > 0 && data_.local.sun_path[0] == 0)
-    data_.local.sun_path[path_length] = 0;
-}
-
-} // namespace detail
-} // namespace local
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // defined(ASIO_HAS_LOCAL_SOCKETS)
-
-#endif // ASIO_LOCAL_DETAIL_IMPL_ENDPOINT_IPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/local/stream_protocol.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/local/stream_protocol.hpp
deleted file mode 100644
index abb0b52d1347..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/local/stream_protocol.hpp
+++ /dev/null
@@ -1,90 +0,0 @@
-//
-// local/stream_protocol.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_LOCAL_STREAM_PROTOCOL_HPP
-#define ASIO_LOCAL_STREAM_PROTOCOL_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_HAS_LOCAL_SOCKETS) \
-  || defined(GENERATING_DOCUMENTATION)
-
-#include "asio/basic_socket_acceptor.hpp"
-#include "asio/basic_socket_iostream.hpp"
-#include "asio/basic_stream_socket.hpp"
-#include "asio/detail/socket_types.hpp"
-#include "asio/local/basic_endpoint.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace local {
-
-/// Encapsulates the flags needed for stream-oriented UNIX sockets.
-/**
- * The asio::local::stream_protocol class contains flags necessary for
- * stream-oriented UNIX domain sockets.
- *
- * @par Thread Safety
- * @e Distinct @e objects: Safe.@n
- * @e Shared @e objects: Safe.
- *
- * @par Concepts:
- * Protocol.
- */
-class stream_protocol
-{
-public:
-  /// Obtain an identifier for the type of the protocol.
-  int type() const
-  {
-    return SOCK_STREAM;
-  }
-
-  /// Obtain an identifier for the protocol.
-  int protocol() const
-  {
-    return 0;
-  }
-
-  /// Obtain an identifier for the protocol family.
-  int family() const
-  {
-    return AF_UNIX;
-  }
-
-  /// The type of a UNIX domain endpoint.
-  typedef basic_endpoint<stream_protocol> endpoint;
-
-  /// The UNIX domain socket type.
-  typedef basic_stream_socket<stream_protocol> socket;
-
-  /// The UNIX domain acceptor type.
-  typedef basic_socket_acceptor<stream_protocol> acceptor;
-
-#if !defined(ASIO_NO_IOSTREAM)
-  /// The UNIX domain iostream type.
-  typedef basic_socket_iostream<stream_protocol> iostream;
-#endif // !defined(ASIO_NO_IOSTREAM)
-};
-
-} // namespace local
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // defined(ASIO_HAS_LOCAL_SOCKETS)
-       //   || defined(GENERATING_DOCUMENTATION)
-
-#endif // ASIO_LOCAL_STREAM_PROTOCOL_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/placeholders.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/placeholders.hpp
deleted file mode 100644
index 371ac7f52505..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/placeholders.hpp
+++ /dev/null
@@ -1,123 +0,0 @@
-//
-// placeholders.hpp
-// ~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_PLACEHOLDERS_HPP
-#define ASIO_PLACEHOLDERS_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_HAS_BOOST_BIND)
-# include <boost/bind/arg.hpp>
-#endif // defined(ASIO_HAS_BOOST_BIND)
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace placeholders {
-
-#if defined(GENERATING_DOCUMENTATION)
-
-/// An argument placeholder, for use with boost::bind(), that corresponds to
-/// the error argument of a handler for any of the asynchronous functions.
-unspecified error;
-
-/// An argument placeholder, for use with boost::bind(), that corresponds to
-/// the bytes_transferred argument of a handler for asynchronous functions such
-/// as asio::basic_stream_socket::async_write_some or
-/// asio::async_write.
-unspecified bytes_transferred;
-
-/// An argument placeholder, for use with boost::bind(), that corresponds to
-/// the iterator argument of a handler for asynchronous functions such as
-/// asio::basic_resolver::async_resolve.
-unspecified iterator;
-
-/// An argument placeholder, for use with boost::bind(), that corresponds to
-/// the signal_number argument of a handler for asynchronous functions such as
-/// asio::signal_set::async_wait.
-unspecified signal_number;
-
-#elif defined(ASIO_HAS_BOOST_BIND)
-# if defined(__BORLANDC__) || defined(__GNUC__)
-
-inline boost::arg<1> error()
-{
-  return boost::arg<1>();
-}
-
-inline boost::arg<2> bytes_transferred()
-{
-  return boost::arg<2>();
-}
-
-inline boost::arg<2> iterator()
-{
-  return boost::arg<2>();
-}
-
-inline boost::arg<2> signal_number()
-{
-  return boost::arg<2>();
-}
-
-# else
-
-namespace detail
-{
-  template <int Number>
-  struct placeholder
-  {
-    static boost::arg<Number>& get()
-    {
-      static boost::arg<Number> result;
-      return result;
-    }
-  };
-}
-
-#  if defined(ASIO_MSVC) && (ASIO_MSVC < 1400)
-
-static boost::arg<1>& error
-  = asio::placeholders::detail::placeholder<1>::get();
-static boost::arg<2>& bytes_transferred
-  = asio::placeholders::detail::placeholder<2>::get();
-static boost::arg<2>& iterator
-  = asio::placeholders::detail::placeholder<2>::get();
-static boost::arg<2>& signal_number
-  = asio::placeholders::detail::placeholder<2>::get();
-
-#  else
-
-namespace
-{
-  boost::arg<1>& error
-    = asio::placeholders::detail::placeholder<1>::get();
-  boost::arg<2>& bytes_transferred
-    = asio::placeholders::detail::placeholder<2>::get();
-  boost::arg<2>& iterator
-    = asio::placeholders::detail::placeholder<2>::get();
-  boost::arg<2>& signal_number
-    = asio::placeholders::detail::placeholder<2>::get();
-} // namespace
-
-#  endif
-# endif
-#endif
-
-} // namespace placeholders
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_PLACEHOLDERS_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/posix/basic_descriptor.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/posix/basic_descriptor.hpp
deleted file mode 100644
index f06da916a7af..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/posix/basic_descriptor.hpp
+++ /dev/null
@@ -1,490 +0,0 @@
-//
-// posix/basic_descriptor.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_POSIX_BASIC_DESCRIPTOR_HPP
-#define ASIO_POSIX_BASIC_DESCRIPTOR_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_HAS_POSIX_STREAM_DESCRIPTOR) \
-  || defined(GENERATING_DOCUMENTATION)
-
-#include "asio/basic_io_object.hpp"
-#include "asio/detail/throw_error.hpp"
-#include "asio/error.hpp"
-#include "asio/posix/descriptor_base.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace posix {
-
-/// Provides POSIX descriptor functionality.
-/**
- * The posix::basic_descriptor class template provides the ability to wrap a
- * POSIX descriptor.
- *
- * @par Thread Safety
- * @e Distinct @e objects: Safe.@n
- * @e Shared @e objects: Unsafe.
- */
-template <typename DescriptorService>
-class basic_descriptor
-  : public basic_io_object<DescriptorService>,
-    public descriptor_base
-{
-public:
-  /// (Deprecated: Use native_handle_type.) The native representation of a
-  /// descriptor.
-  typedef typename DescriptorService::native_handle_type native_type;
-
-  /// The native representation of a descriptor.
-  typedef typename DescriptorService::native_handle_type native_handle_type;
-
-  /// A basic_descriptor is always the lowest layer.
-  typedef basic_descriptor<DescriptorService> lowest_layer_type;
-
-  /// Construct a basic_descriptor without opening it.
-  /**
-   * This constructor creates a descriptor without opening it.
-   *
-   * @param io_service The io_service object that the descriptor will use to
-   * dispatch handlers for any asynchronous operations performed on the
-   * descriptor.
-   */
-  explicit basic_descriptor(asio::io_service& io_service)
-    : basic_io_object<DescriptorService>(io_service)
-  {
-  }
-
-  /// Construct a basic_descriptor on an existing native descriptor.
-  /**
-   * This constructor creates a descriptor object to hold an existing native
-   * descriptor.
-   *
-   * @param io_service The io_service object that the descriptor will use to
-   * dispatch handlers for any asynchronous operations performed on the
-   * descriptor.
-   *
-   * @param native_descriptor A native descriptor.
-   *
-   * @throws asio::system_error Thrown on failure.
-   */
-  basic_descriptor(asio::io_service& io_service,
-      const native_handle_type& native_descriptor)
-    : basic_io_object<DescriptorService>(io_service)
-  {
-    asio::error_code ec;
-    this->get_service().assign(this->get_implementation(),
-        native_descriptor, ec);
-    asio::detail::throw_error(ec, "assign");
-  }
-
-#if defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
-  /// Move-construct a basic_descriptor from another.
-  /**
-   * This constructor moves a descriptor from one object to another.
-   *
-   * @param other The other basic_descriptor object from which the move will
-   * occur.
-   *
-   * @note Following the move, the moved-from object is in the same state as if
-   * constructed using the @c basic_descriptor(io_service&) constructor.
-   */
-  basic_descriptor(basic_descriptor&& other)
-    : basic_io_object<DescriptorService>(
-        ASIO_MOVE_CAST(basic_descriptor)(other))
-  {
-  }
-
-  /// Move-assign a basic_descriptor from another.
-  /**
-   * This assignment operator moves a descriptor from one object to another.
-   *
-   * @param other The other basic_descriptor object from which the move will
-   * occur.
-   *
-   * @note Following the move, the moved-from object is in the same state as if
-   * constructed using the @c basic_descriptor(io_service&) constructor.
-   */
-  basic_descriptor& operator=(basic_descriptor&& other)
-  {
-    basic_io_object<DescriptorService>::operator=(
-        ASIO_MOVE_CAST(basic_descriptor)(other));
-    return *this;
-  }
-#endif // defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
-
-  /// Get a reference to the lowest layer.
-  /**
-   * This function returns a reference to the lowest layer in a stack of
-   * layers. Since a basic_descriptor cannot contain any further layers, it
-   * simply returns a reference to itself.
-   *
-   * @return A reference to the lowest layer in the stack of layers. Ownership
-   * is not transferred to the caller.
-   */
-  lowest_layer_type& lowest_layer()
-  {
-    return *this;
-  }
-
-  /// Get a const reference to the lowest layer.
-  /**
-   * This function returns a const reference to the lowest layer in a stack of
-   * layers. Since a basic_descriptor cannot contain any further layers, it
-   * simply returns a reference to itself.
-   *
-   * @return A const reference to the lowest layer in the stack of layers.
-   * Ownership is not transferred to the caller.
-   */
-  const lowest_layer_type& lowest_layer() const
-  {
-    return *this;
-  }
-
-  /// Assign an existing native descriptor to the descriptor.
-  /*
-   * This function opens the descriptor to hold an existing native descriptor.
-   *
-   * @param native_descriptor A native descriptor.
-   *
-   * @throws asio::system_error Thrown on failure.
-   */
-  void assign(const native_handle_type& native_descriptor)
-  {
-    asio::error_code ec;
-    this->get_service().assign(this->get_implementation(),
-        native_descriptor, ec);
-    asio::detail::throw_error(ec, "assign");
-  }
-
-  /// Assign an existing native descriptor to the descriptor.
-  /*
-   * This function opens the descriptor to hold an existing native descriptor.
-   *
-   * @param native_descriptor A native descriptor.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   */
-  asio::error_code assign(const native_handle_type& native_descriptor,
-      asio::error_code& ec)
-  {
-    return this->get_service().assign(
-        this->get_implementation(), native_descriptor, ec);
-  }
-
-  /// Determine whether the descriptor is open.
-  bool is_open() const
-  {
-    return this->get_service().is_open(this->implementation);
-  }
-
-  /// Close the descriptor.
-  /**
-   * This function is used to close the descriptor. Any asynchronous read or
-   * write operations will be cancelled immediately, and will complete with the
-   * asio::error::operation_aborted error.
-   *
-   * @throws asio::system_error Thrown on failure. Note that, even if
-   * the function indicates an error, the underlying descriptor is closed.
-   */
-  void close()
-  {
-    asio::error_code ec;
-    this->get_service().close(this->get_implementation(), ec);
-    asio::detail::throw_error(ec, "close");
-  }
-
-  /// Close the descriptor.
-  /**
-   * This function is used to close the descriptor. Any asynchronous read or
-   * write operations will be cancelled immediately, and will complete with the
-   * asio::error::operation_aborted error.
-   *
-   * @param ec Set to indicate what error occurred, if any. Note that, even if
-   * the function indicates an error, the underlying descriptor is closed.
-   */
-  asio::error_code close(asio::error_code& ec)
-  {
-    return this->get_service().close(this->get_implementation(), ec);
-  }
-
-  /// (Deprecated: Use native_handle().) Get the native descriptor
-  /// representation.
-  /**
-   * This function may be used to obtain the underlying representation of the
-   * descriptor. This is intended to allow access to native descriptor
-   * functionality that is not otherwise provided.
-   */
-  native_type native()
-  {
-    return this->get_service().native_handle(this->implementation);
-  }
-
-  /// Get the native descriptor representation.
-  /**
-   * This function may be used to obtain the underlying representation of the
-   * descriptor. This is intended to allow access to native descriptor
-   * functionality that is not otherwise provided.
-   */
-  native_handle_type native_handle()
-  {
-    return this->get_service().native_handle(this->implementation);
-  }
-
-  /// Release ownership of the native descriptor implementation.
-  /**
-   * This function may be used to obtain the underlying representation of the
-   * descriptor. After calling this function, @c is_open() returns false. The
-   * caller is responsible for closing the descriptor.
-   *
-   * All outstanding asynchronous read or write operations will finish
-   * immediately, and the handlers for cancelled operations will be passed the
-   * asio::error::operation_aborted error.
-   */
-  native_handle_type release()
-  {
-    return this->get_service().release(this->implementation);
-  }
-
-  /// Cancel all asynchronous operations associated with the descriptor.
-  /**
-   * This function causes all outstanding asynchronous read or write operations
-   * to finish immediately, and the handlers for cancelled operations will be
-   * passed the asio::error::operation_aborted error.
-   *
-   * @throws asio::system_error Thrown on failure.
-   */
-  void cancel()
-  {
-    asio::error_code ec;
-    this->get_service().cancel(this->get_implementation(), ec);
-    asio::detail::throw_error(ec, "cancel");
-  }
-
-  /// Cancel all asynchronous operations associated with the descriptor.
-  /**
-   * This function causes all outstanding asynchronous read or write operations
-   * to finish immediately, and the handlers for cancelled operations will be
-   * passed the asio::error::operation_aborted error.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   */
-  asio::error_code cancel(asio::error_code& ec)
-  {
-    return this->get_service().cancel(this->get_implementation(), ec);
-  }
-
-  /// Perform an IO control command on the descriptor.
-  /**
-   * This function is used to execute an IO control command on the descriptor.
-   *
-   * @param command The IO control command to be performed on the descriptor.
-   *
-   * @throws asio::system_error Thrown on failure.
-   *
-   * @sa IoControlCommand @n
-   * asio::posix::descriptor_base::bytes_readable @n
-   * asio::posix::descriptor_base::non_blocking_io
-   *
-   * @par Example
-   * Getting the number of bytes ready to read:
-   * @code
-   * asio::posix::stream_descriptor descriptor(io_service);
-   * ...
-   * asio::posix::stream_descriptor::bytes_readable command;
-   * descriptor.io_control(command);
-   * std::size_t bytes_readable = command.get();
-   * @endcode
-   */
-  template <typename IoControlCommand>
-  void io_control(IoControlCommand& command)
-  {
-    asio::error_code ec;
-    this->get_service().io_control(this->get_implementation(), command, ec);
-    asio::detail::throw_error(ec, "io_control");
-  }
-
-  /// Perform an IO control command on the descriptor.
-  /**
-   * This function is used to execute an IO control command on the descriptor.
-   *
-   * @param command The IO control command to be performed on the descriptor.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   *
-   * @sa IoControlCommand @n
-   * asio::posix::descriptor_base::bytes_readable @n
-   * asio::posix::descriptor_base::non_blocking_io
-   *
-   * @par Example
-   * Getting the number of bytes ready to read:
-   * @code
-   * asio::posix::stream_descriptor descriptor(io_service);
-   * ...
-   * asio::posix::stream_descriptor::bytes_readable command;
-   * asio::error_code ec;
-   * descriptor.io_control(command, ec);
-   * if (ec)
-   * {
-   *   // An error occurred.
-   * }
-   * std::size_t bytes_readable = command.get();
-   * @endcode
-   */
-  template <typename IoControlCommand>
-  asio::error_code io_control(IoControlCommand& command,
-      asio::error_code& ec)
-  {
-    return this->get_service().io_control(
-        this->get_implementation(), command, ec);
-  }
-
-  /// Gets the non-blocking mode of the descriptor.
-  /**
-   * @returns @c true if the descriptor's synchronous operations will fail with
-   * asio::error::would_block if they are unable to perform the requested
-   * operation immediately. If @c false, synchronous operations will block
-   * until complete.
-   *
-   * @note The non-blocking mode has no effect on the behaviour of asynchronous
-   * operations. Asynchronous operations will never fail with the error
-   * asio::error::would_block.
-   */
-  bool non_blocking() const
-  {
-    return this->get_service().non_blocking(this->implementation);
-  }
-
-  /// Sets the non-blocking mode of the descriptor.
-  /**
-   * @param mode If @c true, the descriptor's synchronous operations will fail
-   * with asio::error::would_block if they are unable to perform the
-   * requested operation immediately. If @c false, synchronous operations will
-   * block until complete.
-   *
-   * @throws asio::system_error Thrown on failure.
-   *
-   * @note The non-blocking mode has no effect on the behaviour of asynchronous
-   * operations. Asynchronous operations will never fail with the error
-   * asio::error::would_block.
-   */
-  void non_blocking(bool mode)
-  {
-    asio::error_code ec;
-    this->get_service().non_blocking(this->get_implementation(), mode, ec);
-    asio::detail::throw_error(ec, "non_blocking");
-  }
-
-  /// Sets the non-blocking mode of the descriptor.
-  /**
-   * @param mode If @c true, the descriptor's synchronous operations will fail
-   * with asio::error::would_block if they are unable to perform the
-   * requested operation immediately. If @c false, synchronous operations will
-   * block until complete.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   *
-   * @note The non-blocking mode has no effect on the behaviour of asynchronous
-   * operations. Asynchronous operations will never fail with the error
-   * asio::error::would_block.
-   */
-  asio::error_code non_blocking(
-      bool mode, asio::error_code& ec)
-  {
-    return this->get_service().non_blocking(
-        this->get_implementation(), mode, ec);
-  }
-
-  /// Gets the non-blocking mode of the native descriptor implementation.
-  /**
-   * This function is used to retrieve the non-blocking mode of the underlying
-   * native descriptor. This mode has no effect on the behaviour of the
-   * descriptor object's synchronous operations.
-   *
-   * @returns @c true if the underlying descriptor is in non-blocking mode and
-   * direct system calls may fail with asio::error::would_block (or the
-   * equivalent system error).
-   *
-   * @note The current non-blocking mode is cached by the descriptor object.
-   * Consequently, the return value may be incorrect if the non-blocking mode
-   * was set directly on the native descriptor.
-   */
-  bool native_non_blocking() const
-  {
-    return this->get_service().native_non_blocking(this->implementation);
-  }
-
-  /// Sets the non-blocking mode of the native descriptor implementation.
-  /**
-   * This function is used to modify the non-blocking mode of the underlying
-   * native descriptor. It has no effect on the behaviour of the descriptor
-   * object's synchronous operations.
-   *
-   * @param mode If @c true, the underlying descriptor is put into non-blocking
-   * mode and direct system calls may fail with asio::error::would_block
-   * (or the equivalent system error).
-   *
-   * @throws asio::system_error Thrown on failure. If the @c mode is
-   * @c false, but the current value of @c non_blocking() is @c true, this
-   * function fails with asio::error::invalid_argument, as the
-   * combination does not make sense.
-   */
-  void native_non_blocking(bool mode)
-  {
-    asio::error_code ec;
-    this->get_service().native_non_blocking(
-        this->get_implementation(), mode, ec);
-    asio::detail::throw_error(ec, "native_non_blocking");
-  }
-
-  /// Sets the non-blocking mode of the native descriptor implementation.
-  /**
-   * This function is used to modify the non-blocking mode of the underlying
-   * native descriptor. It has no effect on the behaviour of the descriptor
-   * object's synchronous operations.
-   *
-   * @param mode If @c true, the underlying descriptor is put into non-blocking
-   * mode and direct system calls may fail with asio::error::would_block
-   * (or the equivalent system error).
-   *
-   * @param ec Set to indicate what error occurred, if any. If the @c mode is
-   * @c false, but the current value of @c non_blocking() is @c true, this
-   * function fails with asio::error::invalid_argument, as the
-   * combination does not make sense.
-   */
-  asio::error_code native_non_blocking(
-      bool mode, asio::error_code& ec)
-  {
-    return this->get_service().native_non_blocking(
-        this->get_implementation(), mode, ec);
-  }
-
-protected:
-  /// Protected destructor to prevent deletion through this type.
-  ~basic_descriptor()
-  {
-  }
-};
-
-} // namespace posix
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // defined(ASIO_HAS_POSIX_STREAM_DESCRIPTOR)
-       //   || defined(GENERATING_DOCUMENTATION)
-
-#endif // ASIO_POSIX_BASIC_DESCRIPTOR_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/posix/basic_stream_descriptor.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/posix/basic_stream_descriptor.hpp
deleted file mode 100644
index e433c6ad9d51..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/posix/basic_stream_descriptor.hpp
+++ /dev/null
@@ -1,362 +0,0 @@
-//
-// posix/basic_stream_descriptor.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_POSIX_BASIC_STREAM_DESCRIPTOR_HPP
-#define ASIO_POSIX_BASIC_STREAM_DESCRIPTOR_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_HAS_POSIX_STREAM_DESCRIPTOR) \
-  || defined(GENERATING_DOCUMENTATION)
-
-#include <cstddef>
-#include "asio/detail/handler_type_requirements.hpp"
-#include "asio/detail/throw_error.hpp"
-#include "asio/error.hpp"
-#include "asio/posix/basic_descriptor.hpp"
-#include "asio/posix/stream_descriptor_service.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace posix {
-
-/// Provides stream-oriented descriptor functionality.
-/**
- * The posix::basic_stream_descriptor class template provides asynchronous and
- * blocking stream-oriented descriptor functionality.
- *
- * @par Thread Safety
- * @e Distinct @e objects: Safe.@n
- * @e Shared @e objects: Unsafe.
- *
- * @par Concepts:
- * AsyncReadStream, AsyncWriteStream, Stream, SyncReadStream, SyncWriteStream.
- */
-template <typename StreamDescriptorService = stream_descriptor_service>
-class basic_stream_descriptor
-  : public basic_descriptor<StreamDescriptorService>
-{
-public:
-  /// (Deprecated: Use native_handle_type.) The native representation of a
-  /// descriptor.
-  typedef typename StreamDescriptorService::native_handle_type native_type;
-
-  /// The native representation of a descriptor.
-  typedef typename StreamDescriptorService::native_handle_type
-    native_handle_type;
-
-  /// Construct a basic_stream_descriptor without opening it.
-  /**
-   * This constructor creates a stream descriptor without opening it. The
-   * descriptor needs to be opened and then connected or accepted before data
-   * can be sent or received on it.
-   *
-   * @param io_service The io_service object that the stream descriptor will
-   * use to dispatch handlers for any asynchronous operations performed on the
-   * descriptor.
-   */
-  explicit basic_stream_descriptor(asio::io_service& io_service)
-    : basic_descriptor<StreamDescriptorService>(io_service)
-  {
-  }
-
-  /// Construct a basic_stream_descriptor on an existing native descriptor.
-  /**
-   * This constructor creates a stream descriptor object to hold an existing
-   * native descriptor.
-   *
-   * @param io_service The io_service object that the stream descriptor will
-   * use to dispatch handlers for any asynchronous operations performed on the
-   * descriptor.
-   *
-   * @param native_descriptor The new underlying descriptor implementation.
-   *
-   * @throws asio::system_error Thrown on failure.
-   */
-  basic_stream_descriptor(asio::io_service& io_service,
-      const native_handle_type& native_descriptor)
-    : basic_descriptor<StreamDescriptorService>(io_service, native_descriptor)
-  {
-  }
-
-#if defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
-  /// Move-construct a basic_stream_descriptor from another.
-  /**
-   * This constructor moves a stream descriptor from one object to another.
-   *
-   * @param other The other basic_stream_descriptor object from which the move
-   * will occur.
-   *
-   * @note Following the move, the moved-from object is in the same state as if
-   * constructed using the @c basic_stream_descriptor(io_service&) constructor.
-   */
-  basic_stream_descriptor(basic_stream_descriptor&& other)
-    : basic_descriptor<StreamDescriptorService>(
-        ASIO_MOVE_CAST(basic_stream_descriptor)(other))
-  {
-  }
-
-  /// Move-assign a basic_stream_descriptor from another.
-  /**
-   * This assignment operator moves a stream descriptor from one object to
-   * another.
-   *
-   * @param other The other basic_stream_descriptor object from which the move
-   * will occur.
-   *
-   * @note Following the move, the moved-from object is in the same state as if
-   * constructed using the @c basic_stream_descriptor(io_service&) constructor.
-   */
-  basic_stream_descriptor& operator=(basic_stream_descriptor&& other)
-  {
-    basic_descriptor<StreamDescriptorService>::operator=(
-        ASIO_MOVE_CAST(basic_stream_descriptor)(other));
-    return *this;
-  }
-#endif // defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
-
-  /// Write some data to the descriptor.
-  /**
-   * This function is used to write data to the stream descriptor. The function
-   * call will block until one or more bytes of the data has been written
-   * successfully, or until an error occurs.
-   *
-   * @param buffers One or more data buffers to be written to the descriptor.
-   *
-   * @returns The number of bytes written.
-   *
-   * @throws asio::system_error Thrown on failure. An error code of
-   * asio::error::eof indicates that the connection was closed by the
-   * peer.
-   *
-   * @note The write_some operation may not transmit all of the data to the
-   * peer. Consider using the @ref write function if you need to ensure that
-   * all data is written before the blocking operation completes.
-   *
-   * @par Example
-   * To write a single data buffer use the @ref buffer function as follows:
-   * @code
-   * descriptor.write_some(asio::buffer(data, size));
-   * @endcode
-   * See the @ref buffer documentation for information on writing multiple
-   * buffers in one go, and how to use it with arrays, boost::array or
-   * std::vector.
-   */
-  template <typename ConstBufferSequence>
-  std::size_t write_some(const ConstBufferSequence& buffers)
-  {
-    asio::error_code ec;
-    std::size_t s = this->get_service().write_some(
-        this->get_implementation(), buffers, ec);
-    asio::detail::throw_error(ec, "write_some");
-    return s;
-  }
-
-  /// Write some data to the descriptor.
-  /**
-   * This function is used to write data to the stream descriptor. The function
-   * call will block until one or more bytes of the data has been written
-   * successfully, or until an error occurs.
-   *
-   * @param buffers One or more data buffers to be written to the descriptor.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   *
-   * @returns The number of bytes written. Returns 0 if an error occurred.
-   *
-   * @note The write_some operation may not transmit all of the data to the
-   * peer. Consider using the @ref write function if you need to ensure that
-   * all data is written before the blocking operation completes.
-   */
-  template <typename ConstBufferSequence>
-  std::size_t write_some(const ConstBufferSequence& buffers,
-      asio::error_code& ec)
-  {
-    return this->get_service().write_some(
-        this->get_implementation(), buffers, ec);
-  }
-
-  /// Start an asynchronous write.
-  /**
-   * This function is used to asynchronously write data to the stream
-   * descriptor. The function call always returns immediately.
-   *
-   * @param buffers One or more data buffers to be written to the descriptor.
-   * Although the buffers object may be copied as necessary, ownership of the
-   * underlying memory blocks is retained by the caller, which must guarantee
-   * that they remain valid until the handler is called.
-   *
-   * @param handler The handler to be called when the write operation completes.
-   * Copies will be made of the handler as required. The function signature of
-   * the handler must be:
-   * @code void handler(
-   *   const asio::error_code& error, // Result of operation.
-   *   std::size_t bytes_transferred           // Number of bytes written.
-   * ); @endcode
-   * Regardless of whether the asynchronous operation completes immediately or
-   * not, the handler will not be invoked from within this function. Invocation
-   * of the handler will be performed in a manner equivalent to using
-   * asio::io_service::post().
-   *
-   * @note The write operation may not transmit all of the data to the peer.
-   * Consider using the @ref async_write function if you need to ensure that all
-   * data is written before the asynchronous operation completes.
-   *
-   * @par Example
-   * To write a single data buffer use the @ref buffer function as follows:
-   * @code
-   * descriptor.async_write_some(asio::buffer(data, size), handler);
-   * @endcode
-   * See the @ref buffer documentation for information on writing multiple
-   * buffers in one go, and how to use it with arrays, boost::array or
-   * std::vector.
-   */
-  template <typename ConstBufferSequence, typename WriteHandler>
-  ASIO_INITFN_RESULT_TYPE(WriteHandler,
-      void (asio::error_code, std::size_t))
-  async_write_some(const ConstBufferSequence& buffers,
-      ASIO_MOVE_ARG(WriteHandler) handler)
-  {
-    // If you get an error on the following line it means that your handler does
-    // not meet the documented type requirements for a WriteHandler.
-    ASIO_WRITE_HANDLER_CHECK(WriteHandler, handler) type_check;
-
-    return this->get_service().async_write_some(this->get_implementation(),
-        buffers, ASIO_MOVE_CAST(WriteHandler)(handler));
-  }
-
-  /// Read some data from the descriptor.
-  /**
-   * This function is used to read data from the stream descriptor. The function
-   * call will block until one or more bytes of data has been read successfully,
-   * or until an error occurs.
-   *
-   * @param buffers One or more buffers into which the data will be read.
-   *
-   * @returns The number of bytes read.
-   *
-   * @throws asio::system_error Thrown on failure. An error code of
-   * asio::error::eof indicates that the connection was closed by the
-   * peer.
-   *
-   * @note The read_some operation may not read all of the requested number of
-   * bytes. Consider using the @ref read function if you need to ensure that
-   * the requested amount of data is read before the blocking operation
-   * completes.
-   *
-   * @par Example
-   * To read into a single data buffer use the @ref buffer function as follows:
-   * @code
-   * descriptor.read_some(asio::buffer(data, size));
-   * @endcode
-   * See the @ref buffer documentation for information on reading into multiple
-   * buffers in one go, and how to use it with arrays, boost::array or
-   * std::vector.
-   */
-  template <typename MutableBufferSequence>
-  std::size_t read_some(const MutableBufferSequence& buffers)
-  {
-    asio::error_code ec;
-    std::size_t s = this->get_service().read_some(
-        this->get_implementation(), buffers, ec);
-    asio::detail::throw_error(ec, "read_some");
-    return s;
-  }
-
-  /// Read some data from the descriptor.
-  /**
-   * This function is used to read data from the stream descriptor. The function
-   * call will block until one or more bytes of data has been read successfully,
-   * or until an error occurs.
-   *
-   * @param buffers One or more buffers into which the data will be read.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   *
-   * @returns The number of bytes read. Returns 0 if an error occurred.
-   *
-   * @note The read_some operation may not read all of the requested number of
-   * bytes. Consider using the @ref read function if you need to ensure that
-   * the requested amount of data is read before the blocking operation
-   * completes.
-   */
-  template <typename MutableBufferSequence>
-  std::size_t read_some(const MutableBufferSequence& buffers,
-      asio::error_code& ec)
-  {
-    return this->get_service().read_some(
-        this->get_implementation(), buffers, ec);
-  }
-
-  /// Start an asynchronous read.
-  /**
-   * This function is used to asynchronously read data from the stream
-   * descriptor. The function call always returns immediately.
-   *
-   * @param buffers One or more buffers into which the data will be read.
-   * Although the buffers object may be copied as necessary, ownership of the
-   * underlying memory blocks is retained by the caller, which must guarantee
-   * that they remain valid until the handler is called.
-   *
-   * @param handler The handler to be called when the read operation completes.
-   * Copies will be made of the handler as required. The function signature of
-   * the handler must be:
-   * @code void handler(
-   *   const asio::error_code& error, // Result of operation.
-   *   std::size_t bytes_transferred           // Number of bytes read.
-   * ); @endcode
-   * Regardless of whether the asynchronous operation completes immediately or
-   * not, the handler will not be invoked from within this function. Invocation
-   * of the handler will be performed in a manner equivalent to using
-   * asio::io_service::post().
-   *
-   * @note The read operation may not read all of the requested number of bytes.
-   * Consider using the @ref async_read function if you need to ensure that the
-   * requested amount of data is read before the asynchronous operation
-   * completes.
-   *
-   * @par Example
-   * To read into a single data buffer use the @ref buffer function as follows:
-   * @code
-   * descriptor.async_read_some(asio::buffer(data, size), handler);
-   * @endcode
-   * See the @ref buffer documentation for information on reading into multiple
-   * buffers in one go, and how to use it with arrays, boost::array or
-   * std::vector.
-   */
-  template <typename MutableBufferSequence, typename ReadHandler>
-  ASIO_INITFN_RESULT_TYPE(ReadHandler,
-      void (asio::error_code, std::size_t))
-  async_read_some(const MutableBufferSequence& buffers,
-      ASIO_MOVE_ARG(ReadHandler) handler)
-  {
-    // If you get an error on the following line it means that your handler does
-    // not meet the documented type requirements for a ReadHandler.
-    ASIO_READ_HANDLER_CHECK(ReadHandler, handler) type_check;
-
-    return this->get_service().async_read_some(this->get_implementation(),
-        buffers, ASIO_MOVE_CAST(ReadHandler)(handler));
-  }
-};
-
-} // namespace posix
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // defined(ASIO_HAS_POSIX_STREAM_DESCRIPTOR)
-       //   || defined(GENERATING_DOCUMENTATION)
-
-#endif // ASIO_POSIX_BASIC_STREAM_DESCRIPTOR_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/posix/descriptor_base.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/posix/descriptor_base.hpp
deleted file mode 100644
index f9bc8417aed2..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/posix/descriptor_base.hpp
+++ /dev/null
@@ -1,97 +0,0 @@
-//
-// posix/descriptor_base.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_POSIX_DESCRIPTOR_BASE_HPP
-#define ASIO_POSIX_DESCRIPTOR_BASE_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_HAS_POSIX_STREAM_DESCRIPTOR) \
-  || defined(GENERATING_DOCUMENTATION)
-
-#include "asio/detail/io_control.hpp"
-#include "asio/detail/socket_option.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace posix {
-
-/// The descriptor_base class is used as a base for the basic_stream_descriptor
-/// class template so that we have a common place to define the associated
-/// IO control commands.
-class descriptor_base
-{
-public:
-  /// (Deprecated: Use non_blocking().) IO control command to set the blocking
-  /// mode of the descriptor.
-  /**
-   * Implements the FIONBIO IO control command.
-   *
-   * @par Example
-   * @code
-   * asio::posix::stream_descriptor descriptor(io_service); 
-   * ...
-   * asio::descriptor_base::non_blocking_io command(true);
-   * descriptor.io_control(command);
-   * @endcode
-   *
-   * @par Concepts:
-   * IoControlCommand.
-   */
-#if defined(GENERATING_DOCUMENTATION)
-  typedef implementation_defined non_blocking_io;
-#else
-  typedef asio::detail::io_control::non_blocking_io non_blocking_io;
-#endif
-
-  /// IO control command to get the amount of data that can be read without
-  /// blocking.
-  /**
-   * Implements the FIONREAD IO control command.
-   *
-   * @par Example
-   * @code
-   * asio::posix::stream_descriptor descriptor(io_service); 
-   * ...
-   * asio::descriptor_base::bytes_readable command(true);
-   * descriptor.io_control(command);
-   * std::size_t bytes_readable = command.get();
-   * @endcode
-   *
-   * @par Concepts:
-   * IoControlCommand.
-   */
-#if defined(GENERATING_DOCUMENTATION)
-  typedef implementation_defined bytes_readable;
-#else
-  typedef asio::detail::io_control::bytes_readable bytes_readable;
-#endif
-
-protected:
-  /// Protected destructor to prevent deletion through this type.
-  ~descriptor_base()
-  {
-  }
-};
-
-} // namespace posix
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // defined(ASIO_HAS_POSIX_STREAM_DESCRIPTOR)
-       //   || defined(GENERATING_DOCUMENTATION)
-
-#endif // ASIO_POSIX_DESCRIPTOR_BASE_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/posix/stream_descriptor.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/posix/stream_descriptor.hpp
deleted file mode 100644
index de90fb5c622f..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/posix/stream_descriptor.hpp
+++ /dev/null
@@ -1,37 +0,0 @@
-//
-// posix/stream_descriptor.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_POSIX_STREAM_DESCRIPTOR_HPP
-#define ASIO_POSIX_STREAM_DESCRIPTOR_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_HAS_POSIX_STREAM_DESCRIPTOR) \
-  || defined(GENERATING_DOCUMENTATION)
-
-#include "asio/posix/basic_stream_descriptor.hpp"
-
-namespace asio {
-namespace posix {
-
-/// Typedef for the typical usage of a stream-oriented descriptor.
-typedef basic_stream_descriptor<> stream_descriptor;
-
-} // namespace posix
-} // namespace asio
-
-#endif // defined(ASIO_HAS_POSIX_STREAM_DESCRIPTOR)
-       //   || defined(GENERATING_DOCUMENTATION)
-
-#endif // ASIO_POSIX_STREAM_DESCRIPTOR_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/posix/stream_descriptor_service.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/posix/stream_descriptor_service.hpp
deleted file mode 100644
index 556912ecf7d8..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/posix/stream_descriptor_service.hpp
+++ /dev/null
@@ -1,260 +0,0 @@
-//
-// posix/stream_descriptor_service.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_POSIX_STREAM_DESCRIPTOR_SERVICE_HPP
-#define ASIO_POSIX_STREAM_DESCRIPTOR_SERVICE_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_HAS_POSIX_STREAM_DESCRIPTOR) \
-  || defined(GENERATING_DOCUMENTATION)
-
-#include <cstddef>
-#include "asio/async_result.hpp"
-#include "asio/error.hpp"
-#include "asio/io_service.hpp"
-#include "asio/detail/reactive_descriptor_service.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace posix {
-
-/// Default service implementation for a stream descriptor.
-class stream_descriptor_service
-#if defined(GENERATING_DOCUMENTATION)
-  : public asio::io_service::service
-#else
-  : public asio::detail::service_base<stream_descriptor_service>
-#endif
-{
-public:
-#if defined(GENERATING_DOCUMENTATION)
-  /// The unique service identifier.
-  static asio::io_service::id id;
-#endif
-
-private:
-  // The type of the platform-specific implementation.
-  typedef detail::reactive_descriptor_service service_impl_type;
-
-public:
-  /// The type of a stream descriptor implementation.
-#if defined(GENERATING_DOCUMENTATION)
-  typedef implementation_defined implementation_type;
-#else
-  typedef service_impl_type::implementation_type implementation_type;
-#endif
-
-  /// (Deprecated: Use native_handle_type.) The native descriptor type.
-#if defined(GENERATING_DOCUMENTATION)
-  typedef implementation_defined native_type;
-#else
-  typedef service_impl_type::native_handle_type native_type;
-#endif
-
-  /// The native descriptor type.
-#if defined(GENERATING_DOCUMENTATION)
-  typedef implementation_defined native_handle_type;
-#else
-  typedef service_impl_type::native_handle_type native_handle_type;
-#endif
-
-  /// Construct a new stream descriptor service for the specified io_service.
-  explicit stream_descriptor_service(asio::io_service& io_service)
-    : asio::detail::service_base<stream_descriptor_service>(io_service),
-      service_impl_(io_service)
-  {
-  }
-
-  /// Construct a new stream descriptor implementation.
-  void construct(implementation_type& impl)
-  {
-    service_impl_.construct(impl);
-  }
-
-#if defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
-  /// Move-construct a new stream descriptor implementation.
-  void move_construct(implementation_type& impl,
-      implementation_type& other_impl)
-  {
-    service_impl_.move_construct(impl, other_impl);
-  }
-
-  /// Move-assign from another stream descriptor implementation.
-  void move_assign(implementation_type& impl,
-      stream_descriptor_service& other_service,
-      implementation_type& other_impl)
-  {
-    service_impl_.move_assign(impl, other_service.service_impl_, other_impl);
-  }
-#endif // defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
-
-  /// Destroy a stream descriptor implementation.
-  void destroy(implementation_type& impl)
-  {
-    service_impl_.destroy(impl);
-  }
-
-  /// Assign an existing native descriptor to a stream descriptor.
-  asio::error_code assign(implementation_type& impl,
-      const native_handle_type& native_descriptor,
-      asio::error_code& ec)
-  {
-    return service_impl_.assign(impl, native_descriptor, ec);
-  }
-
-  /// Determine whether the descriptor is open.
-  bool is_open(const implementation_type& impl) const
-  {
-    return service_impl_.is_open(impl);
-  }
-
-  /// Close a stream descriptor implementation.
-  asio::error_code close(implementation_type& impl,
-      asio::error_code& ec)
-  {
-    return service_impl_.close(impl, ec);
-  }
-
-  /// (Deprecated: Use native_handle().) Get the native descriptor
-  /// implementation.
-  native_type native(implementation_type& impl)
-  {
-    return service_impl_.native_handle(impl);
-  }
-
-  /// Get the native descriptor implementation.
-  native_handle_type native_handle(implementation_type& impl)
-  {
-    return service_impl_.native_handle(impl);
-  }
-
-  /// Release ownership of the native descriptor implementation.
-  native_handle_type release(implementation_type& impl)
-  {
-    return service_impl_.release(impl);
-  }
-
-  /// Cancel all asynchronous operations associated with the descriptor.
-  asio::error_code cancel(implementation_type& impl,
-      asio::error_code& ec)
-  {
-    return service_impl_.cancel(impl, ec);
-  }
-
-  /// Perform an IO control command on the descriptor.
-  template <typename IoControlCommand>
-  asio::error_code io_control(implementation_type& impl,
-      IoControlCommand& command, asio::error_code& ec)
-  {
-    return service_impl_.io_control(impl, command, ec);
-  }
-
-  /// Gets the non-blocking mode of the descriptor.
-  bool non_blocking(const implementation_type& impl) const
-  {
-    return service_impl_.non_blocking(impl);
-  }
-
-  /// Sets the non-blocking mode of the descriptor.
-  asio::error_code non_blocking(implementation_type& impl,
-      bool mode, asio::error_code& ec)
-  {
-    return service_impl_.non_blocking(impl, mode, ec);
-  }
-
-  /// Gets the non-blocking mode of the native descriptor implementation.
-  bool native_non_blocking(const implementation_type& impl) const
-  {
-    return service_impl_.native_non_blocking(impl);
-  }
-
-  /// Sets the non-blocking mode of the native descriptor implementation.
-  asio::error_code native_non_blocking(implementation_type& impl,
-      bool mode, asio::error_code& ec)
-  {
-    return service_impl_.native_non_blocking(impl, mode, ec);
-  }
-
-  /// Write the given data to the stream.
-  template <typename ConstBufferSequence>
-  std::size_t write_some(implementation_type& impl,
-      const ConstBufferSequence& buffers, asio::error_code& ec)
-  {
-    return service_impl_.write_some(impl, buffers, ec);
-  }
-
-  /// Start an asynchronous write.
-  template <typename ConstBufferSequence, typename WriteHandler>
-  ASIO_INITFN_RESULT_TYPE(WriteHandler,
-      void (asio::error_code, std::size_t))
-  async_write_some(implementation_type& impl,
-      const ConstBufferSequence& buffers,
-      ASIO_MOVE_ARG(WriteHandler) handler)
-  {
-    asio::detail::async_result_init<
-      WriteHandler, void (asio::error_code, std::size_t)> init(
-        ASIO_MOVE_CAST(WriteHandler)(handler));
-
-    service_impl_.async_write_some(impl, buffers, init.handler);
-
-    return init.result.get();
-  }
-
-  /// Read some data from the stream.
-  template <typename MutableBufferSequence>
-  std::size_t read_some(implementation_type& impl,
-      const MutableBufferSequence& buffers, asio::error_code& ec)
-  {
-    return service_impl_.read_some(impl, buffers, ec);
-  }
-
-  /// Start an asynchronous read.
-  template <typename MutableBufferSequence, typename ReadHandler>
-  ASIO_INITFN_RESULT_TYPE(ReadHandler,
-      void (asio::error_code, std::size_t))
-  async_read_some(implementation_type& impl,
-      const MutableBufferSequence& buffers,
-      ASIO_MOVE_ARG(ReadHandler) handler)
-  {
-    asio::detail::async_result_init<
-      ReadHandler, void (asio::error_code, std::size_t)> init(
-        ASIO_MOVE_CAST(ReadHandler)(handler));
-
-    service_impl_.async_read_some(impl, buffers, init.handler);
-
-    return init.result.get();
-  }
-
-private:
-  // Destroy all user-defined handler objects owned by the service.
-  void shutdown_service()
-  {
-    service_impl_.shutdown_service();
-  }
-
-  // The platform-specific implementation.
-  service_impl_type service_impl_;
-};
-
-} // namespace posix
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // defined(ASIO_HAS_POSIX_STREAM_DESCRIPTOR)
-       //   || defined(GENERATING_DOCUMENTATION)
-
-#endif // ASIO_POSIX_STREAM_DESCRIPTOR_SERVICE_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/raw_socket_service.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/raw_socket_service.hpp
deleted file mode 100644
index 03e7ae85dcee..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/raw_socket_service.hpp
+++ /dev/null
@@ -1,432 +0,0 @@
-//
-// raw_socket_service.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_RAW_SOCKET_SERVICE_HPP
-#define ASIO_RAW_SOCKET_SERVICE_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include <cstddef>
-#include "asio/async_result.hpp"
-#include "asio/detail/type_traits.hpp"
-#include "asio/error.hpp"
-#include "asio/io_service.hpp"
-
-#if defined(ASIO_WINDOWS_RUNTIME)
-# include "asio/detail/null_socket_service.hpp"
-#elif defined(ASIO_HAS_IOCP)
-# include "asio/detail/win_iocp_socket_service.hpp"
-#else
-# include "asio/detail/reactive_socket_service.hpp"
-#endif
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-
-/// Default service implementation for a raw socket.
-template <typename Protocol>
-class raw_socket_service
-#if defined(GENERATING_DOCUMENTATION)
-  : public asio::io_service::service
-#else
-  : public asio::detail::service_base<raw_socket_service<Protocol> >
-#endif
-{
-public:
-#if defined(GENERATING_DOCUMENTATION)
-  /// The unique service identifier.
-  static asio::io_service::id id;
-#endif
-
-  /// The protocol type.
-  typedef Protocol protocol_type;
-
-  /// The endpoint type.
-  typedef typename Protocol::endpoint endpoint_type;
-
-private:
-  // The type of the platform-specific implementation.
-#if defined(ASIO_WINDOWS_RUNTIME)
-  typedef detail::null_socket_service<Protocol> service_impl_type;
-#elif defined(ASIO_HAS_IOCP)
-  typedef detail::win_iocp_socket_service<Protocol> service_impl_type;
-#else
-  typedef detail::reactive_socket_service<Protocol> service_impl_type;
-#endif
-
-public:
-  /// The type of a raw socket.
-#if defined(GENERATING_DOCUMENTATION)
-  typedef implementation_defined implementation_type;
-#else
-  typedef typename service_impl_type::implementation_type implementation_type;
-#endif
-
-  /// (Deprecated: Use native_handle_type.) The native socket type.
-#if defined(GENERATING_DOCUMENTATION)
-  typedef implementation_defined native_type;
-#else
-  typedef typename service_impl_type::native_handle_type native_type;
-#endif
-
-  /// The native socket type.
-#if defined(GENERATING_DOCUMENTATION)
-  typedef implementation_defined native_handle_type;
-#else
-  typedef typename service_impl_type::native_handle_type native_handle_type;
-#endif
-
-  /// Construct a new raw socket service for the specified io_service.
-  explicit raw_socket_service(asio::io_service& io_service)
-    : asio::detail::service_base<
-        raw_socket_service<Protocol> >(io_service),
-      service_impl_(io_service)
-  {
-  }
-
-  /// Construct a new raw socket implementation.
-  void construct(implementation_type& impl)
-  {
-    service_impl_.construct(impl);
-  }
-
-#if defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
-  /// Move-construct a new raw socket implementation.
-  void move_construct(implementation_type& impl,
-      implementation_type& other_impl)
-  {
-    service_impl_.move_construct(impl, other_impl);
-  }
-
-  /// Move-assign from another raw socket implementation.
-  void move_assign(implementation_type& impl,
-      raw_socket_service& other_service,
-      implementation_type& other_impl)
-  {
-    service_impl_.move_assign(impl, other_service.service_impl_, other_impl);
-  }
-
-  /// Move-construct a new raw socket implementation from another protocol
-  /// type.
-  template <typename Protocol1>
-  void converting_move_construct(implementation_type& impl,
-      typename raw_socket_service<
-        Protocol1>::implementation_type& other_impl,
-      typename enable_if<is_convertible<
-        Protocol1, Protocol>::value>::type* = 0)
-  {
-    service_impl_.template converting_move_construct<Protocol1>(
-        impl, other_impl);
-  }
-#endif // defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
-
-  /// Destroy a raw socket implementation.
-  void destroy(implementation_type& impl)
-  {
-    service_impl_.destroy(impl);
-  }
-
-  // Open a new raw socket implementation.
-  asio::error_code open(implementation_type& impl,
-      const protocol_type& protocol, asio::error_code& ec)
-  {
-    if (protocol.type() == ASIO_OS_DEF(SOCK_RAW))
-      service_impl_.open(impl, protocol, ec);
-    else
-      ec = asio::error::invalid_argument;
-    return ec;
-  }
-
-  /// Assign an existing native socket to a raw socket.
-  asio::error_code assign(implementation_type& impl,
-      const protocol_type& protocol, const native_handle_type& native_socket,
-      asio::error_code& ec)
-  {
-    return service_impl_.assign(impl, protocol, native_socket, ec);
-  }
-
-  /// Determine whether the socket is open.
-  bool is_open(const implementation_type& impl) const
-  {
-    return service_impl_.is_open(impl);
-  }
-
-  /// Close a raw socket implementation.
-  asio::error_code close(implementation_type& impl,
-      asio::error_code& ec)
-  {
-    return service_impl_.close(impl, ec);
-  }
-
-  /// (Deprecated: Use native_handle().) Get the native socket implementation.
-  native_type native(implementation_type& impl)
-  {
-    return service_impl_.native_handle(impl);
-  }
-
-  /// Get the native socket implementation.
-  native_handle_type native_handle(implementation_type& impl)
-  {
-    return service_impl_.native_handle(impl);
-  }
-
-  /// Cancel all asynchronous operations associated with the socket.
-  asio::error_code cancel(implementation_type& impl,
-      asio::error_code& ec)
-  {
-    return service_impl_.cancel(impl, ec);
-  }
-
-  /// Determine whether the socket is at the out-of-band data mark.
-  bool at_mark(const implementation_type& impl,
-      asio::error_code& ec) const
-  {
-    return service_impl_.at_mark(impl, ec);
-  }
-
-  /// Determine the number of bytes available for reading.
-  std::size_t available(const implementation_type& impl,
-      asio::error_code& ec) const
-  {
-    return service_impl_.available(impl, ec);
-  }
-
-  // Bind the raw socket to the specified local endpoint.
-  asio::error_code bind(implementation_type& impl,
-      const endpoint_type& endpoint, asio::error_code& ec)
-  {
-    return service_impl_.bind(impl, endpoint, ec);
-  }
-
-  /// Connect the raw socket to the specified endpoint.
-  asio::error_code connect(implementation_type& impl,
-      const endpoint_type& peer_endpoint, asio::error_code& ec)
-  {
-    return service_impl_.connect(impl, peer_endpoint, ec);
-  }
-
-  /// Start an asynchronous connect.
-  template <typename ConnectHandler>
-  ASIO_INITFN_RESULT_TYPE(ConnectHandler,
-      void (asio::error_code))
-  async_connect(implementation_type& impl,
-      const endpoint_type& peer_endpoint,
-      ASIO_MOVE_ARG(ConnectHandler) handler)
-  {
-    detail::async_result_init<
-      ConnectHandler, void (asio::error_code)> init(
-        ASIO_MOVE_CAST(ConnectHandler)(handler));
-
-    service_impl_.async_connect(impl, peer_endpoint, init.handler);
-
-    return init.result.get();
-  }
-
-  /// Set a socket option.
-  template <typename SettableSocketOption>
-  asio::error_code set_option(implementation_type& impl,
-      const SettableSocketOption& option, asio::error_code& ec)
-  {
-    return service_impl_.set_option(impl, option, ec);
-  }
-
-  /// Get a socket option.
-  template <typename GettableSocketOption>
-  asio::error_code get_option(const implementation_type& impl,
-      GettableSocketOption& option, asio::error_code& ec) const
-  {
-    return service_impl_.get_option(impl, option, ec);
-  }
-
-  /// Perform an IO control command on the socket.
-  template <typename IoControlCommand>
-  asio::error_code io_control(implementation_type& impl,
-      IoControlCommand& command, asio::error_code& ec)
-  {
-    return service_impl_.io_control(impl, command, ec);
-  }
-
-  /// Gets the non-blocking mode of the socket.
-  bool non_blocking(const implementation_type& impl) const
-  {
-    return service_impl_.non_blocking(impl);
-  }
-
-  /// Sets the non-blocking mode of the socket.
-  asio::error_code non_blocking(implementation_type& impl,
-      bool mode, asio::error_code& ec)
-  {
-    return service_impl_.non_blocking(impl, mode, ec);
-  }
-
-  /// Gets the non-blocking mode of the native socket implementation.
-  bool native_non_blocking(const implementation_type& impl) const
-  {
-    return service_impl_.native_non_blocking(impl);
-  }
-
-  /// Sets the non-blocking mode of the native socket implementation.
-  asio::error_code native_non_blocking(implementation_type& impl,
-      bool mode, asio::error_code& ec)
-  {
-    return service_impl_.native_non_blocking(impl, mode, ec);
-  }
-
-  /// Get the local endpoint.
-  endpoint_type local_endpoint(const implementation_type& impl,
-      asio::error_code& ec) const
-  {
-    return service_impl_.local_endpoint(impl, ec);
-  }
-
-  /// Get the remote endpoint.
-  endpoint_type remote_endpoint(const implementation_type& impl,
-      asio::error_code& ec) const
-  {
-    return service_impl_.remote_endpoint(impl, ec);
-  }
-
-  /// Disable sends or receives on the socket.
-  asio::error_code shutdown(implementation_type& impl,
-      socket_base::shutdown_type what, asio::error_code& ec)
-  {
-    return service_impl_.shutdown(impl, what, ec);
-  }
-
-  /// Send the given data to the peer.
-  template <typename ConstBufferSequence>
-  std::size_t send(implementation_type& impl,
-      const ConstBufferSequence& buffers,
-      socket_base::message_flags flags, asio::error_code& ec)
-  {
-    return service_impl_.send(impl, buffers, flags, ec);
-  }
-
-  /// Start an asynchronous send.
-  template <typename ConstBufferSequence, typename WriteHandler>
-  ASIO_INITFN_RESULT_TYPE(WriteHandler,
-      void (asio::error_code, std::size_t))
-  async_send(implementation_type& impl, const ConstBufferSequence& buffers,
-      socket_base::message_flags flags,
-      ASIO_MOVE_ARG(WriteHandler) handler)
-  {
-    detail::async_result_init<
-      WriteHandler, void (asio::error_code, std::size_t)> init(
-        ASIO_MOVE_CAST(WriteHandler)(handler));
-
-    service_impl_.async_send(impl, buffers, flags, init.handler);
-
-    return init.result.get();
-  }
-
-  /// Send raw data to the specified endpoint.
-  template <typename ConstBufferSequence>
-  std::size_t send_to(implementation_type& impl,
-      const ConstBufferSequence& buffers, const endpoint_type& destination,
-      socket_base::message_flags flags, asio::error_code& ec)
-  {
-    return service_impl_.send_to(impl, buffers, destination, flags, ec);
-  }
-
-  /// Start an asynchronous send.
-  template <typename ConstBufferSequence, typename WriteHandler>
-  ASIO_INITFN_RESULT_TYPE(WriteHandler,
-      void (asio::error_code, std::size_t))
-  async_send_to(implementation_type& impl,
-      const ConstBufferSequence& buffers, const endpoint_type& destination,
-      socket_base::message_flags flags,
-      ASIO_MOVE_ARG(WriteHandler) handler)
-  {
-    detail::async_result_init<
-      WriteHandler, void (asio::error_code, std::size_t)> init(
-        ASIO_MOVE_CAST(WriteHandler)(handler));
-
-    service_impl_.async_send_to(impl, buffers,
-        destination, flags, init.handler);
-
-    return init.result.get();
-  }
-
-  /// Receive some data from the peer.
-  template <typename MutableBufferSequence>
-  std::size_t receive(implementation_type& impl,
-      const MutableBufferSequence& buffers,
-      socket_base::message_flags flags, asio::error_code& ec)
-  {
-    return service_impl_.receive(impl, buffers, flags, ec);
-  }
-
-  /// Start an asynchronous receive.
-  template <typename MutableBufferSequence, typename ReadHandler>
-  ASIO_INITFN_RESULT_TYPE(ReadHandler,
-      void (asio::error_code, std::size_t))
-  async_receive(implementation_type& impl,
-      const MutableBufferSequence& buffers,
-      socket_base::message_flags flags,
-      ASIO_MOVE_ARG(ReadHandler) handler)
-  {
-    detail::async_result_init<
-      ReadHandler, void (asio::error_code, std::size_t)> init(
-        ASIO_MOVE_CAST(ReadHandler)(handler));
-
-    service_impl_.async_receive(impl, buffers, flags, init.handler);
-
-    return init.result.get();
-  }
-
-  /// Receive raw data with the endpoint of the sender.
-  template <typename MutableBufferSequence>
-  std::size_t receive_from(implementation_type& impl,
-      const MutableBufferSequence& buffers, endpoint_type& sender_endpoint,
-      socket_base::message_flags flags, asio::error_code& ec)
-  {
-    return service_impl_.receive_from(impl, buffers, sender_endpoint, flags,
-        ec);
-  }
-
-  /// Start an asynchronous receive that will get the endpoint of the sender.
-  template <typename MutableBufferSequence, typename ReadHandler>
-  ASIO_INITFN_RESULT_TYPE(ReadHandler,
-      void (asio::error_code, std::size_t))
-  async_receive_from(implementation_type& impl,
-      const MutableBufferSequence& buffers, endpoint_type& sender_endpoint,
-      socket_base::message_flags flags,
-      ASIO_MOVE_ARG(ReadHandler) handler)
-  {
-    detail::async_result_init<
-      ReadHandler, void (asio::error_code, std::size_t)> init(
-        ASIO_MOVE_CAST(ReadHandler)(handler));
-
-    service_impl_.async_receive_from(impl, buffers,
-        sender_endpoint, flags, init.handler);
-
-    return init.result.get();
-  }
-
-private:
-  // Destroy all user-defined handler objects owned by the service.
-  void shutdown_service()
-  {
-    service_impl_.shutdown_service();
-  }
-
-  // The platform-specific implementation.
-  service_impl_type service_impl_;
-};
-
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_RAW_SOCKET_SERVICE_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/read.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/read.hpp
deleted file mode 100644
index 12c7653c1cdf..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/read.hpp
+++ /dev/null
@@ -1,631 +0,0 @@
-//
-// read.hpp
-// ~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_READ_HPP
-#define ASIO_READ_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include <cstddef>
-#include "asio/async_result.hpp"
-#include "asio/basic_streambuf_fwd.hpp"
-#include "asio/error.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-
-/**
- * @defgroup read asio::read
- *
- * @brief Attempt to read a certain amount of data from a stream before
- * returning.
- */
-/*@{*/
-
-/// Attempt to read a certain amount of data from a stream before returning.
-/**
- * This function is used to read a certain number of bytes of data from a
- * stream. The call will block until one of the following conditions is true:
- *
- * @li The supplied buffers are full. That is, the bytes transferred is equal to
- * the sum of the buffer sizes.
- *
- * @li An error occurred.
- *
- * This operation is implemented in terms of zero or more calls to the stream's
- * read_some function.
- *
- * @param s The stream from which the data is to be read. The type must support
- * the SyncReadStream concept.
- *
- * @param buffers One or more buffers into which the data will be read. The sum
- * of the buffer sizes indicates the maximum number of bytes to read from the
- * stream.
- *
- * @returns The number of bytes transferred.
- *
- * @throws asio::system_error Thrown on failure.
- *
- * @par Example
- * To read into a single data buffer use the @ref buffer function as follows:
- * @code asio::read(s, asio::buffer(data, size)); @endcode
- * See the @ref buffer documentation for information on reading into multiple
- * buffers in one go, and how to use it with arrays, boost::array or
- * std::vector.
- *
- * @note This overload is equivalent to calling:
- * @code asio::read(
- *     s, buffers,
- *     asio::transfer_all()); @endcode
- */
-template <typename SyncReadStream, typename MutableBufferSequence>
-std::size_t read(SyncReadStream& s, const MutableBufferSequence& buffers);
-
-/// Attempt to read a certain amount of data from a stream before returning.
-/**
- * This function is used to read a certain number of bytes of data from a
- * stream. The call will block until one of the following conditions is true:
- *
- * @li The supplied buffers are full. That is, the bytes transferred is equal to
- * the sum of the buffer sizes.
- *
- * @li An error occurred.
- *
- * This operation is implemented in terms of zero or more calls to the stream's
- * read_some function.
- *
- * @param s The stream from which the data is to be read. The type must support
- * the SyncReadStream concept.
- *
- * @param buffers One or more buffers into which the data will be read. The sum
- * of the buffer sizes indicates the maximum number of bytes to read from the
- * stream.
- *
- * @param ec Set to indicate what error occurred, if any.
- *
- * @returns The number of bytes transferred.
- *
- * @par Example
- * To read into a single data buffer use the @ref buffer function as follows:
- * @code asio::read(s, asio::buffer(data, size), ec); @endcode
- * See the @ref buffer documentation for information on reading into multiple
- * buffers in one go, and how to use it with arrays, boost::array or
- * std::vector.
- *
- * @note This overload is equivalent to calling:
- * @code asio::read(
- *     s, buffers,
- *     asio::transfer_all(), ec); @endcode
- */
-template <typename SyncReadStream, typename MutableBufferSequence>
-std::size_t read(SyncReadStream& s, const MutableBufferSequence& buffers,
-    asio::error_code& ec);
-
-/// Attempt to read a certain amount of data from a stream before returning.
-/**
- * This function is used to read a certain number of bytes of data from a
- * stream. The call will block until one of the following conditions is true:
- *
- * @li The supplied buffers are full. That is, the bytes transferred is equal to
- * the sum of the buffer sizes.
- *
- * @li The completion_condition function object returns 0.
- *
- * This operation is implemented in terms of zero or more calls to the stream's
- * read_some function.
- *
- * @param s The stream from which the data is to be read. The type must support
- * the SyncReadStream concept.
- *
- * @param buffers One or more buffers into which the data will be read. The sum
- * of the buffer sizes indicates the maximum number of bytes to read from the
- * stream.
- *
- * @param completion_condition The function object to be called to determine
- * whether the read operation is complete. The signature of the function object
- * must be:
- * @code std::size_t completion_condition(
- *   // Result of latest read_some operation.
- *   const asio::error_code& error,
- *
- *   // Number of bytes transferred so far.
- *   std::size_t bytes_transferred
- * ); @endcode
- * A return value of 0 indicates that the read operation is complete. A non-zero
- * return value indicates the maximum number of bytes to be read on the next
- * call to the stream's read_some function.
- *
- * @returns The number of bytes transferred.
- *
- * @throws asio::system_error Thrown on failure.
- *
- * @par Example
- * To read into a single data buffer use the @ref buffer function as follows:
- * @code asio::read(s, asio::buffer(data, size),
- *     asio::transfer_at_least(32)); @endcode
- * See the @ref buffer documentation for information on reading into multiple
- * buffers in one go, and how to use it with arrays, boost::array or
- * std::vector.
- */
-template <typename SyncReadStream, typename MutableBufferSequence,
-  typename CompletionCondition>
-std::size_t read(SyncReadStream& s, const MutableBufferSequence& buffers,
-    CompletionCondition completion_condition);
-
-/// Attempt to read a certain amount of data from a stream before returning.
-/**
- * This function is used to read a certain number of bytes of data from a
- * stream. The call will block until one of the following conditions is true:
- *
- * @li The supplied buffers are full. That is, the bytes transferred is equal to
- * the sum of the buffer sizes.
- *
- * @li The completion_condition function object returns 0.
- *
- * This operation is implemented in terms of zero or more calls to the stream's
- * read_some function.
- *
- * @param s The stream from which the data is to be read. The type must support
- * the SyncReadStream concept.
- *
- * @param buffers One or more buffers into which the data will be read. The sum
- * of the buffer sizes indicates the maximum number of bytes to read from the
- * stream.
- *
- * @param completion_condition The function object to be called to determine
- * whether the read operation is complete. The signature of the function object
- * must be:
- * @code std::size_t completion_condition(
- *   // Result of latest read_some operation.
- *   const asio::error_code& error,
- *
- *   // Number of bytes transferred so far.
- *   std::size_t bytes_transferred
- * ); @endcode
- * A return value of 0 indicates that the read operation is complete. A non-zero
- * return value indicates the maximum number of bytes to be read on the next
- * call to the stream's read_some function.
- *
- * @param ec Set to indicate what error occurred, if any.
- *
- * @returns The number of bytes read. If an error occurs, returns the total
- * number of bytes successfully transferred prior to the error.
- */
-template <typename SyncReadStream, typename MutableBufferSequence,
-    typename CompletionCondition>
-std::size_t read(SyncReadStream& s, const MutableBufferSequence& buffers,
-    CompletionCondition completion_condition, asio::error_code& ec);
-
-#if !defined(ASIO_NO_IOSTREAM)
-
-/// Attempt to read a certain amount of data from a stream before returning.
-/**
- * This function is used to read a certain number of bytes of data from a
- * stream. The call will block until one of the following conditions is true:
- *
- * @li The supplied buffer is full (that is, it has reached maximum size).
- *
- * @li An error occurred.
- *
- * This operation is implemented in terms of zero or more calls to the stream's
- * read_some function.
- *
- * @param s The stream from which the data is to be read. The type must support
- * the SyncReadStream concept.
- *
- * @param b The basic_streambuf object into which the data will be read.
- *
- * @returns The number of bytes transferred.
- *
- * @throws asio::system_error Thrown on failure.
- *
- * @note This overload is equivalent to calling:
- * @code asio::read(
- *     s, b,
- *     asio::transfer_all()); @endcode
- */
-template <typename SyncReadStream, typename Allocator>
-std::size_t read(SyncReadStream& s, basic_streambuf<Allocator>& b);
-
-/// Attempt to read a certain amount of data from a stream before returning.
-/**
- * This function is used to read a certain number of bytes of data from a
- * stream. The call will block until one of the following conditions is true:
- *
- * @li The supplied buffer is full (that is, it has reached maximum size).
- *
- * @li An error occurred.
- *
- * This operation is implemented in terms of zero or more calls to the stream's
- * read_some function.
- *
- * @param s The stream from which the data is to be read. The type must support
- * the SyncReadStream concept.
- *
- * @param b The basic_streambuf object into which the data will be read.
- *
- * @param ec Set to indicate what error occurred, if any.
- *
- * @returns The number of bytes transferred.
- *
- * @note This overload is equivalent to calling:
- * @code asio::read(
- *     s, b,
- *     asio::transfer_all(), ec); @endcode
- */
-template <typename SyncReadStream, typename Allocator>
-std::size_t read(SyncReadStream& s, basic_streambuf<Allocator>& b,
-    asio::error_code& ec);
-
-/// Attempt to read a certain amount of data from a stream before returning.
-/**
- * This function is used to read a certain number of bytes of data from a
- * stream. The call will block until one of the following conditions is true:
- *
- * @li The supplied buffer is full (that is, it has reached maximum size).
- *
- * @li The completion_condition function object returns 0.
- *
- * This operation is implemented in terms of zero or more calls to the stream's
- * read_some function.
- *
- * @param s The stream from which the data is to be read. The type must support
- * the SyncReadStream concept.
- *
- * @param b The basic_streambuf object into which the data will be read.
- *
- * @param completion_condition The function object to be called to determine
- * whether the read operation is complete. The signature of the function object
- * must be:
- * @code std::size_t completion_condition(
- *   // Result of latest read_some operation.
- *   const asio::error_code& error,
- *
- *   // Number of bytes transferred so far.
- *   std::size_t bytes_transferred
- * ); @endcode
- * A return value of 0 indicates that the read operation is complete. A non-zero
- * return value indicates the maximum number of bytes to be read on the next
- * call to the stream's read_some function.
- *
- * @returns The number of bytes transferred.
- *
- * @throws asio::system_error Thrown on failure.
- */
-template <typename SyncReadStream, typename Allocator,
-    typename CompletionCondition>
-std::size_t read(SyncReadStream& s, basic_streambuf<Allocator>& b,
-    CompletionCondition completion_condition);
-
-/// Attempt to read a certain amount of data from a stream before returning.
-/**
- * This function is used to read a certain number of bytes of data from a
- * stream. The call will block until one of the following conditions is true:
- *
- * @li The supplied buffer is full (that is, it has reached maximum size).
- *
- * @li The completion_condition function object returns 0.
- *
- * This operation is implemented in terms of zero or more calls to the stream's
- * read_some function.
- *
- * @param s The stream from which the data is to be read. The type must support
- * the SyncReadStream concept.
- *
- * @param b The basic_streambuf object into which the data will be read.
- *
- * @param completion_condition The function object to be called to determine
- * whether the read operation is complete. The signature of the function object
- * must be:
- * @code std::size_t completion_condition(
- *   // Result of latest read_some operation.
- *   const asio::error_code& error,
- *
- *   // Number of bytes transferred so far.
- *   std::size_t bytes_transferred
- * ); @endcode
- * A return value of 0 indicates that the read operation is complete. A non-zero
- * return value indicates the maximum number of bytes to be read on the next
- * call to the stream's read_some function.
- *
- * @param ec Set to indicate what error occurred, if any.
- *
- * @returns The number of bytes read. If an error occurs, returns the total
- * number of bytes successfully transferred prior to the error.
- */
-template <typename SyncReadStream, typename Allocator,
-    typename CompletionCondition>
-std::size_t read(SyncReadStream& s, basic_streambuf<Allocator>& b,
-    CompletionCondition completion_condition, asio::error_code& ec);
-
-#endif // !defined(ASIO_NO_IOSTREAM)
-
-/*@}*/
-/**
- * @defgroup async_read asio::async_read
- *
- * @brief Start an asynchronous operation to read a certain amount of data from
- * a stream.
- */
-/*@{*/
-
-/// Start an asynchronous operation to read a certain amount of data from a
-/// stream.
-/**
- * This function is used to asynchronously read a certain number of bytes of
- * data from a stream. The function call always returns immediately. The
- * asynchronous operation will continue until one of the following conditions is
- * true:
- *
- * @li The supplied buffers are full. That is, the bytes transferred is equal to
- * the sum of the buffer sizes.
- *
- * @li An error occurred.
- *
- * This operation is implemented in terms of zero or more calls to the stream's
- * async_read_some function, and is known as a <em>composed operation</em>. The
- * program must ensure that the stream performs no other read operations (such
- * as async_read, the stream's async_read_some function, or any other composed
- * operations that perform reads) until this operation completes.
- *
- * @param s The stream from which the data is to be read. The type must support
- * the AsyncReadStream concept.
- *
- * @param buffers One or more buffers into which the data will be read. The sum
- * of the buffer sizes indicates the maximum number of bytes to read from the
- * stream. Although the buffers object may be copied as necessary, ownership of
- * the underlying memory blocks is retained by the caller, which must guarantee
- * that they remain valid until the handler is called.
- *
- * @param handler The handler to be called when the read operation completes.
- * Copies will be made of the handler as required. The function signature of the
- * handler must be:
- * @code void handler(
- *   const asio::error_code& error, // Result of operation.
- *
- *   std::size_t bytes_transferred           // Number of bytes copied into the
- *                                           // buffers. If an error occurred,
- *                                           // this will be the  number of
- *                                           // bytes successfully transferred
- *                                           // prior to the error.
- * ); @endcode
- * Regardless of whether the asynchronous operation completes immediately or
- * not, the handler will not be invoked from within this function. Invocation of
- * the handler will be performed in a manner equivalent to using
- * asio::io_service::post().
- *
- * @par Example
- * To read into a single data buffer use the @ref buffer function as follows:
- * @code
- * asio::async_read(s, asio::buffer(data, size), handler);
- * @endcode
- * See the @ref buffer documentation for information on reading into multiple
- * buffers in one go, and how to use it with arrays, boost::array or
- * std::vector.
- *
- * @note This overload is equivalent to calling:
- * @code asio::async_read(
- *     s, buffers,
- *     asio::transfer_all(),
- *     handler); @endcode
- */
-template <typename AsyncReadStream, typename MutableBufferSequence,
-    typename ReadHandler>
-ASIO_INITFN_RESULT_TYPE(ReadHandler,
-    void (asio::error_code, std::size_t))
-async_read(AsyncReadStream& s, const MutableBufferSequence& buffers,
-    ASIO_MOVE_ARG(ReadHandler) handler);
-
-/// Start an asynchronous operation to read a certain amount of data from a
-/// stream.
-/**
- * This function is used to asynchronously read a certain number of bytes of
- * data from a stream. The function call always returns immediately. The
- * asynchronous operation will continue until one of the following conditions is
- * true:
- *
- * @li The supplied buffers are full. That is, the bytes transferred is equal to
- * the sum of the buffer sizes.
- *
- * @li The completion_condition function object returns 0.
- *
- * @param s The stream from which the data is to be read. The type must support
- * the AsyncReadStream concept.
- *
- * @param buffers One or more buffers into which the data will be read. The sum
- * of the buffer sizes indicates the maximum number of bytes to read from the
- * stream. Although the buffers object may be copied as necessary, ownership of
- * the underlying memory blocks is retained by the caller, which must guarantee
- * that they remain valid until the handler is called.
- *
- * @param completion_condition The function object to be called to determine
- * whether the read operation is complete. The signature of the function object
- * must be:
- * @code std::size_t completion_condition(
- *   // Result of latest async_read_some operation.
- *   const asio::error_code& error,
- *
- *   // Number of bytes transferred so far.
- *   std::size_t bytes_transferred
- * ); @endcode
- * A return value of 0 indicates that the read operation is complete. A non-zero
- * return value indicates the maximum number of bytes to be read on the next
- * call to the stream's async_read_some function.
- *
- * @param handler The handler to be called when the read operation completes.
- * Copies will be made of the handler as required. The function signature of the
- * handler must be:
- * @code void handler(
- *   const asio::error_code& error, // Result of operation.
- *
- *   std::size_t bytes_transferred           // Number of bytes copied into the
- *                                           // buffers. If an error occurred,
- *                                           // this will be the  number of
- *                                           // bytes successfully transferred
- *                                           // prior to the error.
- * ); @endcode
- * Regardless of whether the asynchronous operation completes immediately or
- * not, the handler will not be invoked from within this function. Invocation of
- * the handler will be performed in a manner equivalent to using
- * asio::io_service::post().
- *
- * @par Example
- * To read into a single data buffer use the @ref buffer function as follows:
- * @code asio::async_read(s,
- *     asio::buffer(data, size),
- *     asio::transfer_at_least(32),
- *     handler); @endcode
- * See the @ref buffer documentation for information on reading into multiple
- * buffers in one go, and how to use it with arrays, boost::array or
- * std::vector.
- */
-template <typename AsyncReadStream, typename MutableBufferSequence,
-    typename CompletionCondition, typename ReadHandler>
-ASIO_INITFN_RESULT_TYPE(ReadHandler,
-    void (asio::error_code, std::size_t))
-async_read(AsyncReadStream& s, const MutableBufferSequence& buffers,
-    CompletionCondition completion_condition,
-    ASIO_MOVE_ARG(ReadHandler) handler);
-
-#if !defined(ASIO_NO_IOSTREAM)
-
-/// Start an asynchronous operation to read a certain amount of data from a
-/// stream.
-/**
- * This function is used to asynchronously read a certain number of bytes of
- * data from a stream. The function call always returns immediately. The
- * asynchronous operation will continue until one of the following conditions is
- * true:
- *
- * @li The supplied buffer is full (that is, it has reached maximum size).
- *
- * @li An error occurred.
- *
- * This operation is implemented in terms of zero or more calls to the stream's
- * async_read_some function, and is known as a <em>composed operation</em>. The
- * program must ensure that the stream performs no other read operations (such
- * as async_read, the stream's async_read_some function, or any other composed
- * operations that perform reads) until this operation completes.
- *
- * @param s The stream from which the data is to be read. The type must support
- * the AsyncReadStream concept.
- *
- * @param b A basic_streambuf object into which the data will be read. Ownership
- * of the streambuf is retained by the caller, which must guarantee that it
- * remains valid until the handler is called.
- *
- * @param handler The handler to be called when the read operation completes.
- * Copies will be made of the handler as required. The function signature of the
- * handler must be:
- * @code void handler(
- *   const asio::error_code& error, // Result of operation.
- *
- *   std::size_t bytes_transferred           // Number of bytes copied into the
- *                                           // buffers. If an error occurred,
- *                                           // this will be the  number of
- *                                           // bytes successfully transferred
- *                                           // prior to the error.
- * ); @endcode
- * Regardless of whether the asynchronous operation completes immediately or
- * not, the handler will not be invoked from within this function. Invocation of
- * the handler will be performed in a manner equivalent to using
- * asio::io_service::post().
- *
- * @note This overload is equivalent to calling:
- * @code asio::async_read(
- *     s, b,
- *     asio::transfer_all(),
- *     handler); @endcode
- */
-template <typename AsyncReadStream, typename Allocator, typename ReadHandler>
-ASIO_INITFN_RESULT_TYPE(ReadHandler,
-    void (asio::error_code, std::size_t))
-async_read(AsyncReadStream& s, basic_streambuf<Allocator>& b,
-    ASIO_MOVE_ARG(ReadHandler) handler);
-
-/// Start an asynchronous operation to read a certain amount of data from a
-/// stream.
-/**
- * This function is used to asynchronously read a certain number of bytes of
- * data from a stream. The function call always returns immediately. The
- * asynchronous operation will continue until one of the following conditions is
- * true:
- *
- * @li The supplied buffer is full (that is, it has reached maximum size).
- *
- * @li The completion_condition function object returns 0.
- *
- * This operation is implemented in terms of zero or more calls to the stream's
- * async_read_some function, and is known as a <em>composed operation</em>. The
- * program must ensure that the stream performs no other read operations (such
- * as async_read, the stream's async_read_some function, or any other composed
- * operations that perform reads) until this operation completes.
- *
- * @param s The stream from which the data is to be read. The type must support
- * the AsyncReadStream concept.
- *
- * @param b A basic_streambuf object into which the data will be read. Ownership
- * of the streambuf is retained by the caller, which must guarantee that it
- * remains valid until the handler is called.
- *
- * @param completion_condition The function object to be called to determine
- * whether the read operation is complete. The signature of the function object
- * must be:
- * @code std::size_t completion_condition(
- *   // Result of latest async_read_some operation.
- *   const asio::error_code& error,
- *
- *   // Number of bytes transferred so far.
- *   std::size_t bytes_transferred
- * ); @endcode
- * A return value of 0 indicates that the read operation is complete. A non-zero
- * return value indicates the maximum number of bytes to be read on the next
- * call to the stream's async_read_some function.
- *
- * @param handler The handler to be called when the read operation completes.
- * Copies will be made of the handler as required. The function signature of the
- * handler must be:
- * @code void handler(
- *   const asio::error_code& error, // Result of operation.
- *
- *   std::size_t bytes_transferred           // Number of bytes copied into the
- *                                           // buffers. If an error occurred,
- *                                           // this will be the  number of
- *                                           // bytes successfully transferred
- *                                           // prior to the error.
- * ); @endcode
- * Regardless of whether the asynchronous operation completes immediately or
- * not, the handler will not be invoked from within this function. Invocation of
- * the handler will be performed in a manner equivalent to using
- * asio::io_service::post().
- */
-template <typename AsyncReadStream, typename Allocator,
-    typename CompletionCondition, typename ReadHandler>
-ASIO_INITFN_RESULT_TYPE(ReadHandler,
-    void (asio::error_code, std::size_t))
-async_read(AsyncReadStream& s, basic_streambuf<Allocator>& b,
-    CompletionCondition completion_condition,
-    ASIO_MOVE_ARG(ReadHandler) handler);
-
-#endif // !defined(ASIO_NO_IOSTREAM)
-
-/*@}*/
-
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#include "asio/impl/read.hpp"
-
-#endif // ASIO_READ_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/read_at.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/read_at.hpp
deleted file mode 100644
index 9b155288cfe3..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/read_at.hpp
+++ /dev/null
@@ -1,664 +0,0 @@
-//
-// read_at.hpp
-// ~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_READ_AT_HPP
-#define ASIO_READ_AT_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include <cstddef>
-#include "asio/async_result.hpp"
-#include "asio/basic_streambuf_fwd.hpp"
-#include "asio/detail/cstdint.hpp"
-#include "asio/error.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-
-/**
- * @defgroup read_at asio::read_at
- *
- * @brief Attempt to read a certain amount of data at the specified offset
- * before returning.
- */
-/*@{*/
-
-/// Attempt to read a certain amount of data at the specified offset before
-/// returning.
-/**
- * This function is used to read a certain number of bytes of data from a
- * random access device at the specified offset. The call will block until one
- * of the following conditions is true:
- *
- * @li The supplied buffers are full. That is, the bytes transferred is equal to
- * the sum of the buffer sizes.
- *
- * @li An error occurred.
- *
- * This operation is implemented in terms of zero or more calls to the device's
- * read_some_at function.
- *
- * @param d The device from which the data is to be read. The type must support
- * the SyncRandomAccessReadDevice concept.
- *
- * @param offset The offset at which the data will be read.
- *
- * @param buffers One or more buffers into which the data will be read. The sum
- * of the buffer sizes indicates the maximum number of bytes to read from the
- * device.
- *
- * @returns The number of bytes transferred.
- *
- * @throws asio::system_error Thrown on failure.
- *
- * @par Example
- * To read into a single data buffer use the @ref buffer function as follows:
- * @code asio::read_at(d, 42, asio::buffer(data, size)); @endcode
- * See the @ref buffer documentation for information on reading into multiple
- * buffers in one go, and how to use it with arrays, boost::array or
- * std::vector.
- *
- * @note This overload is equivalent to calling:
- * @code asio::read_at(
- *     d, 42, buffers,
- *     asio::transfer_all()); @endcode
- */
-template <typename SyncRandomAccessReadDevice, typename MutableBufferSequence>
-std::size_t read_at(SyncRandomAccessReadDevice& d,
-    uint64_t offset, const MutableBufferSequence& buffers);
-
-/// Attempt to read a certain amount of data at the specified offset before
-/// returning.
-/**
- * This function is used to read a certain number of bytes of data from a
- * random access device at the specified offset. The call will block until one
- * of the following conditions is true:
- *
- * @li The supplied buffers are full. That is, the bytes transferred is equal to
- * the sum of the buffer sizes.
- *
- * @li An error occurred.
- *
- * This operation is implemented in terms of zero or more calls to the device's
- * read_some_at function.
- *
- * @param d The device from which the data is to be read. The type must support
- * the SyncRandomAccessReadDevice concept.
- *
- * @param offset The offset at which the data will be read.
- *
- * @param buffers One or more buffers into which the data will be read. The sum
- * of the buffer sizes indicates the maximum number of bytes to read from the
- * device.
- *
- * @param ec Set to indicate what error occurred, if any.
- *
- * @returns The number of bytes transferred.
- *
- * @par Example
- * To read into a single data buffer use the @ref buffer function as follows:
- * @code asio::read_at(d, 42,
- *     asio::buffer(data, size), ec); @endcode
- * See the @ref buffer documentation for information on reading into multiple
- * buffers in one go, and how to use it with arrays, boost::array or
- * std::vector.
- *
- * @note This overload is equivalent to calling:
- * @code asio::read_at(
- *     d, 42, buffers,
- *     asio::transfer_all(), ec); @endcode
- */
-template <typename SyncRandomAccessReadDevice, typename MutableBufferSequence>
-std::size_t read_at(SyncRandomAccessReadDevice& d,
-    uint64_t offset, const MutableBufferSequence& buffers,
-    asio::error_code& ec);
-
-/// Attempt to read a certain amount of data at the specified offset before
-/// returning.
-/**
- * This function is used to read a certain number of bytes of data from a
- * random access device at the specified offset. The call will block until one
- * of the following conditions is true:
- *
- * @li The supplied buffers are full. That is, the bytes transferred is equal to
- * the sum of the buffer sizes.
- *
- * @li The completion_condition function object returns 0.
- *
- * This operation is implemented in terms of zero or more calls to the device's
- * read_some_at function.
- *
- * @param d The device from which the data is to be read. The type must support
- * the SyncRandomAccessReadDevice concept.
- *
- * @param offset The offset at which the data will be read.
- *
- * @param buffers One or more buffers into which the data will be read. The sum
- * of the buffer sizes indicates the maximum number of bytes to read from the
- * device.
- *
- * @param completion_condition The function object to be called to determine
- * whether the read operation is complete. The signature of the function object
- * must be:
- * @code std::size_t completion_condition(
- *   // Result of latest read_some_at operation.
- *   const asio::error_code& error,
- *
- *   // Number of bytes transferred so far.
- *   std::size_t bytes_transferred
- * ); @endcode
- * A return value of 0 indicates that the read operation is complete. A non-zero
- * return value indicates the maximum number of bytes to be read on the next
- * call to the device's read_some_at function.
- *
- * @returns The number of bytes transferred.
- *
- * @throws asio::system_error Thrown on failure.
- *
- * @par Example
- * To read into a single data buffer use the @ref buffer function as follows:
- * @code asio::read_at(d, 42, asio::buffer(data, size),
- *     asio::transfer_at_least(32)); @endcode
- * See the @ref buffer documentation for information on reading into multiple
- * buffers in one go, and how to use it with arrays, boost::array or
- * std::vector.
- */
-template <typename SyncRandomAccessReadDevice, typename MutableBufferSequence,
-    typename CompletionCondition>
-std::size_t read_at(SyncRandomAccessReadDevice& d,
-    uint64_t offset, const MutableBufferSequence& buffers,
-    CompletionCondition completion_condition);
-
-/// Attempt to read a certain amount of data at the specified offset before
-/// returning.
-/**
- * This function is used to read a certain number of bytes of data from a
- * random access device at the specified offset. The call will block until one
- * of the following conditions is true:
- *
- * @li The supplied buffers are full. That is, the bytes transferred is equal to
- * the sum of the buffer sizes.
- *
- * @li The completion_condition function object returns 0.
- *
- * This operation is implemented in terms of zero or more calls to the device's
- * read_some_at function.
- *
- * @param d The device from which the data is to be read. The type must support
- * the SyncRandomAccessReadDevice concept.
- *
- * @param offset The offset at which the data will be read.
- *
- * @param buffers One or more buffers into which the data will be read. The sum
- * of the buffer sizes indicates the maximum number of bytes to read from the
- * device.
- *
- * @param completion_condition The function object to be called to determine
- * whether the read operation is complete. The signature of the function object
- * must be:
- * @code std::size_t completion_condition(
- *   // Result of latest read_some_at operation.
- *   const asio::error_code& error,
- *
- *   // Number of bytes transferred so far.
- *   std::size_t bytes_transferred
- * ); @endcode
- * A return value of 0 indicates that the read operation is complete. A non-zero
- * return value indicates the maximum number of bytes to be read on the next
- * call to the device's read_some_at function.
- *
- * @param ec Set to indicate what error occurred, if any.
- *
- * @returns The number of bytes read. If an error occurs, returns the total
- * number of bytes successfully transferred prior to the error.
- */
-template <typename SyncRandomAccessReadDevice, typename MutableBufferSequence,
-    typename CompletionCondition>
-std::size_t read_at(SyncRandomAccessReadDevice& d,
-    uint64_t offset, const MutableBufferSequence& buffers,
-    CompletionCondition completion_condition, asio::error_code& ec);
-
-#if !defined(ASIO_NO_IOSTREAM)
-
-/// Attempt to read a certain amount of data at the specified offset before
-/// returning.
-/**
- * This function is used to read a certain number of bytes of data from a
- * random access device at the specified offset. The call will block until one
- * of the following conditions is true:
- *
- * @li An error occurred.
- *
- * This operation is implemented in terms of zero or more calls to the device's
- * read_some_at function.
- *
- * @param d The device from which the data is to be read. The type must support
- * the SyncRandomAccessReadDevice concept.
- *
- * @param offset The offset at which the data will be read.
- *
- * @param b The basic_streambuf object into which the data will be read.
- *
- * @returns The number of bytes transferred.
- *
- * @throws asio::system_error Thrown on failure.
- *
- * @note This overload is equivalent to calling:
- * @code asio::read_at(
- *     d, 42, b,
- *     asio::transfer_all()); @endcode
- */
-template <typename SyncRandomAccessReadDevice, typename Allocator>
-std::size_t read_at(SyncRandomAccessReadDevice& d,
-    uint64_t offset, basic_streambuf<Allocator>& b);
-
-/// Attempt to read a certain amount of data at the specified offset before
-/// returning.
-/**
- * This function is used to read a certain number of bytes of data from a
- * random access device at the specified offset. The call will block until one
- * of the following conditions is true:
- *
- * @li An error occurred.
- *
- * This operation is implemented in terms of zero or more calls to the device's
- * read_some_at function.
- *
- * @param d The device from which the data is to be read. The type must support
- * the SyncRandomAccessReadDevice concept.
- *
- * @param offset The offset at which the data will be read.
- *
- * @param b The basic_streambuf object into which the data will be read.
- *
- * @param ec Set to indicate what error occurred, if any.
- *
- * @returns The number of bytes transferred.
- *
- * @note This overload is equivalent to calling:
- * @code asio::read_at(
- *     d, 42, b,
- *     asio::transfer_all(), ec); @endcode
- */
-template <typename SyncRandomAccessReadDevice, typename Allocator>
-std::size_t read_at(SyncRandomAccessReadDevice& d,
-    uint64_t offset, basic_streambuf<Allocator>& b,
-    asio::error_code& ec);
-
-/// Attempt to read a certain amount of data at the specified offset before
-/// returning.
-/**
- * This function is used to read a certain number of bytes of data from a
- * random access device at the specified offset. The call will block until one
- * of the following conditions is true:
- *
- * @li The completion_condition function object returns 0.
- *
- * This operation is implemented in terms of zero or more calls to the device's
- * read_some_at function.
- *
- * @param d The device from which the data is to be read. The type must support
- * the SyncRandomAccessReadDevice concept.
- *
- * @param offset The offset at which the data will be read.
- *
- * @param b The basic_streambuf object into which the data will be read.
- *
- * @param completion_condition The function object to be called to determine
- * whether the read operation is complete. The signature of the function object
- * must be:
- * @code std::size_t completion_condition(
- *   // Result of latest read_some_at operation.
- *   const asio::error_code& error,
- *
- *   // Number of bytes transferred so far.
- *   std::size_t bytes_transferred
- * ); @endcode
- * A return value of 0 indicates that the read operation is complete. A non-zero
- * return value indicates the maximum number of bytes to be read on the next
- * call to the device's read_some_at function.
- *
- * @returns The number of bytes transferred.
- *
- * @throws asio::system_error Thrown on failure.
- */
-template <typename SyncRandomAccessReadDevice, typename Allocator,
-    typename CompletionCondition>
-std::size_t read_at(SyncRandomAccessReadDevice& d,
-    uint64_t offset, basic_streambuf<Allocator>& b,
-    CompletionCondition completion_condition);
-
-/// Attempt to read a certain amount of data at the specified offset before
-/// returning.
-/**
- * This function is used to read a certain number of bytes of data from a
- * random access device at the specified offset. The call will block until one
- * of the following conditions is true:
- *
- * @li The completion_condition function object returns 0.
- *
- * This operation is implemented in terms of zero or more calls to the device's
- * read_some_at function.
- *
- * @param d The device from which the data is to be read. The type must support
- * the SyncRandomAccessReadDevice concept.
- *
- * @param offset The offset at which the data will be read.
- *
- * @param b The basic_streambuf object into which the data will be read.
- *
- * @param completion_condition The function object to be called to determine
- * whether the read operation is complete. The signature of the function object
- * must be:
- * @code std::size_t completion_condition(
- *   // Result of latest read_some_at operation.
- *   const asio::error_code& error,
- *
- *   // Number of bytes transferred so far.
- *   std::size_t bytes_transferred
- * ); @endcode
- * A return value of 0 indicates that the read operation is complete. A non-zero
- * return value indicates the maximum number of bytes to be read on the next
- * call to the device's read_some_at function.
- *
- * @param ec Set to indicate what error occurred, if any.
- *
- * @returns The number of bytes read. If an error occurs, returns the total
- * number of bytes successfully transferred prior to the error.
- */
-template <typename SyncRandomAccessReadDevice, typename Allocator,
-    typename CompletionCondition>
-std::size_t read_at(SyncRandomAccessReadDevice& d,
-    uint64_t offset, basic_streambuf<Allocator>& b,
-    CompletionCondition completion_condition, asio::error_code& ec);
-
-#endif // !defined(ASIO_NO_IOSTREAM)
-
-/*@}*/
-/**
- * @defgroup async_read_at asio::async_read_at
- *
- * @brief Start an asynchronous operation to read a certain amount of data at
- * the specified offset.
- */
-/*@{*/
-
-/// Start an asynchronous operation to read a certain amount of data at the
-/// specified offset.
-/**
- * This function is used to asynchronously read a certain number of bytes of
- * data from a random access device at the specified offset. The function call
- * always returns immediately. The asynchronous operation will continue until
- * one of the following conditions is true:
- *
- * @li The supplied buffers are full. That is, the bytes transferred is equal to
- * the sum of the buffer sizes.
- *
- * @li An error occurred.
- *
- * This operation is implemented in terms of zero or more calls to the device's
- * async_read_some_at function.
- *
- * @param d The device from which the data is to be read. The type must support
- * the AsyncRandomAccessReadDevice concept.
- *
- * @param offset The offset at which the data will be read.
- *
- * @param buffers One or more buffers into which the data will be read. The sum
- * of the buffer sizes indicates the maximum number of bytes to read from the
- * device. Although the buffers object may be copied as necessary, ownership of
- * the underlying memory blocks is retained by the caller, which must guarantee
- * that they remain valid until the handler is called.
- *
- * @param handler The handler to be called when the read operation completes.
- * Copies will be made of the handler as required. The function signature of the
- * handler must be:
- * @code void handler(
- *   // Result of operation.
- *   const asio::error_code& error,
- *
- *   // Number of bytes copied into the buffers. If an error
- *   // occurred, this will be the number of bytes successfully
- *   // transferred prior to the error.
- *   std::size_t bytes_transferred
- * ); @endcode
- * Regardless of whether the asynchronous operation completes immediately or
- * not, the handler will not be invoked from within this function. Invocation of
- * the handler will be performed in a manner equivalent to using
- * asio::io_service::post().
- *
- * @par Example
- * To read into a single data buffer use the @ref buffer function as follows:
- * @code
- * asio::async_read_at(d, 42, asio::buffer(data, size), handler);
- * @endcode
- * See the @ref buffer documentation for information on reading into multiple
- * buffers in one go, and how to use it with arrays, boost::array or
- * std::vector.
- *
- * @note This overload is equivalent to calling:
- * @code asio::async_read_at(
- *     d, 42, buffers,
- *     asio::transfer_all(),
- *     handler); @endcode
- */
-template <typename AsyncRandomAccessReadDevice, typename MutableBufferSequence,
-    typename ReadHandler>
-ASIO_INITFN_RESULT_TYPE(ReadHandler,
-    void (asio::error_code, std::size_t))
-async_read_at(AsyncRandomAccessReadDevice& d, uint64_t offset,
-    const MutableBufferSequence& buffers,
-    ASIO_MOVE_ARG(ReadHandler) handler);
-
-/// Start an asynchronous operation to read a certain amount of data at the
-/// specified offset.
-/**
- * This function is used to asynchronously read a certain number of bytes of
- * data from a random access device at the specified offset. The function call
- * always returns immediately. The asynchronous operation will continue until
- * one of the following conditions is true:
- *
- * @li The supplied buffers are full. That is, the bytes transferred is equal to
- * the sum of the buffer sizes.
- *
- * @li The completion_condition function object returns 0.
- *
- * @param d The device from which the data is to be read. The type must support
- * the AsyncRandomAccessReadDevice concept.
- *
- * @param offset The offset at which the data will be read.
- *
- * @param buffers One or more buffers into which the data will be read. The sum
- * of the buffer sizes indicates the maximum number of bytes to read from the
- * device. Although the buffers object may be copied as necessary, ownership of
- * the underlying memory blocks is retained by the caller, which must guarantee
- * that they remain valid until the handler is called.
- *
- * @param completion_condition The function object to be called to determine
- * whether the read operation is complete. The signature of the function object
- * must be:
- * @code std::size_t completion_condition(
- *   // Result of latest async_read_some_at operation.
- *   const asio::error_code& error,
- *
- *   // Number of bytes transferred so far.
- *   std::size_t bytes_transferred
- * ); @endcode
- * A return value of 0 indicates that the read operation is complete. A non-zero
- * return value indicates the maximum number of bytes to be read on the next
- * call to the device's async_read_some_at function.
- *
- * @param handler The handler to be called when the read operation completes.
- * Copies will be made of the handler as required. The function signature of the
- * handler must be:
- * @code void handler(
- *   // Result of operation.
- *   const asio::error_code& error,
- *
- *   // Number of bytes copied into the buffers. If an error
- *   // occurred, this will be the number of bytes successfully
- *   // transferred prior to the error.
- *   std::size_t bytes_transferred
- * ); @endcode
- * Regardless of whether the asynchronous operation completes immediately or
- * not, the handler will not be invoked from within this function. Invocation of
- * the handler will be performed in a manner equivalent to using
- * asio::io_service::post().
- *
- * @par Example
- * To read into a single data buffer use the @ref buffer function as follows:
- * @code asio::async_read_at(d, 42,
- *     asio::buffer(data, size),
- *     asio::transfer_at_least(32),
- *     handler); @endcode
- * See the @ref buffer documentation for information on reading into multiple
- * buffers in one go, and how to use it with arrays, boost::array or
- * std::vector.
- */
-template <typename AsyncRandomAccessReadDevice, typename MutableBufferSequence,
-    typename CompletionCondition, typename ReadHandler>
-ASIO_INITFN_RESULT_TYPE(ReadHandler,
-    void (asio::error_code, std::size_t))
-async_read_at(AsyncRandomAccessReadDevice& d,
-    uint64_t offset, const MutableBufferSequence& buffers,
-    CompletionCondition completion_condition,
-    ASIO_MOVE_ARG(ReadHandler) handler);
-
-#if !defined(ASIO_NO_IOSTREAM)
-
-/// Start an asynchronous operation to read a certain amount of data at the
-/// specified offset.
-/**
- * This function is used to asynchronously read a certain number of bytes of
- * data from a random access device at the specified offset. The function call
- * always returns immediately. The asynchronous operation will continue until
- * one of the following conditions is true:
- *
- * @li An error occurred.
- *
- * This operation is implemented in terms of zero or more calls to the device's
- * async_read_some_at function.
- *
- * @param d The device from which the data is to be read. The type must support
- * the AsyncRandomAccessReadDevice concept.
- *
- * @param offset The offset at which the data will be read.
- *
- * @param b A basic_streambuf object into which the data will be read. Ownership
- * of the streambuf is retained by the caller, which must guarantee that it
- * remains valid until the handler is called.
- *
- * @param handler The handler to be called when the read operation completes.
- * Copies will be made of the handler as required. The function signature of the
- * handler must be:
- * @code void handler(
- *   // Result of operation.
- *   const asio::error_code& error,
- *
- *   // Number of bytes copied into the buffers. If an error
- *   // occurred, this will be the number of bytes successfully
- *   // transferred prior to the error.
- *   std::size_t bytes_transferred
- * ); @endcode
- * Regardless of whether the asynchronous operation completes immediately or
- * not, the handler will not be invoked from within this function. Invocation of
- * the handler will be performed in a manner equivalent to using
- * asio::io_service::post().
- *
- * @note This overload is equivalent to calling:
- * @code asio::async_read_at(
- *     d, 42, b,
- *     asio::transfer_all(),
- *     handler); @endcode
- */
-template <typename AsyncRandomAccessReadDevice, typename Allocator,
-    typename ReadHandler>
-ASIO_INITFN_RESULT_TYPE(ReadHandler,
-    void (asio::error_code, std::size_t))
-async_read_at(AsyncRandomAccessReadDevice& d, uint64_t offset,
-    basic_streambuf<Allocator>& b, ASIO_MOVE_ARG(ReadHandler) handler);
-
-/// Start an asynchronous operation to read a certain amount of data at the
-/// specified offset.
-/**
- * This function is used to asynchronously read a certain number of bytes of
- * data from a random access device at the specified offset. The function call
- * always returns immediately. The asynchronous operation will continue until
- * one of the following conditions is true:
- *
- * @li The completion_condition function object returns 0.
- *
- * This operation is implemented in terms of zero or more calls to the device's
- * async_read_some_at function.
- *
- * @param d The device from which the data is to be read. The type must support
- * the AsyncRandomAccessReadDevice concept.
- *
- * @param offset The offset at which the data will be read.
- *
- * @param b A basic_streambuf object into which the data will be read. Ownership
- * of the streambuf is retained by the caller, which must guarantee that it
- * remains valid until the handler is called.
- *
- * @param completion_condition The function object to be called to determine
- * whether the read operation is complete. The signature of the function object
- * must be:
- * @code std::size_t completion_condition(
- *   // Result of latest async_read_some_at operation.
- *   const asio::error_code& error,
- *
- *   // Number of bytes transferred so far.
- *   std::size_t bytes_transferred
- * ); @endcode
- * A return value of 0 indicates that the read operation is complete. A non-zero
- * return value indicates the maximum number of bytes to be read on the next
- * call to the device's async_read_some_at function.
- *
- * @param handler The handler to be called when the read operation completes.
- * Copies will be made of the handler as required. The function signature of the
- * handler must be:
- * @code void handler(
- *   // Result of operation.
- *   const asio::error_code& error,
- *
- *   // Number of bytes copied into the buffers. If an error
- *   // occurred, this will be the number of bytes successfully
- *   // transferred prior to the error.
- *   std::size_t bytes_transferred
- * ); @endcode
- * Regardless of whether the asynchronous operation completes immediately or
- * not, the handler will not be invoked from within this function. Invocation of
- * the handler will be performed in a manner equivalent to using
- * asio::io_service::post().
- */
-template <typename AsyncRandomAccessReadDevice, typename Allocator,
-    typename CompletionCondition, typename ReadHandler>
-ASIO_INITFN_RESULT_TYPE(ReadHandler,
-    void (asio::error_code, std::size_t))
-async_read_at(AsyncRandomAccessReadDevice& d,
-    uint64_t offset, basic_streambuf<Allocator>& b,
-    CompletionCondition completion_condition,
-    ASIO_MOVE_ARG(ReadHandler) handler);
-
-#endif // !defined(ASIO_NO_IOSTREAM)
-
-/*@}*/
-
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#include "asio/impl/read_at.hpp"
-
-#endif // ASIO_READ_AT_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/read_until.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/read_until.hpp
deleted file mode 100644
index 212b6f5f1628..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/read_until.hpp
+++ /dev/null
@@ -1,923 +0,0 @@
-//
-// read_until.hpp
-// ~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_READ_UNTIL_HPP
-#define ASIO_READ_UNTIL_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if !defined(ASIO_NO_IOSTREAM)
-
-#include <cstddef>
-#include <string>
-#include "asio/async_result.hpp"
-#include "asio/basic_streambuf.hpp"
-#include "asio/detail/regex_fwd.hpp"
-#include "asio/detail/type_traits.hpp"
-#include "asio/error.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-
-namespace detail
-{
-  char (&has_result_type_helper(...))[2];
-
-  template <typename T>
-  char has_result_type_helper(T*, typename T::result_type* = 0);
-
-  template <typename T>
-  struct has_result_type
-  {
-    enum { value = (sizeof((has_result_type_helper)((T*)(0))) == 1) };
-  };
-} // namespace detail
-
-/// Type trait used to determine whether a type can be used as a match condition
-/// function with read_until and async_read_until.
-template <typename T>
-struct is_match_condition
-{
-#if defined(GENERATING_DOCUMENTATION)
-  /// The value member is true if the type may be used as a match condition.
-  static const bool value;
-#else
-  enum
-  {
-    value = asio::is_function<
-        typename asio::remove_pointer<T>::type>::value
-      || detail::has_result_type<T>::value
-  };
-#endif
-};
-
-/**
- * @defgroup read_until asio::read_until
- *
- * @brief Read data into a streambuf until it contains a delimiter, matches a
- * regular expression, or a function object indicates a match.
- */
-/*@{*/
-
-/// Read data into a streambuf until it contains a specified delimiter.
-/**
- * This function is used to read data into the specified streambuf until the
- * streambuf's get area contains the specified delimiter. The call will block
- * until one of the following conditions is true:
- *
- * @li The get area of the streambuf contains the specified delimiter.
- *
- * @li An error occurred.
- *
- * This operation is implemented in terms of zero or more calls to the stream's
- * read_some function. If the streambuf's get area already contains the
- * delimiter, the function returns immediately.
- *
- * @param s The stream from which the data is to be read. The type must support
- * the SyncReadStream concept.
- *
- * @param b A streambuf object into which the data will be read.
- *
- * @param delim The delimiter character.
- *
- * @returns The number of bytes in the streambuf's get area up to and including
- * the delimiter.
- *
- * @throws asio::system_error Thrown on failure.
- *
- * @note After a successful read_until operation, the streambuf may contain
- * additional data beyond the delimiter. An application will typically leave
- * that data in the streambuf for a subsequent read_until operation to examine.
- *
- * @par Example
- * To read data into a streambuf until a newline is encountered:
- * @code asio::streambuf b;
- * asio::read_until(s, b, '\n');
- * std::istream is(&b);
- * std::string line;
- * std::getline(is, line); @endcode
- * After the @c read_until operation completes successfully, the buffer @c b
- * contains the delimiter:
- * @code { 'a', 'b', ..., 'c', '\n', 'd', 'e', ... } @endcode
- * The call to @c std::getline then extracts the data up to and including the
- * delimiter, so that the string @c line contains:
- * @code { 'a', 'b', ..., 'c', '\n' } @endcode
- * The remaining data is left in the buffer @c b as follows:
- * @code { 'd', 'e', ... } @endcode
- * This data may be the start of a new line, to be extracted by a subsequent
- * @c read_until operation.
- */
-template <typename SyncReadStream, typename Allocator>
-std::size_t read_until(SyncReadStream& s,
-    asio::basic_streambuf<Allocator>& b, char delim);
-
-/// Read data into a streambuf until it contains a specified delimiter.
-/**
- * This function is used to read data into the specified streambuf until the
- * streambuf's get area contains the specified delimiter. The call will block
- * until one of the following conditions is true:
- *
- * @li The get area of the streambuf contains the specified delimiter.
- *
- * @li An error occurred.
- *
- * This operation is implemented in terms of zero or more calls to the stream's
- * read_some function. If the streambuf's get area already contains the
- * delimiter, the function returns immediately.
- *
- * @param s The stream from which the data is to be read. The type must support
- * the SyncReadStream concept.
- *
- * @param b A streambuf object into which the data will be read.
- *
- * @param delim The delimiter character.
- *
- * @param ec Set to indicate what error occurred, if any.
- *
- * @returns The number of bytes in the streambuf's get area up to and including
- * the delimiter. Returns 0 if an error occurred.
- *
- * @note After a successful read_until operation, the streambuf may contain
- * additional data beyond the delimiter. An application will typically leave
- * that data in the streambuf for a subsequent read_until operation to examine.
- */
-template <typename SyncReadStream, typename Allocator>
-std::size_t read_until(SyncReadStream& s,
-    asio::basic_streambuf<Allocator>& b, char delim,
-    asio::error_code& ec);
-
-/// Read data into a streambuf until it contains a specified delimiter.
-/**
- * This function is used to read data into the specified streambuf until the
- * streambuf's get area contains the specified delimiter. The call will block
- * until one of the following conditions is true:
- *
- * @li The get area of the streambuf contains the specified delimiter.
- *
- * @li An error occurred.
- *
- * This operation is implemented in terms of zero or more calls to the stream's
- * read_some function. If the streambuf's get area already contains the
- * delimiter, the function returns immediately.
- *
- * @param s The stream from which the data is to be read. The type must support
- * the SyncReadStream concept.
- *
- * @param b A streambuf object into which the data will be read.
- *
- * @param delim The delimiter string.
- *
- * @returns The number of bytes in the streambuf's get area up to and including
- * the delimiter.
- *
- * @throws asio::system_error Thrown on failure.
- *
- * @note After a successful read_until operation, the streambuf may contain
- * additional data beyond the delimiter. An application will typically leave
- * that data in the streambuf for a subsequent read_until operation to examine.
- *
- * @par Example
- * To read data into a streambuf until a newline is encountered:
- * @code asio::streambuf b;
- * asio::read_until(s, b, "\r\n");
- * std::istream is(&b);
- * std::string line;
- * std::getline(is, line); @endcode
- * After the @c read_until operation completes successfully, the buffer @c b
- * contains the delimiter:
- * @code { 'a', 'b', ..., 'c', '\r', '\n', 'd', 'e', ... } @endcode
- * The call to @c std::getline then extracts the data up to and including the
- * delimiter, so that the string @c line contains:
- * @code { 'a', 'b', ..., 'c', '\r', '\n' } @endcode
- * The remaining data is left in the buffer @c b as follows:
- * @code { 'd', 'e', ... } @endcode
- * This data may be the start of a new line, to be extracted by a subsequent
- * @c read_until operation.
- */
-template <typename SyncReadStream, typename Allocator>
-std::size_t read_until(SyncReadStream& s,
-    asio::basic_streambuf<Allocator>& b, const std::string& delim);
-
-/// Read data into a streambuf until it contains a specified delimiter.
-/**
- * This function is used to read data into the specified streambuf until the
- * streambuf's get area contains the specified delimiter. The call will block
- * until one of the following conditions is true:
- *
- * @li The get area of the streambuf contains the specified delimiter.
- *
- * @li An error occurred.
- *
- * This operation is implemented in terms of zero or more calls to the stream's
- * read_some function. If the streambuf's get area already contains the
- * delimiter, the function returns immediately.
- *
- * @param s The stream from which the data is to be read. The type must support
- * the SyncReadStream concept.
- *
- * @param b A streambuf object into which the data will be read.
- *
- * @param delim The delimiter string.
- *
- * @param ec Set to indicate what error occurred, if any.
- *
- * @returns The number of bytes in the streambuf's get area up to and including
- * the delimiter. Returns 0 if an error occurred.
- *
- * @note After a successful read_until operation, the streambuf may contain
- * additional data beyond the delimiter. An application will typically leave
- * that data in the streambuf for a subsequent read_until operation to examine.
- */
-template <typename SyncReadStream, typename Allocator>
-std::size_t read_until(SyncReadStream& s,
-    asio::basic_streambuf<Allocator>& b, const std::string& delim,
-    asio::error_code& ec);
-
-#if defined(ASIO_HAS_BOOST_REGEX) \
-  || defined(GENERATING_DOCUMENTATION)
-
-/// Read data into a streambuf until some part of the data it contains matches
-/// a regular expression.
-/**
- * This function is used to read data into the specified streambuf until the
- * streambuf's get area contains some data that matches a regular expression.
- * The call will block until one of the following conditions is true:
- *
- * @li A substring of the streambuf's get area matches the regular expression.
- *
- * @li An error occurred.
- *
- * This operation is implemented in terms of zero or more calls to the stream's
- * read_some function. If the streambuf's get area already contains data that
- * matches the regular expression, the function returns immediately.
- *
- * @param s The stream from which the data is to be read. The type must support
- * the SyncReadStream concept.
- *
- * @param b A streambuf object into which the data will be read.
- *
- * @param expr The regular expression.
- *
- * @returns The number of bytes in the streambuf's get area up to and including
- * the substring that matches the regular expression.
- *
- * @throws asio::system_error Thrown on failure.
- *
- * @note After a successful read_until operation, the streambuf may contain
- * additional data beyond that which matched the regular expression. An
- * application will typically leave that data in the streambuf for a subsequent
- * read_until operation to examine.
- *
- * @par Example
- * To read data into a streambuf until a CR-LF sequence is encountered:
- * @code asio::streambuf b;
- * asio::read_until(s, b, boost::regex("\r\n"));
- * std::istream is(&b);
- * std::string line;
- * std::getline(is, line); @endcode
- * After the @c read_until operation completes successfully, the buffer @c b
- * contains the data which matched the regular expression:
- * @code { 'a', 'b', ..., 'c', '\r', '\n', 'd', 'e', ... } @endcode
- * The call to @c std::getline then extracts the data up to and including the
- * match, so that the string @c line contains:
- * @code { 'a', 'b', ..., 'c', '\r', '\n' } @endcode
- * The remaining data is left in the buffer @c b as follows:
- * @code { 'd', 'e', ... } @endcode
- * This data may be the start of a new line, to be extracted by a subsequent
- * @c read_until operation.
- */
-template <typename SyncReadStream, typename Allocator>
-std::size_t read_until(SyncReadStream& s,
-    asio::basic_streambuf<Allocator>& b, const boost::regex& expr);
-
-/// Read data into a streambuf until some part of the data it contains matches
-/// a regular expression.
-/**
- * This function is used to read data into the specified streambuf until the
- * streambuf's get area contains some data that matches a regular expression.
- * The call will block until one of the following conditions is true:
- *
- * @li A substring of the streambuf's get area matches the regular expression.
- *
- * @li An error occurred.
- *
- * This operation is implemented in terms of zero or more calls to the stream's
- * read_some function. If the streambuf's get area already contains data that
- * matches the regular expression, the function returns immediately.
- *
- * @param s The stream from which the data is to be read. The type must support
- * the SyncReadStream concept.
- *
- * @param b A streambuf object into which the data will be read.
- *
- * @param expr The regular expression.
- *
- * @param ec Set to indicate what error occurred, if any.
- *
- * @returns The number of bytes in the streambuf's get area up to and including
- * the substring that matches the regular expression. Returns 0 if an error
- * occurred.
- *
- * @note After a successful read_until operation, the streambuf may contain
- * additional data beyond that which matched the regular expression. An
- * application will typically leave that data in the streambuf for a subsequent
- * read_until operation to examine.
- */
-template <typename SyncReadStream, typename Allocator>
-std::size_t read_until(SyncReadStream& s,
-    asio::basic_streambuf<Allocator>& b, const boost::regex& expr,
-    asio::error_code& ec);
-
-#endif // defined(ASIO_HAS_BOOST_REGEX)
-       // || defined(GENERATING_DOCUMENTATION)
-
-/// Read data into a streambuf until a function object indicates a match.
-/**
- * This function is used to read data into the specified streambuf until a
- * user-defined match condition function object, when applied to the data
- * contained in the streambuf, indicates a successful match. The call will
- * block until one of the following conditions is true:
- *
- * @li The match condition function object returns a std::pair where the second
- * element evaluates to true.
- *
- * @li An error occurred.
- *
- * This operation is implemented in terms of zero or more calls to the stream's
- * read_some function. If the match condition function object already indicates
- * a match, the function returns immediately.
- *
- * @param s The stream from which the data is to be read. The type must support
- * the SyncReadStream concept.
- *
- * @param b A streambuf object into which the data will be read.
- *
- * @param match_condition The function object to be called to determine whether
- * a match exists. The signature of the function object must be:
- * @code pair<iterator, bool> match_condition(iterator begin, iterator end);
- * @endcode
- * where @c iterator represents the type:
- * @code buffers_iterator<basic_streambuf<Allocator>::const_buffers_type>
- * @endcode
- * The iterator parameters @c begin and @c end define the range of bytes to be
- * scanned to determine whether there is a match. The @c first member of the
- * return value is an iterator marking one-past-the-end of the bytes that have
- * been consumed by the match function. This iterator is used to calculate the
- * @c begin parameter for any subsequent invocation of the match condition. The
- * @c second member of the return value is true if a match has been found, false
- * otherwise.
- *
- * @returns The number of bytes in the streambuf's get area that have been fully
- * consumed by the match function.
- *
- * @throws asio::system_error Thrown on failure.
- *
- * @note After a successful read_until operation, the streambuf may contain
- * additional data beyond that which matched the function object. An application
- * will typically leave that data in the streambuf for a subsequent
- *
- * @note The default implementation of the @c is_match_condition type trait
- * evaluates to true for function pointers and function objects with a
- * @c result_type typedef. It must be specialised for other user-defined
- * function objects.
- *
- * @par Examples
- * To read data into a streambuf until whitespace is encountered:
- * @code typedef asio::buffers_iterator<
- *     asio::streambuf::const_buffers_type> iterator;
- *
- * std::pair<iterator, bool>
- * match_whitespace(iterator begin, iterator end)
- * {
- *   iterator i = begin;
- *   while (i != end)
- *     if (std::isspace(*i++))
- *       return std::make_pair(i, true);
- *   return std::make_pair(i, false);
- * }
- * ...
- * asio::streambuf b;
- * asio::read_until(s, b, match_whitespace);
- * @endcode
- *
- * To read data into a streambuf until a matching character is found:
- * @code class match_char
- * {
- * public:
- *   explicit match_char(char c) : c_(c) {}
- *
- *   template <typename Iterator>
- *   std::pair<Iterator, bool> operator()(
- *       Iterator begin, Iterator end) const
- *   {
- *     Iterator i = begin;
- *     while (i != end)
- *       if (c_ == *i++)
- *         return std::make_pair(i, true);
- *     return std::make_pair(i, false);
- *   }
- *
- * private:
- *   char c_;
- * };
- *
- * namespace asio {
- *   template <> struct is_match_condition<match_char>
- *     : public boost::true_type {};
- * } // namespace asio
- * ...
- * asio::streambuf b;
- * asio::read_until(s, b, match_char('a'));
- * @endcode
- */
-template <typename SyncReadStream, typename Allocator, typename MatchCondition>
-std::size_t read_until(SyncReadStream& s,
-    asio::basic_streambuf<Allocator>& b, MatchCondition match_condition,
-    typename enable_if<is_match_condition<MatchCondition>::value>::type* = 0);
-
-/// Read data into a streambuf until a function object indicates a match.
-/**
- * This function is used to read data into the specified streambuf until a
- * user-defined match condition function object, when applied to the data
- * contained in the streambuf, indicates a successful match. The call will
- * block until one of the following conditions is true:
- *
- * @li The match condition function object returns a std::pair where the second
- * element evaluates to true.
- *
- * @li An error occurred.
- *
- * This operation is implemented in terms of zero or more calls to the stream's
- * read_some function. If the match condition function object already indicates
- * a match, the function returns immediately.
- *
- * @param s The stream from which the data is to be read. The type must support
- * the SyncReadStream concept.
- *
- * @param b A streambuf object into which the data will be read.
- *
- * @param match_condition The function object to be called to determine whether
- * a match exists. The signature of the function object must be:
- * @code pair<iterator, bool> match_condition(iterator begin, iterator end);
- * @endcode
- * where @c iterator represents the type:
- * @code buffers_iterator<basic_streambuf<Allocator>::const_buffers_type>
- * @endcode
- * The iterator parameters @c begin and @c end define the range of bytes to be
- * scanned to determine whether there is a match. The @c first member of the
- * return value is an iterator marking one-past-the-end of the bytes that have
- * been consumed by the match function. This iterator is used to calculate the
- * @c begin parameter for any subsequent invocation of the match condition. The
- * @c second member of the return value is true if a match has been found, false
- * otherwise.
- *
- * @param ec Set to indicate what error occurred, if any.
- *
- * @returns The number of bytes in the streambuf's get area that have been fully
- * consumed by the match function. Returns 0 if an error occurred.
- *
- * @note After a successful read_until operation, the streambuf may contain
- * additional data beyond that which matched the function object. An application
- * will typically leave that data in the streambuf for a subsequent
- *
- * @note The default implementation of the @c is_match_condition type trait
- * evaluates to true for function pointers and function objects with a
- * @c result_type typedef. It must be specialised for other user-defined
- * function objects.
- */
-template <typename SyncReadStream, typename Allocator, typename MatchCondition>
-std::size_t read_until(SyncReadStream& s,
-    asio::basic_streambuf<Allocator>& b,
-    MatchCondition match_condition, asio::error_code& ec,
-    typename enable_if<is_match_condition<MatchCondition>::value>::type* = 0);
-
-/*@}*/
-/**
- * @defgroup async_read_until asio::async_read_until
- *
- * @brief Start an asynchronous operation to read data into a streambuf until it
- * contains a delimiter, matches a regular expression, or a function object
- * indicates a match.
- */
-/*@{*/
-
-/// Start an asynchronous operation to read data into a streambuf until it
-/// contains a specified delimiter.
-/**
- * This function is used to asynchronously read data into the specified
- * streambuf until the streambuf's get area contains the specified delimiter.
- * The function call always returns immediately. The asynchronous operation
- * will continue until one of the following conditions is true:
- *
- * @li The get area of the streambuf contains the specified delimiter.
- *
- * @li An error occurred.
- *
- * This operation is implemented in terms of zero or more calls to the stream's
- * async_read_some function, and is known as a <em>composed operation</em>. If
- * the streambuf's get area already contains the delimiter, this asynchronous
- * operation completes immediately. The program must ensure that the stream
- * performs no other read operations (such as async_read, async_read_until, the
- * stream's async_read_some function, or any other composed operations that
- * perform reads) until this operation completes.
- *
- * @param s The stream from which the data is to be read. The type must support
- * the AsyncReadStream concept.
- *
- * @param b A streambuf object into which the data will be read. Ownership of
- * the streambuf is retained by the caller, which must guarantee that it remains
- * valid until the handler is called.
- *
- * @param delim The delimiter character.
- *
- * @param handler The handler to be called when the read operation completes.
- * Copies will be made of the handler as required. The function signature of the
- * handler must be:
- * @code void handler(
- *   // Result of operation.
- *   const asio::error_code& error,
- *
- *   // The number of bytes in the streambuf's get
- *   // area up to and including the delimiter.
- *   // 0 if an error occurred.
- *   std::size_t bytes_transferred
- * ); @endcode
- * Regardless of whether the asynchronous operation completes immediately or
- * not, the handler will not be invoked from within this function. Invocation of
- * the handler will be performed in a manner equivalent to using
- * asio::io_service::post().
- *
- * @note After a successful async_read_until operation, the streambuf may
- * contain additional data beyond the delimiter. An application will typically
- * leave that data in the streambuf for a subsequent async_read_until operation
- * to examine.
- *
- * @par Example
- * To asynchronously read data into a streambuf until a newline is encountered:
- * @code asio::streambuf b;
- * ...
- * void handler(const asio::error_code& e, std::size_t size)
- * {
- *   if (!e)
- *   {
- *     std::istream is(&b);
- *     std::string line;
- *     std::getline(is, line);
- *     ...
- *   }
- * }
- * ...
- * asio::async_read_until(s, b, '\n', handler); @endcode
- * After the @c async_read_until operation completes successfully, the buffer
- * @c b contains the delimiter:
- * @code { 'a', 'b', ..., 'c', '\n', 'd', 'e', ... } @endcode
- * The call to @c std::getline then extracts the data up to and including the
- * delimiter, so that the string @c line contains:
- * @code { 'a', 'b', ..., 'c', '\n' } @endcode
- * The remaining data is left in the buffer @c b as follows:
- * @code { 'd', 'e', ... } @endcode
- * This data may be the start of a new line, to be extracted by a subsequent
- * @c async_read_until operation.
- */
-template <typename AsyncReadStream, typename Allocator, typename ReadHandler>
-ASIO_INITFN_RESULT_TYPE(ReadHandler,
-    void (asio::error_code, std::size_t))
-async_read_until(AsyncReadStream& s,
-    asio::basic_streambuf<Allocator>& b,
-    char delim, ASIO_MOVE_ARG(ReadHandler) handler);
-
-/// Start an asynchronous operation to read data into a streambuf until it
-/// contains a specified delimiter.
-/**
- * This function is used to asynchronously read data into the specified
- * streambuf until the streambuf's get area contains the specified delimiter.
- * The function call always returns immediately. The asynchronous operation
- * will continue until one of the following conditions is true:
- *
- * @li The get area of the streambuf contains the specified delimiter.
- *
- * @li An error occurred.
- *
- * This operation is implemented in terms of zero or more calls to the stream's
- * async_read_some function, and is known as a <em>composed operation</em>. If
- * the streambuf's get area already contains the delimiter, this asynchronous
- * operation completes immediately. The program must ensure that the stream
- * performs no other read operations (such as async_read, async_read_until, the
- * stream's async_read_some function, or any other composed operations that
- * perform reads) until this operation completes.
- *
- * @param s The stream from which the data is to be read. The type must support
- * the AsyncReadStream concept.
- *
- * @param b A streambuf object into which the data will be read. Ownership of
- * the streambuf is retained by the caller, which must guarantee that it remains
- * valid until the handler is called.
- *
- * @param delim The delimiter string.
- *
- * @param handler The handler to be called when the read operation completes.
- * Copies will be made of the handler as required. The function signature of the
- * handler must be:
- * @code void handler(
- *   // Result of operation.
- *   const asio::error_code& error,
- *
- *   // The number of bytes in the streambuf's get
- *   // area up to and including the delimiter.
- *   // 0 if an error occurred.
- *   std::size_t bytes_transferred
- * ); @endcode
- * Regardless of whether the asynchronous operation completes immediately or
- * not, the handler will not be invoked from within this function. Invocation of
- * the handler will be performed in a manner equivalent to using
- * asio::io_service::post().
- *
- * @note After a successful async_read_until operation, the streambuf may
- * contain additional data beyond the delimiter. An application will typically
- * leave that data in the streambuf for a subsequent async_read_until operation
- * to examine.
- *
- * @par Example
- * To asynchronously read data into a streambuf until a newline is encountered:
- * @code asio::streambuf b;
- * ...
- * void handler(const asio::error_code& e, std::size_t size)
- * {
- *   if (!e)
- *   {
- *     std::istream is(&b);
- *     std::string line;
- *     std::getline(is, line);
- *     ...
- *   }
- * }
- * ...
- * asio::async_read_until(s, b, "\r\n", handler); @endcode
- * After the @c async_read_until operation completes successfully, the buffer
- * @c b contains the delimiter:
- * @code { 'a', 'b', ..., 'c', '\r', '\n', 'd', 'e', ... } @endcode
- * The call to @c std::getline then extracts the data up to and including the
- * delimiter, so that the string @c line contains:
- * @code { 'a', 'b', ..., 'c', '\r', '\n' } @endcode
- * The remaining data is left in the buffer @c b as follows:
- * @code { 'd', 'e', ... } @endcode
- * This data may be the start of a new line, to be extracted by a subsequent
- * @c async_read_until operation.
- */
-template <typename AsyncReadStream, typename Allocator, typename ReadHandler>
-ASIO_INITFN_RESULT_TYPE(ReadHandler,
-    void (asio::error_code, std::size_t))
-async_read_until(AsyncReadStream& s,
-    asio::basic_streambuf<Allocator>& b, const std::string& delim,
-    ASIO_MOVE_ARG(ReadHandler) handler);
-
-#if defined(ASIO_HAS_BOOST_REGEX) \
-  || defined(GENERATING_DOCUMENTATION)
-
-/// Start an asynchronous operation to read data into a streambuf until some
-/// part of its data matches a regular expression.
-/**
- * This function is used to asynchronously read data into the specified
- * streambuf until the streambuf's get area contains some data that matches a
- * regular expression. The function call always returns immediately. The
- * asynchronous operation will continue until one of the following conditions
- * is true:
- *
- * @li A substring of the streambuf's get area matches the regular expression.
- *
- * @li An error occurred.
- *
- * This operation is implemented in terms of zero or more calls to the stream's
- * async_read_some function, and is known as a <em>composed operation</em>. If
- * the streambuf's get area already contains data that matches the regular
- * expression, this asynchronous operation completes immediately. The program
- * must ensure that the stream performs no other read operations (such as
- * async_read, async_read_until, the stream's async_read_some function, or any
- * other composed operations that perform reads) until this operation
- * completes.
- *
- * @param s The stream from which the data is to be read. The type must support
- * the AsyncReadStream concept.
- *
- * @param b A streambuf object into which the data will be read. Ownership of
- * the streambuf is retained by the caller, which must guarantee that it remains
- * valid until the handler is called.
- *
- * @param expr The regular expression.
- *
- * @param handler The handler to be called when the read operation completes.
- * Copies will be made of the handler as required. The function signature of the
- * handler must be:
- * @code void handler(
- *   // Result of operation.
- *   const asio::error_code& error,
- *
- *   // The number of bytes in the streambuf's get
- *   // area up to and including the substring
- *   // that matches the regular. expression.
- *   // 0 if an error occurred.
- *   std::size_t bytes_transferred
- * ); @endcode
- * Regardless of whether the asynchronous operation completes immediately or
- * not, the handler will not be invoked from within this function. Invocation of
- * the handler will be performed in a manner equivalent to using
- * asio::io_service::post().
- *
- * @note After a successful async_read_until operation, the streambuf may
- * contain additional data beyond that which matched the regular expression. An
- * application will typically leave that data in the streambuf for a subsequent
- * async_read_until operation to examine.
- *
- * @par Example
- * To asynchronously read data into a streambuf until a CR-LF sequence is
- * encountered:
- * @code asio::streambuf b;
- * ...
- * void handler(const asio::error_code& e, std::size_t size)
- * {
- *   if (!e)
- *   {
- *     std::istream is(&b);
- *     std::string line;
- *     std::getline(is, line);
- *     ...
- *   }
- * }
- * ...
- * asio::async_read_until(s, b, boost::regex("\r\n"), handler); @endcode
- * After the @c async_read_until operation completes successfully, the buffer
- * @c b contains the data which matched the regular expression:
- * @code { 'a', 'b', ..., 'c', '\r', '\n', 'd', 'e', ... } @endcode
- * The call to @c std::getline then extracts the data up to and including the
- * match, so that the string @c line contains:
- * @code { 'a', 'b', ..., 'c', '\r', '\n' } @endcode
- * The remaining data is left in the buffer @c b as follows:
- * @code { 'd', 'e', ... } @endcode
- * This data may be the start of a new line, to be extracted by a subsequent
- * @c async_read_until operation.
- */
-template <typename AsyncReadStream, typename Allocator, typename ReadHandler>
-ASIO_INITFN_RESULT_TYPE(ReadHandler,
-    void (asio::error_code, std::size_t))
-async_read_until(AsyncReadStream& s,
-    asio::basic_streambuf<Allocator>& b, const boost::regex& expr,
-    ASIO_MOVE_ARG(ReadHandler) handler);
-
-#endif // defined(ASIO_HAS_BOOST_REGEX)
-       // || defined(GENERATING_DOCUMENTATION)
-
-/// Start an asynchronous operation to read data into a streambuf until a
-/// function object indicates a match.
-/**
- * This function is used to asynchronously read data into the specified
- * streambuf until a user-defined match condition function object, when applied
- * to the data contained in the streambuf, indicates a successful match. The
- * function call always returns immediately. The asynchronous operation will
- * continue until one of the following conditions is true:
- *
- * @li The match condition function object returns a std::pair where the second
- * element evaluates to true.
- *
- * @li An error occurred.
- *
- * This operation is implemented in terms of zero or more calls to the stream's
- * async_read_some function, and is known as a <em>composed operation</em>. If
- * the match condition function object already indicates a match, this
- * asynchronous operation completes immediately. The program must ensure that
- * the stream performs no other read operations (such as async_read,
- * async_read_until, the stream's async_read_some function, or any other
- * composed operations that perform reads) until this operation completes.
- *
- * @param s The stream from which the data is to be read. The type must support
- * the AsyncReadStream concept.
- *
- * @param b A streambuf object into which the data will be read.
- *
- * @param match_condition The function object to be called to determine whether
- * a match exists. The signature of the function object must be:
- * @code pair<iterator, bool> match_condition(iterator begin, iterator end);
- * @endcode
- * where @c iterator represents the type:
- * @code buffers_iterator<basic_streambuf<Allocator>::const_buffers_type>
- * @endcode
- * The iterator parameters @c begin and @c end define the range of bytes to be
- * scanned to determine whether there is a match. The @c first member of the
- * return value is an iterator marking one-past-the-end of the bytes that have
- * been consumed by the match function. This iterator is used to calculate the
- * @c begin parameter for any subsequent invocation of the match condition. The
- * @c second member of the return value is true if a match has been found, false
- * otherwise.
- *
- * @param handler The handler to be called when the read operation completes.
- * Copies will be made of the handler as required. The function signature of the
- * handler must be:
- * @code void handler(
- *   // Result of operation.
- *   const asio::error_code& error,
- *
- *   // The number of bytes in the streambuf's get
- *   // area that have been fully consumed by the
- *   // match function. O if an error occurred.
- *   std::size_t bytes_transferred
- * ); @endcode
- * Regardless of whether the asynchronous operation completes immediately or
- * not, the handler will not be invoked from within this function. Invocation of
- * the handler will be performed in a manner equivalent to using
- * asio::io_service::post().
- *
- * @note After a successful async_read_until operation, the streambuf may
- * contain additional data beyond that which matched the function object. An
- * application will typically leave that data in the streambuf for a subsequent
- * async_read_until operation to examine.
- *
- * @note The default implementation of the @c is_match_condition type trait
- * evaluates to true for function pointers and function objects with a
- * @c result_type typedef. It must be specialised for other user-defined
- * function objects.
- *
- * @par Examples
- * To asynchronously read data into a streambuf until whitespace is encountered:
- * @code typedef asio::buffers_iterator<
- *     asio::streambuf::const_buffers_type> iterator;
- *
- * std::pair<iterator, bool>
- * match_whitespace(iterator begin, iterator end)
- * {
- *   iterator i = begin;
- *   while (i != end)
- *     if (std::isspace(*i++))
- *       return std::make_pair(i, true);
- *   return std::make_pair(i, false);
- * }
- * ...
- * void handler(const asio::error_code& e, std::size_t size);
- * ...
- * asio::streambuf b;
- * asio::async_read_until(s, b, match_whitespace, handler);
- * @endcode
- *
- * To asynchronously read data into a streambuf until a matching character is
- * found:
- * @code class match_char
- * {
- * public:
- *   explicit match_char(char c) : c_(c) {}
- *
- *   template <typename Iterator>
- *   std::pair<Iterator, bool> operator()(
- *       Iterator begin, Iterator end) const
- *   {
- *     Iterator i = begin;
- *     while (i != end)
- *       if (c_ == *i++)
- *         return std::make_pair(i, true);
- *     return std::make_pair(i, false);
- *   }
- *
- * private:
- *   char c_;
- * };
- *
- * namespace asio {
- *   template <> struct is_match_condition<match_char>
- *     : public boost::true_type {};
- * } // namespace asio
- * ...
- * void handler(const asio::error_code& e, std::size_t size);
- * ...
- * asio::streambuf b;
- * asio::async_read_until(s, b, match_char('a'), handler);
- * @endcode
- */
-template <typename AsyncReadStream, typename Allocator,
-    typename MatchCondition, typename ReadHandler>
-ASIO_INITFN_RESULT_TYPE(ReadHandler,
-    void (asio::error_code, std::size_t))
-async_read_until(AsyncReadStream& s,
-    asio::basic_streambuf<Allocator>& b,
-    MatchCondition match_condition, ASIO_MOVE_ARG(ReadHandler) handler,
-    typename enable_if<is_match_condition<MatchCondition>::value>::type* = 0);
-
-/*@}*/
-
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#include "asio/impl/read_until.hpp"
-
-#endif // !defined(ASIO_NO_IOSTREAM)
-
-#endif // ASIO_READ_UNTIL_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/seq_packet_socket_service.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/seq_packet_socket_service.hpp
deleted file mode 100644
index 688c55aec2b5..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/seq_packet_socket_service.hpp
+++ /dev/null
@@ -1,380 +0,0 @@
-//
-// seq_packet_socket_service.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_SEQ_PACKET_SOCKET_SERVICE_HPP
-#define ASIO_SEQ_PACKET_SOCKET_SERVICE_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include <cstddef>
-#include "asio/async_result.hpp"
-#include "asio/detail/type_traits.hpp"
-#include "asio/error.hpp"
-#include "asio/io_service.hpp"
-
-#if defined(ASIO_WINDOWS_RUNTIME)
-# include "asio/detail/null_socket_service.hpp"
-#elif defined(ASIO_HAS_IOCP)
-# include "asio/detail/win_iocp_socket_service.hpp"
-#else
-# include "asio/detail/reactive_socket_service.hpp"
-#endif
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-
-/// Default service implementation for a sequenced packet socket.
-template <typename Protocol>
-class seq_packet_socket_service
-#if defined(GENERATING_DOCUMENTATION)
-  : public asio::io_service::service
-#else
-  : public asio::detail::service_base<
-      seq_packet_socket_service<Protocol> >
-#endif
-{
-public:
-#if defined(GENERATING_DOCUMENTATION)
-  /// The unique service identifier.
-  static asio::io_service::id id;
-#endif
-
-  /// The protocol type.
-  typedef Protocol protocol_type;
-
-  /// The endpoint type.
-  typedef typename Protocol::endpoint endpoint_type;
-
-private:
-  // The type of the platform-specific implementation.
-#if defined(ASIO_WINDOWS_RUNTIME)
-  typedef detail::null_socket_service<Protocol> service_impl_type;
-#elif defined(ASIO_HAS_IOCP)
-  typedef detail::win_iocp_socket_service<Protocol> service_impl_type;
-#else
-  typedef detail::reactive_socket_service<Protocol> service_impl_type;
-#endif
-
-public:
-  /// The type of a sequenced packet socket implementation.
-#if defined(GENERATING_DOCUMENTATION)
-  typedef implementation_defined implementation_type;
-#else
-  typedef typename service_impl_type::implementation_type implementation_type;
-#endif
-
-  /// (Deprecated: Use native_handle_type.) The native socket type.
-#if defined(GENERATING_DOCUMENTATION)
-  typedef implementation_defined native_type;
-#else
-  typedef typename service_impl_type::native_handle_type native_type;
-#endif
-
-  /// The native socket type.
-#if defined(GENERATING_DOCUMENTATION)
-  typedef implementation_defined native_handle_type;
-#else
-  typedef typename service_impl_type::native_handle_type native_handle_type;
-#endif
-
-  /// Construct a new sequenced packet socket service for the specified
-  /// io_service.
-  explicit seq_packet_socket_service(asio::io_service& io_service)
-    : asio::detail::service_base<
-        seq_packet_socket_service<Protocol> >(io_service),
-      service_impl_(io_service)
-  {
-  }
-
-  /// Construct a new sequenced packet socket implementation.
-  void construct(implementation_type& impl)
-  {
-    service_impl_.construct(impl);
-  }
-
-#if defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
-  /// Move-construct a new sequenced packet socket implementation.
-  void move_construct(implementation_type& impl,
-      implementation_type& other_impl)
-  {
-    service_impl_.move_construct(impl, other_impl);
-  }
-
-  /// Move-assign from another sequenced packet socket implementation.
-  void move_assign(implementation_type& impl,
-      seq_packet_socket_service& other_service,
-      implementation_type& other_impl)
-  {
-    service_impl_.move_assign(impl, other_service.service_impl_, other_impl);
-  }
-
-  /// Move-construct a new sequenced packet socket implementation from another
-  /// protocol type.
-  template <typename Protocol1>
-  void converting_move_construct(implementation_type& impl,
-      typename seq_packet_socket_service<
-        Protocol1>::implementation_type& other_impl,
-      typename enable_if<is_convertible<
-        Protocol1, Protocol>::value>::type* = 0)
-  {
-    service_impl_.template converting_move_construct<Protocol1>(
-        impl, other_impl);
-  }
-#endif // defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
-
-  /// Destroy a sequenced packet socket implementation.
-  void destroy(implementation_type& impl)
-  {
-    service_impl_.destroy(impl);
-  }
-
-  /// Open a sequenced packet socket.
-  asio::error_code open(implementation_type& impl,
-      const protocol_type& protocol, asio::error_code& ec)
-  {
-    if (protocol.type() == ASIO_OS_DEF(SOCK_SEQPACKET))
-      service_impl_.open(impl, protocol, ec);
-    else
-      ec = asio::error::invalid_argument;
-    return ec;
-  }
-
-  /// Assign an existing native socket to a sequenced packet socket.
-  asio::error_code assign(implementation_type& impl,
-      const protocol_type& protocol, const native_handle_type& native_socket,
-      asio::error_code& ec)
-  {
-    return service_impl_.assign(impl, protocol, native_socket, ec);
-  }
-
-  /// Determine whether the socket is open.
-  bool is_open(const implementation_type& impl) const
-  {
-    return service_impl_.is_open(impl);
-  }
-
-  /// Close a sequenced packet socket implementation.
-  asio::error_code close(implementation_type& impl,
-      asio::error_code& ec)
-  {
-    return service_impl_.close(impl, ec);
-  }
-
-  /// (Deprecated: Use native_handle().) Get the native socket implementation.
-  native_type native(implementation_type& impl)
-  {
-    return service_impl_.native_handle(impl);
-  }
-
-  /// Get the native socket implementation.
-  native_handle_type native_handle(implementation_type& impl)
-  {
-    return service_impl_.native_handle(impl);
-  }
-
-  /// Cancel all asynchronous operations associated with the socket.
-  asio::error_code cancel(implementation_type& impl,
-      asio::error_code& ec)
-  {
-    return service_impl_.cancel(impl, ec);
-  }
-
-  /// Determine whether the socket is at the out-of-band data mark.
-  bool at_mark(const implementation_type& impl,
-      asio::error_code& ec) const
-  {
-    return service_impl_.at_mark(impl, ec);
-  }
-
-  /// Determine the number of bytes available for reading.
-  std::size_t available(const implementation_type& impl,
-      asio::error_code& ec) const
-  {
-    return service_impl_.available(impl, ec);
-  }
-
-  /// Bind the sequenced packet socket to the specified local endpoint.
-  asio::error_code bind(implementation_type& impl,
-      const endpoint_type& endpoint, asio::error_code& ec)
-  {
-    return service_impl_.bind(impl, endpoint, ec);
-  }
-
-  /// Connect the sequenced packet socket to the specified endpoint.
-  asio::error_code connect(implementation_type& impl,
-      const endpoint_type& peer_endpoint, asio::error_code& ec)
-  {
-    return service_impl_.connect(impl, peer_endpoint, ec);
-  }
-
-  /// Start an asynchronous connect.
-  template <typename ConnectHandler>
-  ASIO_INITFN_RESULT_TYPE(ConnectHandler,
-      void (asio::error_code))
-  async_connect(implementation_type& impl,
-      const endpoint_type& peer_endpoint,
-      ASIO_MOVE_ARG(ConnectHandler) handler)
-  {
-    detail::async_result_init<
-      ConnectHandler, void (asio::error_code)> init(
-        ASIO_MOVE_CAST(ConnectHandler)(handler));
-
-    service_impl_.async_connect(impl, peer_endpoint, init.handler);
-
-    return init.result.get();
-  }
-
-  /// Set a socket option.
-  template <typename SettableSocketOption>
-  asio::error_code set_option(implementation_type& impl,
-      const SettableSocketOption& option, asio::error_code& ec)
-  {
-    return service_impl_.set_option(impl, option, ec);
-  }
-
-  /// Get a socket option.
-  template <typename GettableSocketOption>
-  asio::error_code get_option(const implementation_type& impl,
-      GettableSocketOption& option, asio::error_code& ec) const
-  {
-    return service_impl_.get_option(impl, option, ec);
-  }
-
-  /// Perform an IO control command on the socket.
-  template <typename IoControlCommand>
-  asio::error_code io_control(implementation_type& impl,
-      IoControlCommand& command, asio::error_code& ec)
-  {
-    return service_impl_.io_control(impl, command, ec);
-  }
-
-  /// Gets the non-blocking mode of the socket.
-  bool non_blocking(const implementation_type& impl) const
-  {
-    return service_impl_.non_blocking(impl);
-  }
-
-  /// Sets the non-blocking mode of the socket.
-  asio::error_code non_blocking(implementation_type& impl,
-      bool mode, asio::error_code& ec)
-  {
-    return service_impl_.non_blocking(impl, mode, ec);
-  }
-
-  /// Gets the non-blocking mode of the native socket implementation.
-  bool native_non_blocking(const implementation_type& impl) const
-  {
-    return service_impl_.native_non_blocking(impl);
-  }
-
-  /// Sets the non-blocking mode of the native socket implementation.
-  asio::error_code native_non_blocking(implementation_type& impl,
-      bool mode, asio::error_code& ec)
-  {
-    return service_impl_.native_non_blocking(impl, mode, ec);
-  }
-
-  /// Get the local endpoint.
-  endpoint_type local_endpoint(const implementation_type& impl,
-      asio::error_code& ec) const
-  {
-    return service_impl_.local_endpoint(impl, ec);
-  }
-
-  /// Get the remote endpoint.
-  endpoint_type remote_endpoint(const implementation_type& impl,
-      asio::error_code& ec) const
-  {
-    return service_impl_.remote_endpoint(impl, ec);
-  }
-
-  /// Disable sends or receives on the socket.
-  asio::error_code shutdown(implementation_type& impl,
-      socket_base::shutdown_type what, asio::error_code& ec)
-  {
-    return service_impl_.shutdown(impl, what, ec);
-  }
-
-  /// Send the given data to the peer.
-  template <typename ConstBufferSequence>
-  std::size_t send(implementation_type& impl,
-      const ConstBufferSequence& buffers,
-      socket_base::message_flags flags, asio::error_code& ec)
-  {
-    return service_impl_.send(impl, buffers, flags, ec);
-  }
-
-  /// Start an asynchronous send.
-  template <typename ConstBufferSequence, typename WriteHandler>
-  ASIO_INITFN_RESULT_TYPE(WriteHandler,
-      void (asio::error_code, std::size_t))
-  async_send(implementation_type& impl,
-      const ConstBufferSequence& buffers,
-      socket_base::message_flags flags,
-      ASIO_MOVE_ARG(WriteHandler) handler)
-  {
-    detail::async_result_init<
-      WriteHandler, void (asio::error_code, std::size_t)> init(
-        ASIO_MOVE_CAST(WriteHandler)(handler));
-
-    service_impl_.async_send(impl, buffers, flags, init.handler);
-
-    return init.result.get();
-  }
-
-  /// Receive some data from the peer.
-  template <typename MutableBufferSequence>
-  std::size_t receive(implementation_type& impl,
-      const MutableBufferSequence& buffers, socket_base::message_flags in_flags,
-      socket_base::message_flags& out_flags, asio::error_code& ec)
-  {
-    return service_impl_.receive_with_flags(impl,
-        buffers, in_flags, out_flags, ec);
-  }
-
-  /// Start an asynchronous receive.
-  template <typename MutableBufferSequence, typename ReadHandler>
-  ASIO_INITFN_RESULT_TYPE(ReadHandler,
-      void (asio::error_code, std::size_t))
-  async_receive(implementation_type& impl,
-      const MutableBufferSequence& buffers, socket_base::message_flags in_flags,
-      socket_base::message_flags& out_flags,
-      ASIO_MOVE_ARG(ReadHandler) handler)
-  {
-    detail::async_result_init<
-      ReadHandler, void (asio::error_code, std::size_t)> init(
-        ASIO_MOVE_CAST(ReadHandler)(handler));
-
-    service_impl_.async_receive_with_flags(impl,
-        buffers, in_flags, out_flags, init.handler);
-
-    return init.result.get();
-  }
-
-private:
-  // Destroy all user-defined handler objects owned by the service.
-  void shutdown_service()
-  {
-    service_impl_.shutdown_service();
-  }
-
-  // The platform-specific implementation.
-  service_impl_type service_impl_;
-};
-
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_SEQ_PACKET_SOCKET_SERVICE_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/serial_port.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/serial_port.hpp
deleted file mode 100644
index 3c3010e155eb..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/serial_port.hpp
+++ /dev/null
@@ -1,36 +0,0 @@
-//
-// serial_port.hpp
-// ~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-// Copyright (c) 2008 Rep Invariant Systems, Inc. (info@repinvariant.com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_SERIAL_PORT_HPP
-#define ASIO_SERIAL_PORT_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_HAS_SERIAL_PORT) \
-  || defined(GENERATING_DOCUMENTATION)
-
-#include "asio/basic_serial_port.hpp"
-
-namespace asio {
-
-/// Typedef for the typical usage of a serial port.
-typedef basic_serial_port<> serial_port;
-
-} // namespace asio
-
-#endif // defined(ASIO_HAS_SERIAL_PORT)
-       //   || defined(GENERATING_DOCUMENTATION)
-
-#endif // ASIO_SERIAL_PORT_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/serial_port_base.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/serial_port_base.hpp
deleted file mode 100644
index ff6d87cca1b3..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/serial_port_base.hpp
+++ /dev/null
@@ -1,167 +0,0 @@
-//
-// serial_port_base.hpp
-// ~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-// Copyright (c) 2008 Rep Invariant Systems, Inc. (info@repinvariant.com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_SERIAL_PORT_BASE_HPP
-#define ASIO_SERIAL_PORT_BASE_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_HAS_SERIAL_PORT) \
-  || defined(GENERATING_DOCUMENTATION)
-
-#if !defined(ASIO_WINDOWS) && !defined(__CYGWIN__)
-# include <termios.h>
-#endif // !defined(ASIO_WINDOWS) && !defined(__CYGWIN__)
-
-#include "asio/detail/socket_types.hpp"
-#include "asio/error_code.hpp"
-
-#if defined(GENERATING_DOCUMENTATION)
-# define ASIO_OPTION_STORAGE implementation_defined
-#elif defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-# define ASIO_OPTION_STORAGE DCB
-#else
-# define ASIO_OPTION_STORAGE termios
-#endif
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-
-/// The serial_port_base class is used as a base for the basic_serial_port class
-/// template so that we have a common place to define the serial port options.
-class serial_port_base
-{
-public:
-  /// Serial port option to permit changing the baud rate.
-  /**
-   * Implements changing the baud rate for a given serial port.
-   */
-  class baud_rate
-  {
-  public:
-    explicit baud_rate(unsigned int rate = 0);
-    unsigned int value() const;
-    ASIO_DECL asio::error_code store(
-        ASIO_OPTION_STORAGE& storage,
-        asio::error_code& ec) const;
-    ASIO_DECL asio::error_code load(
-        const ASIO_OPTION_STORAGE& storage,
-        asio::error_code& ec);
-  private:
-    unsigned int value_;
-  };
-
-  /// Serial port option to permit changing the flow control.
-  /**
-   * Implements changing the flow control for a given serial port.
-   */
-  class flow_control
-  {
-  public:
-    enum type { none, software, hardware };
-    ASIO_DECL explicit flow_control(type t = none);
-    type value() const;
-    ASIO_DECL asio::error_code store(
-        ASIO_OPTION_STORAGE& storage,
-        asio::error_code& ec) const;
-    ASIO_DECL asio::error_code load(
-        const ASIO_OPTION_STORAGE& storage,
-        asio::error_code& ec);
-  private:
-    type value_;
-  };
-
-  /// Serial port option to permit changing the parity.
-  /**
-   * Implements changing the parity for a given serial port.
-   */
-  class parity
-  {
-  public:
-    enum type { none, odd, even };
-    ASIO_DECL explicit parity(type t = none);
-    type value() const;
-    ASIO_DECL asio::error_code store(
-        ASIO_OPTION_STORAGE& storage,
-        asio::error_code& ec) const;
-    ASIO_DECL asio::error_code load(
-        const ASIO_OPTION_STORAGE& storage,
-        asio::error_code& ec);
-  private:
-    type value_;
-  };
-
-  /// Serial port option to permit changing the number of stop bits.
-  /**
-   * Implements changing the number of stop bits for a given serial port.
-   */
-  class stop_bits
-  {
-  public:
-    enum type { one, onepointfive, two };
-    ASIO_DECL explicit stop_bits(type t = one);
-    type value() const;
-    ASIO_DECL asio::error_code store(
-        ASIO_OPTION_STORAGE& storage,
-        asio::error_code& ec) const;
-    ASIO_DECL asio::error_code load(
-        const ASIO_OPTION_STORAGE& storage,
-        asio::error_code& ec);
-  private:
-    type value_;
-  };
-
-  /// Serial port option to permit changing the character size.
-  /**
-   * Implements changing the character size for a given serial port.
-   */
-  class character_size
-  {
-  public:
-    ASIO_DECL explicit character_size(unsigned int t = 8);
-    unsigned int value() const;
-    ASIO_DECL asio::error_code store(
-        ASIO_OPTION_STORAGE& storage,
-        asio::error_code& ec) const;
-    ASIO_DECL asio::error_code load(
-        const ASIO_OPTION_STORAGE& storage,
-        asio::error_code& ec);
-  private:
-    unsigned int value_;
-  };
-
-protected:
-  /// Protected destructor to prevent deletion through this type.
-  ~serial_port_base()
-  {
-  }
-};
-
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#undef ASIO_OPTION_STORAGE
-
-#include "asio/impl/serial_port_base.hpp"
-#if defined(ASIO_HEADER_ONLY)
-# include "asio/impl/serial_port_base.ipp"
-#endif // defined(ASIO_HEADER_ONLY)
-
-#endif // defined(ASIO_HAS_SERIAL_PORT)
-       //   || defined(GENERATING_DOCUMENTATION)
-
-#endif // ASIO_SERIAL_PORT_BASE_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/serial_port_service.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/serial_port_service.hpp
deleted file mode 100644
index 8b0d4f42521c..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/serial_port_service.hpp
+++ /dev/null
@@ -1,253 +0,0 @@
-//
-// serial_port_service.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_SERIAL_PORT_SERVICE_HPP
-#define ASIO_SERIAL_PORT_SERVICE_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_HAS_SERIAL_PORT) \
-  || defined(GENERATING_DOCUMENTATION)
-
-#include <cstddef>
-#include <string>
-#include "asio/async_result.hpp"
-#include "asio/detail/reactive_serial_port_service.hpp"
-#include "asio/detail/win_iocp_serial_port_service.hpp"
-#include "asio/error.hpp"
-#include "asio/io_service.hpp"
-#include "asio/serial_port_base.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-
-/// Default service implementation for a serial port.
-class serial_port_service
-#if defined(GENERATING_DOCUMENTATION)
-  : public asio::io_service::service
-#else
-  : public asio::detail::service_base<serial_port_service>
-#endif
-{
-public:
-#if defined(GENERATING_DOCUMENTATION)
-  /// The unique service identifier.
-  static asio::io_service::id id;
-#endif
-
-private:
-  // The type of the platform-specific implementation.
-#if defined(ASIO_HAS_IOCP)
-  typedef detail::win_iocp_serial_port_service service_impl_type;
-#else
-  typedef detail::reactive_serial_port_service service_impl_type;
-#endif
-
-public:
-  /// The type of a serial port implementation.
-#if defined(GENERATING_DOCUMENTATION)
-  typedef implementation_defined implementation_type;
-#else
-  typedef service_impl_type::implementation_type implementation_type;
-#endif
-
-  /// (Deprecated: Use native_handle_type.) The native handle type.
-#if defined(GENERATING_DOCUMENTATION)
-  typedef implementation_defined native_type;
-#else
-  typedef service_impl_type::native_handle_type native_type;
-#endif
-
-  /// The native handle type.
-#if defined(GENERATING_DOCUMENTATION)
-  typedef implementation_defined native_handle_type;
-#else
-  typedef service_impl_type::native_handle_type native_handle_type;
-#endif
-
-  /// Construct a new serial port service for the specified io_service.
-  explicit serial_port_service(asio::io_service& io_service)
-    : asio::detail::service_base<serial_port_service>(io_service),
-      service_impl_(io_service)
-  {
-  }
-
-  /// Construct a new serial port implementation.
-  void construct(implementation_type& impl)
-  {
-    service_impl_.construct(impl);
-  }
-
-#if defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
-  /// Move-construct a new serial port implementation.
-  void move_construct(implementation_type& impl,
-      implementation_type& other_impl)
-  {
-    service_impl_.move_construct(impl, other_impl);
-  }
-
-  /// Move-assign from another serial port implementation.
-  void move_assign(implementation_type& impl,
-      serial_port_service& other_service,
-      implementation_type& other_impl)
-  {
-    service_impl_.move_assign(impl, other_service.service_impl_, other_impl);
-  }
-#endif // defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
-
-  /// Destroy a serial port implementation.
-  void destroy(implementation_type& impl)
-  {
-    service_impl_.destroy(impl);
-  }
-
-  /// Open a serial port.
-  asio::error_code open(implementation_type& impl,
-      const std::string& device, asio::error_code& ec)
-  {
-    return service_impl_.open(impl, device, ec);
-  }
-
-  /// Assign an existing native handle to a serial port.
-  asio::error_code assign(implementation_type& impl,
-      const native_handle_type& handle, asio::error_code& ec)
-  {
-    return service_impl_.assign(impl, handle, ec);
-  }
-
-  /// Determine whether the handle is open.
-  bool is_open(const implementation_type& impl) const
-  {
-    return service_impl_.is_open(impl);
-  }
-
-  /// Close a serial port implementation.
-  asio::error_code close(implementation_type& impl,
-      asio::error_code& ec)
-  {
-    return service_impl_.close(impl, ec);
-  }
-
-  /// (Deprecated: Use native_handle().) Get the native handle implementation.
-  native_type native(implementation_type& impl)
-  {
-    return service_impl_.native_handle(impl);
-  }
-
-  /// Get the native handle implementation.
-  native_handle_type native_handle(implementation_type& impl)
-  {
-    return service_impl_.native_handle(impl);
-  }
-
-  /// Cancel all asynchronous operations associated with the handle.
-  asio::error_code cancel(implementation_type& impl,
-      asio::error_code& ec)
-  {
-    return service_impl_.cancel(impl, ec);
-  }
-
-  /// Set a serial port option.
-  template <typename SettableSerialPortOption>
-  asio::error_code set_option(implementation_type& impl,
-      const SettableSerialPortOption& option, asio::error_code& ec)
-  {
-    return service_impl_.set_option(impl, option, ec);
-  }
-
-  /// Get a serial port option.
-  template <typename GettableSerialPortOption>
-  asio::error_code get_option(const implementation_type& impl,
-      GettableSerialPortOption& option, asio::error_code& ec) const
-  {
-    return service_impl_.get_option(impl, option, ec);
-  }
-
-  /// Send a break sequence to the serial port.
-  asio::error_code send_break(implementation_type& impl,
-      asio::error_code& ec)
-  {
-    return service_impl_.send_break(impl, ec);
-  }
-
-  /// Write the given data to the stream.
-  template <typename ConstBufferSequence>
-  std::size_t write_some(implementation_type& impl,
-      const ConstBufferSequence& buffers, asio::error_code& ec)
-  {
-    return service_impl_.write_some(impl, buffers, ec);
-  }
-
-  /// Start an asynchronous write.
-  template <typename ConstBufferSequence, typename WriteHandler>
-  ASIO_INITFN_RESULT_TYPE(WriteHandler,
-      void (asio::error_code, std::size_t))
-  async_write_some(implementation_type& impl,
-      const ConstBufferSequence& buffers,
-      ASIO_MOVE_ARG(WriteHandler) handler)
-  {
-    detail::async_result_init<
-      WriteHandler, void (asio::error_code, std::size_t)> init(
-        ASIO_MOVE_CAST(WriteHandler)(handler));
-
-    service_impl_.async_write_some(impl, buffers, init.handler);
-
-    return init.result.get();
-  }
-
-  /// Read some data from the stream.
-  template <typename MutableBufferSequence>
-  std::size_t read_some(implementation_type& impl,
-      const MutableBufferSequence& buffers, asio::error_code& ec)
-  {
-    return service_impl_.read_some(impl, buffers, ec);
-  }
-
-  /// Start an asynchronous read.
-  template <typename MutableBufferSequence, typename ReadHandler>
-  ASIO_INITFN_RESULT_TYPE(ReadHandler,
-      void (asio::error_code, std::size_t))
-  async_read_some(implementation_type& impl,
-      const MutableBufferSequence& buffers,
-      ASIO_MOVE_ARG(ReadHandler) handler)
-  {
-    detail::async_result_init<
-      ReadHandler, void (asio::error_code, std::size_t)> init(
-        ASIO_MOVE_CAST(ReadHandler)(handler));
-
-    service_impl_.async_read_some(impl, buffers, init.handler);
-
-    return init.result.get();
-  }
-
-private:
-  // Destroy all user-defined handler objects owned by the service.
-  void shutdown_service()
-  {
-    service_impl_.shutdown_service();
-  }
-
-  // The platform-specific implementation.
-  service_impl_type service_impl_;
-};
-
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // defined(ASIO_HAS_SERIAL_PORT)
-       //   || defined(GENERATING_DOCUMENTATION)
-
-#endif // ASIO_SERIAL_PORT_SERVICE_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/signal_set.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/signal_set.hpp
deleted file mode 100644
index d1987ba8e40d..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/signal_set.hpp
+++ /dev/null
@@ -1,28 +0,0 @@
-//
-// signal_set.hpp
-// ~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_SIGNAL_SET_HPP
-#define ASIO_SIGNAL_SET_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include "asio/basic_signal_set.hpp"
-
-namespace asio {
-
-/// Typedef for the typical usage of a signal set.
-typedef basic_signal_set<> signal_set;
-
-} // namespace asio
-
-#endif // ASIO_SIGNAL_SET_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/signal_set_service.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/signal_set_service.hpp
deleted file mode 100644
index f187ace9b92a..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/signal_set_service.hpp
+++ /dev/null
@@ -1,134 +0,0 @@
-//
-// signal_set_service.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_SIGNAL_SET_SERVICE_HPP
-#define ASIO_SIGNAL_SET_SERVICE_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include "asio/async_result.hpp"
-#include "asio/detail/signal_set_service.hpp"
-#include "asio/error.hpp"
-#include "asio/io_service.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-
-/// Default service implementation for a signal set.
-class signal_set_service
-#if defined(GENERATING_DOCUMENTATION)
-  : public asio::io_service::service
-#else
-  : public asio::detail::service_base<signal_set_service>
-#endif
-{
-public:
-#if defined(GENERATING_DOCUMENTATION)
-  /// The unique service identifier.
-  static asio::io_service::id id;
-#endif
-
-public:
-  /// The type of a signal set implementation.
-#if defined(GENERATING_DOCUMENTATION)
-  typedef implementation_defined implementation_type;
-#else
-  typedef detail::signal_set_service::implementation_type implementation_type;
-#endif
-
-  /// Construct a new signal set service for the specified io_service.
-  explicit signal_set_service(asio::io_service& io_service)
-    : asio::detail::service_base<signal_set_service>(io_service),
-      service_impl_(io_service)
-  {
-  }
-
-  /// Construct a new signal set implementation.
-  void construct(implementation_type& impl)
-  {
-    service_impl_.construct(impl);
-  }
-
-  /// Destroy a signal set implementation.
-  void destroy(implementation_type& impl)
-  {
-    service_impl_.destroy(impl);
-  }
-
-  /// Add a signal to a signal_set.
-  asio::error_code add(implementation_type& impl,
-      int signal_number, asio::error_code& ec)
-  {
-    return service_impl_.add(impl, signal_number, ec);
-  }
-
-  /// Remove a signal to a signal_set.
-  asio::error_code remove(implementation_type& impl,
-      int signal_number, asio::error_code& ec)
-  {
-    return service_impl_.remove(impl, signal_number, ec);
-  }
-
-  /// Remove all signals from a signal_set.
-  asio::error_code clear(implementation_type& impl,
-      asio::error_code& ec)
-  {
-    return service_impl_.clear(impl, ec);
-  }
-
-  /// Cancel all operations associated with the signal set.
-  asio::error_code cancel(implementation_type& impl,
-      asio::error_code& ec)
-  {
-    return service_impl_.cancel(impl, ec);
-  }
-
-  // Start an asynchronous operation to wait for a signal to be delivered.
-  template <typename SignalHandler>
-  ASIO_INITFN_RESULT_TYPE(SignalHandler,
-      void (asio::error_code, int))
-  async_wait(implementation_type& impl,
-      ASIO_MOVE_ARG(SignalHandler) handler)
-  {
-    detail::async_result_init<
-      SignalHandler, void (asio::error_code, int)> init(
-        ASIO_MOVE_CAST(SignalHandler)(handler));
-
-    service_impl_.async_wait(impl, init.handler);
-
-    return init.result.get();
-  }
-
-private:
-  // Destroy all user-defined handler objects owned by the service.
-  void shutdown_service()
-  {
-    service_impl_.shutdown_service();
-  }
-
-  // Perform any fork-related housekeeping.
-  void fork_service(asio::io_service::fork_event event)
-  {
-    service_impl_.fork_service(event);
-  }
-
-  // The platform-specific implementation.
-  detail::signal_set_service service_impl_;
-};
-
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_SIGNAL_SET_SERVICE_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/socket_acceptor_service.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/socket_acceptor_service.hpp
deleted file mode 100644
index 62038e5d22a3..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/socket_acceptor_service.hpp
+++ /dev/null
@@ -1,302 +0,0 @@
-//
-// socket_acceptor_service.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_SOCKET_ACCEPTOR_SERVICE_HPP
-#define ASIO_SOCKET_ACCEPTOR_SERVICE_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include "asio/basic_socket.hpp"
-#include "asio/detail/type_traits.hpp"
-#include "asio/error.hpp"
-#include "asio/io_service.hpp"
-
-#if defined(ASIO_WINDOWS_RUNTIME)
-# include "asio/detail/null_socket_service.hpp"
-#elif defined(ASIO_HAS_IOCP)
-# include "asio/detail/win_iocp_socket_service.hpp"
-#else
-# include "asio/detail/reactive_socket_service.hpp"
-#endif
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-
-/// Default service implementation for a socket acceptor.
-template <typename Protocol>
-class socket_acceptor_service
-#if defined(GENERATING_DOCUMENTATION)
-  : public asio::io_service::service
-#else
-  : public asio::detail::service_base<socket_acceptor_service<Protocol> >
-#endif
-{
-public:
-#if defined(GENERATING_DOCUMENTATION)
-  /// The unique service identifier.
-  static asio::io_service::id id;
-#endif
-
-  /// The protocol type.
-  typedef Protocol protocol_type;
-
-  /// The endpoint type.
-  typedef typename protocol_type::endpoint endpoint_type;
-
-private:
-  // The type of the platform-specific implementation.
-#if defined(ASIO_WINDOWS_RUNTIME)
-  typedef detail::null_socket_service<Protocol> service_impl_type;
-#elif defined(ASIO_HAS_IOCP)
-  typedef detail::win_iocp_socket_service<Protocol> service_impl_type;
-#else
-  typedef detail::reactive_socket_service<Protocol> service_impl_type;
-#endif
-
-public:
-  /// The native type of the socket acceptor.
-#if defined(GENERATING_DOCUMENTATION)
-  typedef implementation_defined implementation_type;
-#else
-  typedef typename service_impl_type::implementation_type implementation_type;
-#endif
-
-  /// (Deprecated: Use native_handle_type.) The native acceptor type.
-#if defined(GENERATING_DOCUMENTATION)
-  typedef implementation_defined native_type;
-#else
-  typedef typename service_impl_type::native_handle_type native_type;
-#endif
-
-  /// The native acceptor type.
-#if defined(GENERATING_DOCUMENTATION)
-  typedef implementation_defined native_handle_type;
-#else
-  typedef typename service_impl_type::native_handle_type native_handle_type;
-#endif
-
-  /// Construct a new socket acceptor service for the specified io_service.
-  explicit socket_acceptor_service(asio::io_service& io_service)
-    : asio::detail::service_base<
-        socket_acceptor_service<Protocol> >(io_service),
-      service_impl_(io_service)
-  {
-  }
-
-  /// Construct a new socket acceptor implementation.
-  void construct(implementation_type& impl)
-  {
-    service_impl_.construct(impl);
-  }
-
-#if defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
-  /// Move-construct a new socket acceptor implementation.
-  void move_construct(implementation_type& impl,
-      implementation_type& other_impl)
-  {
-    service_impl_.move_construct(impl, other_impl);
-  }
-
-  /// Move-assign from another socket acceptor implementation.
-  void move_assign(implementation_type& impl,
-      socket_acceptor_service& other_service,
-      implementation_type& other_impl)
-  {
-    service_impl_.move_assign(impl, other_service.service_impl_, other_impl);
-  }
-
-  /// Move-construct a new socket acceptor implementation from another protocol
-  /// type.
-  template <typename Protocol1>
-  void converting_move_construct(implementation_type& impl,
-      typename socket_acceptor_service<
-        Protocol1>::implementation_type& other_impl,
-      typename enable_if<is_convertible<
-        Protocol1, Protocol>::value>::type* = 0)
-  {
-    service_impl_.template converting_move_construct<Protocol1>(
-        impl, other_impl);
-  }
-#endif // defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
-
-  /// Destroy a socket acceptor implementation.
-  void destroy(implementation_type& impl)
-  {
-    service_impl_.destroy(impl);
-  }
-
-  /// Open a new socket acceptor implementation.
-  asio::error_code open(implementation_type& impl,
-      const protocol_type& protocol, asio::error_code& ec)
-  {
-    return service_impl_.open(impl, protocol, ec);
-  }
-
-  /// Assign an existing native acceptor to a socket acceptor.
-  asio::error_code assign(implementation_type& impl,
-      const protocol_type& protocol, const native_handle_type& native_acceptor,
-      asio::error_code& ec)
-  {
-    return service_impl_.assign(impl, protocol, native_acceptor, ec);
-  }
-
-  /// Determine whether the acceptor is open.
-  bool is_open(const implementation_type& impl) const
-  {
-    return service_impl_.is_open(impl);
-  }
-
-  /// Cancel all asynchronous operations associated with the acceptor.
-  asio::error_code cancel(implementation_type& impl,
-      asio::error_code& ec)
-  {
-    return service_impl_.cancel(impl, ec);
-  }
-
-  /// Bind the socket acceptor to the specified local endpoint.
-  asio::error_code bind(implementation_type& impl,
-      const endpoint_type& endpoint, asio::error_code& ec)
-  {
-    return service_impl_.bind(impl, endpoint, ec);
-  }
-
-  /// Place the socket acceptor into the state where it will listen for new
-  /// connections.
-  asio::error_code listen(implementation_type& impl, int backlog,
-      asio::error_code& ec)
-  {
-    return service_impl_.listen(impl, backlog, ec);
-  }
-
-  /// Close a socket acceptor implementation.
-  asio::error_code close(implementation_type& impl,
-      asio::error_code& ec)
-  {
-    return service_impl_.close(impl, ec);
-  }
-
-  /// (Deprecated: Use native_handle().) Get the native acceptor implementation.
-  native_type native(implementation_type& impl)
-  {
-    return service_impl_.native_handle(impl);
-  }
-
-  /// Get the native acceptor implementation.
-  native_handle_type native_handle(implementation_type& impl)
-  {
-    return service_impl_.native_handle(impl);
-  }
-
-  /// Set a socket option.
-  template <typename SettableSocketOption>
-  asio::error_code set_option(implementation_type& impl,
-      const SettableSocketOption& option, asio::error_code& ec)
-  {
-    return service_impl_.set_option(impl, option, ec);
-  }
-
-  /// Get a socket option.
-  template <typename GettableSocketOption>
-  asio::error_code get_option(const implementation_type& impl,
-      GettableSocketOption& option, asio::error_code& ec) const
-  {
-    return service_impl_.get_option(impl, option, ec);
-  }
-
-  /// Perform an IO control command on the socket.
-  template <typename IoControlCommand>
-  asio::error_code io_control(implementation_type& impl,
-      IoControlCommand& command, asio::error_code& ec)
-  {
-    return service_impl_.io_control(impl, command, ec);
-  }
-
-  /// Gets the non-blocking mode of the acceptor.
-  bool non_blocking(const implementation_type& impl) const
-  {
-    return service_impl_.non_blocking(impl);
-  }
-
-  /// Sets the non-blocking mode of the acceptor.
-  asio::error_code non_blocking(implementation_type& impl,
-      bool mode, asio::error_code& ec)
-  {
-    return service_impl_.non_blocking(impl, mode, ec);
-  }
-
-  /// Gets the non-blocking mode of the native acceptor implementation.
-  bool native_non_blocking(const implementation_type& impl) const
-  {
-    return service_impl_.native_non_blocking(impl);
-  }
-
-  /// Sets the non-blocking mode of the native acceptor implementation.
-  asio::error_code native_non_blocking(implementation_type& impl,
-      bool mode, asio::error_code& ec)
-  {
-    return service_impl_.native_non_blocking(impl, mode, ec);
-  }
-
-  /// Get the local endpoint.
-  endpoint_type local_endpoint(const implementation_type& impl,
-      asio::error_code& ec) const
-  {
-    return service_impl_.local_endpoint(impl, ec);
-  }
-
-  /// Accept a new connection.
-  template <typename Protocol1, typename SocketService>
-  asio::error_code accept(implementation_type& impl,
-      basic_socket<Protocol1, SocketService>& peer,
-      endpoint_type* peer_endpoint, asio::error_code& ec,
-      typename enable_if<is_convertible<Protocol, Protocol1>::value>::type* = 0)
-  {
-    return service_impl_.accept(impl, peer, peer_endpoint, ec);
-  }
-
-  /// Start an asynchronous accept.
-  template <typename Protocol1, typename SocketService, typename AcceptHandler>
-  ASIO_INITFN_RESULT_TYPE(AcceptHandler,
-      void (asio::error_code))
-  async_accept(implementation_type& impl,
-      basic_socket<Protocol1, SocketService>& peer,
-      endpoint_type* peer_endpoint,
-      ASIO_MOVE_ARG(AcceptHandler) handler,
-      typename enable_if<is_convertible<Protocol, Protocol1>::value>::type* = 0)
-  {
-    detail::async_result_init<
-      AcceptHandler, void (asio::error_code)> init(
-        ASIO_MOVE_CAST(AcceptHandler)(handler));
-
-    service_impl_.async_accept(impl, peer, peer_endpoint, init.handler);
-
-    return init.result.get();
-  }
-
-private:
-  // Destroy all user-defined handler objects owned by the service.
-  void shutdown_service()
-  {
-    service_impl_.shutdown_service();
-  }
-
-  // The platform-specific implementation.
-  service_impl_type service_impl_;
-};
-
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_SOCKET_ACCEPTOR_SERVICE_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/socket_base.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/socket_base.hpp
deleted file mode 100644
index 5412162b432c..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/socket_base.hpp
+++ /dev/null
@@ -1,520 +0,0 @@
-//
-// socket_base.hpp
-// ~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_SOCKET_BASE_HPP
-#define ASIO_SOCKET_BASE_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include "asio/detail/io_control.hpp"
-#include "asio/detail/socket_option.hpp"
-#include "asio/detail/socket_types.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-
-/// The socket_base class is used as a base for the basic_stream_socket and
-/// basic_datagram_socket class templates so that we have a common place to
-/// define the shutdown_type and enum.
-class socket_base
-{
-public:
-  /// Different ways a socket may be shutdown.
-  enum shutdown_type
-  {
-#if defined(GENERATING_DOCUMENTATION)
-    /// Shutdown the receive side of the socket.
-    shutdown_receive = implementation_defined,
-
-    /// Shutdown the send side of the socket.
-    shutdown_send = implementation_defined,
-
-    /// Shutdown both send and receive on the socket.
-    shutdown_both = implementation_defined
-#else
-    shutdown_receive = ASIO_OS_DEF(SHUT_RD),
-    shutdown_send = ASIO_OS_DEF(SHUT_WR),
-    shutdown_both = ASIO_OS_DEF(SHUT_RDWR)
-#endif
-  };
-
-  /// Bitmask type for flags that can be passed to send and receive operations.
-  typedef int message_flags;
-
-#if defined(GENERATING_DOCUMENTATION)
-  /// Peek at incoming data without removing it from the input queue.
-  static const int message_peek = implementation_defined;
-
-  /// Process out-of-band data.
-  static const int message_out_of_band = implementation_defined;
-
-  /// Specify that the data should not be subject to routing.
-  static const int message_do_not_route = implementation_defined;
-
-  /// Specifies that the data marks the end of a record.
-  static const int message_end_of_record = implementation_defined;
-#else
-  ASIO_STATIC_CONSTANT(int,
-      message_peek = ASIO_OS_DEF(MSG_PEEK));
-  ASIO_STATIC_CONSTANT(int,
-      message_out_of_band = ASIO_OS_DEF(MSG_OOB));
-  ASIO_STATIC_CONSTANT(int,
-      message_do_not_route = ASIO_OS_DEF(MSG_DONTROUTE));
-  ASIO_STATIC_CONSTANT(int,
-      message_end_of_record = ASIO_OS_DEF(MSG_EOR));
-#endif
-
-  /// Socket option to permit sending of broadcast messages.
-  /**
-   * Implements the SOL_SOCKET/SO_BROADCAST socket option.
-   *
-   * @par Examples
-   * Setting the option:
-   * @code
-   * asio::ip::udp::socket socket(io_service); 
-   * ...
-   * asio::socket_base::broadcast option(true);
-   * socket.set_option(option);
-   * @endcode
-   *
-   * @par
-   * Getting the current option value:
-   * @code
-   * asio::ip::udp::socket socket(io_service); 
-   * ...
-   * asio::socket_base::broadcast option;
-   * socket.get_option(option);
-   * bool is_set = option.value();
-   * @endcode
-   *
-   * @par Concepts:
-   * Socket_Option, Boolean_Socket_Option.
-   */
-#if defined(GENERATING_DOCUMENTATION)
-  typedef implementation_defined broadcast;
-#else
-  typedef asio::detail::socket_option::boolean<
-    ASIO_OS_DEF(SOL_SOCKET), ASIO_OS_DEF(SO_BROADCAST)>
-      broadcast;
-#endif
-
-  /// Socket option to enable socket-level debugging.
-  /**
-   * Implements the SOL_SOCKET/SO_DEBUG socket option.
-   *
-   * @par Examples
-   * Setting the option:
-   * @code
-   * asio::ip::tcp::socket socket(io_service); 
-   * ...
-   * asio::socket_base::debug option(true);
-   * socket.set_option(option);
-   * @endcode
-   *
-   * @par
-   * Getting the current option value:
-   * @code
-   * asio::ip::tcp::socket socket(io_service); 
-   * ...
-   * asio::socket_base::debug option;
-   * socket.get_option(option);
-   * bool is_set = option.value();
-   * @endcode
-   *
-   * @par Concepts:
-   * Socket_Option, Boolean_Socket_Option.
-   */
-#if defined(GENERATING_DOCUMENTATION)
-  typedef implementation_defined debug;
-#else
-  typedef asio::detail::socket_option::boolean<
-    ASIO_OS_DEF(SOL_SOCKET), ASIO_OS_DEF(SO_DEBUG)> debug;
-#endif
-
-  /// Socket option to prevent routing, use local interfaces only.
-  /**
-   * Implements the SOL_SOCKET/SO_DONTROUTE socket option.
-   *
-   * @par Examples
-   * Setting the option:
-   * @code
-   * asio::ip::udp::socket socket(io_service); 
-   * ...
-   * asio::socket_base::do_not_route option(true);
-   * socket.set_option(option);
-   * @endcode
-   *
-   * @par
-   * Getting the current option value:
-   * @code
-   * asio::ip::udp::socket socket(io_service); 
-   * ...
-   * asio::socket_base::do_not_route option;
-   * socket.get_option(option);
-   * bool is_set = option.value();
-   * @endcode
-   *
-   * @par Concepts:
-   * Socket_Option, Boolean_Socket_Option.
-   */
-#if defined(GENERATING_DOCUMENTATION)
-  typedef implementation_defined do_not_route;
-#else
-  typedef asio::detail::socket_option::boolean<
-    ASIO_OS_DEF(SOL_SOCKET), ASIO_OS_DEF(SO_DONTROUTE)>
-      do_not_route;
-#endif
-
-  /// Socket option to send keep-alives.
-  /**
-   * Implements the SOL_SOCKET/SO_KEEPALIVE socket option.
-   *
-   * @par Examples
-   * Setting the option:
-   * @code
-   * asio::ip::tcp::socket socket(io_service); 
-   * ...
-   * asio::socket_base::keep_alive option(true);
-   * socket.set_option(option);
-   * @endcode
-   *
-   * @par
-   * Getting the current option value:
-   * @code
-   * asio::ip::tcp::socket socket(io_service); 
-   * ...
-   * asio::socket_base::keep_alive option;
-   * socket.get_option(option);
-   * bool is_set = option.value();
-   * @endcode
-   *
-   * @par Concepts:
-   * Socket_Option, Boolean_Socket_Option.
-   */
-#if defined(GENERATING_DOCUMENTATION)
-  typedef implementation_defined keep_alive;
-#else
-  typedef asio::detail::socket_option::boolean<
-    ASIO_OS_DEF(SOL_SOCKET), ASIO_OS_DEF(SO_KEEPALIVE)> keep_alive;
-#endif
-
-  /// Socket option for the send buffer size of a socket.
-  /**
-   * Implements the SOL_SOCKET/SO_SNDBUF socket option.
-   *
-   * @par Examples
-   * Setting the option:
-   * @code
-   * asio::ip::tcp::socket socket(io_service); 
-   * ...
-   * asio::socket_base::send_buffer_size option(8192);
-   * socket.set_option(option);
-   * @endcode
-   *
-   * @par
-   * Getting the current option value:
-   * @code
-   * asio::ip::tcp::socket socket(io_service); 
-   * ...
-   * asio::socket_base::send_buffer_size option;
-   * socket.get_option(option);
-   * int size = option.value();
-   * @endcode
-   *
-   * @par Concepts:
-   * Socket_Option, Integer_Socket_Option.
-   */
-#if defined(GENERATING_DOCUMENTATION)
-  typedef implementation_defined send_buffer_size;
-#else
-  typedef asio::detail::socket_option::integer<
-    ASIO_OS_DEF(SOL_SOCKET), ASIO_OS_DEF(SO_SNDBUF)>
-      send_buffer_size;
-#endif
-
-  /// Socket option for the send low watermark.
-  /**
-   * Implements the SOL_SOCKET/SO_SNDLOWAT socket option.
-   *
-   * @par Examples
-   * Setting the option:
-   * @code
-   * asio::ip::tcp::socket socket(io_service); 
-   * ...
-   * asio::socket_base::send_low_watermark option(1024);
-   * socket.set_option(option);
-   * @endcode
-   *
-   * @par
-   * Getting the current option value:
-   * @code
-   * asio::ip::tcp::socket socket(io_service); 
-   * ...
-   * asio::socket_base::send_low_watermark option;
-   * socket.get_option(option);
-   * int size = option.value();
-   * @endcode
-   *
-   * @par Concepts:
-   * Socket_Option, Integer_Socket_Option.
-   */
-#if defined(GENERATING_DOCUMENTATION)
-  typedef implementation_defined send_low_watermark;
-#else
-  typedef asio::detail::socket_option::integer<
-    ASIO_OS_DEF(SOL_SOCKET), ASIO_OS_DEF(SO_SNDLOWAT)>
-      send_low_watermark;
-#endif
-
-  /// Socket option for the receive buffer size of a socket.
-  /**
-   * Implements the SOL_SOCKET/SO_RCVBUF socket option.
-   *
-   * @par Examples
-   * Setting the option:
-   * @code
-   * asio::ip::tcp::socket socket(io_service); 
-   * ...
-   * asio::socket_base::receive_buffer_size option(8192);
-   * socket.set_option(option);
-   * @endcode
-   *
-   * @par
-   * Getting the current option value:
-   * @code
-   * asio::ip::tcp::socket socket(io_service); 
-   * ...
-   * asio::socket_base::receive_buffer_size option;
-   * socket.get_option(option);
-   * int size = option.value();
-   * @endcode
-   *
-   * @par Concepts:
-   * Socket_Option, Integer_Socket_Option.
-   */
-#if defined(GENERATING_DOCUMENTATION)
-  typedef implementation_defined receive_buffer_size;
-#else
-  typedef asio::detail::socket_option::integer<
-    ASIO_OS_DEF(SOL_SOCKET), ASIO_OS_DEF(SO_RCVBUF)>
-      receive_buffer_size;
-#endif
-
-  /// Socket option for the receive low watermark.
-  /**
-   * Implements the SOL_SOCKET/SO_RCVLOWAT socket option.
-   *
-   * @par Examples
-   * Setting the option:
-   * @code
-   * asio::ip::tcp::socket socket(io_service); 
-   * ...
-   * asio::socket_base::receive_low_watermark option(1024);
-   * socket.set_option(option);
-   * @endcode
-   *
-   * @par
-   * Getting the current option value:
-   * @code
-   * asio::ip::tcp::socket socket(io_service); 
-   * ...
-   * asio::socket_base::receive_low_watermark option;
-   * socket.get_option(option);
-   * int size = option.value();
-   * @endcode
-   *
-   * @par Concepts:
-   * Socket_Option, Integer_Socket_Option.
-   */
-#if defined(GENERATING_DOCUMENTATION)
-  typedef implementation_defined receive_low_watermark;
-#else
-  typedef asio::detail::socket_option::integer<
-    ASIO_OS_DEF(SOL_SOCKET), ASIO_OS_DEF(SO_RCVLOWAT)>
-      receive_low_watermark;
-#endif
-
-  /// Socket option to allow the socket to be bound to an address that is
-  /// already in use.
-  /**
-   * Implements the SOL_SOCKET/SO_REUSEADDR socket option.
-   *
-   * @par Examples
-   * Setting the option:
-   * @code
-   * asio::ip::tcp::acceptor acceptor(io_service); 
-   * ...
-   * asio::socket_base::reuse_address option(true);
-   * acceptor.set_option(option);
-   * @endcode
-   *
-   * @par
-   * Getting the current option value:
-   * @code
-   * asio::ip::tcp::acceptor acceptor(io_service); 
-   * ...
-   * asio::socket_base::reuse_address option;
-   * acceptor.get_option(option);
-   * bool is_set = option.value();
-   * @endcode
-   *
-   * @par Concepts:
-   * Socket_Option, Boolean_Socket_Option.
-   */
-#if defined(GENERATING_DOCUMENTATION)
-  typedef implementation_defined reuse_address;
-#else
-  typedef asio::detail::socket_option::boolean<
-    ASIO_OS_DEF(SOL_SOCKET), ASIO_OS_DEF(SO_REUSEADDR)>
-      reuse_address;
-#endif
-
-  /// Socket option to specify whether the socket lingers on close if unsent
-  /// data is present.
-  /**
-   * Implements the SOL_SOCKET/SO_LINGER socket option.
-   *
-   * @par Examples
-   * Setting the option:
-   * @code
-   * asio::ip::tcp::socket socket(io_service); 
-   * ...
-   * asio::socket_base::linger option(true, 30);
-   * socket.set_option(option);
-   * @endcode
-   *
-   * @par
-   * Getting the current option value:
-   * @code
-   * asio::ip::tcp::socket socket(io_service); 
-   * ...
-   * asio::socket_base::linger option;
-   * socket.get_option(option);
-   * bool is_set = option.enabled();
-   * unsigned short timeout = option.timeout();
-   * @endcode
-   *
-   * @par Concepts:
-   * Socket_Option, Linger_Socket_Option.
-   */
-#if defined(GENERATING_DOCUMENTATION)
-  typedef implementation_defined linger;
-#else
-  typedef asio::detail::socket_option::linger<
-    ASIO_OS_DEF(SOL_SOCKET), ASIO_OS_DEF(SO_LINGER)>
-      linger;
-#endif
-
-  /// Socket option to report aborted connections on accept.
-  /**
-   * Implements a custom socket option that determines whether or not an accept
-   * operation is permitted to fail with asio::error::connection_aborted.
-   * By default the option is false.
-   *
-   * @par Examples
-   * Setting the option:
-   * @code
-   * asio::ip::tcp::acceptor acceptor(io_service); 
-   * ...
-   * asio::socket_base::enable_connection_aborted option(true);
-   * acceptor.set_option(option);
-   * @endcode
-   *
-   * @par
-   * Getting the current option value:
-   * @code
-   * asio::ip::tcp::acceptor acceptor(io_service); 
-   * ...
-   * asio::socket_base::enable_connection_aborted option;
-   * acceptor.get_option(option);
-   * bool is_set = option.value();
-   * @endcode
-   *
-   * @par Concepts:
-   * Socket_Option, Boolean_Socket_Option.
-   */
-#if defined(GENERATING_DOCUMENTATION)
-  typedef implementation_defined enable_connection_aborted;
-#else
-  typedef asio::detail::socket_option::boolean<
-    asio::detail::custom_socket_option_level,
-    asio::detail::enable_connection_aborted_option>
-    enable_connection_aborted;
-#endif
-
-  /// (Deprecated: Use non_blocking().) IO control command to
-  /// set the blocking mode of the socket.
-  /**
-   * Implements the FIONBIO IO control command.
-   *
-   * @par Example
-   * @code
-   * asio::ip::tcp::socket socket(io_service); 
-   * ...
-   * asio::socket_base::non_blocking_io command(true);
-   * socket.io_control(command);
-   * @endcode
-   *
-   * @par Concepts:
-   * IO_Control_Command, Boolean_IO_Control_Command.
-   */
-#if defined(GENERATING_DOCUMENTATION)
-  typedef implementation_defined non_blocking_io;
-#else
-  typedef asio::detail::io_control::non_blocking_io non_blocking_io;
-#endif
-
-  /// IO control command to get the amount of data that can be read without
-  /// blocking.
-  /**
-   * Implements the FIONREAD IO control command.
-   *
-   * @par Example
-   * @code
-   * asio::ip::tcp::socket socket(io_service); 
-   * ...
-   * asio::socket_base::bytes_readable command(true);
-   * socket.io_control(command);
-   * std::size_t bytes_readable = command.get();
-   * @endcode
-   *
-   * @par Concepts:
-   * IO_Control_Command, Size_IO_Control_Command.
-   */
-#if defined(GENERATING_DOCUMENTATION)
-  typedef implementation_defined bytes_readable;
-#else
-  typedef asio::detail::io_control::bytes_readable bytes_readable;
-#endif
-
-  /// The maximum length of the queue of pending incoming connections.
-#if defined(GENERATING_DOCUMENTATION)
-  static const int max_connections = implementation_defined;
-#else
-  ASIO_STATIC_CONSTANT(int, max_connections
-      = ASIO_OS_DEF(SOMAXCONN));
-#endif
-
-protected:
-  /// Protected destructor to prevent deletion through this type.
-  ~socket_base()
-  {
-  }
-};
-
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_SOCKET_BASE_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/spawn.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/spawn.hpp
deleted file mode 100644
index 078ef886d006..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/spawn.hpp
+++ /dev/null
@@ -1,265 +0,0 @@
-//
-// spawn.hpp
-// ~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_SPAWN_HPP
-#define ASIO_SPAWN_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include <boost/coroutine/all.hpp>
-#include "asio/detail/weak_ptr.hpp"
-#include "asio/detail/wrapped_handler.hpp"
-#include "asio/io_service.hpp"
-#include "asio/strand.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-
-/// Context object the represents the currently executing coroutine.
-/**
- * The basic_yield_context class is used to represent the currently executing
- * stackful coroutine. A basic_yield_context may be passed as a handler to an
- * asynchronous operation. For example:
- *
- * @code template <typename Handler>
- * void my_coroutine(basic_yield_context<Handler> yield)
- * {
- *   ...
- *   std::size_t n = my_socket.async_read_some(buffer, yield);
- *   ...
- * } @endcode
- *
- * The initiating function (async_read_some in the above example) suspends the
- * current coroutine. The coroutine is resumed when the asynchronous operation
- * completes, and the result of the operation is returned.
- */
-template <typename Handler>
-class basic_yield_context
-{
-public:
-  /// The coroutine callee type, used by the implementation.
-  /**
-   * When using Boost.Coroutine v1, this type is:
-   * @code typename coroutine<void()> @endcode
-   * When using Boost.Coroutine v2 (unidirectional coroutines), this type is:
-   * @code push_coroutine<void> @endcode
-   */
-#if defined(GENERATING_DOCUMENTATION)
-  typedef implementation_defined callee_type;
-#elif defined(BOOST_COROUTINES_UNIDIRECT) || defined(BOOST_COROUTINES_V2)
-  typedef boost::coroutines::push_coroutine<void> callee_type;
-#else
-  typedef boost::coroutines::coroutine<void()> callee_type;
-#endif
-  
-  /// The coroutine caller type, used by the implementation.
-  /**
-   * When using Boost.Coroutine v1, this type is:
-   * @code typename coroutine<void()>::caller_type @endcode
-   * When using Boost.Coroutine v2 (unidirectional coroutines), this type is:
-   * @code pull_coroutine<void> @endcode
-   */
-#if defined(GENERATING_DOCUMENTATION)
-  typedef implementation_defined caller_type;
-#elif defined(BOOST_COROUTINES_UNIDIRECT) || defined(BOOST_COROUTINES_V2)
-  typedef boost::coroutines::pull_coroutine<void> caller_type;
-#else
-  typedef boost::coroutines::coroutine<void()>::caller_type caller_type;
-#endif
-
-  /// Construct a yield context to represent the specified coroutine.
-  /**
-   * Most applications do not need to use this constructor. Instead, the
-   * spawn() function passes a yield context as an argument to the coroutine
-   * function.
-   */
-  basic_yield_context(
-      const detail::weak_ptr<callee_type>& coro,
-      caller_type& ca, Handler& handler)
-    : coro_(coro),
-      ca_(ca),
-      handler_(handler),
-      ec_(0)
-  {
-  }
-
-  /// Return a yield context that sets the specified error_code.
-  /**
-   * By default, when a yield context is used with an asynchronous operation, a
-   * non-success error_code is converted to system_error and thrown. This
-   * operator may be used to specify an error_code object that should instead be
-   * set with the asynchronous operation's result. For example:
-   *
-   * @code template <typename Handler>
-   * void my_coroutine(basic_yield_context<Handler> yield)
-   * {
-   *   ...
-   *   std::size_t n = my_socket.async_read_some(buffer, yield[ec]);
-   *   if (ec)
-   *   {
-   *     // An error occurred.
-   *   }
-   *   ...
-   * } @endcode
-   */
-  basic_yield_context operator[](asio::error_code& ec) const
-  {
-    basic_yield_context tmp(*this);
-    tmp.ec_ = &ec;
-    return tmp;
-  }
-
-#if defined(GENERATING_DOCUMENTATION)
-private:
-#endif // defined(GENERATING_DOCUMENTATION)
-  detail::weak_ptr<callee_type> coro_;
-  caller_type& ca_;
-  Handler& handler_;
-  asio::error_code* ec_;
-};
-
-#if defined(GENERATING_DOCUMENTATION)
-/// Context object that represents the currently executing coroutine.
-typedef basic_yield_context<unspecified> yield_context;
-#else // defined(GENERATING_DOCUMENTATION)
-typedef basic_yield_context<
-  detail::wrapped_handler<
-    io_service::strand, void(*)(),
-    detail::is_continuation_if_running> > yield_context;
-#endif // defined(GENERATING_DOCUMENTATION)
-
-/**
- * @defgroup spawn asio::spawn
- *
- * @brief Start a new stackful coroutine.
- *
- * The spawn() function is a high-level wrapper over the Boost.Coroutine
- * library. This function enables programs to implement asynchronous logic in a
- * synchronous manner, as illustrated by the following example:
- *
- * @code asio::spawn(my_strand, do_echo);
- *
- * // ...
- *
- * void do_echo(asio::yield_context yield)
- * {
- *   try
- *   {
- *     char data[128];
- *     for (;;)
- *     {
- *       std::size_t length =
- *         my_socket.async_read_some(
- *           asio::buffer(data), yield);
- *
- *       asio::async_write(my_socket,
- *           asio::buffer(data, length), yield);
- *     }
- *   }
- *   catch (std::exception& e)
- *   {
- *     // ...
- *   }
- * } @endcode
- */
-/*@{*/
-
-/// Start a new stackful coroutine, calling the specified handler when it
-/// completes.
-/**
- * This function is used to launch a new coroutine.
- *
- * @param handler A handler to be called when the coroutine exits. More
- * importantly, the handler provides an execution context (via the the handler
- * invocation hook) for the coroutine. The handler must have the signature:
- * @code void handler(); @endcode
- *
- * @param function The coroutine function. The function must have the signature:
- * @code void function(basic_yield_context<Handler> yield); @endcode
- *
- * @param attributes Boost.Coroutine attributes used to customise the coroutine.
- */
-template <typename Handler, typename Function>
-void spawn(ASIO_MOVE_ARG(Handler) handler,
-    ASIO_MOVE_ARG(Function) function,
-    const boost::coroutines::attributes& attributes
-      = boost::coroutines::attributes());
-
-/// Start a new stackful coroutine, inheriting the execution context of another.
-/**
- * This function is used to launch a new coroutine.
- *
- * @param ctx Identifies the current coroutine as a parent of the new
- * coroutine. This specifies that the new coroutine should inherit the
- * execution context of the parent. For example, if the parent coroutine is
- * executing in a particular strand, then the new coroutine will execute in the
- * same strand.
- *
- * @param function The coroutine function. The function must have the signature:
- * @code void function(basic_yield_context<Handler> yield); @endcode
- *
- * @param attributes Boost.Coroutine attributes used to customise the coroutine.
- */
-template <typename Handler, typename Function>
-void spawn(basic_yield_context<Handler> ctx,
-    ASIO_MOVE_ARG(Function) function,
-    const boost::coroutines::attributes& attributes
-      = boost::coroutines::attributes());
-
-/// Start a new stackful coroutine that executes in the context of a strand.
-/**
- * This function is used to launch a new coroutine.
- *
- * @param strand Identifies a strand. By starting multiple coroutines on the
- * same strand, the implementation ensures that none of those coroutines can
- * execute simultaneously.
- *
- * @param function The coroutine function. The function must have the signature:
- * @code void function(yield_context yield); @endcode
- *
- * @param attributes Boost.Coroutine attributes used to customise the coroutine.
- */
-template <typename Function>
-void spawn(asio::io_service::strand strand,
-    ASIO_MOVE_ARG(Function) function,
-    const boost::coroutines::attributes& attributes
-      = boost::coroutines::attributes());
-
-/// Start a new stackful coroutine that executes on a given io_service.
-/**
- * This function is used to launch a new coroutine.
- *
- * @param io_service Identifies the io_service that will run the coroutine. The
- * new coroutine is implicitly given its own strand within this io_service.
- *
- * @param function The coroutine function. The function must have the signature:
- * @code void function(yield_context yield); @endcode
- *
- * @param attributes Boost.Coroutine attributes used to customise the coroutine.
- */
-template <typename Function>
-void spawn(asio::io_service& io_service,
-    ASIO_MOVE_ARG(Function) function,
-    const boost::coroutines::attributes& attributes
-      = boost::coroutines::attributes());
-
-/*@}*/
-
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#include "asio/impl/spawn.hpp"
-
-#endif // ASIO_SPAWN_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl.hpp
deleted file mode 100644
index 06102fcb013a..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl.hpp
+++ /dev/null
@@ -1,30 +0,0 @@
-//
-// ssl.hpp
-// ~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_SSL_HPP
-#define ASIO_SSL_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/ssl/basic_context.hpp"
-#include "asio/ssl/context.hpp"
-#include "asio/ssl/context_base.hpp"
-#include "asio/ssl/context_service.hpp"
-#include "asio/ssl/error.hpp"
-#include "asio/ssl/rfc2818_verification.hpp"
-#include "asio/ssl/stream.hpp"
-#include "asio/ssl/stream_base.hpp"
-#include "asio/ssl/stream_service.hpp"
-#include "asio/ssl/verify_context.hpp"
-#include "asio/ssl/verify_mode.hpp"
-
-#endif // ASIO_SSL_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/basic_context.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/basic_context.hpp
deleted file mode 100644
index 17d53806afce..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/basic_context.hpp
+++ /dev/null
@@ -1,40 +0,0 @@
-//
-// ssl/basic_context.hpp
-// ~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_SSL_BASIC_CONTEXT_HPP
-#define ASIO_SSL_BASIC_CONTEXT_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_ENABLE_OLD_SSL)
-# include "asio/ssl/old/basic_context.hpp"
-#endif // defined(ASIO_ENABLE_OLD_SSL)
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace ssl {
-
-#if defined(ASIO_ENABLE_OLD_SSL)
-
-using asio::ssl::old::basic_context;
-
-#endif // defined(ASIO_ENABLE_OLD_SSL)
-
-} // namespace ssl
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_SSL_BASIC_CONTEXT_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/context.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/context.hpp
deleted file mode 100644
index 87a01e74bf41..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/context.hpp
+++ /dev/null
@@ -1,787 +0,0 @@
-//
-// ssl/context.hpp
-// ~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_SSL_CONTEXT_HPP
-#define ASIO_SSL_CONTEXT_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_ENABLE_OLD_SSL)
-# include "asio/ssl/basic_context.hpp"
-# include "asio/ssl/context_service.hpp"
-#else // defined(ASIO_ENABLE_OLD_SSL)
-# include <string>
-# include "asio/buffer.hpp"
-# include "asio/io_service.hpp"
-# include "asio/ssl/context_base.hpp"
-# include "asio/ssl/detail/openssl_types.hpp"
-# include "asio/ssl/detail/openssl_init.hpp"
-# include "asio/ssl/detail/password_callback.hpp"
-# include "asio/ssl/detail/verify_callback.hpp"
-# include "asio/ssl/verify_mode.hpp"
-#endif // defined(ASIO_ENABLE_OLD_SSL)
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace ssl {
-
-#if defined(ASIO_ENABLE_OLD_SSL)
-
-/// Typedef for the typical usage of context.
-typedef basic_context<context_service> context;
-
-#else // defined(ASIO_ENABLE_OLD_SSL)
-
-class context
-  : public context_base,
-    private noncopyable
-{
-public:
-  /// The native handle type of the SSL context.
-  typedef SSL_CTX* native_handle_type;
-
-  /// (Deprecated: Use native_handle_type.) The native type of the SSL context.
-  typedef SSL_CTX* impl_type;
-
-  /// Constructor.
-  ASIO_DECL explicit context(method m);
-
-  /// Deprecated constructor taking a reference to an io_service object.
-  ASIO_DECL context(asio::io_service&, method m);
-
-#if defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
-  /// Move-construct a context from another.
-  /**
-   * This constructor moves an SSL context from one object to another.
-   *
-   * @param other The other context object from which the move will occur.
-   *
-   * @note Following the move, the following operations only are valid for the
-   * moved-from object:
-   * @li Destruction.
-   * @li As a target for move-assignment.
-   */
-  ASIO_DECL context(context&& other);
-
-  /// Move-assign a context from another.
-  /**
-   * This assignment operator moves an SSL context from one object to another.
-   *
-   * @param other The other context object from which the move will occur.
-   *
-   * @note Following the move, the following operations only are valid for the
-   * moved-from object:
-   * @li Destruction.
-   * @li As a target for move-assignment.
-   */
-  ASIO_DECL context& operator=(context&& other);
-#endif // defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
-
-  /// Destructor.
-  ASIO_DECL ~context();
-
-  /// Get the underlying implementation in the native type.
-  /**
-   * This function may be used to obtain the underlying implementation of the
-   * context. This is intended to allow access to context functionality that is
-   * not otherwise provided.
-   */
-  ASIO_DECL native_handle_type native_handle();
-
-  /// (Deprecated: Use native_handle().) Get the underlying implementation in
-  /// the native type.
-  /**
-   * This function may be used to obtain the underlying implementation of the
-   * context. This is intended to allow access to context functionality that is
-   * not otherwise provided.
-   */
-  ASIO_DECL impl_type impl();
-
-  /// Clear options on the context.
-  /**
-   * This function may be used to configure the SSL options used by the context.
-   *
-   * @param o A bitmask of options. The available option values are defined in
-   * the context_base class. The specified options, if currently enabled on the
-   * context, are cleared.
-   *
-   * @throws asio::system_error Thrown on failure.
-   *
-   * @note Calls @c SSL_CTX_clear_options.
-   */
-  ASIO_DECL void clear_options(options o);
-
-  /// Clear options on the context.
-  /**
-   * This function may be used to configure the SSL options used by the context.
-   *
-   * @param o A bitmask of options. The available option values are defined in
-   * the context_base class. The specified options, if currently enabled on the
-   * context, are cleared.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   *
-   * @note Calls @c SSL_CTX_clear_options.
-   */
-  ASIO_DECL asio::error_code clear_options(options o,
-      asio::error_code& ec);
-
-  /// Set options on the context.
-  /**
-   * This function may be used to configure the SSL options used by the context.
-   *
-   * @param o A bitmask of options. The available option values are defined in
-   * the context_base class. The options are bitwise-ored with any existing
-   * value for the options.
-   *
-   * @throws asio::system_error Thrown on failure.
-   *
-   * @note Calls @c SSL_CTX_set_options.
-   */
-  ASIO_DECL void set_options(options o);
-
-  /// Set options on the context.
-  /**
-   * This function may be used to configure the SSL options used by the context.
-   *
-   * @param o A bitmask of options. The available option values are defined in
-   * the context_base class. The options are bitwise-ored with any existing
-   * value for the options.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   *
-   * @note Calls @c SSL_CTX_set_options.
-   */
-  ASIO_DECL asio::error_code set_options(options o,
-      asio::error_code& ec);
-
-  /// Set the peer verification mode.
-  /**
-   * This function may be used to configure the peer verification mode used by
-   * the context.
-   *
-   * @param v A bitmask of peer verification modes. See @ref verify_mode for
-   * available values.
-   *
-   * @throws asio::system_error Thrown on failure.
-   *
-   * @note Calls @c SSL_CTX_set_verify.
-   */
-  ASIO_DECL void set_verify_mode(verify_mode v);
-
-  /// Set the peer verification mode.
-  /**
-   * This function may be used to configure the peer verification mode used by
-   * the context.
-   *
-   * @param v A bitmask of peer verification modes. See @ref verify_mode for
-   * available values.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   *
-   * @note Calls @c SSL_CTX_set_verify.
-   */
-  ASIO_DECL asio::error_code set_verify_mode(
-      verify_mode v, asio::error_code& ec);
-
-  /// Set the peer verification depth.
-  /**
-   * This function may be used to configure the maximum verification depth
-   * allowed by the context.
-   *
-   * @param depth Maximum depth for the certificate chain verification that
-   * shall be allowed.
-   *
-   * @throws asio::system_error Thrown on failure.
-   *
-   * @note Calls @c SSL_CTX_set_verify_depth.
-   */
-  ASIO_DECL void set_verify_depth(int depth);
-
-  /// Set the peer verification depth.
-  /**
-   * This function may be used to configure the maximum verification depth
-   * allowed by the context.
-   *
-   * @param depth Maximum depth for the certificate chain verification that
-   * shall be allowed.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   *
-   * @note Calls @c SSL_CTX_set_verify_depth.
-   */
-  ASIO_DECL asio::error_code set_verify_depth(
-      int depth, asio::error_code& ec);
-
-  /// Set the callback used to verify peer certificates.
-  /**
-   * This function is used to specify a callback function that will be called
-   * by the implementation when it needs to verify a peer certificate.
-   *
-   * @param callback The function object to be used for verifying a certificate.
-   * The function signature of the handler must be:
-   * @code bool verify_callback(
-   *   bool preverified, // True if the certificate passed pre-verification.
-   *   verify_context& ctx // The peer certificate and other context.
-   * ); @endcode
-   * The return value of the callback is true if the certificate has passed
-   * verification, false otherwise.
-   *
-   * @throws asio::system_error Thrown on failure.
-   *
-   * @note Calls @c SSL_CTX_set_verify.
-   */
-  template <typename VerifyCallback>
-  void set_verify_callback(VerifyCallback callback);
-
-  /// Set the callback used to verify peer certificates.
-  /**
-   * This function is used to specify a callback function that will be called
-   * by the implementation when it needs to verify a peer certificate.
-   *
-   * @param callback The function object to be used for verifying a certificate.
-   * The function signature of the handler must be:
-   * @code bool verify_callback(
-   *   bool preverified, // True if the certificate passed pre-verification.
-   *   verify_context& ctx // The peer certificate and other context.
-   * ); @endcode
-   * The return value of the callback is true if the certificate has passed
-   * verification, false otherwise.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   *
-   * @note Calls @c SSL_CTX_set_verify.
-   */
-  template <typename VerifyCallback>
-  asio::error_code set_verify_callback(VerifyCallback callback,
-      asio::error_code& ec);
-
-  /// Load a certification authority file for performing verification.
-  /**
-   * This function is used to load one or more trusted certification authorities
-   * from a file.
-   *
-   * @param filename The name of a file containing certification authority
-   * certificates in PEM format.
-   *
-   * @throws asio::system_error Thrown on failure.
-   *
-   * @note Calls @c SSL_CTX_load_verify_locations.
-   */
-  ASIO_DECL void load_verify_file(const std::string& filename);
-
-  /// Load a certification authority file for performing verification.
-  /**
-   * This function is used to load the certificates for one or more trusted
-   * certification authorities from a file.
-   *
-   * @param filename The name of a file containing certification authority
-   * certificates in PEM format.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   *
-   * @note Calls @c SSL_CTX_load_verify_locations.
-   */
-  ASIO_DECL asio::error_code load_verify_file(
-      const std::string& filename, asio::error_code& ec);
-
-  /// Add certification authority for performing verification.
-  /**
-   * This function is used to add one trusted certification authority
-   * from a memory buffer.
-   *
-   * @param ca The buffer containing the certification authority certificate.
-   * The certificate must use the PEM format.
-   *
-   * @throws asio::system_error Thrown on failure.
-   *
-   * @note Calls @c SSL_CTX_get_cert_store and @c X509_STORE_add_cert.
-   */
-  ASIO_DECL void add_certificate_authority(const const_buffer& ca);
-
-  /// Add certification authority for performing verification.
-  /**
-   * This function is used to add one trusted certification authority
-   * from a memory buffer.
-   *
-   * @param ca The buffer containing the certification authority certificate.
-   * The certificate must use the PEM format.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   *
-   * @note Calls @c SSL_CTX_get_cert_store and @c X509_STORE_add_cert.
-   */
-  ASIO_DECL asio::error_code add_certificate_authority(
-      const const_buffer& ca, asio::error_code& ec);
-
-  /// Configures the context to use the default directories for finding
-  /// certification authority certificates.
-  /**
-   * This function specifies that the context should use the default,
-   * system-dependent directories for locating certification authority
-   * certificates.
-   *
-   * @throws asio::system_error Thrown on failure.
-   *
-   * @note Calls @c SSL_CTX_set_default_verify_paths.
-   */
-  ASIO_DECL void set_default_verify_paths();
-
-  /// Configures the context to use the default directories for finding
-  /// certification authority certificates.
-  /**
-   * This function specifies that the context should use the default,
-   * system-dependent directories for locating certification authority
-   * certificates.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   *
-   * @note Calls @c SSL_CTX_set_default_verify_paths.
-   */
-  ASIO_DECL asio::error_code set_default_verify_paths(
-      asio::error_code& ec);
-
-  /// Add a directory containing certificate authority files to be used for
-  /// performing verification.
-  /**
-   * This function is used to specify the name of a directory containing
-   * certification authority certificates. Each file in the directory must
-   * contain a single certificate. The files must be named using the subject
-   * name's hash and an extension of ".0".
-   *
-   * @param path The name of a directory containing the certificates.
-   *
-   * @throws asio::system_error Thrown on failure.
-   *
-   * @note Calls @c SSL_CTX_load_verify_locations.
-   */
-  ASIO_DECL void add_verify_path(const std::string& path);
-
-  /// Add a directory containing certificate authority files to be used for
-  /// performing verification.
-  /**
-   * This function is used to specify the name of a directory containing
-   * certification authority certificates. Each file in the directory must
-   * contain a single certificate. The files must be named using the subject
-   * name's hash and an extension of ".0".
-   *
-   * @param path The name of a directory containing the certificates.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   *
-   * @note Calls @c SSL_CTX_load_verify_locations.
-   */
-  ASIO_DECL asio::error_code add_verify_path(
-      const std::string& path, asio::error_code& ec);
-
-  /// Use a certificate from a memory buffer.
-  /**
-   * This function is used to load a certificate into the context from a buffer.
-   *
-   * @param certificate The buffer containing the certificate.
-   *
-   * @param format The certificate format (ASN.1 or PEM).
-   *
-   * @throws asio::system_error Thrown on failure.
-   *
-   * @note Calls @c SSL_CTX_use_certificate or SSL_CTX_use_certificate_ASN1.
-   */
-  ASIO_DECL void use_certificate(
-      const const_buffer& certificate, file_format format);
-
-  /// Use a certificate from a memory buffer.
-  /**
-   * This function is used to load a certificate into the context from a buffer.
-   *
-   * @param certificate The buffer containing the certificate.
-   *
-   * @param format The certificate format (ASN.1 or PEM).
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   *
-   * @note Calls @c SSL_CTX_use_certificate or SSL_CTX_use_certificate_ASN1.
-   */
-  ASIO_DECL asio::error_code use_certificate(
-      const const_buffer& certificate, file_format format,
-      asio::error_code& ec);
-
-  /// Use a certificate from a file.
-  /**
-   * This function is used to load a certificate into the context from a file.
-   *
-   * @param filename The name of the file containing the certificate.
-   *
-   * @param format The file format (ASN.1 or PEM).
-   *
-   * @throws asio::system_error Thrown on failure.
-   *
-   * @note Calls @c SSL_CTX_use_certificate_file.
-   */
-  ASIO_DECL void use_certificate_file(
-      const std::string& filename, file_format format);
-
-  /// Use a certificate from a file.
-  /**
-   * This function is used to load a certificate into the context from a file.
-   *
-   * @param filename The name of the file containing the certificate.
-   *
-   * @param format The file format (ASN.1 or PEM).
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   *
-   * @note Calls @c SSL_CTX_use_certificate_file.
-   */
-  ASIO_DECL asio::error_code use_certificate_file(
-      const std::string& filename, file_format format,
-      asio::error_code& ec);
-
-  /// Use a certificate chain from a memory buffer.
-  /**
-   * This function is used to load a certificate chain into the context from a
-   * buffer.
-   *
-   * @param chain The buffer containing the certificate chain. The certificate
-   * chain must use the PEM format.
-   *
-   * @throws asio::system_error Thrown on failure.
-   *
-   * @note Calls @c SSL_CTX_use_certificate and SSL_CTX_add_extra_chain_cert.
-   */
-  ASIO_DECL void use_certificate_chain(const const_buffer& chain);
-
-  /// Use a certificate chain from a memory buffer.
-  /**
-   * This function is used to load a certificate chain into the context from a
-   * buffer.
-   *
-   * @param chain The buffer containing the certificate chain. The certificate
-   * chain must use the PEM format.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   *
-   * @note Calls @c SSL_CTX_use_certificate and SSL_CTX_add_extra_chain_cert.
-   */
-  ASIO_DECL asio::error_code use_certificate_chain(
-      const const_buffer& chain, asio::error_code& ec);
-
-  /// Use a certificate chain from a file.
-  /**
-   * This function is used to load a certificate chain into the context from a
-   * file.
-   *
-   * @param filename The name of the file containing the certificate. The file
-   * must use the PEM format.
-   *
-   * @throws asio::system_error Thrown on failure.
-   *
-   * @note Calls @c SSL_CTX_use_certificate_chain_file.
-   */
-  ASIO_DECL void use_certificate_chain_file(const std::string& filename);
-
-  /// Use a certificate chain from a file.
-  /**
-   * This function is used to load a certificate chain into the context from a
-   * file.
-   *
-   * @param filename The name of the file containing the certificate. The file
-   * must use the PEM format.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   *
-   * @note Calls @c SSL_CTX_use_certificate_chain_file.
-   */
-  ASIO_DECL asio::error_code use_certificate_chain_file(
-      const std::string& filename, asio::error_code& ec);
-
-  /// Use a private key from a memory buffer.
-  /**
-   * This function is used to load a private key into the context from a buffer.
-   *
-   * @param private_key The buffer containing the private key.
-   *
-   * @param format The private key format (ASN.1 or PEM).
-   *
-   * @throws asio::system_error Thrown on failure.
-   *
-   * @note Calls @c SSL_CTX_use_PrivateKey or SSL_CTX_use_PrivateKey_ASN1.
-   */
-  ASIO_DECL void use_private_key(
-      const const_buffer& private_key, file_format format);
-
-  /// Use a private key from a memory buffer.
-  /**
-   * This function is used to load a private key into the context from a buffer.
-   *
-   * @param private_key The buffer containing the private key.
-   *
-   * @param format The private key format (ASN.1 or PEM).
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   *
-   * @note Calls @c SSL_CTX_use_PrivateKey or SSL_CTX_use_PrivateKey_ASN1.
-   */
-  ASIO_DECL asio::error_code use_private_key(
-      const const_buffer& private_key, file_format format,
-      asio::error_code& ec);
-
-  /// Use a private key from a file.
-  /**
-   * This function is used to load a private key into the context from a file.
-   *
-   * @param filename The name of the file containing the private key.
-   *
-   * @param format The file format (ASN.1 or PEM).
-   *
-   * @throws asio::system_error Thrown on failure.
-   *
-   * @note Calls @c SSL_CTX_use_PrivateKey_file.
-   */
-  ASIO_DECL void use_private_key_file(
-      const std::string& filename, file_format format);
-
-  /// Use a private key from a file.
-  /**
-   * This function is used to load a private key into the context from a file.
-   *
-   * @param filename The name of the file containing the private key.
-   *
-   * @param format The file format (ASN.1 or PEM).
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   *
-   * @note Calls @c SSL_CTX_use_PrivateKey_file.
-   */
-  ASIO_DECL asio::error_code use_private_key_file(
-      const std::string& filename, file_format format,
-      asio::error_code& ec);
-
-  /// Use an RSA private key from a memory buffer.
-  /**
-   * This function is used to load an RSA private key into the context from a
-   * buffer.
-   *
-   * @param private_key The buffer containing the RSA private key.
-   *
-   * @param format The private key format (ASN.1 or PEM).
-   *
-   * @throws asio::system_error Thrown on failure.
-   *
-   * @note Calls @c SSL_CTX_use_RSAPrivateKey or SSL_CTX_use_RSAPrivateKey_ASN1.
-   */
-  ASIO_DECL void use_rsa_private_key(
-      const const_buffer& private_key, file_format format);
-
-  /// Use an RSA private key from a memory buffer.
-  /**
-   * This function is used to load an RSA private key into the context from a
-   * buffer.
-   *
-   * @param private_key The buffer containing the RSA private key.
-   *
-   * @param format The private key format (ASN.1 or PEM).
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   *
-   * @note Calls @c SSL_CTX_use_RSAPrivateKey or SSL_CTX_use_RSAPrivateKey_ASN1.
-   */
-  ASIO_DECL asio::error_code use_rsa_private_key(
-      const const_buffer& private_key, file_format format,
-      asio::error_code& ec);
-
-  /// Use an RSA private key from a file.
-  /**
-   * This function is used to load an RSA private key into the context from a
-   * file.
-   *
-   * @param filename The name of the file containing the RSA private key.
-   *
-   * @param format The file format (ASN.1 or PEM).
-   *
-   * @throws asio::system_error Thrown on failure.
-   *
-   * @note Calls @c SSL_CTX_use_RSAPrivateKey_file.
-   */
-  ASIO_DECL void use_rsa_private_key_file(
-      const std::string& filename, file_format format);
-
-  /// Use an RSA private key from a file.
-  /**
-   * This function is used to load an RSA private key into the context from a
-   * file.
-   *
-   * @param filename The name of the file containing the RSA private key.
-   *
-   * @param format The file format (ASN.1 or PEM).
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   *
-   * @note Calls @c SSL_CTX_use_RSAPrivateKey_file.
-   */
-  ASIO_DECL asio::error_code use_rsa_private_key_file(
-      const std::string& filename, file_format format,
-      asio::error_code& ec);
-
-  /// Use the specified memory buffer to obtain the temporary Diffie-Hellman
-  /// parameters.
-  /**
-   * This function is used to load Diffie-Hellman parameters into the context
-   * from a buffer.
-   *
-   * @param dh The memory buffer containing the Diffie-Hellman parameters. The
-   * buffer must use the PEM format.
-   *
-   * @throws asio::system_error Thrown on failure.
-   *
-   * @note Calls @c SSL_CTX_set_tmp_dh.
-   */
-  ASIO_DECL void use_tmp_dh(const const_buffer& dh);
-
-  /// Use the specified memory buffer to obtain the temporary Diffie-Hellman
-  /// parameters.
-  /**
-   * This function is used to load Diffie-Hellman parameters into the context
-   * from a buffer.
-   *
-   * @param dh The memory buffer containing the Diffie-Hellman parameters. The
-   * buffer must use the PEM format.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   *
-   * @note Calls @c SSL_CTX_set_tmp_dh.
-   */
-  ASIO_DECL asio::error_code use_tmp_dh(
-      const const_buffer& dh, asio::error_code& ec);
-
-  /// Use the specified file to obtain the temporary Diffie-Hellman parameters.
-  /**
-   * This function is used to load Diffie-Hellman parameters into the context
-   * from a file.
-   *
-   * @param filename The name of the file containing the Diffie-Hellman
-   * parameters. The file must use the PEM format.
-   *
-   * @throws asio::system_error Thrown on failure.
-   *
-   * @note Calls @c SSL_CTX_set_tmp_dh.
-   */
-  ASIO_DECL void use_tmp_dh_file(const std::string& filename);
-
-  /// Use the specified file to obtain the temporary Diffie-Hellman parameters.
-  /**
-   * This function is used to load Diffie-Hellman parameters into the context
-   * from a file.
-   *
-   * @param filename The name of the file containing the Diffie-Hellman
-   * parameters. The file must use the PEM format.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   *
-   * @note Calls @c SSL_CTX_set_tmp_dh.
-   */
-  ASIO_DECL asio::error_code use_tmp_dh_file(
-      const std::string& filename, asio::error_code& ec);
-
-  /// Set the password callback.
-  /**
-   * This function is used to specify a callback function to obtain password
-   * information about an encrypted key in PEM format.
-   *
-   * @param callback The function object to be used for obtaining the password.
-   * The function signature of the handler must be:
-   * @code std::string password_callback(
-   *   std::size_t max_length,  // The maximum size for a password.
-   *   password_purpose purpose // Whether password is for reading or writing.
-   * ); @endcode
-   * The return value of the callback is a string containing the password.
-   *
-   * @throws asio::system_error Thrown on failure.
-   *
-   * @note Calls @c SSL_CTX_set_default_passwd_cb.
-   */
-  template <typename PasswordCallback>
-  void set_password_callback(PasswordCallback callback);
-
-  /// Set the password callback.
-  /**
-   * This function is used to specify a callback function to obtain password
-   * information about an encrypted key in PEM format.
-   *
-   * @param callback The function object to be used for obtaining the password.
-   * The function signature of the handler must be:
-   * @code std::string password_callback(
-   *   std::size_t max_length,  // The maximum size for a password.
-   *   password_purpose purpose // Whether password is for reading or writing.
-   * ); @endcode
-   * The return value of the callback is a string containing the password.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   *
-   * @note Calls @c SSL_CTX_set_default_passwd_cb.
-   */
-  template <typename PasswordCallback>
-  asio::error_code set_password_callback(PasswordCallback callback,
-      asio::error_code& ec);
-
-private:
-  struct bio_cleanup;
-  struct x509_cleanup;
-  struct evp_pkey_cleanup;
-  struct rsa_cleanup;
-  struct dh_cleanup;
-
-  // Helper function used to set a peer certificate verification callback.
-  ASIO_DECL asio::error_code do_set_verify_callback(
-      detail::verify_callback_base* callback, asio::error_code& ec);
-
-  // Callback used when the SSL implementation wants to verify a certificate.
-  ASIO_DECL static int verify_callback_function(
-      int preverified, X509_STORE_CTX* ctx);
-
-  // Helper function used to set a password callback.
-  ASIO_DECL asio::error_code do_set_password_callback(
-      detail::password_callback_base* callback, asio::error_code& ec);
-
-  // Callback used when the SSL implementation wants a password.
-  ASIO_DECL static int password_callback_function(
-      char* buf, int size, int purpose, void* data);
-
-  // Helper function to set the temporary Diffie-Hellman parameters from a BIO.
-  ASIO_DECL asio::error_code do_use_tmp_dh(
-      BIO* bio, asio::error_code& ec);
-
-  // Helper function to make a BIO from a memory buffer.
-  ASIO_DECL BIO* make_buffer_bio(const const_buffer& b);
-
-  // The underlying native implementation.
-  native_handle_type handle_;
-
-  // Ensure openssl is initialised.
-  asio::ssl::detail::openssl_init<> init_;
-};
-
-#endif // defined(ASIO_ENABLE_OLD_SSL)
-
-} // namespace ssl
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#include "asio/ssl/impl/context.hpp"
-#if defined(ASIO_HEADER_ONLY)
-# include "asio/ssl/impl/context.ipp"
-#endif // defined(ASIO_HEADER_ONLY)
-
-#endif // ASIO_SSL_CONTEXT_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/context_base.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/context_base.hpp
deleted file mode 100644
index 3fc400ed3d72..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/context_base.hpp
+++ /dev/null
@@ -1,167 +0,0 @@
-//
-// ssl/context_base.hpp
-// ~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_SSL_CONTEXT_BASE_HPP
-#define ASIO_SSL_CONTEXT_BASE_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include "asio/ssl/detail/openssl_types.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace ssl {
-
-/// The context_base class is used as a base for the basic_context class
-/// template so that we have a common place to define various enums.
-class context_base
-{
-public:
-  /// Different methods supported by a context.
-  enum method
-  {
-    /// Generic SSL version 2.
-    sslv2,
-
-    /// SSL version 2 client.
-    sslv2_client,
-
-    /// SSL version 2 server.
-    sslv2_server,
-
-    /// Generic SSL version 3.
-    sslv3,
-
-    /// SSL version 3 client.
-    sslv3_client,
-
-    /// SSL version 3 server.
-    sslv3_server,
-
-    /// Generic TLS version 1.
-    tlsv1,
-
-    /// TLS version 1 client.
-    tlsv1_client,
-
-    /// TLS version 1 server.
-    tlsv1_server,
-
-    /// Generic SSL/TLS.
-    sslv23,
-
-    /// SSL/TLS client.
-    sslv23_client,
-
-    /// SSL/TLS server.
-    sslv23_server,
-
-    /// Generic TLS version 1.1.
-    tlsv11,
-
-    /// TLS version 1.1 client.
-    tlsv11_client,
-
-    /// TLS version 1.1 server.
-    tlsv11_server,
-
-    /// Generic TLS version 1.2.
-    tlsv12,
-
-    /// TLS version 1.2 client.
-    tlsv12_client,
-
-    /// TLS version 1.2 server.
-    tlsv12_server
-  };
-
-  /// Bitmask type for SSL options.
-  typedef long options;
-
-#if defined(GENERATING_DOCUMENTATION)
-  /// Implement various bug workarounds.
-  static const long default_workarounds = implementation_defined;
-
-  /// Always create a new key when using tmp_dh parameters.
-  static const long single_dh_use = implementation_defined;
-
-  /// Disable SSL v2.
-  static const long no_sslv2 = implementation_defined;
-
-  /// Disable SSL v3.
-  static const long no_sslv3 = implementation_defined;
-
-  /// Disable TLS v1.
-  static const long no_tlsv1 = implementation_defined;
-
-  /// Disable compression. Compression is disabled by default.
-  static const long no_compression = implementation_defined;
-#else
-  ASIO_STATIC_CONSTANT(long, default_workarounds = SSL_OP_ALL);
-  ASIO_STATIC_CONSTANT(long, single_dh_use = SSL_OP_SINGLE_DH_USE);
-  ASIO_STATIC_CONSTANT(long, no_sslv2 = SSL_OP_NO_SSLv2);
-  ASIO_STATIC_CONSTANT(long, no_sslv3 = SSL_OP_NO_SSLv3);
-  ASIO_STATIC_CONSTANT(long, no_tlsv1 = SSL_OP_NO_TLSv1);
-# if defined(SSL_OP_NO_COMPRESSION)
-  ASIO_STATIC_CONSTANT(long, no_compression = SSL_OP_NO_COMPRESSION);
-# else // defined(SSL_OP_NO_COMPRESSION)
-  ASIO_STATIC_CONSTANT(long, no_compression = 0x20000L);
-# endif // defined(SSL_OP_NO_COMPRESSION)
-#endif
-
-  /// File format types.
-  enum file_format
-  {
-    /// ASN.1 file.
-    asn1,
-
-    /// PEM file.
-    pem
-  };
-
-#if !defined(GENERATING_DOCUMENTATION)
-  // The following types and constants are preserved for backward compatibility.
-  // New programs should use the equivalents of the same names that are defined
-  // in the asio::ssl namespace.
-  typedef int verify_mode;
-  ASIO_STATIC_CONSTANT(int, verify_none = SSL_VERIFY_NONE);
-  ASIO_STATIC_CONSTANT(int, verify_peer = SSL_VERIFY_PEER);
-  ASIO_STATIC_CONSTANT(int,
-      verify_fail_if_no_peer_cert = SSL_VERIFY_FAIL_IF_NO_PEER_CERT);
-  ASIO_STATIC_CONSTANT(int, verify_client_once = SSL_VERIFY_CLIENT_ONCE);
-#endif
-
-  /// Purpose of PEM password.
-  enum password_purpose
-  {
-    /// The password is needed for reading/decryption.
-    for_reading,
-
-    /// The password is needed for writing/encryption.
-    for_writing
-  };
-
-protected:
-  /// Protected destructor to prevent deletion through this type.
-  ~context_base()
-  {
-  }
-};
-
-} // namespace ssl
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_SSL_CONTEXT_BASE_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/context_service.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/context_service.hpp
deleted file mode 100644
index af293a1ef9d6..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/context_service.hpp
+++ /dev/null
@@ -1,40 +0,0 @@
-//
-// ssl/context_service.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_SSL_CONTEXT_SERVICE_HPP
-#define ASIO_SSL_CONTEXT_SERVICE_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-  
-#if defined(ASIO_ENABLE_OLD_SSL)
-# include "asio/ssl/old/context_service.hpp"
-#endif // defined(ASIO_ENABLE_OLD_SSL)
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace ssl {
-
-#if defined(ASIO_ENABLE_OLD_SSL)
-
-using asio::ssl::old::context_service;
-
-#endif // defined(ASIO_ENABLE_OLD_SSL)
-
-} // namespace ssl
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_SSL_CONTEXT_SERVICE_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/detail/buffered_handshake_op.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/detail/buffered_handshake_op.hpp
deleted file mode 100644
index aed99dd0de64..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/detail/buffered_handshake_op.hpp
+++ /dev/null
@@ -1,110 +0,0 @@
-//
-// ssl/detail/buffered_handshake_op.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_SSL_DETAIL_BUFFERED_HANDSHAKE_OP_HPP
-#define ASIO_SSL_DETAIL_BUFFERED_HANDSHAKE_OP_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if !defined(ASIO_ENABLE_OLD_SSL)
-# include "asio/ssl/detail/engine.hpp"
-#endif // !defined(ASIO_ENABLE_OLD_SSL)
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace ssl {
-namespace detail {
-
-#if !defined(ASIO_ENABLE_OLD_SSL)
-
-template <typename ConstBufferSequence>
-class buffered_handshake_op
-{
-public:
-  buffered_handshake_op(stream_base::handshake_type type,
-      const ConstBufferSequence& buffers)
-    : type_(type),
-      buffers_(buffers),
-      total_buffer_size_(asio::buffer_size(buffers_))
-  {
-  }
-
-  engine::want operator()(engine& eng,
-      asio::error_code& ec,
-      std::size_t& bytes_transferred) const
-  {
-    typename ConstBufferSequence::const_iterator iter = buffers_.begin();
-    typename ConstBufferSequence::const_iterator end = buffers_.end();
-    std::size_t accumulated_size = 0;
-
-    for (;;)
-    {
-      engine::want want = eng.handshake(type_, ec);
-      if (want != engine::want_input_and_retry
-          || bytes_transferred == total_buffer_size_)
-        return want;
-
-      // Find the next buffer piece to be fed to the engine.
-      while (iter != end)
-      {
-        const_buffer buffer(*iter);
-
-        // Skip over any buffers which have already been consumed by the engine.
-        if (bytes_transferred >= accumulated_size + buffer_size(buffer))
-        {
-          accumulated_size += buffer_size(buffer);
-          ++iter;
-          continue;
-        }
-
-        // The current buffer may have been partially consumed by the engine on
-        // a previous iteration. If so, adjust the buffer to point to the
-        // unused portion.
-        if (bytes_transferred > accumulated_size)
-          buffer = buffer + (bytes_transferred - accumulated_size);
-
-        // Pass the buffer to the engine, and update the bytes transferred to
-        // reflect the total number of bytes consumed so far.
-        bytes_transferred += buffer_size(buffer);
-        buffer = eng.put_input(buffer);
-        bytes_transferred -= buffer_size(buffer);
-        break;
-      }
-    }
-  }
-
-  template <typename Handler>
-  void call_handler(Handler& handler,
-      const asio::error_code& ec,
-      const std::size_t& bytes_transferred) const
-  {
-    handler(ec, bytes_transferred);
-  }
-
-private:
-  stream_base::handshake_type type_;
-  ConstBufferSequence buffers_;
-  std::size_t total_buffer_size_;
-};
-
-#endif // !defined(ASIO_ENABLE_OLD_SSL)
-
-} // namespace detail
-} // namespace ssl
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_SSL_DETAIL_BUFFERED_HANDSHAKE_OP_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/detail/engine.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/detail/engine.hpp
deleted file mode 100644
index 9bb42b6e05d0..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/detail/engine.hpp
+++ /dev/null
@@ -1,164 +0,0 @@
-//
-// ssl/detail/engine.hpp
-// ~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_SSL_DETAIL_ENGINE_HPP
-#define ASIO_SSL_DETAIL_ENGINE_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if !defined(ASIO_ENABLE_OLD_SSL)
-# include "asio/buffer.hpp"
-# include "asio/detail/static_mutex.hpp"
-# include "asio/ssl/detail/openssl_types.hpp"
-# include "asio/ssl/detail/verify_callback.hpp"
-# include "asio/ssl/stream_base.hpp"
-# include "asio/ssl/verify_mode.hpp"
-#endif // !defined(ASIO_ENABLE_OLD_SSL)
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace ssl {
-namespace detail {
-
-#if !defined(ASIO_ENABLE_OLD_SSL)
-
-class engine
-{
-public:
-  enum want
-  {
-    // Returned by functions to indicate that the engine wants input. The input
-    // buffer should be updated to point to the data. The engine then needs to
-    // be called again to retry the operation.
-    want_input_and_retry = -2,
-
-    // Returned by functions to indicate that the engine wants to write output.
-    // The output buffer points to the data to be written. The engine then
-    // needs to be called again to retry the operation.
-    want_output_and_retry = -1,
-
-    // Returned by functions to indicate that the engine doesn't need input or
-    // output.
-    want_nothing = 0,
-
-    // Returned by functions to indicate that the engine wants to write output.
-    // The output buffer points to the data to be written. After that the
-    // operation is complete, and the engine does not need to be called again.
-    want_output = 1
-  };
-
-  // Construct a new engine for the specified context.
-  ASIO_DECL explicit engine(SSL_CTX* context);
-
-  // Destructor.
-  ASIO_DECL ~engine();
-
-  // Get the underlying implementation in the native type.
-  ASIO_DECL SSL* native_handle();
-
-  // Set the peer verification mode.
-  ASIO_DECL asio::error_code set_verify_mode(
-      verify_mode v, asio::error_code& ec);
-
-  // Set the peer verification depth.
-  ASIO_DECL asio::error_code set_verify_depth(
-      int depth, asio::error_code& ec);
-
-  // Set a peer certificate verification callback.
-  ASIO_DECL asio::error_code set_verify_callback(
-      verify_callback_base* callback, asio::error_code& ec);
-
-  // Perform an SSL handshake using either SSL_connect (client-side) or
-  // SSL_accept (server-side).
-  ASIO_DECL want handshake(
-      stream_base::handshake_type type, asio::error_code& ec);
-
-  // Perform a graceful shutdown of the SSL session.
-  ASIO_DECL want shutdown(asio::error_code& ec);
-
-  // Write bytes to the SSL session.
-  ASIO_DECL want write(const asio::const_buffer& data,
-      asio::error_code& ec, std::size_t& bytes_transferred);
-
-  // Read bytes from the SSL session.
-  ASIO_DECL want read(const asio::mutable_buffer& data,
-      asio::error_code& ec, std::size_t& bytes_transferred);
-
-  // Get output data to be written to the transport.
-  ASIO_DECL asio::mutable_buffers_1 get_output(
-      const asio::mutable_buffer& data);
-
-  // Put input data that was read from the transport.
-  ASIO_DECL asio::const_buffer put_input(
-      const asio::const_buffer& data);
-
-  // Map an error::eof code returned by the underlying transport according to
-  // the type and state of the SSL session. Returns a const reference to the
-  // error code object, suitable for passing to a completion handler.
-  ASIO_DECL const asio::error_code& map_error_code(
-      asio::error_code& ec) const;
-
-private:
-  // Disallow copying and assignment.
-  engine(const engine&);
-  engine& operator=(const engine&);
-
-  // Callback used when the SSL implementation wants to verify a certificate.
-  ASIO_DECL static int verify_callback_function(
-      int preverified, X509_STORE_CTX* ctx);
-
-  // The SSL_accept function may not be thread safe. This mutex is used to
-  // protect all calls to the SSL_accept function.
-  ASIO_DECL static asio::detail::static_mutex& accept_mutex();
-
-  // Perform one operation. Returns >= 0 on success or error, want_read if the
-  // operation needs more input, or want_write if it needs to write some output
-  // before the operation can complete.
-  ASIO_DECL want perform(int (engine::* op)(void*, std::size_t),
-      void* data, std::size_t length, asio::error_code& ec,
-      std::size_t* bytes_transferred);
-
-  // Adapt the SSL_accept function to the signature needed for perform().
-  ASIO_DECL int do_accept(void*, std::size_t);
-
-  // Adapt the SSL_connect function to the signature needed for perform().
-  ASIO_DECL int do_connect(void*, std::size_t);
-
-  // Adapt the SSL_shutdown function to the signature needed for perform().
-  ASIO_DECL int do_shutdown(void*, std::size_t);
-
-  // Adapt the SSL_read function to the signature needed for perform().
-  ASIO_DECL int do_read(void* data, std::size_t length);
-
-  // Adapt the SSL_write function to the signature needed for perform().
-  ASIO_DECL int do_write(void* data, std::size_t length);
-
-  SSL* ssl_;
-  BIO* ext_bio_;
-};
-
-#endif // !defined(ASIO_ENABLE_OLD_SSL)
-
-} // namespace detail
-} // namespace ssl
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#if defined(ASIO_HEADER_ONLY)
-# include "asio/ssl/detail/impl/engine.ipp"
-#endif // defined(ASIO_HEADER_ONLY)
-
-#endif // ASIO_SSL_DETAIL_ENGINE_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/detail/handshake_op.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/detail/handshake_op.hpp
deleted file mode 100644
index 25c110f3b1e3..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/detail/handshake_op.hpp
+++ /dev/null
@@ -1,68 +0,0 @@
-//
-// ssl/detail/handshake_op.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_SSL_DETAIL_HANDSHAKE_OP_HPP
-#define ASIO_SSL_DETAIL_HANDSHAKE_OP_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if !defined(ASIO_ENABLE_OLD_SSL)
-# include "asio/ssl/detail/engine.hpp"
-#endif // !defined(ASIO_ENABLE_OLD_SSL)
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace ssl {
-namespace detail {
-
-#if !defined(ASIO_ENABLE_OLD_SSL)
-
-class handshake_op
-{
-public:
-  handshake_op(stream_base::handshake_type type)
-    : type_(type)
-  {
-  }
-
-  engine::want operator()(engine& eng,
-      asio::error_code& ec,
-      std::size_t& bytes_transferred) const
-  {
-    bytes_transferred = 0;
-    return eng.handshake(type_, ec);
-  }
-
-  template <typename Handler>
-  void call_handler(Handler& handler,
-      const asio::error_code& ec,
-      const std::size_t&) const
-  {
-    handler(ec);
-  }
-
-private:
-  stream_base::handshake_type type_;
-};
-
-#endif // !defined(ASIO_ENABLE_OLD_SSL)
-
-} // namespace detail
-} // namespace ssl
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_SSL_DETAIL_HANDSHAKE_OP_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/detail/impl/engine.ipp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/detail/impl/engine.ipp
deleted file mode 100644
index 59f8283fa408..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/detail/impl/engine.ipp
+++ /dev/null
@@ -1,326 +0,0 @@
-//
-// ssl/detail/impl/engine.ipp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_SSL_DETAIL_IMPL_ENGINE_IPP
-#define ASIO_SSL_DETAIL_IMPL_ENGINE_IPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if !defined(ASIO_ENABLE_OLD_SSL)
-# include "asio/detail/throw_error.hpp"
-# include "asio/error.hpp"
-# include "asio/ssl/detail/engine.hpp"
-# include "asio/ssl/error.hpp"
-# include "asio/ssl/verify_context.hpp"
-#endif // !defined(ASIO_ENABLE_OLD_SSL)
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace ssl {
-namespace detail {
-
-#if !defined(ASIO_ENABLE_OLD_SSL)
-
-engine::engine(SSL_CTX* context)
-  : ssl_(::SSL_new(context))
-{
-  if (!ssl_)
-  {
-    asio::error_code ec(
-        static_cast<int>(::ERR_get_error()),
-        asio::error::get_ssl_category());
-    asio::detail::throw_error(ec, "engine");
-  }
-
-  accept_mutex().init();
-
-  ::SSL_set_mode(ssl_, SSL_MODE_ENABLE_PARTIAL_WRITE);
-  ::SSL_set_mode(ssl_, SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER);
-#if defined(SSL_MODE_RELEASE_BUFFERS)
-  ::SSL_set_mode(ssl_, SSL_MODE_RELEASE_BUFFERS);
-#endif // defined(SSL_MODE_RELEASE_BUFFERS)
-
-  ::BIO* int_bio = 0;
-  ::BIO_new_bio_pair(&int_bio, 0, &ext_bio_, 0);
-  ::SSL_set_bio(ssl_, int_bio, int_bio);
-}
-
-engine::~engine()
-{
-  if (SSL_get_app_data(ssl_))
-  {
-    delete static_cast<verify_callback_base*>(SSL_get_app_data(ssl_));
-    SSL_set_app_data(ssl_, 0);
-  }
-
-  ::BIO_free(ext_bio_);
-  ::SSL_free(ssl_);
-}
-
-SSL* engine::native_handle()
-{
-  return ssl_;
-}
-
-asio::error_code engine::set_verify_mode(
-    verify_mode v, asio::error_code& ec)
-{
-  ::SSL_set_verify(ssl_, v, ::SSL_get_verify_callback(ssl_));
-
-  ec = asio::error_code();
-  return ec;
-}
-
-asio::error_code engine::set_verify_depth(
-    int depth, asio::error_code& ec)
-{
-  ::SSL_set_verify_depth(ssl_, depth);
-
-  ec = asio::error_code();
-  return ec;
-}
-
-asio::error_code engine::set_verify_callback(
-    verify_callback_base* callback, asio::error_code& ec)
-{
-  if (SSL_get_app_data(ssl_))
-    delete static_cast<verify_callback_base*>(SSL_get_app_data(ssl_));
-
-  SSL_set_app_data(ssl_, callback);
-
-  ::SSL_set_verify(ssl_, ::SSL_get_verify_mode(ssl_),
-      &engine::verify_callback_function);
-
-  ec = asio::error_code();
-  return ec;
-}
-
-int engine::verify_callback_function(int preverified, X509_STORE_CTX* ctx)
-{
-  if (ctx)
-  {
-    if (SSL* ssl = static_cast<SSL*>(
-          ::X509_STORE_CTX_get_ex_data(
-            ctx, ::SSL_get_ex_data_X509_STORE_CTX_idx())))
-    {
-      if (SSL_get_app_data(ssl))
-      {
-        verify_callback_base* callback =
-          static_cast<verify_callback_base*>(
-              SSL_get_app_data(ssl));
-
-        verify_context verify_ctx(ctx);
-        return callback->call(preverified != 0, verify_ctx) ? 1 : 0;
-      }
-    }
-  }
-
-  return 0;
-}
-
-engine::want engine::handshake(
-    stream_base::handshake_type type, asio::error_code& ec)
-{
-  return perform((type == asio::ssl::stream_base::client)
-      ? &engine::do_connect : &engine::do_accept, 0, 0, ec, 0);
-}
-
-engine::want engine::shutdown(asio::error_code& ec)
-{
-  return perform(&engine::do_shutdown, 0, 0, ec, 0);
-}
-
-engine::want engine::write(const asio::const_buffer& data,
-    asio::error_code& ec, std::size_t& bytes_transferred)
-{
-  if (asio::buffer_size(data) == 0)
-  {
-    ec = asio::error_code();
-    return engine::want_nothing;
-  }
-
-  return perform(&engine::do_write,
-      const_cast<void*>(asio::buffer_cast<const void*>(data)),
-      asio::buffer_size(data), ec, &bytes_transferred);
-}
-
-engine::want engine::read(const asio::mutable_buffer& data,
-    asio::error_code& ec, std::size_t& bytes_transferred)
-{
-  if (asio::buffer_size(data) == 0)
-  {
-    ec = asio::error_code();
-    return engine::want_nothing;
-  }
-
-  return perform(&engine::do_read,
-      asio::buffer_cast<void*>(data),
-      asio::buffer_size(data), ec, &bytes_transferred);
-}
-
-asio::mutable_buffers_1 engine::get_output(
-    const asio::mutable_buffer& data)
-{
-  int length = ::BIO_read(ext_bio_,
-      asio::buffer_cast<void*>(data),
-      static_cast<int>(asio::buffer_size(data)));
-
-  return asio::buffer(data,
-      length > 0 ? static_cast<std::size_t>(length) : 0);
-}
-
-asio::const_buffer engine::put_input(
-    const asio::const_buffer& data)
-{
-  int length = ::BIO_write(ext_bio_,
-      asio::buffer_cast<const void*>(data),
-      static_cast<int>(asio::buffer_size(data)));
-
-  return asio::buffer(data +
-      (length > 0 ? static_cast<std::size_t>(length) : 0));
-}
-
-const asio::error_code& engine::map_error_code(
-    asio::error_code& ec) const
-{
-  // We only want to map the error::eof code.
-  if (ec != asio::error::eof)
-    return ec;
-
-  // If there's data yet to be read, it's an error.
-  if (BIO_wpending(ext_bio_))
-  {
-    ec = asio::error_code(
-        ERR_PACK(ERR_LIB_SSL, 0, SSL_R_SHORT_READ),
-        asio::error::get_ssl_category());
-    return ec;
-  }
-
-  // SSL v2 doesn't provide a protocol-level shutdown, so an eof on the
-  // underlying transport is passed through.
-  if (ssl_ && ssl_->version == SSL2_VERSION)
-    return ec;
-
-  // Otherwise, the peer should have negotiated a proper shutdown.
-  if ((::SSL_get_shutdown(ssl_) & SSL_RECEIVED_SHUTDOWN) == 0)
-  {
-    ec = asio::error_code(
-        ERR_PACK(ERR_LIB_SSL, 0, SSL_R_SHORT_READ),
-        asio::error::get_ssl_category());
-  }
-
-  return ec;
-}
-
-asio::detail::static_mutex& engine::accept_mutex()
-{
-  static asio::detail::static_mutex mutex = ASIO_STATIC_MUTEX_INIT;
-  return mutex;
-}
-
-engine::want engine::perform(int (engine::* op)(void*, std::size_t),
-    void* data, std::size_t length, asio::error_code& ec,
-    std::size_t* bytes_transferred)
-{
-  std::size_t pending_output_before = ::BIO_ctrl_pending(ext_bio_);
-  int result = (this->*op)(data, length);
-  int ssl_error = ::SSL_get_error(ssl_, result);
-  int sys_error = static_cast<int>(::ERR_get_error());
-  std::size_t pending_output_after = ::BIO_ctrl_pending(ext_bio_);
-
-  if (ssl_error == SSL_ERROR_SSL)
-  {
-    ec = asio::error_code(sys_error,
-        asio::error::get_ssl_category());
-    return want_nothing;
-  }
-
-  if (ssl_error == SSL_ERROR_SYSCALL)
-  {
-    ec = asio::error_code(sys_error,
-        asio::error::get_system_category());
-    return want_nothing;
-  }
-
-  if (result > 0 && bytes_transferred)
-    *bytes_transferred = static_cast<std::size_t>(result);
-
-  if (ssl_error == SSL_ERROR_WANT_WRITE)
-  {
-    ec = asio::error_code();
-    return want_output_and_retry;
-  }
-  else if (pending_output_after > pending_output_before)
-  {
-    ec = asio::error_code();
-    return result > 0 ? want_output : want_output_and_retry;
-  }
-  else if (ssl_error == SSL_ERROR_WANT_READ)
-  {
-    ec = asio::error_code();
-    return want_input_and_retry;
-  }
-  else if (::SSL_get_shutdown(ssl_) & SSL_RECEIVED_SHUTDOWN)
-  {
-    ec = asio::error::eof;
-    return want_nothing;
-  }
-  else
-  {
-    ec = asio::error_code();
-    return want_nothing;
-  }
-}
-
-int engine::do_accept(void*, std::size_t)
-{
-  asio::detail::static_mutex::scoped_lock lock(accept_mutex());
-  return ::SSL_accept(ssl_);
-}
-
-int engine::do_connect(void*, std::size_t)
-{
-  return ::SSL_connect(ssl_);
-}
-
-int engine::do_shutdown(void*, std::size_t)
-{
-  int result = ::SSL_shutdown(ssl_);
-  if (result == 0)
-    result = ::SSL_shutdown(ssl_);
-  return result;
-}
-
-int engine::do_read(void* data, std::size_t length)
-{
-  return ::SSL_read(ssl_, data,
-      length < INT_MAX ? static_cast<int>(length) : INT_MAX);
-}
-
-int engine::do_write(void* data, std::size_t length)
-{
-  return ::SSL_write(ssl_, data,
-      length < INT_MAX ? static_cast<int>(length) : INT_MAX);
-}
-
-#endif // !defined(ASIO_ENABLE_OLD_SSL)
-
-} // namespace detail
-} // namespace ssl
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_SSL_DETAIL_IMPL_ENGINE_IPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/detail/impl/openssl_init.ipp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/detail/impl/openssl_init.ipp
deleted file mode 100644
index 5104a4156660..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/detail/impl/openssl_init.ipp
+++ /dev/null
@@ -1,145 +0,0 @@
-//
-// ssl/detail/impl/openssl_init.ipp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2005 Voipster / Indrek dot Juhani at voipster dot com
-// Copyright (c) 2005-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_SSL_DETAIL_IMPL_OPENSSL_INIT_IPP
-#define ASIO_SSL_DETAIL_IMPL_OPENSSL_INIT_IPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include <vector>
-#include "asio/detail/assert.hpp"
-#include "asio/detail/mutex.hpp"
-#include "asio/detail/tss_ptr.hpp"
-#include "asio/ssl/detail/openssl_init.hpp"
-#include "asio/ssl/detail/openssl_types.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace ssl {
-namespace detail {
-
-class openssl_init_base::do_init
-{
-public:
-  do_init()
-  {
-    ::SSL_library_init();
-    ::SSL_load_error_strings();        
-    ::OpenSSL_add_all_algorithms();
-
-    mutexes_.resize(::CRYPTO_num_locks());
-    for (size_t i = 0; i < mutexes_.size(); ++i)
-      mutexes_[i].reset(new asio::detail::mutex);
-    ::CRYPTO_set_locking_callback(&do_init::openssl_locking_func);
-    ::CRYPTO_set_id_callback(&do_init::openssl_id_func);
-
-#if !defined(SSL_OP_NO_COMPRESSION) \
-  && (OPENSSL_VERSION_NUMBER >= 0x00908000L)
-    null_compression_methods_ = sk_SSL_COMP_new_null();
-#endif // !defined(SSL_OP_NO_COMPRESSION)
-       // && (OPENSSL_VERSION_NUMBER >= 0x00908000L)
-  }
-
-  ~do_init()
-  {
-#if !defined(SSL_OP_NO_COMPRESSION) \
-  && (OPENSSL_VERSION_NUMBER >= 0x00908000L)
-    sk_SSL_COMP_free(null_compression_methods_);
-#endif // !defined(SSL_OP_NO_COMPRESSION)
-       // && (OPENSSL_VERSION_NUMBER >= 0x00908000L)
-
-    ::CRYPTO_set_id_callback(0);
-    ::CRYPTO_set_locking_callback(0);
-    ::ERR_free_strings();
-    ::ERR_remove_state(0);
-    ::EVP_cleanup();
-    ::CRYPTO_cleanup_all_ex_data();
-    ::CONF_modules_unload(1);
-#if !defined(OPENSSL_NO_ENGINE)
-    ::ENGINE_cleanup();
-#endif // !defined(OPENSSL_NO_ENGINE)
-  }
-
-#if !defined(SSL_OP_NO_COMPRESSION) \
-  && (OPENSSL_VERSION_NUMBER >= 0x00908000L)
-  STACK_OF(SSL_COMP)* get_null_compression_methods() const
-  {
-    return null_compression_methods_;
-  }
-#endif // !defined(SSL_OP_NO_COMPRESSION)
-       // && (OPENSSL_VERSION_NUMBER >= 0x00908000L)
-
-private:
-  static unsigned long openssl_id_func()
-  {
-#if defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-    return ::GetCurrentThreadId();
-#else // defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-    void* id = instance()->thread_id_;
-    if (id == 0)
-      instance()->thread_id_ = id = &id; // Ugh.
-    ASIO_ASSERT(sizeof(unsigned long) >= sizeof(void*));
-    return reinterpret_cast<unsigned long>(id);
-#endif // defined(ASIO_WINDOWS) || defined(__CYGWIN__)
-  }
-
-  static void openssl_locking_func(int mode, int n, 
-    const char* /*file*/, int /*line*/)
-  {
-    if (mode & CRYPTO_LOCK)
-      instance()->mutexes_[n]->lock();
-    else
-      instance()->mutexes_[n]->unlock();
-  }
-
-  // Mutexes to be used in locking callbacks.
-  std::vector<asio::detail::shared_ptr<
-        asio::detail::mutex> > mutexes_;
-
-#if !defined(ASIO_WINDOWS) && !defined(__CYGWIN__)
-  // The thread identifiers to be used by openssl.
-  asio::detail::tss_ptr<void> thread_id_;
-#endif // !defined(ASIO_WINDOWS) && !defined(__CYGWIN__)
-
-#if !defined(SSL_OP_NO_COMPRESSION) \
-  && (OPENSSL_VERSION_NUMBER >= 0x00908000L)
-  STACK_OF(SSL_COMP)* null_compression_methods_;
-#endif // !defined(SSL_OP_NO_COMPRESSION)
-       // && (OPENSSL_VERSION_NUMBER >= 0x00908000L)
-};
-
-asio::detail::shared_ptr<openssl_init_base::do_init>
-openssl_init_base::instance()
-{
-  static asio::detail::shared_ptr<do_init> init(new do_init);
-  return init;
-}
-
-#if !defined(SSL_OP_NO_COMPRESSION) \
-  && (OPENSSL_VERSION_NUMBER >= 0x00908000L)
-STACK_OF(SSL_COMP)* openssl_init_base::get_null_compression_methods()
-{
-  return instance()->get_null_compression_methods();
-}
-#endif // !defined(SSL_OP_NO_COMPRESSION)
-       // && (OPENSSL_VERSION_NUMBER >= 0x00908000L)
-
-} // namespace detail
-} // namespace ssl
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_SSL_DETAIL_IMPL_OPENSSL_INIT_IPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/detail/io.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/detail/io.hpp
deleted file mode 100644
index bb60ccc4f9db..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/detail/io.hpp
+++ /dev/null
@@ -1,347 +0,0 @@
-//
-// ssl/detail/io.hpp
-// ~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_SSL_DETAIL_IO_HPP
-#define ASIO_SSL_DETAIL_IO_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if !defined(ASIO_ENABLE_OLD_SSL)
-# include "asio/ssl/detail/engine.hpp"
-# include "asio/ssl/detail/stream_core.hpp"
-# include "asio/write.hpp"
-#endif // !defined(ASIO_ENABLE_OLD_SSL)
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace ssl {
-namespace detail {
-
-#if !defined(ASIO_ENABLE_OLD_SSL)
-
-template <typename Stream, typename Operation>
-std::size_t io(Stream& next_layer, stream_core& core,
-    const Operation& op, asio::error_code& ec)
-{
-  std::size_t bytes_transferred = 0;
-  do switch (op(core.engine_, ec, bytes_transferred))
-  {
-  case engine::want_input_and_retry:
-
-    // If the input buffer is empty then we need to read some more data from
-    // the underlying transport.
-    if (asio::buffer_size(core.input_) == 0)
-      core.input_ = asio::buffer(core.input_buffer_,
-          next_layer.read_some(core.input_buffer_, ec));
-
-    // Pass the new input data to the engine.
-    core.input_ = core.engine_.put_input(core.input_);
-
-    // Try the operation again.
-    continue;
-
-  case engine::want_output_and_retry:
-
-    // Get output data from the engine and write it to the underlying
-    // transport.
-    asio::write(next_layer,
-        core.engine_.get_output(core.output_buffer_), ec);
-
-    // Try the operation again.
-    continue;
-
-  case engine::want_output:
-
-    // Get output data from the engine and write it to the underlying
-    // transport.
-    asio::write(next_layer,
-        core.engine_.get_output(core.output_buffer_), ec);
-
-    // Operation is complete. Return result to caller.
-    core.engine_.map_error_code(ec);
-    return bytes_transferred;
-
-  default:
-
-    // Operation is complete. Return result to caller.
-    core.engine_.map_error_code(ec);
-    return bytes_transferred;
-
-  } while (!ec);
-
-  // Operation failed. Return result to caller.
-  core.engine_.map_error_code(ec);
-  return 0;
-}
-
-template <typename Stream, typename Operation, typename Handler>
-class io_op
-{
-public:
-  io_op(Stream& next_layer, stream_core& core,
-      const Operation& op, Handler& handler)
-    : next_layer_(next_layer),
-      core_(core),
-      op_(op),
-      start_(0),
-      want_(engine::want_nothing),
-      bytes_transferred_(0),
-      handler_(ASIO_MOVE_CAST(Handler)(handler))
-  {
-  }
-
-#if defined(ASIO_HAS_MOVE)
-  io_op(const io_op& other)
-    : next_layer_(other.next_layer_),
-      core_(other.core_),
-      op_(other.op_),
-      start_(other.start_),
-      want_(other.want_),
-      ec_(other.ec_),
-      bytes_transferred_(other.bytes_transferred_),
-      handler_(other.handler_)
-  {
-  }
-
-  io_op(io_op&& other)
-    : next_layer_(other.next_layer_),
-      core_(other.core_),
-      op_(other.op_),
-      start_(other.start_),
-      want_(other.want_),
-      ec_(other.ec_),
-      bytes_transferred_(other.bytes_transferred_),
-      handler_(ASIO_MOVE_CAST(Handler)(other.handler_))
-  {
-  }
-#endif // defined(ASIO_HAS_MOVE)
-
-  void operator()(asio::error_code ec,
-      std::size_t bytes_transferred = ~std::size_t(0), int start = 0)
-  {
-    switch (start_ = start)
-    {
-    case 1: // Called after at least one async operation.
-      do
-      {
-        switch (want_ = op_(core_.engine_, ec_, bytes_transferred_))
-        {
-        case engine::want_input_and_retry:
-
-          // If the input buffer already has data in it we can pass it to the
-          // engine and then retry the operation immediately.
-          if (asio::buffer_size(core_.input_) != 0)
-          {
-            core_.input_ = core_.engine_.put_input(core_.input_);
-            continue;
-          }
-
-          // The engine wants more data to be read from input. However, we
-          // cannot allow more than one read operation at a time on the
-          // underlying transport. The pending_read_ timer's expiry is set to
-          // pos_infin if a read is in progress, and neg_infin otherwise.
-          if (core_.pending_read_.expires_at() == core_.neg_infin())
-          {
-            // Prevent other read operations from being started.
-            core_.pending_read_.expires_at(core_.pos_infin());
-
-            // Start reading some data from the underlying transport.
-            next_layer_.async_read_some(
-                asio::buffer(core_.input_buffer_),
-                ASIO_MOVE_CAST(io_op)(*this));
-          }
-          else
-          {
-            // Wait until the current read operation completes.
-            core_.pending_read_.async_wait(ASIO_MOVE_CAST(io_op)(*this));
-          }
-
-          // Yield control until asynchronous operation completes. Control
-          // resumes at the "default:" label below.
-          return;
-
-        case engine::want_output_and_retry:
-        case engine::want_output:
-
-          // The engine wants some data to be written to the output. However, we
-          // cannot allow more than one write operation at a time on the
-          // underlying transport. The pending_write_ timer's expiry is set to
-          // pos_infin if a write is in progress, and neg_infin otherwise.
-          if (core_.pending_write_.expires_at() == core_.neg_infin())
-          {
-            // Prevent other write operations from being started.
-            core_.pending_write_.expires_at(core_.pos_infin());
-
-            // Start writing all the data to the underlying transport.
-            asio::async_write(next_layer_,
-                core_.engine_.get_output(core_.output_buffer_),
-                ASIO_MOVE_CAST(io_op)(*this));
-          }
-          else
-          {
-            // Wait until the current write operation completes.
-            core_.pending_write_.async_wait(ASIO_MOVE_CAST(io_op)(*this));
-          }
-
-          // Yield control until asynchronous operation completes. Control
-          // resumes at the "default:" label below.
-          return;
-
-        default:
-
-          // The SSL operation is done and we can invoke the handler, but we
-          // have to keep in mind that this function might be being called from
-          // the async operation's initiating function. In this case we're not
-          // allowed to call the handler directly. Instead, issue a zero-sized
-          // read so the handler runs "as-if" posted using io_service::post().
-          if (start)
-          {
-            next_layer_.async_read_some(
-                asio::buffer(core_.input_buffer_, 0),
-                ASIO_MOVE_CAST(io_op)(*this));
-
-            // Yield control until asynchronous operation completes. Control
-            // resumes at the "default:" label below.
-            return;
-          }
-          else
-          {
-            // Continue on to run handler directly.
-            break;
-          }
-        }
-
-        default:
-        if (bytes_transferred != ~std::size_t(0) && !ec_)
-          ec_ = ec;
-
-        switch (want_)
-        {
-        case engine::want_input_and_retry:
-
-          // Add received data to the engine's input.
-          core_.input_ = asio::buffer(
-              core_.input_buffer_, bytes_transferred);
-          core_.input_ = core_.engine_.put_input(core_.input_);
-
-          // Release any waiting read operations.
-          core_.pending_read_.expires_at(core_.neg_infin());
-
-          // Try the operation again.
-          continue;
-
-        case engine::want_output_and_retry:
-
-          // Release any waiting write operations.
-          core_.pending_write_.expires_at(core_.neg_infin());
-
-          // Try the operation again.
-          continue;
-
-        case engine::want_output:
-
-          // Release any waiting write operations.
-          core_.pending_write_.expires_at(core_.neg_infin());
-
-          // Fall through to call handler.
-
-        default:
-
-          // Pass the result to the handler.
-          op_.call_handler(handler_,
-              core_.engine_.map_error_code(ec_),
-              ec_ ? 0 : bytes_transferred_);
-
-          // Our work here is done.
-          return;
-        }
-      } while (!ec_);
-
-      // Operation failed. Pass the result to the handler.
-      op_.call_handler(handler_, core_.engine_.map_error_code(ec_), 0);
-    }
-  }
-
-//private:
-  Stream& next_layer_;
-  stream_core& core_;
-  Operation op_;
-  int start_;
-  engine::want want_;
-  asio::error_code ec_;
-  std::size_t bytes_transferred_;
-  Handler handler_;
-};
-
-template <typename Stream, typename Operation,  typename Handler>
-inline void* asio_handler_allocate(std::size_t size,
-    io_op<Stream, Operation, Handler>* this_handler)
-{
-  return asio_handler_alloc_helpers::allocate(
-      size, this_handler->handler_);
-}
-
-template <typename Stream, typename Operation, typename Handler>
-inline void asio_handler_deallocate(void* pointer, std::size_t size,
-    io_op<Stream, Operation, Handler>* this_handler)
-{
-  asio_handler_alloc_helpers::deallocate(
-      pointer, size, this_handler->handler_);
-}
-
-template <typename Stream, typename Operation, typename Handler>
-inline bool asio_handler_is_continuation(
-    io_op<Stream, Operation, Handler>* this_handler)
-{
-  return this_handler->start_ == 0 ? true
-    : asio_handler_cont_helpers::is_continuation(this_handler->handler_);
-}
-
-template <typename Function, typename Stream,
-    typename Operation, typename Handler>
-inline void asio_handler_invoke(Function& function,
-    io_op<Stream, Operation, Handler>* this_handler)
-{
-  asio_handler_invoke_helpers::invoke(
-      function, this_handler->handler_);
-}
-
-template <typename Function, typename Stream,
-    typename Operation, typename Handler>
-inline void asio_handler_invoke(const Function& function,
-    io_op<Stream, Operation, Handler>* this_handler)
-{
-  asio_handler_invoke_helpers::invoke(
-      function, this_handler->handler_);
-}
-
-template <typename Stream, typename Operation, typename Handler>
-inline void async_io(Stream& next_layer, stream_core& core,
-    const Operation& op, Handler& handler)
-{
-  io_op<Stream, Operation, Handler>(
-    next_layer, core, op, handler)(
-      asio::error_code(), 0, 1);
-}
-
-#endif // !defined(ASIO_ENABLE_OLD_SSL)
-
-} // namespace detail
-} // namespace ssl
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_SSL_DETAIL_IO_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/detail/openssl_init.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/detail/openssl_init.hpp
deleted file mode 100644
index 317ba1f85454..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/detail/openssl_init.hpp
+++ /dev/null
@@ -1,101 +0,0 @@
-//
-// ssl/detail/openssl_init.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_SSL_DETAIL_OPENSSL_INIT_HPP
-#define ASIO_SSL_DETAIL_OPENSSL_INIT_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include <cstring>
-#include "asio/detail/noncopyable.hpp"
-#include "asio/detail/shared_ptr.hpp"
-#include "asio/ssl/detail/openssl_types.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace ssl {
-namespace detail {
-
-class openssl_init_base
-  : private noncopyable
-{
-protected:
-  // Class that performs the actual initialisation.
-  class do_init;
-
-  // Helper function to manage a do_init singleton. The static instance of the
-  // openssl_init object ensures that this function is always called before
-  // main, and therefore before any other threads can get started. The do_init
-  // instance must be static in this function to ensure that it gets
-  // initialised before any other global objects try to use it.
-  ASIO_DECL static asio::detail::shared_ptr<do_init> instance();
-
-#if !defined(SSL_OP_NO_COMPRESSION) \
-  && (OPENSSL_VERSION_NUMBER >= 0x00908000L)
-  // Get an empty stack of compression methods, to be used when disabling
-  // compression.
-  ASIO_DECL static STACK_OF(SSL_COMP)* get_null_compression_methods();
-#endif // !defined(SSL_OP_NO_COMPRESSION)
-       // && (OPENSSL_VERSION_NUMBER >= 0x00908000L)
-};
-
-template <bool Do_Init = true>
-class openssl_init : private openssl_init_base
-{
-public:
-  // Constructor.
-  openssl_init()
-    : ref_(instance())
-  {
-    using namespace std; // For memmove.
-
-    // Ensure openssl_init::instance_ is linked in.
-    openssl_init* tmp = &instance_;
-    memmove(&tmp, &tmp, sizeof(openssl_init*));
-  }
-
-  // Destructor.
-  ~openssl_init()
-  {
-  }
-
-#if !defined(SSL_OP_NO_COMPRESSION) \
-  && (OPENSSL_VERSION_NUMBER >= 0x00908000L)
-  using openssl_init_base::get_null_compression_methods;
-#endif // !defined(SSL_OP_NO_COMPRESSION)
-       // && (OPENSSL_VERSION_NUMBER >= 0x00908000L)
-
-private:
-  // Instance to force initialisation of openssl at global scope.
-  static openssl_init instance_;
-
-  // Reference to singleton do_init object to ensure that openssl does not get
-  // cleaned up until the last user has finished with it.
-  asio::detail::shared_ptr<do_init> ref_;
-};
-
-template <bool Do_Init>
-openssl_init<Do_Init> openssl_init<Do_Init>::instance_;
-
-} // namespace detail
-} // namespace ssl
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#if defined(ASIO_HEADER_ONLY)
-# include "asio/ssl/detail/impl/openssl_init.ipp"
-#endif // defined(ASIO_HEADER_ONLY)
-
-#endif // ASIO_SSL_DETAIL_OPENSSL_INIT_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/detail/openssl_types.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/detail/openssl_types.hpp
deleted file mode 100644
index 21b9dab0eed2..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/detail/openssl_types.hpp
+++ /dev/null
@@ -1,28 +0,0 @@
-//
-// ssl/detail/openssl_types.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_SSL_DETAIL_OPENSSL_TYPES_HPP
-#define ASIO_SSL_DETAIL_OPENSSL_TYPES_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include <openssl/conf.h>
-#include <openssl/ssl.h>
-#if !defined(OPENSSL_NO_ENGINE)
-# include <openssl/engine.h>
-#endif // !defined(OPENSSL_NO_ENGINE)
-#include <openssl/err.h>
-#include <openssl/x509v3.h>
-#include "asio/detail/socket_types.hpp"
-
-#endif // ASIO_SSL_DETAIL_OPENSSL_TYPES_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/detail/password_callback.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/detail/password_callback.hpp
deleted file mode 100644
index 78017021d450..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/detail/password_callback.hpp
+++ /dev/null
@@ -1,72 +0,0 @@
-//
-// ssl/detail/password_callback.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_SSL_DETAIL_PASSWORD_CALLBACK_HPP
-#define ASIO_SSL_DETAIL_PASSWORD_CALLBACK_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if !defined(ASIO_ENABLE_OLD_SSL)
-# include <cstddef>
-# include <string>
-# include "asio/ssl/context_base.hpp"
-#endif // !defined(ASIO_ENABLE_OLD_SSL)
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace ssl {
-namespace detail {
-
-#if !defined(ASIO_ENABLE_OLD_SSL)
-
-class password_callback_base
-{
-public:
-  virtual ~password_callback_base()
-  {
-  }
-
-  virtual std::string call(std::size_t size,
-      context_base::password_purpose purpose) = 0;
-};
-
-template <typename PasswordCallback>
-class password_callback : public password_callback_base
-{
-public:
-  explicit password_callback(PasswordCallback callback)
-    : callback_(callback)
-  {
-  }
-
-  virtual std::string call(std::size_t size,
-      context_base::password_purpose purpose)
-  {
-    return callback_(size, purpose);
-  }
-
-private:
-  PasswordCallback callback_;
-};
-
-#endif // !defined(ASIO_ENABLE_OLD_SSL)
-
-} // namespace detail
-} // namespace ssl
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_SSL_DETAIL_PASSWORD_CALLBACK_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/detail/read_op.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/detail/read_op.hpp
deleted file mode 100644
index b48efbe82d43..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/detail/read_op.hpp
+++ /dev/null
@@ -1,73 +0,0 @@
-//
-// ssl/detail/read_op.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_SSL_DETAIL_READ_OP_HPP
-#define ASIO_SSL_DETAIL_READ_OP_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if !defined(ASIO_ENABLE_OLD_SSL)
-# include "asio/detail/buffer_sequence_adapter.hpp"
-# include "asio/ssl/detail/engine.hpp"
-#endif // !defined(ASIO_ENABLE_OLD_SSL)
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace ssl {
-namespace detail {
-
-#if !defined(ASIO_ENABLE_OLD_SSL)
-
-template <typename MutableBufferSequence>
-class read_op
-{
-public:
-  read_op(const MutableBufferSequence& buffers)
-    : buffers_(buffers)
-  {
-  }
-
-  engine::want operator()(engine& eng,
-      asio::error_code& ec,
-      std::size_t& bytes_transferred) const
-  {
-    asio::mutable_buffer buffer =
-      asio::detail::buffer_sequence_adapter<asio::mutable_buffer,
-        MutableBufferSequence>::first(buffers_);
-
-    return eng.read(buffer, ec, bytes_transferred);
-  }
-
-  template <typename Handler>
-  void call_handler(Handler& handler,
-      const asio::error_code& ec,
-      const std::size_t& bytes_transferred) const
-  {
-    handler(ec, bytes_transferred);
-  }
-
-private:
-  MutableBufferSequence buffers_;
-};
-
-#endif // !defined(ASIO_ENABLE_OLD_SSL)
-
-} // namespace detail
-} // namespace ssl
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_SSL_DETAIL_READ_OP_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/detail/shutdown_op.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/detail/shutdown_op.hpp
deleted file mode 100644
index f220ee255aaa..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/detail/shutdown_op.hpp
+++ /dev/null
@@ -1,60 +0,0 @@
-//
-// ssl/detail/shutdown_op.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_SSL_DETAIL_SHUTDOWN_OP_HPP
-#define ASIO_SSL_DETAIL_SHUTDOWN_OP_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if !defined(ASIO_ENABLE_OLD_SSL)
-# include "asio/ssl/detail/engine.hpp"
-#endif // !defined(ASIO_ENABLE_OLD_SSL)
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace ssl {
-namespace detail {
-
-#if !defined(ASIO_ENABLE_OLD_SSL)
-
-class shutdown_op
-{
-public:
-  engine::want operator()(engine& eng,
-      asio::error_code& ec,
-      std::size_t& bytes_transferred) const
-  {
-    bytes_transferred = 0;
-    return eng.shutdown(ec);
-  }
-
-  template <typename Handler>
-  void call_handler(Handler& handler,
-      const asio::error_code& ec,
-      const std::size_t&) const
-  {
-    handler(ec);
-  }
-};
-
-#endif // !defined(ASIO_ENABLE_OLD_SSL)
-
-} // namespace detail
-} // namespace ssl
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_SSL_DETAIL_SHUTDOWN_OP_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/detail/stream_core.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/detail/stream_core.hpp
deleted file mode 100644
index b29bbfcc7303..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/detail/stream_core.hpp
+++ /dev/null
@@ -1,126 +0,0 @@
-//
-// ssl/detail/stream_core.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_SSL_DETAIL_STREAM_CORE_HPP
-#define ASIO_SSL_DETAIL_STREAM_CORE_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if !defined(ASIO_ENABLE_OLD_SSL)
-# if defined(ASIO_HAS_BOOST_DATE_TIME)
-#  include "asio/deadline_timer.hpp"
-# else // defined(ASIO_HAS_BOOST_DATE_TIME)
-#  include "asio/steady_timer.hpp"
-# endif // defined(ASIO_HAS_BOOST_DATE_TIME)
-# include "asio/ssl/detail/engine.hpp"
-# include "asio/buffer.hpp"
-#endif // !defined(ASIO_ENABLE_OLD_SSL)
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace ssl {
-namespace detail {
-
-#if !defined(ASIO_ENABLE_OLD_SSL)
-
-struct stream_core
-{
-  // According to the OpenSSL documentation, this is the buffer size that is
-  // sufficient to hold the largest possible TLS record.
-  enum { max_tls_record_size = 17 * 1024 };
-
-  stream_core(SSL_CTX* context, asio::io_service& io_service)
-    : engine_(context),
-      pending_read_(io_service),
-      pending_write_(io_service),
-      output_buffer_space_(max_tls_record_size),
-      output_buffer_(asio::buffer(output_buffer_space_)),
-      input_buffer_space_(max_tls_record_size),
-      input_buffer_(asio::buffer(input_buffer_space_))
-  {
-    pending_read_.expires_at(neg_infin());
-    pending_write_.expires_at(neg_infin());
-  }
-
-  ~stream_core()
-  {
-  }
-
-  // The SSL engine.
-  engine engine_;
-
-#if defined(ASIO_HAS_BOOST_DATE_TIME)
-  // Timer used for storing queued read operations.
-  asio::deadline_timer pending_read_;
-
-  // Timer used for storing queued write operations.
-  asio::deadline_timer pending_write_;
-
-  // Helper function for obtaining a time value that always fires.
-  static asio::deadline_timer::time_type neg_infin()
-  {
-    return boost::posix_time::neg_infin;
-  }
-
-  // Helper function for obtaining a time value that never fires.
-  static asio::deadline_timer::time_type pos_infin()
-  {
-    return boost::posix_time::pos_infin;
-  }
-#else // defined(ASIO_HAS_BOOST_DATE_TIME)
-  // Timer used for storing queued read operations.
-  asio::steady_timer pending_read_;
-
-  // Timer used for storing queued write operations.
-  asio::steady_timer pending_write_;
-
-  // Helper function for obtaining a time value that always fires.
-  static asio::steady_timer::time_point neg_infin()
-  {
-    return (asio::steady_timer::time_point::min)();
-  }
-
-  // Helper function for obtaining a time value that never fires.
-  static asio::steady_timer::time_point pos_infin()
-  {
-    return (asio::steady_timer::time_point::max)();
-  }
-#endif // defined(ASIO_HAS_BOOST_DATE_TIME)
-
-  // Buffer space used to prepare output intended for the transport.
-  std::vector<unsigned char> output_buffer_space_;
-
-  // A buffer that may be used to prepare output intended for the transport.
-  const asio::mutable_buffers_1 output_buffer_;
-
-  // Buffer space used to read input intended for the engine.
-  std::vector<unsigned char> input_buffer_space_;
-
-  // A buffer that may be used to read input intended for the engine.
-  const asio::mutable_buffers_1 input_buffer_;
-
-  // The buffer pointing to the engine's unconsumed input.
-  asio::const_buffer input_;
-};
-
-#endif // !defined(ASIO_ENABLE_OLD_SSL)
-
-} // namespace detail
-} // namespace ssl
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_SSL_DETAIL_STREAM_CORE_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/detail/verify_callback.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/detail/verify_callback.hpp
deleted file mode 100644
index 48df3505df4f..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/detail/verify_callback.hpp
+++ /dev/null
@@ -1,68 +0,0 @@
-//
-// ssl/detail/verify_callback.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_SSL_DETAIL_VERIFY_CALLBACK_HPP
-#define ASIO_SSL_DETAIL_VERIFY_CALLBACK_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if !defined(ASIO_ENABLE_OLD_SSL)
-# include "asio/ssl/verify_context.hpp"
-#endif // !defined(ASIO_ENABLE_OLD_SSL)
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace ssl {
-namespace detail {
-
-#if !defined(ASIO_ENABLE_OLD_SSL)
-
-class verify_callback_base
-{
-public:
-  virtual ~verify_callback_base()
-  {
-  }
-
-  virtual bool call(bool preverified, verify_context& ctx) = 0;
-};
-
-template <typename VerifyCallback>
-class verify_callback : public verify_callback_base
-{
-public:
-  explicit verify_callback(VerifyCallback callback)
-    : callback_(callback)
-  {
-  }
-
-  virtual bool call(bool preverified, verify_context& ctx)
-  {
-    return callback_(preverified, ctx);
-  }
-
-private:
-  VerifyCallback callback_;
-};
-
-#endif // !defined(ASIO_ENABLE_OLD_SSL)
-
-} // namespace detail
-} // namespace ssl
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_SSL_DETAIL_VERIFY_CALLBACK_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/detail/write_op.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/detail/write_op.hpp
deleted file mode 100644
index f95c2a8bfe3c..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/detail/write_op.hpp
+++ /dev/null
@@ -1,73 +0,0 @@
-//
-// ssl/detail/write_op.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_SSL_DETAIL_WRITE_OP_HPP
-#define ASIO_SSL_DETAIL_WRITE_OP_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if !defined(ASIO_ENABLE_OLD_SSL)
-# include "asio/detail/buffer_sequence_adapter.hpp"
-# include "asio/ssl/detail/engine.hpp"
-#endif // !defined(ASIO_ENABLE_OLD_SSL)
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace ssl {
-namespace detail {
-
-#if !defined(ASIO_ENABLE_OLD_SSL)
-
-template <typename ConstBufferSequence>
-class write_op
-{
-public:
-  write_op(const ConstBufferSequence& buffers)
-    : buffers_(buffers)
-  {
-  }
-
-  engine::want operator()(engine& eng,
-      asio::error_code& ec,
-      std::size_t& bytes_transferred) const
-  {
-    asio::const_buffer buffer =
-      asio::detail::buffer_sequence_adapter<asio::const_buffer,
-        ConstBufferSequence>::first(buffers_);
-
-    return eng.write(buffer, ec, bytes_transferred);
-  }
-
-  template <typename Handler>
-  void call_handler(Handler& handler,
-      const asio::error_code& ec,
-      const std::size_t& bytes_transferred) const
-  {
-    handler(ec, bytes_transferred);
-  }
-
-private:
-  ConstBufferSequence buffers_;
-};
-
-#endif // !defined(ASIO_ENABLE_OLD_SSL)
-
-} // namespace detail
-} // namespace ssl
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_SSL_DETAIL_WRITE_OP_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/error.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/error.hpp
deleted file mode 100644
index b5369c012f0b..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/error.hpp
+++ /dev/null
@@ -1,68 +0,0 @@
-//
-// ssl/error.hpp
-// ~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_SSL_ERROR_HPP
-#define ASIO_SSL_ERROR_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include "asio/error_code.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace error {
-
-enum ssl_errors
-{
-};
-
-extern ASIO_DECL
-const asio::error_category& get_ssl_category();
-
-static const asio::error_category& ssl_category
-  = asio::error::get_ssl_category();
-
-} // namespace error
-} // namespace asio
-
-#if defined(ASIO_HAS_STD_SYSTEM_ERROR)
-namespace std {
-
-template<> struct is_error_code_enum<asio::error::ssl_errors>
-{
-  static const bool value = true;
-};
-
-} // namespace std
-#endif // defined(ASIO_HAS_STD_SYSTEM_ERROR)
-
-namespace asio {
-namespace error {
-
-inline asio::error_code make_error_code(ssl_errors e)
-{
-  return asio::error_code(
-      static_cast<int>(e), get_ssl_category());
-}
-
-} // namespace error
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#if defined(ASIO_HEADER_ONLY)
-# include "asio/ssl/impl/error.ipp"
-#endif // defined(ASIO_HEADER_ONLY)
-
-#endif // ASIO_SSL_ERROR_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/impl/context.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/impl/context.hpp
deleted file mode 100644
index 115a3e4e7957..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/impl/context.hpp
+++ /dev/null
@@ -1,71 +0,0 @@
-//
-// ssl/impl/context.hpp
-// ~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2005 Voipster / Indrek dot Juhani at voipster dot com
-// Copyright (c) 2005-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_SSL_IMPL_CONTEXT_HPP
-#define ASIO_SSL_IMPL_CONTEXT_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if !defined(ASIO_ENABLE_OLD_SSL)
-# include "asio/detail/throw_error.hpp"
-#endif // !defined(ASIO_ENABLE_OLD_SSL)
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace ssl {
-
-#if !defined(ASIO_ENABLE_OLD_SSL)
-
-template <typename VerifyCallback>
-void context::set_verify_callback(VerifyCallback callback)
-{
-  asio::error_code ec;
-  this->set_verify_callback(callback, ec);
-  asio::detail::throw_error(ec, "set_verify_callback");
-}
-
-template <typename VerifyCallback>
-asio::error_code context::set_verify_callback(
-    VerifyCallback callback, asio::error_code& ec)
-{
-  return do_set_verify_callback(
-      new detail::verify_callback<VerifyCallback>(callback), ec);
-}
-
-template <typename PasswordCallback>
-void context::set_password_callback(PasswordCallback callback)
-{
-  asio::error_code ec;
-  this->set_password_callback(callback, ec);
-  asio::detail::throw_error(ec, "set_password_callback");
-}
-
-template <typename PasswordCallback>
-asio::error_code context::set_password_callback(
-    PasswordCallback callback, asio::error_code& ec)
-{
-  return do_set_password_callback(
-      new detail::password_callback<PasswordCallback>(callback), ec);
-}
-
-#endif // !defined(ASIO_ENABLE_OLD_SSL)
-
-} // namespace ssl
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_SSL_IMPL_CONTEXT_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/impl/context.ipp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/impl/context.ipp
deleted file mode 100644
index 785b3ee4bf5c..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/impl/context.ipp
+++ /dev/null
@@ -1,950 +0,0 @@
-//
-// ssl/impl/context.ipp
-// ~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2005 Voipster / Indrek dot Juhani at voipster dot com
-// Copyright (c) 2005-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_SSL_IMPL_CONTEXT_IPP
-#define ASIO_SSL_IMPL_CONTEXT_IPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if !defined(ASIO_ENABLE_OLD_SSL)
-# include <cstring>
-# include "asio/detail/throw_error.hpp"
-# include "asio/error.hpp"
-# include "asio/ssl/context.hpp"
-# include "asio/ssl/error.hpp"
-#endif // !defined(ASIO_ENABLE_OLD_SSL)
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace ssl {
-
-#if !defined(ASIO_ENABLE_OLD_SSL)
-
-struct context::bio_cleanup
-{
-  BIO* p;
-  ~bio_cleanup() { if (p) ::BIO_free(p); }
-};
-
-struct context::x509_cleanup
-{
-  X509* p;
-  ~x509_cleanup() { if (p) ::X509_free(p); }
-};
-
-struct context::evp_pkey_cleanup
-{
-  EVP_PKEY* p;
-  ~evp_pkey_cleanup() { if (p) ::EVP_PKEY_free(p); }
-};
-
-struct context::rsa_cleanup
-{
-  RSA* p;
-  ~rsa_cleanup() { if (p) ::RSA_free(p); }
-};
-
-struct context::dh_cleanup
-{
-  DH* p;
-  ~dh_cleanup() { if (p) ::DH_free(p); }
-};
-
-context::context(context::method m)
-  : handle_(0)
-{
-  switch (m)
-  {
-#if defined(OPENSSL_NO_SSL2)
-  case context::sslv2:
-  case context::sslv2_client:
-  case context::sslv2_server:
-    asio::detail::throw_error(
-        asio::error::invalid_argument, "context");
-    break;
-#else // defined(OPENSSL_NO_SSL2)
-  case context::sslv2:
-    handle_ = ::SSL_CTX_new(::SSLv2_method());
-    break;
-  case context::sslv2_client:
-    handle_ = ::SSL_CTX_new(::SSLv2_client_method());
-    break;
-  case context::sslv2_server:
-    handle_ = ::SSL_CTX_new(::SSLv2_server_method());
-    break;
-#endif // defined(OPENSSL_NO_SSL2)
-  case context::sslv3:
-    handle_ = ::SSL_CTX_new(::SSLv3_method());
-    break;
-  case context::sslv3_client:
-    handle_ = ::SSL_CTX_new(::SSLv3_client_method());
-    break;
-  case context::sslv3_server:
-    handle_ = ::SSL_CTX_new(::SSLv3_server_method());
-    break;
-  case context::tlsv1:
-    handle_ = ::SSL_CTX_new(::TLSv1_method());
-    break;
-  case context::tlsv1_client:
-    handle_ = ::SSL_CTX_new(::TLSv1_client_method());
-    break;
-  case context::tlsv1_server:
-    handle_ = ::SSL_CTX_new(::TLSv1_server_method());
-    break;
-  case context::sslv23:
-    handle_ = ::SSL_CTX_new(::SSLv23_method());
-    break;
-  case context::sslv23_client:
-    handle_ = ::SSL_CTX_new(::SSLv23_client_method());
-    break;
-  case context::sslv23_server:
-    handle_ = ::SSL_CTX_new(::SSLv23_server_method());
-    break;
-#if defined(SSL_TXT_TLSV1_1)
-  case context::tlsv11:
-    handle_ = ::SSL_CTX_new(::TLSv1_1_method());
-    break;
-  case context::tlsv11_client:
-    handle_ = ::SSL_CTX_new(::TLSv1_1_client_method());
-    break;
-  case context::tlsv11_server:
-    handle_ = ::SSL_CTX_new(::TLSv1_1_server_method());
-    break;
-#else // defined(SSL_TXT_TLSV1_1)
-  case context::tlsv11:
-  case context::tlsv11_client:
-  case context::tlsv11_server:
-    asio::detail::throw_error(
-        asio::error::invalid_argument, "context");
-    break;
-#endif // defined(SSL_TXT_TLSV1_1)
-#if defined(SSL_TXT_TLSV1_2)
-  case context::tlsv12:
-    handle_ = ::SSL_CTX_new(::TLSv1_2_method());
-    break;
-  case context::tlsv12_client:
-    handle_ = ::SSL_CTX_new(::TLSv1_2_client_method());
-    break;
-  case context::tlsv12_server:
-    handle_ = ::SSL_CTX_new(::TLSv1_2_server_method());
-    break;
-#else // defined(SSL_TXT_TLSV1_2) 
-  case context::tlsv12:
-  case context::tlsv12_client:
-  case context::tlsv12_server:
-    asio::detail::throw_error(
-        asio::error::invalid_argument, "context");
-    break;
-#endif // defined(SSL_TXT_TLSV1_2) 
-  default:
-    handle_ = ::SSL_CTX_new(0);
-    break;
-  }
-
-  if (handle_ == 0)
-  {
-    asio::error_code ec(
-        static_cast<int>(::ERR_get_error()),
-        asio::error::get_ssl_category());
-    asio::detail::throw_error(ec, "context");
-  }
-
-  set_options(no_compression);
-}
-
-context::context(asio::io_service&, context::method m)
-  : handle_(0)
-{
-  context tmp(m);
-  handle_ = tmp.handle_;
-  tmp.handle_ = 0;
-}
-
-#if defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
-context::context(context&& other)
-{
-  handle_ = other.handle_;
-  other.handle_ = 0;
-}
-
-context& context::operator=(context&& other)
-{
-  context tmp(ASIO_MOVE_CAST(context)(*this));
-  handle_ = other.handle_;
-  other.handle_ = 0;
-  return *this;
-}
-#endif // defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
-
-context::~context()
-{
-  if (handle_)
-  {
-    if (handle_->default_passwd_callback_userdata)
-    {
-      detail::password_callback_base* callback =
-        static_cast<detail::password_callback_base*>(
-            handle_->default_passwd_callback_userdata);
-      delete callback;
-      handle_->default_passwd_callback_userdata = 0;
-    }
-
-    if (SSL_CTX_get_app_data(handle_))
-    {
-      detail::verify_callback_base* callback =
-        static_cast<detail::verify_callback_base*>(
-            SSL_CTX_get_app_data(handle_));
-      delete callback;
-      SSL_CTX_set_app_data(handle_, 0);
-    }
-
-    ::SSL_CTX_free(handle_);
-  }
-}
-
-context::native_handle_type context::native_handle()
-{
-  return handle_;
-}
-
-context::impl_type context::impl()
-{
-  return handle_;
-}
-
-void context::clear_options(context::options o)
-{
-  asio::error_code ec;
-  clear_options(o, ec);
-  asio::detail::throw_error(ec, "clear_options");
-}
-
-asio::error_code context::clear_options(
-    context::options o, asio::error_code& ec)
-{
-#if (OPENSSL_VERSION_NUMBER >= 0x009080DFL) \
-  && (OPENSSL_VERSION_NUMBER != 0x00909000L)
-# if !defined(SSL_OP_NO_COMPRESSION)
-  if ((o & context::no_compression) != 0)
-  {
-# if (OPENSSL_VERSION_NUMBER >= 0x00908000L)
-    handle_->comp_methods = SSL_COMP_get_compression_methods();
-# endif // (OPENSSL_VERSION_NUMBER >= 0x00908000L)
-    o ^= context::no_compression;
-  }
-# endif // !defined(SSL_OP_NO_COMPRESSION)
-
-  ::SSL_CTX_clear_options(handle_, o);
-
-  ec = asio::error_code();
-#else // (OPENSSL_VERSION_NUMBER >= 0x009080DFL)
-      //   && (OPENSSL_VERSION_NUMBER != 0x00909000L)
-  (void)o;
-  ec = asio::error::operation_not_supported;
-#endif // (OPENSSL_VERSION_NUMBER >= 0x009080DFL)
-       //   && (OPENSSL_VERSION_NUMBER != 0x00909000L)
-  return ec;
-}
-
-void context::set_options(context::options o)
-{
-  asio::error_code ec;
-  set_options(o, ec);
-  asio::detail::throw_error(ec, "set_options");
-}
-
-asio::error_code context::set_options(
-    context::options o, asio::error_code& ec)
-{
-#if !defined(SSL_OP_NO_COMPRESSION)
-  if ((o & context::no_compression) != 0)
-  {
-#if (OPENSSL_VERSION_NUMBER >= 0x00908000L)
-    handle_->comp_methods =
-      asio::ssl::detail::openssl_init<>::get_null_compression_methods();
-#endif // (OPENSSL_VERSION_NUMBER >= 0x00908000L)
-    o ^= context::no_compression;
-  }
-#endif // !defined(SSL_OP_NO_COMPRESSION)
-
-  ::SSL_CTX_set_options(handle_, o);
-
-  ec = asio::error_code();
-  return ec;
-}
-
-void context::set_verify_mode(verify_mode v)
-{
-  asio::error_code ec;
-  set_verify_mode(v, ec);
-  asio::detail::throw_error(ec, "set_verify_mode");
-}
-
-asio::error_code context::set_verify_mode(
-    verify_mode v, asio::error_code& ec)
-{
-  ::SSL_CTX_set_verify(handle_, v, ::SSL_CTX_get_verify_callback(handle_));
-
-  ec = asio::error_code();
-  return ec;
-}
-
-void context::set_verify_depth(int depth)
-{
-  asio::error_code ec;
-  set_verify_depth(depth, ec);
-  asio::detail::throw_error(ec, "set_verify_depth");
-}
-
-asio::error_code context::set_verify_depth(
-    int depth, asio::error_code& ec)
-{
-  ::SSL_CTX_set_verify_depth(handle_, depth);
-
-  ec = asio::error_code();
-  return ec;
-}
-
-void context::load_verify_file(const std::string& filename)
-{
-  asio::error_code ec;
-  load_verify_file(filename, ec);
-  asio::detail::throw_error(ec, "load_verify_file");
-}
-
-asio::error_code context::load_verify_file(
-    const std::string& filename, asio::error_code& ec)
-{
-  if (::SSL_CTX_load_verify_locations(handle_, filename.c_str(), 0) != 1)
-  {
-    ec = asio::error_code(
-        static_cast<int>(::ERR_get_error()),
-        asio::error::get_ssl_category());
-    return ec;
-  }
-
-  ec = asio::error_code();
-  return ec;
-}
-
-void context::add_certificate_authority(const const_buffer& ca)
-{
-  asio::error_code ec;
-  add_certificate_authority(ca, ec);
-  asio::detail::throw_error(ec, "add_certificate_authority");
-}
-
-asio::error_code context::add_certificate_authority(
-    const const_buffer& ca, asio::error_code& ec)
-{
-  ::ERR_clear_error();
-
-  bio_cleanup bio = { make_buffer_bio(ca) };
-  if (bio.p)
-  {
-    x509_cleanup cert = { ::PEM_read_bio_X509(bio.p, 0, 0, 0) };
-    if (cert.p)
-    {
-      if (X509_STORE* store = ::SSL_CTX_get_cert_store(handle_))
-      {
-        if (::X509_STORE_add_cert(store, cert.p) == 1)
-        {
-          ec = asio::error_code();
-          return ec;
-        }
-      }
-    }
-  }
-
-  ec = asio::error_code(
-      static_cast<int>(::ERR_get_error()),
-      asio::error::get_ssl_category());
-  return ec;
-}
-
-void context::set_default_verify_paths()
-{
-  asio::error_code ec;
-  set_default_verify_paths(ec);
-  asio::detail::throw_error(ec, "set_default_verify_paths");
-}
-
-asio::error_code context::set_default_verify_paths(
-    asio::error_code& ec)
-{
-  if (::SSL_CTX_set_default_verify_paths(handle_) != 1)
-  {
-    ec = asio::error_code(
-        static_cast<int>(::ERR_get_error()),
-        asio::error::get_ssl_category());
-    return ec;
-  }
-
-  ec = asio::error_code();
-  return ec;
-}
-
-void context::add_verify_path(const std::string& path)
-{
-  asio::error_code ec;
-  add_verify_path(path, ec);
-  asio::detail::throw_error(ec, "add_verify_path");
-}
-
-asio::error_code context::add_verify_path(
-    const std::string& path, asio::error_code& ec)
-{
-  if (::SSL_CTX_load_verify_locations(handle_, 0, path.c_str()) != 1)
-  {
-    ec = asio::error_code(
-        static_cast<int>(::ERR_get_error()),
-        asio::error::get_ssl_category());
-    return ec;
-  }
-
-  ec = asio::error_code();
-  return ec;
-}
-
-void context::use_certificate(
-    const const_buffer& certificate, file_format format)
-{
-  asio::error_code ec;
-  use_certificate(certificate, format, ec);
-  asio::detail::throw_error(ec, "use_certificate");
-}
-
-asio::error_code context::use_certificate(
-    const const_buffer& certificate, file_format format,
-    asio::error_code& ec)
-{
-  ::ERR_clear_error();
-
-  if (format == context_base::asn1)
-  {
-    if (::SSL_CTX_use_certificate_ASN1(handle_,
-          static_cast<int>(buffer_size(certificate)),
-          buffer_cast<const unsigned char*>(certificate)) == 1)
-    {
-      ec = asio::error_code();
-      return ec;
-    }
-  }
-  else if (format == context_base::pem)
-  {
-    bio_cleanup bio = { make_buffer_bio(certificate) };
-    if (bio.p)
-    {
-      x509_cleanup cert = { ::PEM_read_bio_X509(bio.p, 0, 0, 0) };
-      if (cert.p)
-      {
-        if (::SSL_CTX_use_certificate(handle_, cert.p) == 1)
-        {
-          ec = asio::error_code();
-          return ec;
-        }
-      }
-    }
-  }
-  else
-  {
-    ec = asio::error::invalid_argument;
-    return ec;
-  }
-
-  ec = asio::error_code(
-      static_cast<int>(::ERR_get_error()),
-      asio::error::get_ssl_category());
-  return ec;
-}
-
-void context::use_certificate_file(
-    const std::string& filename, file_format format)
-{
-  asio::error_code ec;
-  use_certificate_file(filename, format, ec);
-  asio::detail::throw_error(ec, "use_certificate_file");
-}
-
-asio::error_code context::use_certificate_file(
-    const std::string& filename, file_format format,
-    asio::error_code& ec)
-{
-  int file_type;
-  switch (format)
-  {
-  case context_base::asn1:
-    file_type = SSL_FILETYPE_ASN1;
-    break;
-  case context_base::pem:
-    file_type = SSL_FILETYPE_PEM;
-    break;
-  default:
-    {
-      ec = asio::error::invalid_argument;
-      return ec;
-    }
-  }
-
-  if (::SSL_CTX_use_certificate_file(handle_, filename.c_str(), file_type) != 1)
-  {
-    ec = asio::error_code(
-        static_cast<int>(::ERR_get_error()),
-        asio::error::get_ssl_category());
-    return ec;
-  }
-
-  ec = asio::error_code();
-  return ec;
-}
-
-void context::use_certificate_chain(const const_buffer& chain)
-{
-  asio::error_code ec;
-  use_certificate_chain(chain, ec);
-  asio::detail::throw_error(ec, "use_certificate_chain");
-}
-
-asio::error_code context::use_certificate_chain(
-    const const_buffer& chain, asio::error_code& ec)
-{
-  ::ERR_clear_error();
-
-  bio_cleanup bio = { make_buffer_bio(chain) };
-  if (bio.p)
-  {
-    x509_cleanup cert = {
-      ::PEM_read_bio_X509_AUX(bio.p, 0,
-          handle_->default_passwd_callback,
-          handle_->default_passwd_callback_userdata) };
-    if (!cert.p)
-    {
-      ec = asio::error_code(ERR_R_PEM_LIB,
-          asio::error::get_ssl_category());
-      return ec;
-    }
-
-    int result = ::SSL_CTX_use_certificate(handle_, cert.p);
-    if (result == 0 || ::ERR_peek_error() != 0)
-    {
-      ec = asio::error_code(
-          static_cast<int>(::ERR_get_error()),
-          asio::error::get_ssl_category());
-      return ec;
-    }
-
-    if (handle_->extra_certs)
-    {
-      ::sk_X509_pop_free(handle_->extra_certs, X509_free);
-      handle_->extra_certs = 0;
-    }
-
-    while (X509* cacert = ::PEM_read_bio_X509(bio.p, 0,
-          handle_->default_passwd_callback,
-          handle_->default_passwd_callback_userdata))
-    {
-      if (!::SSL_CTX_add_extra_chain_cert(handle_, cacert))
-      {
-        ec = asio::error_code(
-            static_cast<int>(::ERR_get_error()),
-            asio::error::get_ssl_category());
-        return ec;
-      }
-    }
-  
-    result = ::ERR_peek_last_error();
-    if ((ERR_GET_LIB(result) == ERR_LIB_PEM)
-        && (ERR_GET_REASON(result) == PEM_R_NO_START_LINE))
-    {
-      ::ERR_clear_error();
-      ec = asio::error_code();
-      return ec;
-    }
-  }
-
-  ec = asio::error_code(
-      static_cast<int>(::ERR_get_error()),
-      asio::error::get_ssl_category());
-  return ec;
-}
-
-void context::use_certificate_chain_file(const std::string& filename)
-{
-  asio::error_code ec;
-  use_certificate_chain_file(filename, ec);
-  asio::detail::throw_error(ec, "use_certificate_chain_file");
-}
-
-asio::error_code context::use_certificate_chain_file(
-    const std::string& filename, asio::error_code& ec)
-{
-  if (::SSL_CTX_use_certificate_chain_file(handle_, filename.c_str()) != 1)
-  {
-    ec = asio::error_code(
-        static_cast<int>(::ERR_get_error()),
-        asio::error::get_ssl_category());
-    return ec;
-  }
-
-  ec = asio::error_code();
-  return ec;
-}
-
-void context::use_private_key(
-    const const_buffer& private_key, context::file_format format)
-{
-  asio::error_code ec;
-  use_private_key(private_key, format, ec);
-  asio::detail::throw_error(ec, "use_private_key");
-}
-
-asio::error_code context::use_private_key(
-    const const_buffer& private_key, context::file_format format,
-    asio::error_code& ec)
-{
-  ::ERR_clear_error();
-
-  bio_cleanup bio = { make_buffer_bio(private_key) };
-  if (bio.p)
-  {
-    evp_pkey_cleanup evp_private_key = { 0 };
-    switch (format)
-    {
-    case context_base::asn1:
-      evp_private_key.p = ::d2i_PrivateKey_bio(bio.p, 0);
-      break;
-    case context_base::pem:
-      evp_private_key.p = ::PEM_read_bio_PrivateKey(bio.p, 0, 0, 0);
-      break;
-    default:
-      {
-        ec = asio::error::invalid_argument;
-        return ec;
-      }
-    }
-
-    if (evp_private_key.p)
-    {
-      if (::SSL_CTX_use_PrivateKey(handle_, evp_private_key.p) == 1)
-      {
-        ec = asio::error_code();
-        return ec;
-      }
-    }
-  }
-
-  ec = asio::error_code(
-      static_cast<int>(::ERR_get_error()),
-      asio::error::get_ssl_category());
-  return ec;
-}
-
-void context::use_private_key_file(
-    const std::string& filename, context::file_format format)
-{
-  asio::error_code ec;
-  use_private_key_file(filename, format, ec);
-  asio::detail::throw_error(ec, "use_private_key_file");
-}
-
-void context::use_rsa_private_key(
-    const const_buffer& private_key, context::file_format format)
-{
-  asio::error_code ec;
-  use_rsa_private_key(private_key, format, ec);
-  asio::detail::throw_error(ec, "use_rsa_private_key");
-}
-
-asio::error_code context::use_rsa_private_key(
-    const const_buffer& private_key, context::file_format format,
-    asio::error_code& ec)
-{
-  ::ERR_clear_error();
-
-  bio_cleanup bio = { make_buffer_bio(private_key) };
-  if (bio.p)
-  {
-    rsa_cleanup rsa_private_key = { 0 };
-    switch (format)
-    {
-    case context_base::asn1:
-      rsa_private_key.p = ::d2i_RSAPrivateKey_bio(bio.p, 0);
-      break;
-    case context_base::pem:
-      rsa_private_key.p = ::PEM_read_bio_RSAPrivateKey(bio.p, 0, 0, 0);
-      break;
-    default:
-      {
-        ec = asio::error::invalid_argument;
-        return ec;
-      }
-    }
-
-    if (rsa_private_key.p)
-    {
-      if (::SSL_CTX_use_RSAPrivateKey(handle_, rsa_private_key.p) == 1)
-      {
-        ec = asio::error_code();
-        return ec;
-      }
-    }
-  }
-
-  ec = asio::error_code(
-      static_cast<int>(::ERR_get_error()),
-      asio::error::get_ssl_category());
-  return ec;
-}
-
-asio::error_code context::use_private_key_file(
-    const std::string& filename, context::file_format format,
-    asio::error_code& ec)
-{
-  int file_type;
-  switch (format)
-  {
-  case context_base::asn1:
-    file_type = SSL_FILETYPE_ASN1;
-    break;
-  case context_base::pem:
-    file_type = SSL_FILETYPE_PEM;
-    break;
-  default:
-    {
-      ec = asio::error::invalid_argument;
-      return ec;
-    }
-  }
-
-  if (::SSL_CTX_use_PrivateKey_file(handle_, filename.c_str(), file_type) != 1)
-  {
-    ec = asio::error_code(
-        static_cast<int>(::ERR_get_error()),
-        asio::error::get_ssl_category());
-    return ec;
-  }
-
-  ec = asio::error_code();
-  return ec;
-}
-
-void context::use_rsa_private_key_file(
-    const std::string& filename, context::file_format format)
-{
-  asio::error_code ec;
-  use_rsa_private_key_file(filename, format, ec);
-  asio::detail::throw_error(ec, "use_rsa_private_key_file");
-}
-
-asio::error_code context::use_rsa_private_key_file(
-    const std::string& filename, context::file_format format,
-    asio::error_code& ec)
-{
-  int file_type;
-  switch (format)
-  {
-  case context_base::asn1:
-    file_type = SSL_FILETYPE_ASN1;
-    break;
-  case context_base::pem:
-    file_type = SSL_FILETYPE_PEM;
-    break;
-  default:
-    {
-      ec = asio::error::invalid_argument;
-      return ec;
-    }
-  }
-
-  if (::SSL_CTX_use_RSAPrivateKey_file(
-        handle_, filename.c_str(), file_type) != 1)
-  {
-    ec = asio::error_code(
-        static_cast<int>(::ERR_get_error()),
-        asio::error::get_ssl_category());
-    return ec;
-  }
-
-  ec = asio::error_code();
-  return ec;
-}
-
-void context::use_tmp_dh(const const_buffer& dh)
-{
-  asio::error_code ec;
-  use_tmp_dh(dh, ec);
-  asio::detail::throw_error(ec, "use_tmp_dh");
-}
-
-asio::error_code context::use_tmp_dh(
-    const const_buffer& dh, asio::error_code& ec)
-{
-  bio_cleanup bio = { make_buffer_bio(dh) };
-  if (bio.p)
-  {
-    return do_use_tmp_dh(bio.p, ec);
-  }
-
-  ec = asio::error_code(
-      static_cast<int>(::ERR_get_error()),
-      asio::error::get_ssl_category());
-  return ec;
-}
-
-void context::use_tmp_dh_file(const std::string& filename)
-{
-  asio::error_code ec;
-  use_tmp_dh_file(filename, ec);
-  asio::detail::throw_error(ec, "use_tmp_dh_file");
-}
-
-asio::error_code context::use_tmp_dh_file(
-    const std::string& filename, asio::error_code& ec)
-{
-  bio_cleanup bio = { ::BIO_new_file(filename.c_str(), "r") };
-  if (bio.p)
-  {
-    return do_use_tmp_dh(bio.p, ec);
-  }
-
-  ec = asio::error_code(
-      static_cast<int>(::ERR_get_error()),
-      asio::error::get_ssl_category());
-  return ec;
-}
-
-asio::error_code context::do_use_tmp_dh(
-    BIO* bio, asio::error_code& ec)
-{
-  ::ERR_clear_error();
-
-  dh_cleanup dh = { ::PEM_read_bio_DHparams(bio, 0, 0, 0) };
-  if (dh.p)
-  {
-    if (::SSL_CTX_set_tmp_dh(handle_, dh.p) == 1)
-    {
-      ec = asio::error_code();
-      return ec;
-    }
-  }
-
-  ec = asio::error_code(
-      static_cast<int>(::ERR_get_error()),
-      asio::error::get_ssl_category());
-  return ec;
-}
-
-asio::error_code context::do_set_verify_callback(
-    detail::verify_callback_base* callback, asio::error_code& ec)
-{
-  if (SSL_CTX_get_app_data(handle_))
-  {
-    delete static_cast<detail::verify_callback_base*>(
-        SSL_CTX_get_app_data(handle_));
-  }
-
-  SSL_CTX_set_app_data(handle_, callback);
-
-  ::SSL_CTX_set_verify(handle_,
-      ::SSL_CTX_get_verify_mode(handle_),
-      &context::verify_callback_function);
-
-  ec = asio::error_code();
-  return ec;
-}
-
-int context::verify_callback_function(int preverified, X509_STORE_CTX* ctx)
-{
-  if (ctx)
-  {
-    if (SSL* ssl = static_cast<SSL*>(
-          ::X509_STORE_CTX_get_ex_data(
-            ctx, ::SSL_get_ex_data_X509_STORE_CTX_idx())))
-    {
-      if (SSL_CTX* handle = ::SSL_get_SSL_CTX(ssl))
-      {
-        if (SSL_CTX_get_app_data(handle))
-        {
-          detail::verify_callback_base* callback =
-            static_cast<detail::verify_callback_base*>(
-                SSL_CTX_get_app_data(handle));
-
-          verify_context verify_ctx(ctx);
-          return callback->call(preverified != 0, verify_ctx) ? 1 : 0;
-        }
-      }
-    }
-  }
-
-  return 0;
-}
-
-asio::error_code context::do_set_password_callback(
-    detail::password_callback_base* callback, asio::error_code& ec)
-{
-  if (handle_->default_passwd_callback_userdata)
-    delete static_cast<detail::password_callback_base*>(
-        handle_->default_passwd_callback_userdata);
-
-  handle_->default_passwd_callback_userdata = callback;
-
-  SSL_CTX_set_default_passwd_cb(handle_, &context::password_callback_function);
-
-  ec = asio::error_code();
-  return ec;
-}
-
-int context::password_callback_function(
-    char* buf, int size, int purpose, void* data)
-{
-  using namespace std; // For strncat and strlen.
-
-  if (data)
-  {
-    detail::password_callback_base* callback =
-      static_cast<detail::password_callback_base*>(data);
-
-    std::string passwd = callback->call(static_cast<std::size_t>(size),
-        purpose ? context_base::for_writing : context_base::for_reading);
-
-#if defined(ASIO_HAS_SECURE_RTL)
-    strcpy_s(buf, size, passwd.c_str());
-#else // defined(ASIO_HAS_SECURE_RTL)
-    *buf = '\0';
-    strncat(buf, passwd.c_str(), size);
-#endif // defined(ASIO_HAS_SECURE_RTL)
-
-    return static_cast<int>(strlen(buf));
-  }
-
-  return 0;
-}
-
-BIO* context::make_buffer_bio(const const_buffer& b)
-{
-  return ::BIO_new_mem_buf(
-      const_cast<void*>(buffer_cast<const void*>(b)),
-      static_cast<int>(buffer_size(b)));
-}
-
-#endif // !defined(ASIO_ENABLE_OLD_SSL)
-
-} // namespace ssl
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_SSL_IMPL_CONTEXT_IPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/impl/error.ipp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/impl/error.ipp
deleted file mode 100644
index 93626f11a8bd..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/impl/error.ipp
+++ /dev/null
@@ -1,57 +0,0 @@
-//
-// ssl/impl/error.ipp
-// ~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_SSL_IMPL_ERROR_IPP
-#define ASIO_SSL_IMPL_ERROR_IPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include "asio/ssl/error.hpp"
-#include "asio/ssl/detail/openssl_init.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace error {
-
-namespace detail {
-
-class ssl_category : public asio::error_category
-{
-public:
-  const char* name() const ASIO_ERROR_CATEGORY_NOEXCEPT
-  {
-    return "asio.ssl";
-  }
-
-  std::string message(int value) const
-  {
-    const char* s = ::ERR_reason_error_string(value);
-    return s ? s : "asio.ssl error";
-  }
-};
-
-} // namespace detail
-
-const asio::error_category& get_ssl_category()
-{
-  static detail::ssl_category instance;
-  return instance;
-}
-
-} // namespace error
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_SSL_IMPL_ERROR_IPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/impl/rfc2818_verification.ipp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/impl/rfc2818_verification.ipp
deleted file mode 100644
index 86cb23dea80a..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/impl/rfc2818_verification.ipp
+++ /dev/null
@@ -1,166 +0,0 @@
-//
-// ssl/impl/rfc2818_verification.ipp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_SSL_IMPL_RFC2818_VERIFICATION_IPP
-#define ASIO_SSL_IMPL_RFC2818_VERIFICATION_IPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if !defined(ASIO_ENABLE_OLD_SSL)
-# include <cctype>
-# include <cstring>
-# include "asio/ip/address.hpp"
-# include "asio/ssl/rfc2818_verification.hpp"
-# include "asio/ssl/detail/openssl_types.hpp"
-#endif // !defined(ASIO_ENABLE_OLD_SSL)
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace ssl {
-
-#if !defined(ASIO_ENABLE_OLD_SSL)
-
-bool rfc2818_verification::operator()(
-    bool preverified, verify_context& ctx) const
-{
-  using namespace std; // For memcmp.
-
-  // Don't bother looking at certificates that have failed pre-verification.
-  if (!preverified)
-    return false;
-
-  // We're only interested in checking the certificate at the end of the chain.
-  int depth = X509_STORE_CTX_get_error_depth(ctx.native_handle());
-  if (depth > 0)
-    return true;
-
-  // Try converting the host name to an address. If it is an address then we
-  // need to look for an IP address in the certificate rather than a host name.
-  asio::error_code ec;
-  ip::address address = ip::address::from_string(host_, ec);
-  bool is_address = !ec;
-
-  X509* cert = X509_STORE_CTX_get_current_cert(ctx.native_handle());
-
-  // Go through the alternate names in the certificate looking for matching DNS
-  // or IP address entries.
-  GENERAL_NAMES* gens = static_cast<GENERAL_NAMES*>(
-      X509_get_ext_d2i(cert, NID_subject_alt_name, 0, 0));
-  for (int i = 0; i < sk_GENERAL_NAME_num(gens); ++i)
-  {
-    GENERAL_NAME* gen = sk_GENERAL_NAME_value(gens, i);
-    if (gen->type == GEN_DNS && !is_address)
-    {
-      ASN1_IA5STRING* domain = gen->d.dNSName;
-      if (domain->type == V_ASN1_IA5STRING && domain->data && domain->length)
-      {
-        const char* pattern = reinterpret_cast<const char*>(domain->data);
-        std::size_t pattern_length = domain->length;
-        if (match_pattern(pattern, pattern_length, host_.c_str()))
-        {
-          GENERAL_NAMES_free(gens);
-          return true;
-        }
-      }
-    }
-    else if (gen->type == GEN_IPADD && is_address)
-    {
-      ASN1_OCTET_STRING* ip_address = gen->d.iPAddress;
-      if (ip_address->type == V_ASN1_OCTET_STRING && ip_address->data)
-      {
-        if (address.is_v4() && ip_address->length == 4)
-        {
-          ip::address_v4::bytes_type bytes = address.to_v4().to_bytes();
-          if (memcmp(bytes.data(), ip_address->data, 4) == 0)
-          {
-            GENERAL_NAMES_free(gens);
-            return true;
-          }
-        }
-        else if (address.is_v6() && ip_address->length == 16)
-        {
-          ip::address_v6::bytes_type bytes = address.to_v6().to_bytes();
-          if (memcmp(bytes.data(), ip_address->data, 16) == 0)
-          {
-            GENERAL_NAMES_free(gens);
-            return true;
-          }
-        }
-      }
-    }
-  }
-  GENERAL_NAMES_free(gens);
-
-  // No match in the alternate names, so try the common names. We should only
-  // use the "most specific" common name, which is the last one in the list.
-  X509_NAME* name = X509_get_subject_name(cert);
-  int i = -1;
-  ASN1_STRING* common_name = 0;
-  while ((i = X509_NAME_get_index_by_NID(name, NID_commonName, i)) >= 0)
-  {
-    X509_NAME_ENTRY* name_entry = X509_NAME_get_entry(name, i);
-    common_name = X509_NAME_ENTRY_get_data(name_entry);
-  }
-  if (common_name && common_name->data && common_name->length)
-  {
-    const char* pattern = reinterpret_cast<const char*>(common_name->data);
-    std::size_t pattern_length = common_name->length;
-    if (match_pattern(pattern, pattern_length, host_.c_str()))
-      return true;
-  }
-
-  return false;
-}
-
-bool rfc2818_verification::match_pattern(const char* pattern,
-    std::size_t pattern_length, const char* host)
-{
-  using namespace std; // For tolower.
-
-  const char* p = pattern;
-  const char* p_end = p + pattern_length;
-  const char* h = host;
-
-  while (p != p_end && *h)
-  {
-    if (*p == '*')
-    {
-      ++p;
-      while (*h && *h != '.')
-        if (match_pattern(p, p_end - p, h++))
-          return true;
-    }
-    else if (tolower(*p) == tolower(*h))
-    {
-      ++p;
-      ++h;
-    }
-    else
-    {
-      return false;
-    }
-  }
-
-  return p == p_end && !*h;
-}
-
-#endif // !defined(ASIO_ENABLE_OLD_SSL)
-
-} // namespace ssl
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_SSL_IMPL_RFC2818_VERIFICATION_IPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/impl/src.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/impl/src.hpp
deleted file mode 100644
index 43fd9090a0de..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/impl/src.hpp
+++ /dev/null
@@ -1,28 +0,0 @@
-//
-// impl/ssl/src.hpp
-// ~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_SSL_IMPL_SRC_HPP
-#define ASIO_SSL_IMPL_SRC_HPP
-
-#define ASIO_SOURCE
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_HEADER_ONLY)
-# error Do not compile Asio library source with ASIO_HEADER_ONLY defined
-#endif
-
-#include "asio/ssl/impl/context.ipp"
-#include "asio/ssl/impl/error.ipp"
-#include "asio/ssl/detail/impl/engine.ipp"
-#include "asio/ssl/detail/impl/openssl_init.ipp"
-#include "asio/ssl/impl/rfc2818_verification.ipp"
-
-#endif // ASIO_SSL_IMPL_SRC_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/old/basic_context.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/old/basic_context.hpp
deleted file mode 100644
index f53fddd45600..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/old/basic_context.hpp
+++ /dev/null
@@ -1,434 +0,0 @@
-//
-// ssl/old/basic_context.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2005 Voipster / Indrek dot Juhani at voipster dot com
-// Copyright (c) 2005-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_SSL_OLD_BASIC_CONTEXT_HPP
-#define ASIO_SSL_OLD_BASIC_CONTEXT_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include <string>
-#include <boost/noncopyable.hpp>
-#include "asio/detail/throw_error.hpp"
-#include "asio/error.hpp"
-#include "asio/io_service.hpp"
-#include "asio/ssl/context_base.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace ssl {
-namespace old {
-
-/// SSL context.
-template <typename Service>
-class basic_context
-  : public context_base,
-    private boost::noncopyable
-{
-public:
-  /// The type of the service that will be used to provide context operations.
-  typedef Service service_type;
-
-  /// The native implementation type of the SSL context.
-  typedef typename service_type::impl_type impl_type;
-
-  /// Constructor.
-  basic_context(asio::io_service& io_service, method m)
-    : service_(asio::use_service<Service>(io_service)),
-      impl_(service_.null())
-  {
-    service_.create(impl_, m);
-  }
-
-  /// Destructor.
-  ~basic_context()
-  {
-    service_.destroy(impl_);
-  }
-
-  /// Get the underlying implementation in the native type.
-  /**
-   * This function may be used to obtain the underlying implementation of the
-   * context. This is intended to allow access to context functionality that is
-   * not otherwise provided.
-   */
-  impl_type impl()
-  {
-    return impl_;
-  }
-
-  /// Set options on the context.
-  /**
-   * This function may be used to configure the SSL options used by the context.
-   *
-   * @param o A bitmask of options. The available option values are defined in
-   * the context_base class. The options are bitwise-ored with any existing
-   * value for the options.
-   *
-   * @throws asio::system_error Thrown on failure.
-   */
-  void set_options(options o)
-  {
-    asio::error_code ec;
-    service_.set_options(impl_, o, ec);
-    asio::detail::throw_error(ec);
-  }
-
-  /// Set options on the context.
-  /**
-   * This function may be used to configure the SSL options used by the context.
-   *
-   * @param o A bitmask of options. The available option values are defined in
-   * the context_base class. The options are bitwise-ored with any existing
-   * value for the options.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   */
-  asio::error_code set_options(options o,
-      asio::error_code& ec)
-  {
-    return service_.set_options(impl_, o, ec);
-  }
-
-  /// Set the peer verification mode.
-  /**
-   * This function may be used to configure the peer verification mode used by
-   * the context.
-   *
-   * @param v A bitmask of peer verification modes. The available verify_mode
-   * values are defined in the context_base class.
-   *
-   * @throws asio::system_error Thrown on failure.
-   */
-  void set_verify_mode(verify_mode v)
-  {
-    asio::error_code ec;
-    service_.set_verify_mode(impl_, v, ec);
-    asio::detail::throw_error(ec);
-  }
-
-  /// Set the peer verification mode.
-  /**
-   * This function may be used to configure the peer verification mode used by
-   * the context.
-   *
-   * @param v A bitmask of peer verification modes. The available verify_mode
-   * values are defined in the context_base class.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   */
-  asio::error_code set_verify_mode(verify_mode v,
-      asio::error_code& ec)
-  {
-    return service_.set_verify_mode(impl_, v, ec);
-  }
-
-  /// Load a certification authority file for performing verification.
-  /**
-   * This function is used to load one or more trusted certification authorities
-   * from a file.
-   *
-   * @param filename The name of a file containing certification authority
-   * certificates in PEM format.
-   *
-   * @throws asio::system_error Thrown on failure.
-   */
-  void load_verify_file(const std::string& filename)
-  {
-    asio::error_code ec;
-    service_.load_verify_file(impl_, filename, ec);
-    asio::detail::throw_error(ec);
-  }
-
-  /// Load a certification authority file for performing verification.
-  /**
-   * This function is used to load the certificates for one or more trusted
-   * certification authorities from a file.
-   *
-   * @param filename The name of a file containing certification authority
-   * certificates in PEM format.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   */
-  asio::error_code load_verify_file(const std::string& filename,
-      asio::error_code& ec)
-  {
-    return service_.load_verify_file(impl_, filename, ec);
-  }
-
-  /// Add a directory containing certificate authority files to be used for
-  /// performing verification.
-  /**
-   * This function is used to specify the name of a directory containing
-   * certification authority certificates. Each file in the directory must
-   * contain a single certificate. The files must be named using the subject
-   * name's hash and an extension of ".0".
-   *
-   * @param path The name of a directory containing the certificates.
-   *
-   * @throws asio::system_error Thrown on failure.
-   */
-  void add_verify_path(const std::string& path)
-  {
-    asio::error_code ec;
-    service_.add_verify_path(impl_, path, ec);
-    asio::detail::throw_error(ec);
-  }
-
-  /// Add a directory containing certificate authority files to be used for
-  /// performing verification.
-  /**
-   * This function is used to specify the name of a directory containing
-   * certification authority certificates. Each file in the directory must
-   * contain a single certificate. The files must be named using the subject
-   * name's hash and an extension of ".0".
-   *
-   * @param path The name of a directory containing the certificates.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   */
-  asio::error_code add_verify_path(const std::string& path,
-      asio::error_code& ec)
-  {
-    return service_.add_verify_path(impl_, path, ec);
-  }
-
-  /// Use a certificate from a file.
-  /**
-   * This function is used to load a certificate into the context from a file.
-   *
-   * @param filename The name of the file containing the certificate.
-   *
-   * @param format The file format (ASN.1 or PEM).
-   *
-   * @throws asio::system_error Thrown on failure.
-   */
-  void use_certificate_file(const std::string& filename, file_format format)
-  {
-    asio::error_code ec;
-    service_.use_certificate_file(impl_, filename, format, ec);
-    asio::detail::throw_error(ec);
-  }
-
-  /// Use a certificate from a file.
-  /**
-   * This function is used to load a certificate into the context from a file.
-   *
-   * @param filename The name of the file containing the certificate.
-   *
-   * @param format The file format (ASN.1 or PEM).
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   */
-  asio::error_code use_certificate_file(const std::string& filename,
-      file_format format, asio::error_code& ec)
-  {
-    return service_.use_certificate_file(impl_, filename, format, ec);
-  }
-
-  /// Use a certificate chain from a file.
-  /**
-   * This function is used to load a certificate chain into the context from a
-   * file.
-   *
-   * @param filename The name of the file containing the certificate. The file
-   * must use the PEM format.
-   *
-   * @throws asio::system_error Thrown on failure.
-   */
-  void use_certificate_chain_file(const std::string& filename)
-  {
-    asio::error_code ec;
-    service_.use_certificate_chain_file(impl_, filename, ec);
-    asio::detail::throw_error(ec);
-  }
-
-  /// Use a certificate chain from a file.
-  /**
-   * This function is used to load a certificate chain into the context from a
-   * file.
-   *
-   * @param filename The name of the file containing the certificate. The file
-   * must use the PEM format.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   */
-  asio::error_code use_certificate_chain_file(
-      const std::string& filename, asio::error_code& ec)
-  {
-    return service_.use_certificate_chain_file(impl_, filename, ec);
-  }
-
-  /// Use a private key from a file.
-  /**
-   * This function is used to load a private key into the context from a file.
-   *
-   * @param filename The name of the file containing the private key.
-   *
-   * @param format The file format (ASN.1 or PEM).
-   *
-   * @throws asio::system_error Thrown on failure.
-   */
-  void use_private_key_file(const std::string& filename, file_format format)
-  {
-    asio::error_code ec;
-    service_.use_private_key_file(impl_, filename, format, ec);
-    asio::detail::throw_error(ec);
-  }
-
-  /// Use a private key from a file.
-  /**
-   * This function is used to load a private key into the context from a file.
-   *
-   * @param filename The name of the file containing the private key.
-   *
-   * @param format The file format (ASN.1 or PEM).
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   */
-  asio::error_code use_private_key_file(const std::string& filename,
-      file_format format, asio::error_code& ec)
-  {
-    return service_.use_private_key_file(impl_, filename, format, ec);
-  }
-
-  /// Use an RSA private key from a file.
-  /**
-   * This function is used to load an RSA private key into the context from a
-   * file.
-   *
-   * @param filename The name of the file containing the RSA private key.
-   *
-   * @param format The file format (ASN.1 or PEM).
-   *
-   * @throws asio::system_error Thrown on failure.
-   */
-  void use_rsa_private_key_file(const std::string& filename, file_format format)
-  {
-    asio::error_code ec;
-    service_.use_rsa_private_key_file(impl_, filename, format, ec);
-    asio::detail::throw_error(ec);
-  }
-
-  /// Use an RSA private key from a file.
-  /**
-   * This function is used to load an RSA private key into the context from a
-   * file.
-   *
-   * @param filename The name of the file containing the RSA private key.
-   *
-   * @param format The file format (ASN.1 or PEM).
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   */
-  asio::error_code use_rsa_private_key_file(
-      const std::string& filename, file_format format,
-      asio::error_code& ec)
-  {
-    return service_.use_rsa_private_key_file(impl_, filename, format, ec);
-  }
-
-  /// Use the specified file to obtain the temporary Diffie-Hellman parameters.
-  /**
-   * This function is used to load Diffie-Hellman parameters into the context
-   * from a file.
-   *
-   * @param filename The name of the file containing the Diffie-Hellman
-   * parameters. The file must use the PEM format.
-   *
-   * @throws asio::system_error Thrown on failure.
-   */
-  void use_tmp_dh_file(const std::string& filename)
-  {
-    asio::error_code ec;
-    service_.use_tmp_dh_file(impl_, filename, ec);
-    asio::detail::throw_error(ec);
-  }
-
-  /// Use the specified file to obtain the temporary Diffie-Hellman parameters.
-  /**
-   * This function is used to load Diffie-Hellman parameters into the context
-   * from a file.
-   *
-   * @param filename The name of the file containing the Diffie-Hellman
-   * parameters. The file must use the PEM format.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   */
-  asio::error_code use_tmp_dh_file(const std::string& filename,
-      asio::error_code& ec)
-  {
-    return service_.use_tmp_dh_file(impl_, filename, ec);
-  }
-
-  /// Set the password callback.
-  /**
-   * This function is used to specify a callback function to obtain password
-   * information about an encrypted key in PEM format.
-   *
-   * @param callback The function object to be used for obtaining the password.
-   * The function signature of the handler must be:
-   * @code std::string password_callback(
-   *   std::size_t max_length,  // The maximum size for a password.
-   *   password_purpose purpose // Whether password is for reading or writing.
-   * ); @endcode
-   * The return value of the callback is a string containing the password.
-   *
-   * @throws asio::system_error Thrown on failure.
-   */
-  template <typename PasswordCallback>
-  void set_password_callback(PasswordCallback callback)
-  {
-    asio::error_code ec;
-    service_.set_password_callback(impl_, callback, ec);
-    asio::detail::throw_error(ec);
-  }
-
-  /// Set the password callback.
-  /**
-   * This function is used to specify a callback function to obtain password
-   * information about an encrypted key in PEM format.
-   *
-   * @param callback The function object to be used for obtaining the password.
-   * The function signature of the handler must be:
-   * @code std::string password_callback(
-   *   std::size_t max_length,  // The maximum size for a password.
-   *   password_purpose purpose // Whether password is for reading or writing.
-   * ); @endcode
-   * The return value of the callback is a string containing the password.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   */
-  template <typename PasswordCallback>
-  asio::error_code set_password_callback(PasswordCallback callback,
-      asio::error_code& ec)
-  {
-    return service_.set_password_callback(impl_, callback, ec);
-  }
-
-private:
-  /// The backend service implementation.
-  service_type& service_;
-
-  /// The underlying native implementation.
-  impl_type impl_;
-};
-
-} // namespace old
-} // namespace ssl
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_SSL_OLD_BASIC_CONTEXT_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/old/context_service.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/old/context_service.hpp
deleted file mode 100644
index 34928aab0310..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/old/context_service.hpp
+++ /dev/null
@@ -1,174 +0,0 @@
-//
-// ssl/old/context_service.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2005 Voipster / Indrek dot Juhani at voipster dot com
-// Copyright (c) 2005-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_SSL_OLD_CONTEXT_SERVICE_HPP
-#define ASIO_SSL_OLD_CONTEXT_SERVICE_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include <string>
-#include <boost/noncopyable.hpp>
-#include "asio/error.hpp"
-#include "asio/io_service.hpp"
-#include "asio/ssl/context_base.hpp"
-#include "asio/ssl/old/detail/openssl_context_service.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace ssl {
-namespace old {
-
-/// Default service implementation for a context.
-class context_service
-#if defined(GENERATING_DOCUMENTATION)
-  : public asio::io_service::service
-#else
-  : public asio::detail::service_base<context_service>
-#endif
-{
-private:
-  // The type of the platform-specific implementation.
-  typedef old::detail::openssl_context_service service_impl_type;
-
-public:
-#if defined(GENERATING_DOCUMENTATION)
-  /// The unique service identifier.
-  static asio::io_service::id id;
-#endif
-
-  /// The type of the context.
-#if defined(GENERATING_DOCUMENTATION)
-  typedef implementation_defined impl_type;
-#else
-  typedef service_impl_type::impl_type impl_type;
-#endif
-
-  /// Constructor.
-  explicit context_service(asio::io_service& io_service)
-    : asio::detail::service_base<context_service>(io_service),
-      service_impl_(asio::use_service<service_impl_type>(io_service))
-  {
-  }
-
-  /// Return a null context implementation.
-  impl_type null() const
-  {
-    return service_impl_.null();
-  }
-
-  /// Create a new context implementation.
-  void create(impl_type& impl, context_base::method m)
-  {
-    service_impl_.create(impl, m);
-  }
-
-  /// Destroy a context implementation.
-  void destroy(impl_type& impl)
-  {
-    service_impl_.destroy(impl);
-  }
-
-  /// Set options on the context.
-  asio::error_code set_options(impl_type& impl,
-      context_base::options o, asio::error_code& ec)
-  {
-    return service_impl_.set_options(impl, o, ec);
-  }
-
-  /// Set peer verification mode.
-  asio::error_code set_verify_mode(impl_type& impl,
-      context_base::verify_mode v, asio::error_code& ec)
-  {
-    return service_impl_.set_verify_mode(impl, v, ec);
-  }
-
-  /// Load a certification authority file for performing verification.
-  asio::error_code load_verify_file(impl_type& impl,
-      const std::string& filename, asio::error_code& ec)
-  {
-    return service_impl_.load_verify_file(impl, filename, ec);
-  }
-
-  /// Add a directory containing certification authority files to be used for
-  /// performing verification.
-  asio::error_code add_verify_path(impl_type& impl,
-      const std::string& path, asio::error_code& ec)
-  {
-    return service_impl_.add_verify_path(impl, path, ec);
-  }
-
-  /// Use a certificate from a file.
-  asio::error_code use_certificate_file(impl_type& impl,
-      const std::string& filename, context_base::file_format format,
-      asio::error_code& ec)
-  {
-    return service_impl_.use_certificate_file(impl, filename, format, ec);
-  }
-
-  /// Use a certificate chain from a file.
-  asio::error_code use_certificate_chain_file(impl_type& impl,
-      const std::string& filename, asio::error_code& ec)
-  {
-    return service_impl_.use_certificate_chain_file(impl, filename, ec);
-  }
-
-  /// Use a private key from a file.
-  asio::error_code use_private_key_file(impl_type& impl,
-      const std::string& filename, context_base::file_format format,
-      asio::error_code& ec)
-  {
-    return service_impl_.use_private_key_file(impl, filename, format, ec);
-  }
-
-  /// Use an RSA private key from a file.
-  asio::error_code use_rsa_private_key_file(impl_type& impl,
-      const std::string& filename, context_base::file_format format,
-      asio::error_code& ec)
-  {
-    return service_impl_.use_rsa_private_key_file(impl, filename, format, ec);
-  }
-
-  /// Use the specified file to obtain the temporary Diffie-Hellman parameters.
-  asio::error_code use_tmp_dh_file(impl_type& impl,
-      const std::string& filename, asio::error_code& ec)
-  {
-    return service_impl_.use_tmp_dh_file(impl, filename, ec);
-  }
-
-  /// Set the password callback.
-  template <typename PasswordCallback>
-  asio::error_code set_password_callback(impl_type& impl,
-      PasswordCallback callback, asio::error_code& ec)
-  {
-    return service_impl_.set_password_callback(impl, callback, ec);
-  }
-
-private:
-  // Destroy all user-defined handler objects owned by the service.
-  void shutdown_service()
-  {
-  }
-
-  // The service that provides the platform-specific implementation.
-  service_impl_type& service_impl_;
-};
-
-} // namespace old
-} // namespace ssl
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_SSL_OLD_CONTEXT_SERVICE_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/old/detail/openssl_context_service.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/old/detail/openssl_context_service.hpp
deleted file mode 100644
index 941ad26d564d..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/old/detail/openssl_context_service.hpp
+++ /dev/null
@@ -1,386 +0,0 @@
-//
-// ssl/old/detail/openssl_context_service.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2005 Voipster / Indrek dot Juhani at voipster dot com
-// Copyright (c) 2005-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_SSL_OLD_DETAIL_OPENSSL_CONTEXT_SERVICE_HPP
-#define ASIO_SSL_OLD_DETAIL_OPENSSL_CONTEXT_SERVICE_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include <cstring>
-#include <string>
-#include <boost/function.hpp>
-#include "asio/detail/throw_error.hpp"
-#include "asio/error.hpp"
-#include "asio/io_service.hpp"
-#include "asio/ssl/context_base.hpp"
-#include "asio/ssl/detail/openssl_init.hpp"
-#include "asio/ssl/detail/openssl_types.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace ssl {
-namespace old {
-namespace detail {
-
-class openssl_context_service
-  : public asio::detail::service_base<openssl_context_service>
-{
-public:
-  // The native type of the context.
-  typedef ::SSL_CTX* impl_type;
-
-  // The type for the password callback function object.
-  typedef boost::function<std::string(std::size_t,
-      context_base::password_purpose)> password_callback_type;
-
-  // Constructor.
-  openssl_context_service(asio::io_service& io_service)
-    : asio::detail::service_base<openssl_context_service>(io_service)
-  {
-  }
-
-  // Destroy all user-defined handler objects owned by the service.
-  void shutdown_service()
-  {
-  }
-
-  // Return a null context implementation.
-  static impl_type null()
-  {
-    return 0;
-  }
-
-  // Create a new context implementation.
-  void create(impl_type& impl, context_base::method m)
-  {
-    switch (m)
-    {
-#if defined(OPENSSL_NO_SSL2)
-    case context_base::sslv2:
-    case context_base::sslv2_client:
-    case context_base::sslv2_server:
-      asio::detail::throw_error(asio::error::invalid_argument);
-      break;
-#else // defined(OPENSSL_NO_SSL2)
-    case context_base::sslv2:
-      impl = ::SSL_CTX_new(::SSLv2_method());
-      break;
-    case context_base::sslv2_client:
-      impl = ::SSL_CTX_new(::SSLv2_client_method());
-      break;
-    case context_base::sslv2_server:
-      impl = ::SSL_CTX_new(::SSLv2_server_method());
-      break;
-#endif // defined(OPENSSL_NO_SSL2)
-    case context_base::sslv3:
-      impl = ::SSL_CTX_new(::SSLv3_method());
-      break;
-    case context_base::sslv3_client:
-      impl = ::SSL_CTX_new(::SSLv3_client_method());
-      break;
-    case context_base::sslv3_server:
-      impl = ::SSL_CTX_new(::SSLv3_server_method());
-      break;
-    case context_base::tlsv1:
-      impl = ::SSL_CTX_new(::TLSv1_method());
-      break;
-    case context_base::tlsv1_client:
-      impl = ::SSL_CTX_new(::TLSv1_client_method());
-      break;
-    case context_base::tlsv1_server:
-      impl = ::SSL_CTX_new(::TLSv1_server_method());
-      break;
-    case context_base::sslv23:
-      impl = ::SSL_CTX_new(::SSLv23_method());
-      break;
-    case context_base::sslv23_client:
-      impl = ::SSL_CTX_new(::SSLv23_client_method());
-      break;
-    case context_base::sslv23_server:
-      impl = ::SSL_CTX_new(::SSLv23_server_method());
-      break;
-    default:
-      impl = ::SSL_CTX_new(0);
-      break;
-    }
-  }
-
-  // Destroy a context implementation.
-  void destroy(impl_type& impl)
-  {
-    if (impl != null())
-    {
-      if (impl->default_passwd_callback_userdata)
-      {
-        password_callback_type* callback =
-          static_cast<password_callback_type*>(
-              impl->default_passwd_callback_userdata);
-        delete callback;
-        impl->default_passwd_callback_userdata = 0;
-      }
-
-      ::SSL_CTX_free(impl);
-      impl = null();
-    }
-  }
-
-  // Set options on the context.
-  asio::error_code set_options(impl_type& impl,
-      context_base::options o, asio::error_code& ec)
-  {
-    ::SSL_CTX_set_options(impl, o);
-
-    ec = asio::error_code();
-    return ec;
-  }
-
-  // Set peer verification mode.
-  asio::error_code set_verify_mode(impl_type& impl,
-      context_base::verify_mode v, asio::error_code& ec)
-  {
-    ::SSL_CTX_set_verify(impl, v, 0);
-
-    ec = asio::error_code();
-    return ec;
-  }
-
-  // Load a certification authority file for performing verification.
-  asio::error_code load_verify_file(impl_type& impl,
-      const std::string& filename, asio::error_code& ec)
-  {
-    if (::SSL_CTX_load_verify_locations(impl, filename.c_str(), 0) != 1)
-    {
-      ec = asio::error::invalid_argument;
-      return ec;
-    }
-
-    ec = asio::error_code();
-    return ec;
-  }
-
-  // Add a directory containing certification authority files to be used for
-  // performing verification.
-  asio::error_code add_verify_path(impl_type& impl,
-      const std::string& path, asio::error_code& ec)
-  {
-    if (::SSL_CTX_load_verify_locations(impl, 0, path.c_str()) != 1)
-    {
-      ec = asio::error::invalid_argument;
-      return ec;
-    }
-
-    ec = asio::error_code();
-    return ec;
-  }
-
-  // Use a certificate from a file.
-  asio::error_code use_certificate_file(impl_type& impl,
-      const std::string& filename, context_base::file_format format,
-      asio::error_code& ec)
-  {
-    int file_type;
-    switch (format)
-    {
-    case context_base::asn1:
-      file_type = SSL_FILETYPE_ASN1;
-      break;
-    case context_base::pem:
-      file_type = SSL_FILETYPE_PEM;
-      break;
-    default:
-      {
-        ec = asio::error::invalid_argument;
-        return ec;
-      }
-    }
-
-    if (::SSL_CTX_use_certificate_file(impl, filename.c_str(), file_type) != 1)
-    {
-      ec = asio::error::invalid_argument;
-      return ec;
-    }
-
-    ec = asio::error_code();
-    return ec;
-  }
-
-  // Use a certificate chain from a file.
-  asio::error_code use_certificate_chain_file(impl_type& impl,
-      const std::string& filename, asio::error_code& ec)
-  {
-    if (::SSL_CTX_use_certificate_chain_file(impl, filename.c_str()) != 1)
-    {
-      ec = asio::error::invalid_argument;
-      return ec;
-    }
-
-    ec = asio::error_code();
-    return ec;
-  }
-
-  // Use a private key from a file.
-  asio::error_code use_private_key_file(impl_type& impl,
-      const std::string& filename, context_base::file_format format,
-      asio::error_code& ec)
-  {
-    int file_type;
-    switch (format)
-    {
-    case context_base::asn1:
-      file_type = SSL_FILETYPE_ASN1;
-      break;
-    case context_base::pem:
-      file_type = SSL_FILETYPE_PEM;
-      break;
-    default:
-      {
-        ec = asio::error::invalid_argument;
-        return ec;
-      }
-    }
-
-    if (::SSL_CTX_use_PrivateKey_file(impl, filename.c_str(), file_type) != 1)
-    {
-      ec = asio::error::invalid_argument;
-      return ec;
-    }
-
-    ec = asio::error_code();
-    return ec;
-  }
-
-  // Use an RSA private key from a file.
-  asio::error_code use_rsa_private_key_file(impl_type& impl,
-      const std::string& filename, context_base::file_format format,
-      asio::error_code& ec)
-  {
-    int file_type;
-    switch (format)
-    {
-    case context_base::asn1:
-      file_type = SSL_FILETYPE_ASN1;
-      break;
-    case context_base::pem:
-      file_type = SSL_FILETYPE_PEM;
-      break;
-    default:
-      {
-        ec = asio::error::invalid_argument;
-        return ec;
-      }
-    }
-
-    if (::SSL_CTX_use_RSAPrivateKey_file(
-          impl, filename.c_str(), file_type) != 1)
-    {
-      ec = asio::error::invalid_argument;
-      return ec;
-    }
-
-    ec = asio::error_code();
-    return ec;
-  }
-
-  // Use the specified file to obtain the temporary Diffie-Hellman parameters.
-  asio::error_code use_tmp_dh_file(impl_type& impl,
-      const std::string& filename, asio::error_code& ec)
-  {
-    ::BIO* bio = ::BIO_new_file(filename.c_str(), "r");
-    if (!bio)
-    {
-      ec = asio::error::invalid_argument;
-      return ec;
-    }
-
-    ::DH* dh = ::PEM_read_bio_DHparams(bio, 0, 0, 0);
-    if (!dh)
-    {
-      ::BIO_free(bio);
-      ec = asio::error::invalid_argument;
-      return ec;
-    }
-
-    ::BIO_free(bio);
-    int result = ::SSL_CTX_set_tmp_dh(impl, dh);
-    ::DH_free(dh);
-    if (result != 1)
-    {
-      ec = asio::error::invalid_argument;
-      return ec;
-    }
-
-    ec = asio::error_code();
-    return ec;
-  }
-
-  static int password_callback(char* buf, int size, int purpose, void* data)
-  {
-    using namespace std; // For strncat and strlen.
-
-    if (data)
-    {
-      password_callback_type* callback =
-        static_cast<password_callback_type*>(data);
-      std::string passwd = (*callback)(static_cast<std::size_t>(size),
-          purpose ? context_base::for_writing : context_base::for_reading);
-      *buf = '\0';
-      strncat(buf, passwd.c_str(), size);
-      return strlen(buf);
-    }
-
-    return 0;
-  }
-
-  // Set the password callback.
-  template <typename Password_Callback>
-  asio::error_code set_password_callback(impl_type& impl,
-      Password_Callback callback, asio::error_code& ec)
-  {
-    // Allocate callback function object if not already present.
-    if (impl->default_passwd_callback_userdata)
-    {
-      password_callback_type* callback_function =
-        static_cast<password_callback_type*>(
-            impl->default_passwd_callback_userdata);
-      *callback_function = callback;
-    }
-    else
-    {
-      password_callback_type* callback_function =
-        new password_callback_type(callback);
-      impl->default_passwd_callback_userdata = callback_function;
-    }
-
-    // Set the password callback.
-    SSL_CTX_set_default_passwd_cb(impl,
-        &openssl_context_service::password_callback);
-
-    ec = asio::error_code();
-    return ec;
-  }
-
-private:
-  // Ensure openssl is initialised.
-  asio::ssl::detail::openssl_init<> init_;
-};
-
-} // namespace detail
-} // namespace old
-} // namespace ssl
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_SSL_OLD_DETAIL_OPENSSL_CONTEXT_SERVICE_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/old/detail/openssl_operation.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/old/detail/openssl_operation.hpp
deleted file mode 100644
index 9ea9c94676e2..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/old/detail/openssl_operation.hpp
+++ /dev/null
@@ -1,524 +0,0 @@
-//
-// ssl/old/detail/openssl_operation.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2005 Voipster / Indrek dot Juhani at voipster dot com
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_SSL_OLD_DETAIL_OPENSSL_OPERATION_HPP
-#define ASIO_SSL_OLD_DETAIL_OPENSSL_OPERATION_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include <boost/function.hpp>
-#include <boost/bind.hpp>
-#include "asio/buffer.hpp"
-#include "asio/detail/assert.hpp"
-#include "asio/detail/socket_ops.hpp"
-#include "asio/placeholders.hpp"
-#include "asio/ssl/detail/openssl_types.hpp"
-#include "asio/ssl/error.hpp"
-#include "asio/strand.hpp"
-#include "asio/system_error.hpp"
-#include "asio/write.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace ssl {
-namespace old {
-namespace detail {
-
-typedef boost::function<int (::SSL*)> ssl_primitive_func; 
-typedef boost::function<void (const asio::error_code&, int)>
-  user_handler_func;
-
-// Network send_/recv buffer implementation
-//
-//
-class net_buffer
-{
-  static const int  NET_BUF_SIZE = 16*1024 + 256; // SSL record size + spare
-
-  unsigned char buf_[NET_BUF_SIZE];
-  unsigned char* data_start_;
-  unsigned char* data_end_;
-
-public:
-  net_buffer()
-  {
-    data_start_ = data_end_ = buf_;
-  }
-  unsigned char* get_unused_start() { return data_end_; }
-  unsigned char* get_data_start() { return data_start_; }
-  size_t get_unused_len() { return (NET_BUF_SIZE - (data_end_ - buf_)); }    
-  size_t get_data_len() { return (data_end_ - data_start_); }    
-  void data_added(size_t count)
-  { 
-    data_end_ += count; 
-    data_end_ = data_end_ > (buf_ + NET_BUF_SIZE)? 
-      (buf_ + NET_BUF_SIZE):
-      data_end_; 
-  }
-  void data_removed(size_t count) 
-  { 
-    data_start_ += count; 
-    if (data_start_ >= data_end_) reset(); 
-  }
-  void reset() { data_start_ = buf_; data_end_ = buf_; }               
-  bool has_data() { return (data_start_ < data_end_); }
-}; // class net_buffer
-
-//
-// Operation class
-//
-//
-template <typename Stream>
-class openssl_operation
-{
-public:
-
-  // Constructor for asynchronous operations
-  openssl_operation(ssl_primitive_func primitive,
-                    Stream& socket,
-                    net_buffer& recv_buf,
-                    SSL* session,
-                    BIO* ssl_bio,
-                    user_handler_func  handler,
-                    asio::io_service::strand& strand
-                    )
-    : primitive_(primitive)
-    , user_handler_(handler)
-    , strand_(&strand)
-    , recv_buf_(recv_buf)
-    , socket_(socket)
-    , ssl_bio_(ssl_bio)
-    , session_(session)
-  {
-    write_ = boost::bind(
-      &openssl_operation::do_async_write, 
-      this, boost::arg<1>(), boost::arg<2>()
-    );
-    read_ = boost::bind(
-      &openssl_operation::do_async_read, 
-      this
-    );
-    handler_= boost::bind(
-      &openssl_operation::async_user_handler, 
-      this, boost::arg<1>(), boost::arg<2>()
-    );
-  }
-
-  // Constructor for synchronous operations
-  openssl_operation(ssl_primitive_func primitive,
-                    Stream& socket,
-                    net_buffer& recv_buf,
-                    SSL* session,
-                    BIO* ssl_bio)
-    : primitive_(primitive)
-    , strand_(0)
-    , recv_buf_(recv_buf)
-    , socket_(socket)
-    , ssl_bio_(ssl_bio)
-    , session_(session)
-  {      
-    write_ = boost::bind(
-      &openssl_operation::do_sync_write, 
-      this, boost::arg<1>(), boost::arg<2>()
-    );
-    read_ = boost::bind(
-      &openssl_operation::do_sync_read, 
-      this
-    );
-    handler_ = boost::bind(
-      &openssl_operation::sync_user_handler, 
-      this, boost::arg<1>(), boost::arg<2>()
-      );
-  }
-
-  // Start operation
-  // In case of asynchronous it returns 0, in sync mode returns success code
-  // or throws an error...
-  int start()
-  {
-    int rc = primitive_( session_ );
-
-    bool is_operation_done = (rc > 0);  
-                // For connect/accept/shutdown, the operation
-                // is done, when return code is 1
-                // for write, it is done, when is retcode > 0
-                // for read, it is done when retcode > 0
-
-    int error_code =  !is_operation_done ?
-          ::SSL_get_error( session_, rc ) :
-          0;        
-    int sys_error_code = ERR_get_error();
-
-    if (error_code == SSL_ERROR_SSL)
-      return handler_(asio::error_code(
-            sys_error_code, asio::error::get_ssl_category()), rc);
-
-    bool is_read_needed = (error_code == SSL_ERROR_WANT_READ);
-    bool is_write_needed = (error_code == SSL_ERROR_WANT_WRITE ||
-                              ::BIO_ctrl_pending( ssl_bio_ ));
-    bool is_shut_down_received = 
-      ((::SSL_get_shutdown( session_ ) & SSL_RECEIVED_SHUTDOWN) == 
-          SSL_RECEIVED_SHUTDOWN);
-    bool is_shut_down_sent = 
-      ((::SSL_get_shutdown( session_ ) & SSL_SENT_SHUTDOWN) ==
-            SSL_SENT_SHUTDOWN);
-
-    if (is_shut_down_sent && is_shut_down_received
-        && is_operation_done && !is_write_needed)
-      // SSL connection is shut down cleanly
-      return handler_(asio::error_code(), 1);
-
-    if (is_shut_down_received && !is_operation_done)
-      // Shutdown has been requested, while we were reading or writing...
-      // abort our action...
-      return handler_(asio::error::shut_down, 0);
-
-    if (!is_operation_done && !is_read_needed && !is_write_needed 
-      && !is_shut_down_sent)
-    {
-      // The operation has failed... It is not completed and does 
-      // not want network communication nor does want to send shutdown out...
-      if (error_code == SSL_ERROR_SYSCALL)
-      {
-        return handler_(asio::error_code(
-              sys_error_code, asio::error::system_category), rc); 
-      }
-      else
-      {
-        return handler_(asio::error_code(
-              sys_error_code, asio::error::get_ssl_category()), rc); 
-      }
-    }
-
-    if (!is_operation_done && !is_write_needed)
-    {
-      // We may have left over data that we can pass to SSL immediately
-      if (recv_buf_.get_data_len() > 0)
-      {
-        // Pass the buffered data to SSL
-        int written = ::BIO_write
-        ( 
-          ssl_bio_, 
-          recv_buf_.get_data_start(), 
-          recv_buf_.get_data_len() 
-        );
-
-        if (written > 0)
-        {
-          recv_buf_.data_removed(written);
-        }
-        else if (written < 0)
-        {
-          if (!BIO_should_retry(ssl_bio_))
-          {
-            // Some serios error with BIO....
-            return handler_(asio::error::no_recovery, 0);
-          }
-        }
-
-        return start();
-      }
-      else if (is_read_needed || (is_shut_down_sent && !is_shut_down_received))
-      {
-        return read_();
-      }
-    }
-
-    // Continue with operation, flush any SSL data out to network...
-    return write_(is_operation_done, rc); 
-  }
-
-// Private implementation
-private:
-  typedef boost::function<int (const asio::error_code&, int)>
-    int_handler_func;
-  typedef boost::function<int (bool, int)> write_func;
-  typedef boost::function<int ()> read_func;
-
-  ssl_primitive_func  primitive_;
-  user_handler_func  user_handler_;
-  asio::io_service::strand* strand_;
-  write_func  write_;
-  read_func  read_;
-  int_handler_func handler_;
-    
-  net_buffer send_buf_; // buffers for network IO
-
-  // The recv buffer is owned by the stream, not the operation, since there can
-  // be left over bytes after passing the data up to the application, and these
-  // bytes need to be kept around for the next read operation issued by the
-  // application.
-  net_buffer& recv_buf_;
-
-  Stream& socket_;
-  BIO*    ssl_bio_;
-  SSL*    session_;
-
-  //
-  int sync_user_handler(const asio::error_code& error, int rc)
-  {
-    if (!error)
-      return rc;
-
-    throw asio::system_error(error);
-  }
-    
-  int async_user_handler(asio::error_code error, int rc)
-  {
-    if (rc < 0)
-    {
-      if (!error)
-        error = asio::error::no_recovery;
-      rc = 0;
-    }
-
-    user_handler_(error, rc);
-    return 0;
-  }
-
-  // Writes bytes asynchronously from SSL to NET
-  int  do_async_write(bool is_operation_done, int rc) 
-  {
-    int len = ::BIO_ctrl_pending( ssl_bio_ );
-    if ( len )
-    { 
-      // There is something to write into net, do it...
-      len = (int)send_buf_.get_unused_len() > len? 
-        len: 
-        send_buf_.get_unused_len();
-        
-      if (len == 0)
-      {
-        // In case our send buffer is full, we have just to wait until 
-        // previous send to complete...
-        return 0;
-      }
-
-      // Read outgoing data from bio
-      len = ::BIO_read( ssl_bio_, send_buf_.get_unused_start(), len); 
-         
-      if (len > 0)
-      {
-        unsigned char *data_start = send_buf_.get_unused_start();
-        send_buf_.data_added(len);
- 
-        ASIO_ASSERT(strand_);
-        asio::async_write
-        ( 
-          socket_, 
-          asio::buffer(data_start, len),
-          strand_->wrap
-          (
-            boost::bind
-            (
-              &openssl_operation::async_write_handler, 
-              this, 
-              is_operation_done,
-              rc, 
-              asio::placeholders::error, 
-              asio::placeholders::bytes_transferred
-            )
-          )
-        );
-                  
-        return 0;
-      }
-      else if (!BIO_should_retry(ssl_bio_))
-      {
-        // Seems like fatal error
-        // reading from SSL BIO has failed...
-        handler_(asio::error::no_recovery, 0);
-        return 0;
-      }
-    }
-    
-    if (is_operation_done)
-    {
-      // Finish the operation, with success
-      handler_(asio::error_code(), rc);
-      return 0;
-    }
-    
-    // OPeration is not done and writing to net has been made...
-    // start operation again
-    start();
-          
-    return 0;
-  }
-
-  void async_write_handler(bool is_operation_done, int rc, 
-    const asio::error_code& error, size_t bytes_sent)
-  {
-    if (!error)
-    {
-      // Remove data from send buffer
-      send_buf_.data_removed(bytes_sent);
-
-      if (is_operation_done)
-        handler_(asio::error_code(), rc);
-      else
-        // Since the operation was not completed, try it again...
-        start();
-    }
-    else 
-      handler_(error, rc);
-  }
-
-  int do_async_read()
-  {
-    // Wait for new data
-    ASIO_ASSERT(strand_);
-    socket_.async_read_some
-    ( 
-      asio::buffer(recv_buf_.get_unused_start(),
-        recv_buf_.get_unused_len()),
-      strand_->wrap
-      (
-        boost::bind
-        (
-          &openssl_operation::async_read_handler, 
-          this, 
-          asio::placeholders::error, 
-          asio::placeholders::bytes_transferred
-        )
-      )
-    );
-    return 0;
-  }
-
-  void async_read_handler(const asio::error_code& error,
-      size_t bytes_recvd)
-  {
-    if (!error)
-    {
-      recv_buf_.data_added(bytes_recvd);
-
-      // Pass the received data to SSL
-      int written = ::BIO_write
-      ( 
-        ssl_bio_, 
-        recv_buf_.get_data_start(), 
-        recv_buf_.get_data_len() 
-      );
-
-      if (written > 0)
-      {
-        recv_buf_.data_removed(written);
-      }
-      else if (written < 0)
-      {
-        if (!BIO_should_retry(ssl_bio_))
-        {
-          // Some serios error with BIO....
-          handler_(asio::error::no_recovery, 0);
-          return;
-        }
-      }
-
-      // and try the SSL primitive again
-      start();
-    }
-    else
-    {
-      // Error in network level...
-      // SSL can't continue either...
-      handler_(error, 0);
-    }
-  }
-
-  // Syncronous functions...
-  int do_sync_write(bool is_operation_done, int rc)
-  {
-    int len = ::BIO_ctrl_pending( ssl_bio_ );
-    if ( len )
-    { 
-      // There is something to write into net, do it...
-      len = (int)send_buf_.get_unused_len() > len? 
-        len: 
-        send_buf_.get_unused_len();
-        
-      // Read outgoing data from bio
-      len = ::BIO_read( ssl_bio_, send_buf_.get_unused_start(), len); 
-         
-      if (len > 0)
-      {
-        size_t sent_len = asio::write( 
-                  socket_, 
-                  asio::buffer(send_buf_.get_unused_start(), len)
-                  );
-
-        send_buf_.data_added(len);
-        send_buf_.data_removed(sent_len);
-      }          
-      else if (!BIO_should_retry(ssl_bio_))
-      {
-        // Seems like fatal error
-        // reading from SSL BIO has failed...
-        throw asio::system_error(asio::error::no_recovery);
-      }
-    }
-    
-    if (is_operation_done)
-      // Finish the operation, with success
-      return rc;
-                
-    // Operation is not finished, start again.
-    return start();
-  }
-
-  int do_sync_read()
-  {
-    size_t len = socket_.read_some
-      ( 
-        asio::buffer(recv_buf_.get_unused_start(),
-          recv_buf_.get_unused_len())
-      );
-
-    // Write data to ssl
-    recv_buf_.data_added(len);
-
-    // Pass the received data to SSL
-    int written = ::BIO_write
-    ( 
-      ssl_bio_, 
-      recv_buf_.get_data_start(), 
-      recv_buf_.get_data_len() 
-    );
-
-    if (written > 0)
-    {
-      recv_buf_.data_removed(written);
-    }
-    else if (written < 0)
-    {
-      if (!BIO_should_retry(ssl_bio_))
-      {
-        // Some serios error with BIO....
-        throw asio::system_error(asio::error::no_recovery);
-      }
-    }
-
-    // Try the operation again
-    return start();
-  }
-}; // class openssl_operation
-
-} // namespace detail
-} // namespace old
-} // namespace ssl
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_SSL_OLD_DETAIL_OPENSSL_OPERATION_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/old/detail/openssl_stream_service.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/old/detail/openssl_stream_service.hpp
deleted file mode 100644
index 11154e9442e0..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/old/detail/openssl_stream_service.hpp
+++ /dev/null
@@ -1,571 +0,0 @@
-//
-// ssl/old/detail/stream_service.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2005 Voipster / Indrek dot Juhani at voipster dot com
-// Copyright (c) 2005-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_SSL_OLD_DETAIL_OPENSSL_STREAM_SERVICE_HPP
-#define ASIO_SSL_OLD_DETAIL_OPENSSL_STREAM_SERVICE_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include <cstddef>
-#include <climits>
-#include <memory>
-#include <boost/config.hpp>
-#include <boost/noncopyable.hpp>
-#include <boost/function.hpp>
-#include <boost/bind.hpp>
-#include "asio/detail/buffer_sequence_adapter.hpp"
-#include "asio/error.hpp"
-#include "asio/io_service.hpp"
-#include "asio/ssl/basic_context.hpp"
-#include "asio/ssl/stream_base.hpp"
-#include "asio/ssl/old/detail/openssl_operation.hpp"
-#include "asio/ssl/detail/openssl_types.hpp"
-#include "asio/strand.hpp"
-#include "asio/system_error.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace ssl {
-namespace old {
-namespace detail {
-
-class openssl_stream_service
-  : public asio::detail::service_base<openssl_stream_service>
-{
-private:
-  enum { max_buffer_size = INT_MAX };
-
-  //Base handler for asyncrhonous operations
-  template <typename Stream>
-  class base_handler
-  {
-  public:
-    typedef boost::function<
-      void (const asio::error_code&, size_t)> func_t;
-
-    base_handler(asio::io_service& io_service)
-      : op_(NULL)
-      , io_service_(io_service)
-      , work_(io_service)
-    {}
-    
-    void do_func(const asio::error_code& error, size_t size)
-    {
-      func_(error, size);
-    }
-        
-    void set_operation(openssl_operation<Stream>* op) { op_ = op; }
-    void set_func(func_t func) { func_ = func; }
-
-    ~base_handler()
-    {
-      delete op_;
-    }
-
-  private:
-    func_t func_;
-    openssl_operation<Stream>* op_;
-    asio::io_service& io_service_;
-    asio::io_service::work work_;
-  };  // class base_handler
-
-  // Handler for asynchronous IO (write/read) operations
-  template<typename Stream, typename Handler>
-  class io_handler 
-    : public base_handler<Stream>
-  {
-  public:
-    io_handler(Handler handler, asio::io_service& io_service)
-      : base_handler<Stream>(io_service)
-      , handler_(handler)
-    {
-      this->set_func(boost::bind(
-        &io_handler<Stream, Handler>::handler_impl, 
-        this, boost::arg<1>(), boost::arg<2>() ));
-    }
-
-  private:
-    Handler handler_;
-    void handler_impl(const asio::error_code& error, size_t size)
-    {
-      std::auto_ptr<io_handler<Stream, Handler> > this_ptr(this);
-      handler_(error, size);
-    }
-  };  // class io_handler 
-
-  // Handler for asyncrhonous handshake (connect, accept) functions
-  template <typename Stream, typename Handler>
-  class handshake_handler
-    : public base_handler<Stream>
-  {
-  public:
-    handshake_handler(Handler handler, asio::io_service& io_service)
-      : base_handler<Stream>(io_service)
-      , handler_(handler)
-    {
-      this->set_func(boost::bind(
-        &handshake_handler<Stream, Handler>::handler_impl, 
-        this, boost::arg<1>(), boost::arg<2>() ));
-    }
-
-  private:
-    Handler handler_;
-    void handler_impl(const asio::error_code& error, size_t)
-    {
-      std::auto_ptr<handshake_handler<Stream, Handler> > this_ptr(this);
-      handler_(error);
-    }
-
-  };  // class handshake_handler
-
-  // Handler for asyncrhonous shutdown
-  template <typename Stream, typename Handler>
-  class shutdown_handler
-    : public base_handler<Stream>
-  {
-  public:
-    shutdown_handler(Handler handler, asio::io_service& io_service)
-      : base_handler<Stream>(io_service),
-        handler_(handler)
-    { 
-      this->set_func(boost::bind(
-        &shutdown_handler<Stream, Handler>::handler_impl, 
-        this, boost::arg<1>(), boost::arg<2>() ));
-    }
-
-  private:
-    Handler handler_;
-    void handler_impl(const asio::error_code& error, size_t)
-    {
-      std::auto_ptr<shutdown_handler<Stream, Handler> > this_ptr(this);
-      handler_(error);
-    }
-  };  // class shutdown_handler
-
-public:
-  // The implementation type.
-  typedef struct impl_struct
-  {
-    ::SSL* ssl;
-    ::BIO* ext_bio;
-    net_buffer recv_buf;
-  } * impl_type;
-
-  // Construct a new stream socket service for the specified io_service.
-  explicit openssl_stream_service(asio::io_service& io_service)
-    : asio::detail::service_base<openssl_stream_service>(io_service),
-      strand_(io_service)
-  {
-  }
-
-  // Destroy all user-defined handler objects owned by the service.
-  void shutdown_service()
-  {
-  }
-
-  // Return a null stream implementation.
-  impl_type null() const
-  {
-    return 0;
-  }
-
-  // Create a new stream implementation.
-  template <typename Stream, typename Context_Service>
-  void create(impl_type& impl, Stream& /*next_layer*/,
-      basic_context<Context_Service>& context)
-  {
-    impl = new impl_struct;
-    impl->ssl = ::SSL_new(context.impl());
-    ::SSL_set_mode(impl->ssl, SSL_MODE_ENABLE_PARTIAL_WRITE);
-    ::SSL_set_mode(impl->ssl, SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER);
-    ::BIO* int_bio = 0;
-    impl->ext_bio = 0;
-    ::BIO_new_bio_pair(&int_bio, 8192, &impl->ext_bio, 8192);
-    ::SSL_set_bio(impl->ssl, int_bio, int_bio);
-  }
-
-  // Destroy a stream implementation.
-  template <typename Stream>
-  void destroy(impl_type& impl, Stream& /*next_layer*/)
-  {
-    if (impl != 0)
-    {
-      ::BIO_free(impl->ext_bio);
-      ::SSL_free(impl->ssl);
-      delete impl;
-      impl = 0;
-    }
-  }
-
-  // Perform SSL handshaking.
-  template <typename Stream>
-  asio::error_code handshake(impl_type& impl, Stream& next_layer,
-      stream_base::handshake_type type, asio::error_code& ec)
-  {
-    try
-    {
-      openssl_operation<Stream> op(
-        type == stream_base::client ?
-          &ssl_wrap<mutex_type>::SSL_connect:
-          &ssl_wrap<mutex_type>::SSL_accept,
-        next_layer,
-        impl->recv_buf,
-        impl->ssl,
-        impl->ext_bio);
-      op.start();
-    }
-    catch (asio::system_error& e)
-    {
-      ec = e.code();
-      return ec;
-    }
-
-    ec = asio::error_code();
-    return ec;
-  }
-
-  // Start an asynchronous SSL handshake.
-  template <typename Stream, typename Handler>
-  void async_handshake(impl_type& impl, Stream& next_layer,
-      stream_base::handshake_type type, Handler handler)
-  {
-    typedef handshake_handler<Stream, Handler> connect_handler;
-
-    connect_handler* local_handler = 
-      new connect_handler(handler, get_io_service());
-
-    openssl_operation<Stream>* op = new openssl_operation<Stream>
-    (
-      type == stream_base::client ?
-        &ssl_wrap<mutex_type>::SSL_connect:
-        &ssl_wrap<mutex_type>::SSL_accept,
-      next_layer,
-      impl->recv_buf,
-      impl->ssl,
-      impl->ext_bio,
-      boost::bind
-      (
-        &base_handler<Stream>::do_func, 
-        local_handler,
-        boost::arg<1>(),
-        boost::arg<2>()
-      ),
-      strand_
-    );
-    local_handler->set_operation(op);
-
-    strand_.post(boost::bind(&openssl_operation<Stream>::start, op));
-  }
-
-  // Shut down SSL on the stream.
-  template <typename Stream>
-  asio::error_code shutdown(impl_type& impl, Stream& next_layer,
-      asio::error_code& ec)
-  {
-    try
-    {
-      openssl_operation<Stream> op(
-        &ssl_wrap<mutex_type>::SSL_shutdown,
-        next_layer,
-        impl->recv_buf,
-        impl->ssl,
-        impl->ext_bio);
-      op.start();
-    }
-    catch (asio::system_error& e)
-    {
-      ec = e.code();
-      return ec;
-    }
-
-    ec = asio::error_code();
-    return ec;
-  }
-
-  // Asynchronously shut down SSL on the stream.
-  template <typename Stream, typename Handler>
-  void async_shutdown(impl_type& impl, Stream& next_layer, Handler handler)
-  {
-    typedef shutdown_handler<Stream, Handler> disconnect_handler;
-
-    disconnect_handler* local_handler = 
-      new disconnect_handler(handler, get_io_service());
-
-    openssl_operation<Stream>* op = new openssl_operation<Stream>
-    (
-      &ssl_wrap<mutex_type>::SSL_shutdown,
-      next_layer,
-      impl->recv_buf,
-      impl->ssl,
-      impl->ext_bio,
-      boost::bind
-      (
-        &base_handler<Stream>::do_func, 
-        local_handler, 
-        boost::arg<1>(),
-        boost::arg<2>()
-      ),
-      strand_
-    );
-    local_handler->set_operation(op);
-
-    strand_.post(boost::bind(&openssl_operation<Stream>::start, op));        
-  }
-
-  // Write some data to the stream.
-  template <typename Stream, typename Const_Buffers>
-  std::size_t write_some(impl_type& impl, Stream& next_layer,
-      const Const_Buffers& buffers, asio::error_code& ec)
-  {
-    size_t bytes_transferred = 0;
-    try
-    {
-      asio::const_buffer buffer =
-        asio::detail::buffer_sequence_adapter<
-          asio::const_buffer, Const_Buffers>::first(buffers);
-
-      std::size_t buffer_size = asio::buffer_size(buffer);
-      if (buffer_size > max_buffer_size)
-        buffer_size = max_buffer_size;
-      else if (buffer_size == 0)
-      {
-        ec = asio::error_code();
-        return 0;
-      }
-
-      boost::function<int (SSL*)> send_func =
-        boost::bind(boost::type<int>(), &::SSL_write, boost::arg<1>(),  
-            asio::buffer_cast<const void*>(buffer),
-            static_cast<int>(buffer_size));
-      openssl_operation<Stream> op(
-        send_func,
-        next_layer,
-        impl->recv_buf,
-        impl->ssl,
-        impl->ext_bio
-      );
-      bytes_transferred = static_cast<size_t>(op.start());
-    }
-    catch (asio::system_error& e)
-    {
-      ec = e.code();
-      return 0;
-    }
-
-    ec = asio::error_code();
-    return bytes_transferred;
-  }
-
-  // Start an asynchronous write.
-  template <typename Stream, typename Const_Buffers, typename Handler>
-  void async_write_some(impl_type& impl, Stream& next_layer,
-      const Const_Buffers& buffers, Handler handler)
-  {
-    typedef io_handler<Stream, Handler> send_handler;
-
-    asio::const_buffer buffer =
-      asio::detail::buffer_sequence_adapter<
-        asio::const_buffer, Const_Buffers>::first(buffers);
-
-    std::size_t buffer_size = asio::buffer_size(buffer);
-    if (buffer_size > max_buffer_size)
-      buffer_size = max_buffer_size;
-    else if (buffer_size == 0)
-    {
-      get_io_service().post(asio::detail::bind_handler(
-            handler, asio::error_code(), 0));
-      return;
-    }
-
-    send_handler* local_handler = new send_handler(handler, get_io_service());
-
-    boost::function<int (SSL*)> send_func =
-      boost::bind(boost::type<int>(), &::SSL_write, boost::arg<1>(),
-          asio::buffer_cast<const void*>(buffer),
-          static_cast<int>(buffer_size));
-
-    openssl_operation<Stream>* op = new openssl_operation<Stream>
-    (
-      send_func,
-      next_layer,
-      impl->recv_buf,
-      impl->ssl,
-      impl->ext_bio,
-      boost::bind
-      (
-        &base_handler<Stream>::do_func, 
-        local_handler, 
-        boost::arg<1>(),
-        boost::arg<2>()
-      ),
-      strand_
-    );
-    local_handler->set_operation(op);
-
-    strand_.post(boost::bind(&openssl_operation<Stream>::start, op));        
-  }
-
-  // Read some data from the stream.
-  template <typename Stream, typename Mutable_Buffers>
-  std::size_t read_some(impl_type& impl, Stream& next_layer,
-      const Mutable_Buffers& buffers, asio::error_code& ec)
-  {
-    size_t bytes_transferred = 0;
-    try
-    {
-      asio::mutable_buffer buffer =
-        asio::detail::buffer_sequence_adapter<
-          asio::mutable_buffer, Mutable_Buffers>::first(buffers);
-
-      std::size_t buffer_size = asio::buffer_size(buffer);
-      if (buffer_size > max_buffer_size)
-        buffer_size = max_buffer_size;
-      else if (buffer_size == 0)
-      {
-        ec = asio::error_code();
-        return 0;
-      }
-
-      boost::function<int (SSL*)> recv_func =
-        boost::bind(boost::type<int>(), &::SSL_read, boost::arg<1>(),
-            asio::buffer_cast<void*>(buffer),
-            static_cast<int>(buffer_size));
-      openssl_operation<Stream> op(recv_func,
-        next_layer,
-        impl->recv_buf,
-        impl->ssl,
-        impl->ext_bio
-      );
-
-      bytes_transferred = static_cast<size_t>(op.start());
-    }
-    catch (asio::system_error& e)
-    {
-      ec = e.code();
-      return 0;
-    }
-
-    ec = asio::error_code();
-    return bytes_transferred;
-  }
-
-  // Start an asynchronous read.
-  template <typename Stream, typename Mutable_Buffers, typename Handler>
-  void async_read_some(impl_type& impl, Stream& next_layer,
-      const Mutable_Buffers& buffers, Handler handler)
-  {
-    typedef io_handler<Stream, Handler> recv_handler;
-
-    asio::mutable_buffer buffer =
-      asio::detail::buffer_sequence_adapter<
-        asio::mutable_buffer, Mutable_Buffers>::first(buffers);
-
-    std::size_t buffer_size = asio::buffer_size(buffer);
-    if (buffer_size > max_buffer_size)
-      buffer_size = max_buffer_size;
-    else if (buffer_size == 0)
-    {
-      get_io_service().post(asio::detail::bind_handler(
-            handler, asio::error_code(), 0));
-      return;
-    }
-
-    recv_handler* local_handler = new recv_handler(handler, get_io_service());
-
-    boost::function<int (SSL*)> recv_func =
-      boost::bind(boost::type<int>(), &::SSL_read, boost::arg<1>(),
-          asio::buffer_cast<void*>(buffer),
-          static_cast<int>(buffer_size));
-
-    openssl_operation<Stream>* op = new openssl_operation<Stream>
-    (
-      recv_func,
-      next_layer,
-      impl->recv_buf,
-      impl->ssl,
-      impl->ext_bio,
-      boost::bind
-      (
-        &base_handler<Stream>::do_func, 
-        local_handler, 
-        boost::arg<1>(),
-        boost::arg<2>()
-      ),
-      strand_
-    );
-    local_handler->set_operation(op);
-
-    strand_.post(boost::bind(&openssl_operation<Stream>::start, op));        
-  }
-
-  // Peek at the incoming data on the stream.
-  template <typename Stream, typename Mutable_Buffers>
-  std::size_t peek(impl_type& /*impl*/, Stream& /*next_layer*/,
-      const Mutable_Buffers& /*buffers*/, asio::error_code& ec)
-  {
-    ec = asio::error_code();
-    return 0;
-  }
-
-  // Determine the amount of data that may be read without blocking.
-  template <typename Stream>
-  std::size_t in_avail(impl_type& /*impl*/, Stream& /*next_layer*/,
-      asio::error_code& ec)
-  {
-    ec = asio::error_code();
-    return 0;
-  }
-
-private:  
-  asio::io_service::strand strand_;
-
-  typedef asio::detail::mutex mutex_type;
-  
-  template<typename Mutex>
-  struct ssl_wrap
-  {
-    static Mutex ssl_mutex_;
-
-    static int SSL_accept(SSL *ssl)
-    {
-      typename Mutex::scoped_lock lock(ssl_mutex_);
-      return ::SSL_accept(ssl);
-    }
-  
-    static int SSL_connect(SSL *ssl)
-    {
-      typename Mutex::scoped_lock lock(ssl_mutex_);
-      return ::SSL_connect(ssl);
-    }
-  
-    static int SSL_shutdown(SSL *ssl)
-    {
-      typename Mutex::scoped_lock lock(ssl_mutex_);
-      return ::SSL_shutdown(ssl);  
-    }    
-  };  
-};
-
-template<typename Mutex>
-Mutex openssl_stream_service::ssl_wrap<Mutex>::ssl_mutex_;
-
-} // namespace detail
-} // namespace old
-} // namespace ssl
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_SSL_OLD_DETAIL_OPENSSL_STREAM_SERVICE_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/old/stream.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/old/stream.hpp
deleted file mode 100644
index 42ab3c2ab7ef..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/old/stream.hpp
+++ /dev/null
@@ -1,501 +0,0 @@
-//
-// ssl/old/stream.hpp
-// ~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2005 Voipster / Indrek dot Juhani at voipster dot com
-// Copyright (c) 2005-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_SSL_OLD_STREAM_HPP
-#define ASIO_SSL_OLD_STREAM_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include <cstddef>
-#include <boost/noncopyable.hpp>
-#include "asio/detail/throw_error.hpp"
-#include "asio/detail/type_traits.hpp"
-#include "asio/error.hpp"
-#include "asio/ssl/basic_context.hpp"
-#include "asio/ssl/stream_base.hpp"
-#include "asio/ssl/stream_service.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace ssl {
-namespace old {
-
-/// Provides stream-oriented functionality using SSL.
-/**
- * The stream class template provides asynchronous and blocking stream-oriented
- * functionality using SSL.
- *
- * @par Thread Safety
- * @e Distinct @e objects: Safe.@n
- * @e Shared @e objects: Unsafe.
- *
- * @par Example
- * To use the SSL stream template with an ip::tcp::socket, you would write:
- * @code
- * asio::io_service io_service;
- * asio::ssl::context context(io_service, asio::ssl::context::sslv23);
- * asio::ssl::stream<asio::ip::tcp::socket> sock(io_service, context);
- * @endcode
- *
- * @par Concepts:
- * AsyncReadStream, AsyncWriteStream, Stream, SyncRead_Stream, SyncWriteStream.
- */
-template <typename Stream, typename Service = old::stream_service>
-class stream
-  : public stream_base,
-    private boost::noncopyable
-{
-public:
-  /// The type of the next layer.
-  typedef typename remove_reference<Stream>::type next_layer_type;
-
-  /// The type of the lowest layer.
-  typedef typename next_layer_type::lowest_layer_type lowest_layer_type;
-
-  /// The type of the service that will be used to provide stream operations.
-  typedef Service service_type;
-
-  /// The native implementation type of the stream.
-  typedef typename service_type::impl_type impl_type;
-
-  /// Construct a stream.
-  /**
-   * This constructor creates a stream and initialises the underlying stream
-   * object.
-   *
-   * @param arg The argument to be passed to initialise the underlying stream.
-   *
-   * @param context The SSL context to be used for the stream.
-   */
-  template <typename Arg, typename Context_Service>
-  explicit stream(Arg& arg, basic_context<Context_Service>& context)
-    : next_layer_(arg),
-      service_(asio::use_service<Service>(next_layer_.get_io_service())),
-      impl_(service_.null())
-  {
-    service_.create(impl_, next_layer_, context);
-  }
-
-  /// Destructor.
-  ~stream()
-  {
-    service_.destroy(impl_, next_layer_);
-  }
-
-  /// Get the io_service associated with the object.
-  /**
-   * This function may be used to obtain the io_service object that the stream
-   * uses to dispatch handlers for asynchronous operations.
-   *
-   * @return A reference to the io_service object that stream will use to
-   * dispatch handlers. Ownership is not transferred to the caller.
-   */
-  asio::io_service& get_io_service()
-  {
-    return next_layer_.get_io_service();
-  }
-
-  /// Get a reference to the next layer.
-  /**
-   * This function returns a reference to the next layer in a stack of stream
-   * layers.
-   *
-   * @return A reference to the next layer in the stack of stream layers.
-   * Ownership is not transferred to the caller.
-   */
-  next_layer_type& next_layer()
-  {
-    return next_layer_;
-  }
-
-  /// Get a reference to the lowest layer.
-  /**
-   * This function returns a reference to the lowest layer in a stack of
-   * stream layers.
-   *
-   * @return A reference to the lowest layer in the stack of stream layers.
-   * Ownership is not transferred to the caller.
-   */
-  lowest_layer_type& lowest_layer()
-  {
-    return next_layer_.lowest_layer();
-  }
-
-  /// Get a const reference to the lowest layer.
-  /**
-   * This function returns a const reference to the lowest layer in a stack of
-   * stream layers.
-   *
-   * @return A const reference to the lowest layer in the stack of stream
-   * layers. Ownership is not transferred to the caller.
-   */
-  const lowest_layer_type& lowest_layer() const
-  {
-    return next_layer_.lowest_layer();
-  }
-
-  /// Get the underlying implementation in the native type.
-  /**
-   * This function may be used to obtain the underlying implementation of the
-   * context. This is intended to allow access to stream functionality that is
-   * not otherwise provided.
-   */
-  impl_type impl()
-  {
-    return impl_;
-  }
-
-  /// Perform SSL handshaking.
-  /**
-   * This function is used to perform SSL handshaking on the stream. The
-   * function call will block until handshaking is complete or an error occurs.
-   *
-   * @param type The type of handshaking to be performed, i.e. as a client or as
-   * a server.
-   *
-   * @throws asio::system_error Thrown on failure.
-   */
-  void handshake(handshake_type type)
-  {
-    asio::error_code ec;
-    service_.handshake(impl_, next_layer_, type, ec);
-    asio::detail::throw_error(ec);
-  }
-
-  /// Perform SSL handshaking.
-  /**
-   * This function is used to perform SSL handshaking on the stream. The
-   * function call will block until handshaking is complete or an error occurs.
-   *
-   * @param type The type of handshaking to be performed, i.e. as a client or as
-   * a server.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   */
-  asio::error_code handshake(handshake_type type,
-      asio::error_code& ec)
-  {
-    return service_.handshake(impl_, next_layer_, type, ec);
-  }
-
-  /// Start an asynchronous SSL handshake.
-  /**
-   * This function is used to asynchronously perform an SSL handshake on the
-   * stream. This function call always returns immediately.
-   *
-   * @param type The type of handshaking to be performed, i.e. as a client or as
-   * a server.
-   *
-   * @param handler The handler to be called when the handshake operation
-   * completes. Copies will be made of the handler as required. The equivalent
-   * function signature of the handler must be:
-   * @code void handler(
-   *   const asio::error_code& error // Result of operation.
-   * ); @endcode
-   */
-  template <typename HandshakeHandler>
-  void async_handshake(handshake_type type, HandshakeHandler handler)
-  {
-    service_.async_handshake(impl_, next_layer_, type, handler);
-  }
-
-  /// Shut down SSL on the stream.
-  /**
-   * This function is used to shut down SSL on the stream. The function call
-   * will block until SSL has been shut down or an error occurs.
-   *
-   * @throws asio::system_error Thrown on failure.
-   */
-  void shutdown()
-  {
-    asio::error_code ec;
-    service_.shutdown(impl_, next_layer_, ec);
-    asio::detail::throw_error(ec);
-  }
-
-  /// Shut down SSL on the stream.
-  /**
-   * This function is used to shut down SSL on the stream. The function call
-   * will block until SSL has been shut down or an error occurs.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   */
-  asio::error_code shutdown(asio::error_code& ec)
-  {
-    return service_.shutdown(impl_, next_layer_, ec);
-  }
-
-  /// Asynchronously shut down SSL on the stream.
-  /**
-   * This function is used to asynchronously shut down SSL on the stream. This
-   * function call always returns immediately.
-   *
-   * @param handler The handler to be called when the handshake operation
-   * completes. Copies will be made of the handler as required. The equivalent
-   * function signature of the handler must be:
-   * @code void handler(
-   *   const asio::error_code& error // Result of operation.
-   * ); @endcode
-   */
-  template <typename ShutdownHandler>
-  void async_shutdown(ShutdownHandler handler)
-  {
-    service_.async_shutdown(impl_, next_layer_, handler);
-  }
-
-  /// Write some data to the stream.
-  /**
-   * This function is used to write data on the stream. The function call will
-   * block until one or more bytes of data has been written successfully, or
-   * until an error occurs.
-   *
-   * @param buffers The data to be written.
-   *
-   * @returns The number of bytes written.
-   *
-   * @throws asio::system_error Thrown on failure.
-   *
-   * @note The write_some operation may not transmit all of the data to the
-   * peer. Consider using the @ref write function if you need to ensure that all
-   * data is written before the blocking operation completes.
-   */
-  template <typename ConstBufferSequence>
-  std::size_t write_some(const ConstBufferSequence& buffers)
-  {
-    asio::error_code ec;
-    std::size_t s = service_.write_some(impl_, next_layer_, buffers, ec);
-    asio::detail::throw_error(ec);
-    return s;
-  }
-
-  /// Write some data to the stream.
-  /**
-   * This function is used to write data on the stream. The function call will
-   * block until one or more bytes of data has been written successfully, or
-   * until an error occurs.
-   *
-   * @param buffers The data to be written to the stream.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   *
-   * @returns The number of bytes written. Returns 0 if an error occurred.
-   *
-   * @note The write_some operation may not transmit all of the data to the
-   * peer. Consider using the @ref write function if you need to ensure that all
-   * data is written before the blocking operation completes.
-   */
-  template <typename ConstBufferSequence>
-  std::size_t write_some(const ConstBufferSequence& buffers,
-      asio::error_code& ec)
-  {
-    return service_.write_some(impl_, next_layer_, buffers, ec);
-  }
-
-  /// Start an asynchronous write.
-  /**
-   * This function is used to asynchronously write one or more bytes of data to
-   * the stream. The function call always returns immediately.
-   *
-   * @param buffers The data to be written to the stream. Although the buffers
-   * object may be copied as necessary, ownership of the underlying buffers is
-   * retained by the caller, which must guarantee that they remain valid until
-   * the handler is called.
-   *
-   * @param handler The handler to be called when the write operation completes.
-   * Copies will be made of the handler as required. The equivalent function
-   * signature of the handler must be:
-   * @code void handler(
-   *   const asio::error_code& error, // Result of operation.
-   *   std::size_t bytes_transferred           // Number of bytes written.
-   * ); @endcode
-   *
-   * @note The async_write_some operation may not transmit all of the data to
-   * the peer. Consider using the @ref async_write function if you need to
-   * ensure that all data is written before the blocking operation completes.
-   */
-  template <typename ConstBufferSequence, typename WriteHandler>
-  void async_write_some(const ConstBufferSequence& buffers,
-      WriteHandler handler)
-  {
-    service_.async_write_some(impl_, next_layer_, buffers, handler);
-  }
-
-  /// Read some data from the stream.
-  /**
-   * This function is used to read data from the stream. The function call will
-   * block until one or more bytes of data has been read successfully, or until
-   * an error occurs.
-   *
-   * @param buffers The buffers into which the data will be read.
-   *
-   * @returns The number of bytes read.
-   *
-   * @throws asio::system_error Thrown on failure.
-   *
-   * @note The read_some operation may not read all of the requested number of
-   * bytes. Consider using the @ref read function if you need to ensure that the
-   * requested amount of data is read before the blocking operation completes.
-   */
-  template <typename MutableBufferSequence>
-  std::size_t read_some(const MutableBufferSequence& buffers)
-  {
-    asio::error_code ec;
-    std::size_t s = service_.read_some(impl_, next_layer_, buffers, ec);
-    asio::detail::throw_error(ec);
-    return s;
-  }
-
-  /// Read some data from the stream.
-  /**
-   * This function is used to read data from the stream. The function call will
-   * block until one or more bytes of data has been read successfully, or until
-   * an error occurs.
-   *
-   * @param buffers The buffers into which the data will be read.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   *
-   * @returns The number of bytes read. Returns 0 if an error occurred.
-   *
-   * @note The read_some operation may not read all of the requested number of
-   * bytes. Consider using the @ref read function if you need to ensure that the
-   * requested amount of data is read before the blocking operation completes.
-   */
-  template <typename MutableBufferSequence>
-  std::size_t read_some(const MutableBufferSequence& buffers,
-      asio::error_code& ec)
-  {
-    return service_.read_some(impl_, next_layer_, buffers, ec);
-  }
-
-  /// Start an asynchronous read.
-  /**
-   * This function is used to asynchronously read one or more bytes of data from
-   * the stream. The function call always returns immediately.
-   *
-   * @param buffers The buffers into which the data will be read. Although the
-   * buffers object may be copied as necessary, ownership of the underlying
-   * buffers is retained by the caller, which must guarantee that they remain
-   * valid until the handler is called.
-   *
-   * @param handler The handler to be called when the read operation completes.
-   * Copies will be made of the handler as required. The equivalent function
-   * signature of the handler must be:
-   * @code void handler(
-   *   const asio::error_code& error, // Result of operation.
-   *   std::size_t bytes_transferred           // Number of bytes read.
-   * ); @endcode
-   *
-   * @note The async_read_some operation may not read all of the requested
-   * number of bytes. Consider using the @ref async_read function if you need to
-   * ensure that the requested amount of data is read before the asynchronous
-   * operation completes.
-   */
-  template <typename MutableBufferSequence, typename ReadHandler>
-  void async_read_some(const MutableBufferSequence& buffers,
-      ReadHandler handler)
-  {
-    service_.async_read_some(impl_, next_layer_, buffers, handler);
-  }
-
-  /// Peek at the incoming data on the stream.
-  /**
-   * This function is used to peek at the incoming data on the stream, without
-   * removing it from the input queue. The function call will block until data
-   * has been read successfully or an error occurs.
-   *
-   * @param buffers The buffers into which the data will be read.
-   *
-   * @returns The number of bytes read.
-   *
-   * @throws asio::system_error Thrown on failure.
-   */
-  template <typename MutableBufferSequence>
-  std::size_t peek(const MutableBufferSequence& buffers)
-  {
-    asio::error_code ec;
-    std::size_t s = service_.peek(impl_, next_layer_, buffers, ec);
-    asio::detail::throw_error(ec);
-    return s;
-  }
-
-  /// Peek at the incoming data on the stream.
-  /**
-   * This function is used to peek at the incoming data on the stream, withoutxi
-   * removing it from the input queue. The function call will block until data
-   * has been read successfully or an error occurs.
-   *
-   * @param buffers The buffers into which the data will be read.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   *
-   * @returns The number of bytes read. Returns 0 if an error occurred.
-   */
-  template <typename MutableBufferSequence>
-  std::size_t peek(const MutableBufferSequence& buffers,
-      asio::error_code& ec)
-  {
-    return service_.peek(impl_, next_layer_, buffers, ec);
-  }
-
-  /// Determine the amount of data that may be read without blocking.
-  /**
-   * This function is used to determine the amount of data, in bytes, that may
-   * be read from the stream without blocking.
-   *
-   * @returns The number of bytes of data that can be read without blocking.
-   *
-   * @throws asio::system_error Thrown on failure.
-   */
-  std::size_t in_avail()
-  {
-    asio::error_code ec;
-    std::size_t s = service_.in_avail(impl_, next_layer_, ec);
-    asio::detail::throw_error(ec);
-    return s;
-  }
-
-  /// Determine the amount of data that may be read without blocking.
-  /**
-   * This function is used to determine the amount of data, in bytes, that may
-   * be read from the stream without blocking.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   *
-   * @returns The number of bytes of data that can be read without blocking.
-   */
-  std::size_t in_avail(asio::error_code& ec)
-  {
-    return service_.in_avail(impl_, next_layer_, ec);
-  }
-
-private:
-  /// The next layer.
-  Stream next_layer_;
-
-  /// The backend service implementation.
-  service_type& service_;
-
-  /// The underlying native implementation.
-  impl_type impl_;
-};
-
-} // namespace old
-} // namespace ssl
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_SSL_OLD_STREAM_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/old/stream_service.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/old/stream_service.hpp
deleted file mode 100644
index 2c3c442298fa..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/old/stream_service.hpp
+++ /dev/null
@@ -1,184 +0,0 @@
-//
-// ssl/old/stream_service.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2005 Voipster / Indrek dot Juhani at voipster dot com
-// Copyright (c) 2005-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_SSL_OLD_STREAM_SERVICE_HPP
-#define ASIO_SSL_OLD_STREAM_SERVICE_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include <cstddef>
-#include <boost/noncopyable.hpp>
-#include "asio/io_service.hpp"
-#include "asio/ssl/basic_context.hpp"
-#include "asio/ssl/old/detail/openssl_stream_service.hpp"
-#include "asio/ssl/stream_base.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace ssl {
-namespace old {
-
-/// Default service implementation for an SSL stream.
-class stream_service
-#if defined(GENERATING_DOCUMENTATION)
-  : public asio::io_service::service
-#else
-  : public asio::detail::service_base<stream_service>
-#endif
-{
-private:
-  // The type of the platform-specific implementation.
-  typedef old::detail::openssl_stream_service service_impl_type;
-
-public:
-#if defined(GENERATING_DOCUMENTATION)
-  /// The unique service identifier.
-  static asio::io_service::id id;
-#endif
-
-  /// The type of a stream implementation.
-#if defined(GENERATING_DOCUMENTATION)
-  typedef implementation_defined impl_type;
-#else
-  typedef service_impl_type::impl_type impl_type;
-#endif
-
-  /// Construct a new stream service for the specified io_service.
-  explicit stream_service(asio::io_service& io_service)
-    : asio::detail::service_base<stream_service>(io_service),
-      service_impl_(asio::use_service<service_impl_type>(io_service))
-  {
-  }
-
-  /// Return a null stream implementation.
-  impl_type null() const
-  {
-    return service_impl_.null();
-  }
-
-  /// Create a new stream implementation.
-  template <typename Stream, typename Context_Service>
-  void create(impl_type& impl, Stream& next_layer,
-      basic_context<Context_Service>& context)
-  {
-    service_impl_.create(impl, next_layer, context);
-  }
-
-  /// Destroy a stream implementation.
-  template <typename Stream>
-  void destroy(impl_type& impl, Stream& next_layer)
-  {
-    service_impl_.destroy(impl, next_layer);
-  }
-
-  /// Perform SSL handshaking.
-  template <typename Stream>
-  asio::error_code handshake(impl_type& impl, Stream& next_layer,
-      stream_base::handshake_type type, asio::error_code& ec)
-  {
-    return service_impl_.handshake(impl, next_layer, type, ec);
-  }
-
-  /// Start an asynchronous SSL handshake.
-  template <typename Stream, typename HandshakeHandler>
-  void async_handshake(impl_type& impl, Stream& next_layer,
-      stream_base::handshake_type type, HandshakeHandler handler)
-  {
-    service_impl_.async_handshake(impl, next_layer, type, handler);
-  }
-
-  /// Shut down SSL on the stream.
-  template <typename Stream>
-  asio::error_code shutdown(impl_type& impl, Stream& next_layer,
-      asio::error_code& ec)
-  {
-    return service_impl_.shutdown(impl, next_layer, ec);
-  }
-
-  /// Asynchronously shut down SSL on the stream.
-  template <typename Stream, typename ShutdownHandler>
-  void async_shutdown(impl_type& impl, Stream& next_layer,
-      ShutdownHandler handler)
-  {
-    service_impl_.async_shutdown(impl, next_layer, handler);
-  }
-
-  /// Write some data to the stream.
-  template <typename Stream, typename ConstBufferSequence>
-  std::size_t write_some(impl_type& impl, Stream& next_layer,
-      const ConstBufferSequence& buffers, asio::error_code& ec)
-  {
-    return service_impl_.write_some(impl, next_layer, buffers, ec);
-  }
-
-  /// Start an asynchronous write.
-  template <typename Stream, typename ConstBufferSequence,
-      typename WriteHandler>
-  void async_write_some(impl_type& impl, Stream& next_layer,
-      const ConstBufferSequence& buffers, WriteHandler handler)
-  {
-    service_impl_.async_write_some(impl, next_layer, buffers, handler);
-  }
-
-  /// Read some data from the stream.
-  template <typename Stream, typename MutableBufferSequence>
-  std::size_t read_some(impl_type& impl, Stream& next_layer,
-      const MutableBufferSequence& buffers, asio::error_code& ec)
-  {
-    return service_impl_.read_some(impl, next_layer, buffers, ec);
-  }
-
-  /// Start an asynchronous read.
-  template <typename Stream, typename MutableBufferSequence,
-      typename ReadHandler>
-  void async_read_some(impl_type& impl, Stream& next_layer,
-      const MutableBufferSequence& buffers, ReadHandler handler)
-  {
-    service_impl_.async_read_some(impl, next_layer, buffers, handler);
-  }
-
-  /// Peek at the incoming data on the stream.
-  template <typename Stream, typename MutableBufferSequence>
-  std::size_t peek(impl_type& impl, Stream& next_layer,
-      const MutableBufferSequence& buffers, asio::error_code& ec)
-  {
-    return service_impl_.peek(impl, next_layer, buffers, ec);
-  }
-
-  /// Determine the amount of data that may be read without blocking.
-  template <typename Stream>
-  std::size_t in_avail(impl_type& impl, Stream& next_layer,
-      asio::error_code& ec)
-  {
-    return service_impl_.in_avail(impl, next_layer, ec);
-  }
-
-private:
-  // Destroy all user-defined handler objects owned by the service.
-  void shutdown_service()
-  {
-  }
-
-  // The service that provides the platform-specific implementation.
-  service_impl_type& service_impl_;
-};
-
-} // namespace old
-} // namespace ssl
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_SSL_OLD_STREAM_SERVICE_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/rfc2818_verification.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/rfc2818_verification.hpp
deleted file mode 100644
index acadfaa70e01..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/rfc2818_verification.hpp
+++ /dev/null
@@ -1,100 +0,0 @@
-//
-// ssl/rfc2818_verification.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_SSL_RFC2818_VERIFICATION_HPP
-#define ASIO_SSL_RFC2818_VERIFICATION_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if !defined(ASIO_ENABLE_OLD_SSL)
-# include <string>
-# include "asio/ssl/detail/openssl_types.hpp"
-# include "asio/ssl/verify_context.hpp"
-#endif // !defined(ASIO_ENABLE_OLD_SSL)
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace ssl {
-
-#if !defined(ASIO_ENABLE_OLD_SSL)
-
-/// Verifies a certificate against a hostname according to the rules described
-/// in RFC 2818.
-/**
- * @par Example
- * The following example shows how to synchronously open a secure connection to
- * a given host name:
- * @code
- * using asio::ip::tcp;
- * namespace ssl = asio::ssl;
- * typedef ssl::stream<tcp::socket> ssl_socket;
- *
- * // Create a context that uses the default paths for finding CA certificates.
- * ssl::context ctx(ssl::context::sslv23);
- * ctx.set_default_verify_paths();
- *
- * // Open a socket and connect it to the remote host.
- * asio::io_service io_service;
- * ssl_socket sock(io_service, ctx);
- * tcp::resolver resolver(io_service);
- * tcp::resolver::query query("host.name", "https");
- * asio::connect(sock.lowest_layer(), resolver.resolve(query));
- * sock.lowest_layer().set_option(tcp::no_delay(true));
- *
- * // Perform SSL handshake and verify the remote host's certificate.
- * sock.set_verify_mode(ssl::verify_peer);
- * sock.set_verify_callback(ssl::rfc2818_verification("host.name"));
- * sock.handshake(ssl_socket::client);
- *
- * // ... read and write as normal ...
- * @endcode
- */
-class rfc2818_verification
-{
-public:
-  /// The type of the function object's result.
-  typedef bool result_type;
-
-  /// Constructor.
-  explicit rfc2818_verification(const std::string& host)
-    : host_(host)
-  {
-  }
-
-  /// Perform certificate verification.
-  ASIO_DECL bool operator()(bool preverified, verify_context& ctx) const;
-
-private:
-  // Helper function to check a host name against a pattern.
-  ASIO_DECL static bool match_pattern(const char* pattern,
-      std::size_t pattern_length, const char* host);
-
-  // Helper function to check a host name against an IPv4 address
-  // The host name to be checked.
-  std::string host_;
-};
-
-#endif // defined(ASIO_ENABLE_OLD_SSL)
-
-} // namespace ssl
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#if defined(ASIO_HEADER_ONLY)
-# include "asio/ssl/impl/rfc2818_verification.ipp"
-#endif // defined(ASIO_HEADER_ONLY)
-
-#endif // ASIO_SSL_RFC2818_VERIFICATION_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/stream.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/stream.hpp
deleted file mode 100644
index 5e3af015c45c..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/stream.hpp
+++ /dev/null
@@ -1,756 +0,0 @@
-//
-// ssl/stream.hpp
-// ~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_SSL_STREAM_HPP
-#define ASIO_SSL_STREAM_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_ENABLE_OLD_SSL)
-# include "asio/ssl/old/stream.hpp"
-#else // defined(ASIO_ENABLE_OLD_SSL)
-# include "asio/async_result.hpp"
-# include "asio/detail/buffer_sequence_adapter.hpp"
-# include "asio/detail/handler_type_requirements.hpp"
-# include "asio/detail/noncopyable.hpp"
-# include "asio/detail/type_traits.hpp"
-# include "asio/ssl/context.hpp"
-# include "asio/ssl/detail/buffered_handshake_op.hpp"
-# include "asio/ssl/detail/handshake_op.hpp"
-# include "asio/ssl/detail/io.hpp"
-# include "asio/ssl/detail/read_op.hpp"
-# include "asio/ssl/detail/shutdown_op.hpp"
-# include "asio/ssl/detail/stream_core.hpp"
-# include "asio/ssl/detail/write_op.hpp"
-# include "asio/ssl/stream_base.hpp"
-#endif // defined(ASIO_ENABLE_OLD_SSL)
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace ssl {
-
-#if defined(ASIO_ENABLE_OLD_SSL)
-
-using asio::ssl::old::stream;
-
-#else // defined(ASIO_ENABLE_OLD_SSL)
-
-/// Provides stream-oriented functionality using SSL.
-/**
- * The stream class template provides asynchronous and blocking stream-oriented
- * functionality using SSL.
- *
- * @par Thread Safety
- * @e Distinct @e objects: Safe.@n
- * @e Shared @e objects: Unsafe. The application must also ensure that all
- * asynchronous operations are performed within the same implicit or explicit
- * strand.
- *
- * @par Example
- * To use the SSL stream template with an ip::tcp::socket, you would write:
- * @code
- * asio::io_service io_service;
- * asio::ssl::context ctx(asio::ssl::context::sslv23);
- * asio::ssl::stream<asio:ip::tcp::socket> sock(io_service, ctx);
- * @endcode
- *
- * @par Concepts:
- * AsyncReadStream, AsyncWriteStream, Stream, SyncReadStream, SyncWriteStream.
- */
-template <typename Stream>
-class stream :
-  public stream_base,
-  private noncopyable
-{
-public:
-  /// The native handle type of the SSL stream.
-  typedef SSL* native_handle_type;
-
-  /// Structure for use with deprecated impl_type.
-  struct impl_struct
-  {
-    SSL* ssl;
-  };
-
-  /// (Deprecated: Use native_handle_type.) The underlying implementation type.
-  typedef impl_struct* impl_type;
-
-  /// The type of the next layer.
-  typedef typename remove_reference<Stream>::type next_layer_type;
-
-  /// The type of the lowest layer.
-  typedef typename next_layer_type::lowest_layer_type lowest_layer_type;
-
-  /// Construct a stream.
-  /**
-   * This constructor creates a stream and initialises the underlying stream
-   * object.
-   *
-   * @param arg The argument to be passed to initialise the underlying stream.
-   *
-   * @param ctx The SSL context to be used for the stream.
-   */
-  template <typename Arg>
-  stream(Arg& arg, context& ctx)
-    : next_layer_(arg),
-      core_(ctx.native_handle(), next_layer_.lowest_layer().get_io_service())
-  {
-    backwards_compatible_impl_.ssl = core_.engine_.native_handle();
-  }
-
-  /// Destructor.
-  ~stream()
-  {
-  }
-
-  /// Get the io_service associated with the object.
-  /**
-   * This function may be used to obtain the io_service object that the stream
-   * uses to dispatch handlers for asynchronous operations.
-   *
-   * @return A reference to the io_service object that stream will use to
-   * dispatch handlers. Ownership is not transferred to the caller.
-   */
-  asio::io_service& get_io_service()
-  {
-    return next_layer_.lowest_layer().get_io_service();
-  }
-
-  /// Get the underlying implementation in the native type.
-  /**
-   * This function may be used to obtain the underlying implementation of the
-   * context. This is intended to allow access to context functionality that is
-   * not otherwise provided.
-   *
-   * @par Example
-   * The native_handle() function returns a pointer of type @c SSL* that is
-   * suitable for passing to functions such as @c SSL_get_verify_result and
-   * @c SSL_get_peer_certificate:
-   * @code
-   * asio::ssl::stream<asio:ip::tcp::socket> sock(io_service, ctx);
-   *
-   * // ... establish connection and perform handshake ...
-   *
-   * if (X509* cert = SSL_get_peer_certificate(sock.native_handle()))
-   * {
-   *   if (SSL_get_verify_result(sock.native_handle()) == X509_V_OK)
-   *   {
-   *     // ...
-   *   }
-   * }
-   * @endcode
-   */
-  native_handle_type native_handle()
-  {
-    return core_.engine_.native_handle();
-  }
-
-  /// (Deprecated: Use native_handle().) Get the underlying implementation in
-  /// the native type.
-  /**
-   * This function may be used to obtain the underlying implementation of the
-   * context. This is intended to allow access to stream functionality that is
-   * not otherwise provided.
-   */
-  impl_type impl()
-  {
-    return &backwards_compatible_impl_;
-  }
-
-  /// Get a reference to the next layer.
-  /**
-   * This function returns a reference to the next layer in a stack of stream
-   * layers.
-   *
-   * @return A reference to the next layer in the stack of stream layers.
-   * Ownership is not transferred to the caller.
-   */
-  const next_layer_type& next_layer() const
-  {
-    return next_layer_;
-  }
-
-  /// Get a reference to the next layer.
-  /**
-   * This function returns a reference to the next layer in a stack of stream
-   * layers.
-   *
-   * @return A reference to the next layer in the stack of stream layers.
-   * Ownership is not transferred to the caller.
-   */
-  next_layer_type& next_layer()
-  {
-    return next_layer_;
-  }
-
-  /// Get a reference to the lowest layer.
-  /**
-   * This function returns a reference to the lowest layer in a stack of
-   * stream layers.
-   *
-   * @return A reference to the lowest layer in the stack of stream layers.
-   * Ownership is not transferred to the caller.
-   */
-  lowest_layer_type& lowest_layer()
-  {
-    return next_layer_.lowest_layer();
-  }
-
-  /// Get a reference to the lowest layer.
-  /**
-   * This function returns a reference to the lowest layer in a stack of
-   * stream layers.
-   *
-   * @return A reference to the lowest layer in the stack of stream layers.
-   * Ownership is not transferred to the caller.
-   */
-  const lowest_layer_type& lowest_layer() const
-  {
-    return next_layer_.lowest_layer();
-  }
-
-  /// Set the peer verification mode.
-  /**
-   * This function may be used to configure the peer verification mode used by
-   * the stream. The new mode will override the mode inherited from the context.
-   *
-   * @param v A bitmask of peer verification modes. See @ref verify_mode for
-   * available values.
-   *
-   * @throws asio::system_error Thrown on failure.
-   *
-   * @note Calls @c SSL_set_verify.
-   */
-  void set_verify_mode(verify_mode v)
-  {
-    asio::error_code ec;
-    set_verify_mode(v, ec);
-    asio::detail::throw_error(ec, "set_verify_mode");
-  }
-
-  /// Set the peer verification mode.
-  /**
-   * This function may be used to configure the peer verification mode used by
-   * the stream. The new mode will override the mode inherited from the context.
-   *
-   * @param v A bitmask of peer verification modes. See @ref verify_mode for
-   * available values.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   *
-   * @note Calls @c SSL_set_verify.
-   */
-  asio::error_code set_verify_mode(
-      verify_mode v, asio::error_code& ec)
-  {
-    return core_.engine_.set_verify_mode(v, ec);
-  }
-
-  /// Set the peer verification depth.
-  /**
-   * This function may be used to configure the maximum verification depth
-   * allowed by the stream.
-   *
-   * @param depth Maximum depth for the certificate chain verification that
-   * shall be allowed.
-   *
-   * @throws asio::system_error Thrown on failure.
-   *
-   * @note Calls @c SSL_set_verify_depth.
-   */
-  void set_verify_depth(int depth)
-  {
-    asio::error_code ec;
-    set_verify_depth(depth, ec);
-    asio::detail::throw_error(ec, "set_verify_depth");
-  }
-
-  /// Set the peer verification depth.
-  /**
-   * This function may be used to configure the maximum verification depth
-   * allowed by the stream.
-   *
-   * @param depth Maximum depth for the certificate chain verification that
-   * shall be allowed.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   *
-   * @note Calls @c SSL_set_verify_depth.
-   */
-  asio::error_code set_verify_depth(
-      int depth, asio::error_code& ec)
-  {
-    return core_.engine_.set_verify_depth(depth, ec);
-  }
-
-  /// Set the callback used to verify peer certificates.
-  /**
-   * This function is used to specify a callback function that will be called
-   * by the implementation when it needs to verify a peer certificate.
-   *
-   * @param callback The function object to be used for verifying a certificate.
-   * The function signature of the handler must be:
-   * @code bool verify_callback(
-   *   bool preverified, // True if the certificate passed pre-verification.
-   *   verify_context& ctx // The peer certificate and other context.
-   * ); @endcode
-   * The return value of the callback is true if the certificate has passed
-   * verification, false otherwise.
-   *
-   * @throws asio::system_error Thrown on failure.
-   *
-   * @note Calls @c SSL_set_verify.
-   */
-  template <typename VerifyCallback>
-  void set_verify_callback(VerifyCallback callback)
-  {
-    asio::error_code ec;
-    this->set_verify_callback(callback, ec);
-    asio::detail::throw_error(ec, "set_verify_callback");
-  }
-
-  /// Set the callback used to verify peer certificates.
-  /**
-   * This function is used to specify a callback function that will be called
-   * by the implementation when it needs to verify a peer certificate.
-   *
-   * @param callback The function object to be used for verifying a certificate.
-   * The function signature of the handler must be:
-   * @code bool verify_callback(
-   *   bool preverified, // True if the certificate passed pre-verification.
-   *   verify_context& ctx // The peer certificate and other context.
-   * ); @endcode
-   * The return value of the callback is true if the certificate has passed
-   * verification, false otherwise.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   *
-   * @note Calls @c SSL_set_verify.
-   */
-  template <typename VerifyCallback>
-  asio::error_code set_verify_callback(VerifyCallback callback,
-      asio::error_code& ec)
-  {
-    return core_.engine_.set_verify_callback(
-        new detail::verify_callback<VerifyCallback>(callback), ec);
-  }
-
-  /// Perform SSL handshaking.
-  /**
-   * This function is used to perform SSL handshaking on the stream. The
-   * function call will block until handshaking is complete or an error occurs.
-   *
-   * @param type The type of handshaking to be performed, i.e. as a client or as
-   * a server.
-   *
-   * @throws asio::system_error Thrown on failure.
-   */
-  void handshake(handshake_type type)
-  {
-    asio::error_code ec;
-    handshake(type, ec);
-    asio::detail::throw_error(ec, "handshake");
-  }
-
-  /// Perform SSL handshaking.
-  /**
-   * This function is used to perform SSL handshaking on the stream. The
-   * function call will block until handshaking is complete or an error occurs.
-   *
-   * @param type The type of handshaking to be performed, i.e. as a client or as
-   * a server.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   */
-  asio::error_code handshake(handshake_type type,
-      asio::error_code& ec)
-  {
-    detail::io(next_layer_, core_, detail::handshake_op(type), ec);
-    return ec;
-  }
-
-  /// Perform SSL handshaking.
-  /**
-   * This function is used to perform SSL handshaking on the stream. The
-   * function call will block until handshaking is complete or an error occurs.
-   *
-   * @param type The type of handshaking to be performed, i.e. as a client or as
-   * a server.
-   *
-   * @param buffers The buffered data to be reused for the handshake.
-   *
-   * @throws asio::system_error Thrown on failure.
-   */
-  template <typename ConstBufferSequence>
-  void handshake(handshake_type type, const ConstBufferSequence& buffers)
-  {
-    asio::error_code ec;
-    handshake(type, buffers, ec);
-    asio::detail::throw_error(ec, "handshake");
-  }
-
-  /// Perform SSL handshaking.
-  /**
-   * This function is used to perform SSL handshaking on the stream. The
-   * function call will block until handshaking is complete or an error occurs.
-   *
-   * @param type The type of handshaking to be performed, i.e. as a client or as
-   * a server.
-   *
-   * @param buffers The buffered data to be reused for the handshake.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   */
-  template <typename ConstBufferSequence>
-  asio::error_code handshake(handshake_type type,
-      const ConstBufferSequence& buffers, asio::error_code& ec)
-  {
-    detail::io(next_layer_, core_,
-        detail::buffered_handshake_op<ConstBufferSequence>(type, buffers), ec);
-    return ec;
-  }
-
-  /// Start an asynchronous SSL handshake.
-  /**
-   * This function is used to asynchronously perform an SSL handshake on the
-   * stream. This function call always returns immediately.
-   *
-   * @param type The type of handshaking to be performed, i.e. as a client or as
-   * a server.
-   *
-   * @param handler The handler to be called when the handshake operation
-   * completes. Copies will be made of the handler as required. The equivalent
-   * function signature of the handler must be:
-   * @code void handler(
-   *   const asio::error_code& error // Result of operation.
-   * ); @endcode
-   */
-  template <typename HandshakeHandler>
-  ASIO_INITFN_RESULT_TYPE(HandshakeHandler,
-      void (asio::error_code))
-  async_handshake(handshake_type type,
-      ASIO_MOVE_ARG(HandshakeHandler) handler)
-  {
-    // If you get an error on the following line it means that your handler does
-    // not meet the documented type requirements for a HandshakeHandler.
-    ASIO_HANDSHAKE_HANDLER_CHECK(HandshakeHandler, handler) type_check;
-
-    asio::detail::async_result_init<
-      HandshakeHandler, void (asio::error_code)> init(
-        ASIO_MOVE_CAST(HandshakeHandler)(handler));
-
-    detail::async_io(next_layer_, core_,
-        detail::handshake_op(type), init.handler);
-
-    return init.result.get();
-  }
-
-  /// Start an asynchronous SSL handshake.
-  /**
-   * This function is used to asynchronously perform an SSL handshake on the
-   * stream. This function call always returns immediately.
-   *
-   * @param type The type of handshaking to be performed, i.e. as a client or as
-   * a server.
-   *
-   * @param buffers The buffered data to be reused for the handshake. Although
-   * the buffers object may be copied as necessary, ownership of the underlying
-   * buffers is retained by the caller, which must guarantee that they remain
-   * valid until the handler is called.
-   *
-   * @param handler The handler to be called when the handshake operation
-   * completes. Copies will be made of the handler as required. The equivalent
-   * function signature of the handler must be:
-   * @code void handler(
-   *   const asio::error_code& error, // Result of operation.
-   *   std::size_t bytes_transferred // Amount of buffers used in handshake.
-   * ); @endcode
-   */
-  template <typename ConstBufferSequence, typename BufferedHandshakeHandler>
-  ASIO_INITFN_RESULT_TYPE(BufferedHandshakeHandler,
-      void (asio::error_code, std::size_t))
-  async_handshake(handshake_type type, const ConstBufferSequence& buffers,
-      ASIO_MOVE_ARG(BufferedHandshakeHandler) handler)
-  {
-    // If you get an error on the following line it means that your handler does
-    // not meet the documented type requirements for a BufferedHandshakeHandler.
-    ASIO_BUFFERED_HANDSHAKE_HANDLER_CHECK(
-        BufferedHandshakeHandler, handler) type_check;
-
-    asio::detail::async_result_init<BufferedHandshakeHandler,
-      void (asio::error_code, std::size_t)> init(
-        ASIO_MOVE_CAST(BufferedHandshakeHandler)(handler));
-
-    detail::async_io(next_layer_, core_,
-        detail::buffered_handshake_op<ConstBufferSequence>(type, buffers),
-        init.handler);
-
-    return init.result.get();
-  }
-
-  /// Shut down SSL on the stream.
-  /**
-   * This function is used to shut down SSL on the stream. The function call
-   * will block until SSL has been shut down or an error occurs.
-   *
-   * @throws asio::system_error Thrown on failure.
-   */
-  void shutdown()
-  {
-    asio::error_code ec;
-    shutdown(ec);
-    asio::detail::throw_error(ec, "shutdown");
-  }
-
-  /// Shut down SSL on the stream.
-  /**
-   * This function is used to shut down SSL on the stream. The function call
-   * will block until SSL has been shut down or an error occurs.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   */
-  asio::error_code shutdown(asio::error_code& ec)
-  {
-    detail::io(next_layer_, core_, detail::shutdown_op(), ec);
-    return ec;
-  }
-
-  /// Asynchronously shut down SSL on the stream.
-  /**
-   * This function is used to asynchronously shut down SSL on the stream. This
-   * function call always returns immediately.
-   *
-   * @param handler The handler to be called when the handshake operation
-   * completes. Copies will be made of the handler as required. The equivalent
-   * function signature of the handler must be:
-   * @code void handler(
-   *   const asio::error_code& error // Result of operation.
-   * ); @endcode
-   */
-  template <typename ShutdownHandler>
-  ASIO_INITFN_RESULT_TYPE(ShutdownHandler,
-      void (asio::error_code))
-  async_shutdown(ASIO_MOVE_ARG(ShutdownHandler) handler)
-  {
-    // If you get an error on the following line it means that your handler does
-    // not meet the documented type requirements for a ShutdownHandler.
-    ASIO_SHUTDOWN_HANDLER_CHECK(ShutdownHandler, handler) type_check;
-
-    asio::detail::async_result_init<
-      ShutdownHandler, void (asio::error_code)> init(
-        ASIO_MOVE_CAST(ShutdownHandler)(handler));
-
-    detail::async_io(next_layer_, core_, detail::shutdown_op(), init.handler);
-
-    return init.result.get();
-  }
-
-  /// Write some data to the stream.
-  /**
-   * This function is used to write data on the stream. The function call will
-   * block until one or more bytes of data has been written successfully, or
-   * until an error occurs.
-   *
-   * @param buffers The data to be written.
-   *
-   * @returns The number of bytes written.
-   *
-   * @throws asio::system_error Thrown on failure.
-   *
-   * @note The write_some operation may not transmit all of the data to the
-   * peer. Consider using the @ref write function if you need to ensure that all
-   * data is written before the blocking operation completes.
-   */
-  template <typename ConstBufferSequence>
-  std::size_t write_some(const ConstBufferSequence& buffers)
-  {
-    asio::error_code ec;
-    std::size_t n = write_some(buffers, ec);
-    asio::detail::throw_error(ec, "write_some");
-    return n;
-  }
-
-  /// Write some data to the stream.
-  /**
-   * This function is used to write data on the stream. The function call will
-   * block until one or more bytes of data has been written successfully, or
-   * until an error occurs.
-   *
-   * @param buffers The data to be written to the stream.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   *
-   * @returns The number of bytes written. Returns 0 if an error occurred.
-   *
-   * @note The write_some operation may not transmit all of the data to the
-   * peer. Consider using the @ref write function if you need to ensure that all
-   * data is written before the blocking operation completes.
-   */
-  template <typename ConstBufferSequence>
-  std::size_t write_some(const ConstBufferSequence& buffers,
-      asio::error_code& ec)
-  {
-    return detail::io(next_layer_, core_,
-        detail::write_op<ConstBufferSequence>(buffers), ec);
-  }
-
-  /// Start an asynchronous write.
-  /**
-   * This function is used to asynchronously write one or more bytes of data to
-   * the stream. The function call always returns immediately.
-   *
-   * @param buffers The data to be written to the stream. Although the buffers
-   * object may be copied as necessary, ownership of the underlying buffers is
-   * retained by the caller, which must guarantee that they remain valid until
-   * the handler is called.
-   *
-   * @param handler The handler to be called when the write operation completes.
-   * Copies will be made of the handler as required. The equivalent function
-   * signature of the handler must be:
-   * @code void handler(
-   *   const asio::error_code& error, // Result of operation.
-   *   std::size_t bytes_transferred           // Number of bytes written.
-   * ); @endcode
-   *
-   * @note The async_write_some operation may not transmit all of the data to
-   * the peer. Consider using the @ref async_write function if you need to
-   * ensure that all data is written before the blocking operation completes.
-   */
-  template <typename ConstBufferSequence, typename WriteHandler>
-  ASIO_INITFN_RESULT_TYPE(WriteHandler,
-      void (asio::error_code, std::size_t))
-  async_write_some(const ConstBufferSequence& buffers,
-      ASIO_MOVE_ARG(WriteHandler) handler)
-  {
-    // If you get an error on the following line it means that your handler does
-    // not meet the documented type requirements for a WriteHandler.
-    ASIO_WRITE_HANDLER_CHECK(WriteHandler, handler) type_check;
-
-    asio::detail::async_result_init<
-      WriteHandler, void (asio::error_code, std::size_t)> init(
-        ASIO_MOVE_CAST(WriteHandler)(handler));
-
-    detail::async_io(next_layer_, core_,
-        detail::write_op<ConstBufferSequence>(buffers), init.handler);
-
-    return init.result.get();
-  }
-
-  /// Read some data from the stream.
-  /**
-   * This function is used to read data from the stream. The function call will
-   * block until one or more bytes of data has been read successfully, or until
-   * an error occurs.
-   *
-   * @param buffers The buffers into which the data will be read.
-   *
-   * @returns The number of bytes read.
-   *
-   * @throws asio::system_error Thrown on failure.
-   *
-   * @note The read_some operation may not read all of the requested number of
-   * bytes. Consider using the @ref read function if you need to ensure that the
-   * requested amount of data is read before the blocking operation completes.
-   */
-  template <typename MutableBufferSequence>
-  std::size_t read_some(const MutableBufferSequence& buffers)
-  {
-    asio::error_code ec;
-    std::size_t n = read_some(buffers, ec);
-    asio::detail::throw_error(ec, "read_some");
-    return n;
-  }
-
-  /// Read some data from the stream.
-  /**
-   * This function is used to read data from the stream. The function call will
-   * block until one or more bytes of data has been read successfully, or until
-   * an error occurs.
-   *
-   * @param buffers The buffers into which the data will be read.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   *
-   * @returns The number of bytes read. Returns 0 if an error occurred.
-   *
-   * @note The read_some operation may not read all of the requested number of
-   * bytes. Consider using the @ref read function if you need to ensure that the
-   * requested amount of data is read before the blocking operation completes.
-   */
-  template <typename MutableBufferSequence>
-  std::size_t read_some(const MutableBufferSequence& buffers,
-      asio::error_code& ec)
-  {
-    return detail::io(next_layer_, core_,
-        detail::read_op<MutableBufferSequence>(buffers), ec);
-  }
-
-  /// Start an asynchronous read.
-  /**
-   * This function is used to asynchronously read one or more bytes of data from
-   * the stream. The function call always returns immediately.
-   *
-   * @param buffers The buffers into which the data will be read. Although the
-   * buffers object may be copied as necessary, ownership of the underlying
-   * buffers is retained by the caller, which must guarantee that they remain
-   * valid until the handler is called.
-   *
-   * @param handler The handler to be called when the read operation completes.
-   * Copies will be made of the handler as required. The equivalent function
-   * signature of the handler must be:
-   * @code void handler(
-   *   const asio::error_code& error, // Result of operation.
-   *   std::size_t bytes_transferred           // Number of bytes read.
-   * ); @endcode
-   *
-   * @note The async_read_some operation may not read all of the requested
-   * number of bytes. Consider using the @ref async_read function if you need to
-   * ensure that the requested amount of data is read before the asynchronous
-   * operation completes.
-   */
-  template <typename MutableBufferSequence, typename ReadHandler>
-  ASIO_INITFN_RESULT_TYPE(ReadHandler,
-      void (asio::error_code, std::size_t))
-  async_read_some(const MutableBufferSequence& buffers,
-      ASIO_MOVE_ARG(ReadHandler) handler)
-  {
-    // If you get an error on the following line it means that your handler does
-    // not meet the documented type requirements for a ReadHandler.
-    ASIO_READ_HANDLER_CHECK(ReadHandler, handler) type_check;
-
-    asio::detail::async_result_init<
-      ReadHandler, void (asio::error_code, std::size_t)> init(
-        ASIO_MOVE_CAST(ReadHandler)(handler));
-
-    detail::async_io(next_layer_, core_,
-        detail::read_op<MutableBufferSequence>(buffers), init.handler);
-
-    return init.result.get();
-  }
-
-private:
-  Stream next_layer_;
-  detail::stream_core core_;
-  impl_struct backwards_compatible_impl_;
-};
-
-#endif // defined(ASIO_ENABLE_OLD_SSL)
-
-} // namespace ssl
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_SSL_STREAM_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/stream_base.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/stream_base.hpp
deleted file mode 100644
index 8b3a9c5df365..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/stream_base.hpp
+++ /dev/null
@@ -1,52 +0,0 @@
-//
-// ssl/stream_base.hpp
-// ~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_SSL_STREAM_BASE_HPP
-#define ASIO_SSL_STREAM_BASE_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace ssl {
-
-/// The stream_base class is used as a base for the asio::ssl::stream
-/// class template so that we have a common place to define various enums.
-class stream_base
-{
-public:
-  /// Different handshake types.
-  enum handshake_type
-  {
-    /// Perform handshaking as a client.
-    client,
-
-    /// Perform handshaking as a server.
-    server
-  };
-
-protected:
-  /// Protected destructor to prevent deletion through this type.
-  ~stream_base()
-  {
-  }
-};
-
-} // namespace ssl
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_SSL_STREAM_BASE_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/stream_service.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/stream_service.hpp
deleted file mode 100644
index a3d130fa6317..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/stream_service.hpp
+++ /dev/null
@@ -1,40 +0,0 @@
-//
-// ssl/stream_service.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_SSL_STREAM_SERVICE_HPP
-#define ASIO_SSL_STREAM_SERVICE_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_ENABLE_OLD_SSL)
-# include "asio/ssl/old/stream_service.hpp"
-#endif // defined(ASIO_ENABLE_OLD_SSL)
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace ssl {
-
-#if defined(ASIO_ENABLE_OLD_SSL)
-
-using asio::ssl::old::stream_service;
-
-#endif // defined(ASIO_ENABLE_OLD_SSL)
-
-} // namespace ssl
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_SSL_STREAM_SERVICE_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/verify_context.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/verify_context.hpp
deleted file mode 100644
index 1de681ccbe50..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/verify_context.hpp
+++ /dev/null
@@ -1,73 +0,0 @@
-//
-// ssl/verify_context.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_SSL_VERIFY_CONTEXT_HPP
-#define ASIO_SSL_VERIFY_CONTEXT_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if !defined(ASIO_ENABLE_OLD_SSL)
-# include "asio/detail/noncopyable.hpp"
-# include "asio/ssl/detail/openssl_types.hpp"
-#endif // !defined(ASIO_ENABLE_OLD_SSL)
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace ssl {
-
-#if !defined(ASIO_ENABLE_OLD_SSL)
-
-/// A simple wrapper around the X509_STORE_CTX type, used during verification of
-/// a peer certificate.
-/**
- * @note The verify_context does not own the underlying X509_STORE_CTX object.
- */
-class verify_context
-  : private noncopyable
-{
-public:
-  /// The native handle type of the verification context.
-  typedef X509_STORE_CTX* native_handle_type;
-
-  /// Constructor.
-  explicit verify_context(native_handle_type handle)
-    : handle_(handle)
-  {
-  }
-
-  /// Get the underlying implementation in the native type.
-  /**
-   * This function may be used to obtain the underlying implementation of the
-   * context. This is intended to allow access to context functionality that is
-   * not otherwise provided.
-   */
-  native_handle_type native_handle()
-  {
-    return handle_;
-  }
-
-private:
-  // The underlying native implementation.
-  native_handle_type handle_;
-};
-
-#endif // defined(ASIO_ENABLE_OLD_SSL)
-
-} // namespace ssl
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_SSL_VERIFY_CONTEXT_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/verify_mode.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/verify_mode.hpp
deleted file mode 100644
index f5921d073284..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/ssl/verify_mode.hpp
+++ /dev/null
@@ -1,63 +0,0 @@
-//
-// ssl/verify_mode.hpp
-// ~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_SSL_VERIFY_MODE_HPP
-#define ASIO_SSL_VERIFY_MODE_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include "asio/ssl/detail/openssl_types.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace ssl {
-
-/// Bitmask type for peer verification.
-/**
- * Possible values are:
- *
- * @li @ref verify_none
- * @li @ref verify_peer
- * @li @ref verify_fail_if_no_peer_cert
- * @li @ref verify_client_once
- */
-typedef int verify_mode;
-
-#if defined(GENERATING_DOCUMENTATION)
-/// No verification.
-const int verify_none = implementation_defined;
-
-/// Verify the peer.
-const int verify_peer = implementation_defined;
-
-/// Fail verification if the peer has no certificate. Ignored unless
-/// @ref verify_peer is set.
-const int verify_fail_if_no_peer_cert = implementation_defined;
-
-/// Do not request client certificate on renegotiation. Ignored unless
-/// @ref verify_peer is set.
-const int verify_client_once = implementation_defined;
-#else
-const int verify_none = SSL_VERIFY_NONE;
-const int verify_peer = SSL_VERIFY_PEER;
-const int verify_fail_if_no_peer_cert = SSL_VERIFY_FAIL_IF_NO_PEER_CERT;
-const int verify_client_once = SSL_VERIFY_CLIENT_ONCE;
-#endif
-
-} // namespace ssl
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_SSL_VERIFY_MODE_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/steady_timer.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/steady_timer.hpp
deleted file mode 100644
index e7472f608554..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/steady_timer.hpp
+++ /dev/null
@@ -1,61 +0,0 @@
-//
-// steady_timer.hpp
-// ~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_STEADY_TIMER_HPP
-#define ASIO_STEADY_TIMER_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_HAS_STD_CHRONO) \
-  || defined(ASIO_HAS_BOOST_CHRONO) \
-  || defined(GENERATING_DOCUMENTATION)
-
-#if defined(ASIO_HAS_STD_CHRONO)
-# include <chrono>
-#elif defined(ASIO_HAS_BOOST_CHRONO)
-# include <boost/chrono/system_clocks.hpp>
-#endif
-
-#include "asio/basic_waitable_timer.hpp"
-
-namespace asio {
-
-#if defined(GENERATING_DOCUMENTATION)
-/// Typedef for a timer based on the steady clock.
-/**
- * This typedef uses the C++11 @c &lt;chrono&gt; standard library facility, if
- * available. Otherwise, it may use the Boost.Chrono library. To explicitly
- * utilise Boost.Chrono, use the basic_waitable_timer template directly:
- * @code
- * typedef basic_waitable_timer<boost::chrono::steady_clock> timer;
- * @endcode
- */
-typedef basic_waitable_timer<chrono::steady_clock> steady_timer;
-#elif defined(ASIO_HAS_STD_CHRONO)
-# if defined(ASIO_HAS_STD_CHRONO_MONOTONIC_CLOCK)
-typedef basic_waitable_timer<std::chrono::monotonic_clock> steady_timer;
-# else // defined(ASIO_HAS_STD_CHRONO_MONOTONIC_CLOCK)
-typedef basic_waitable_timer<std::chrono::steady_clock> steady_timer;
-# endif // defined(ASIO_HAS_STD_CHRONO_MONOTONIC_CLOCK)
-#elif defined(ASIO_HAS_BOOST_CHRONO)
-typedef basic_waitable_timer<boost::chrono::steady_clock> steady_timer;
-#endif
-
-} // namespace asio
-
-#endif // defined(ASIO_HAS_STD_CHRONO) 
-       //   || defined(ASIO_HAS_BOOST_CHRONO)
-       //   || defined(GENERATING_DOCUMENTATION)
-
-#endif // ASIO_STEADY_TIMER_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/strand.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/strand.hpp
deleted file mode 100644
index a81718be0b20..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/strand.hpp
+++ /dev/null
@@ -1,251 +0,0 @@
-//
-// strand.hpp
-// ~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_STRAND_HPP
-#define ASIO_STRAND_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include "asio/async_result.hpp"
-#include "asio/detail/handler_type_requirements.hpp"
-#include "asio/detail/strand_service.hpp"
-#include "asio/detail/wrapped_handler.hpp"
-#include "asio/io_service.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-
-/// Provides serialised handler execution.
-/**
- * The io_service::strand class provides the ability to post and dispatch
- * handlers with the guarantee that none of those handlers will execute
- * concurrently.
- *
- * @par Order of handler invocation
- * Given:
- *
- * @li a strand object @c s
- *
- * @li an object @c a meeting completion handler requirements
- *
- * @li an object @c a1 which is an arbitrary copy of @c a made by the
- * implementation
- *
- * @li an object @c b meeting completion handler requirements
- *
- * @li an object @c b1 which is an arbitrary copy of @c b made by the
- * implementation
- *
- * if any of the following conditions are true:
- *
- * @li @c s.post(a) happens-before @c s.post(b)
- * 
- * @li @c s.post(a) happens-before @c s.dispatch(b), where the latter is
- * performed outside the strand
- * 
- * @li @c s.dispatch(a) happens-before @c s.post(b), where the former is
- * performed outside the strand
- * 
- * @li @c s.dispatch(a) happens-before @c s.dispatch(b), where both are
- * performed outside the strand
- *   
- * then @c asio_handler_invoke(a1, &a1) happens-before
- * @c asio_handler_invoke(b1, &b1).
- * 
- * Note that in the following case:
- * @code async_op_1(..., s.wrap(a));
- * async_op_2(..., s.wrap(b)); @endcode
- * the completion of the first async operation will perform @c s.dispatch(a),
- * and the second will perform @c s.dispatch(b), but the order in which those
- * are performed is unspecified. That is, you cannot state whether one
- * happens-before the other. Therefore none of the above conditions are met and
- * no ordering guarantee is made.
- *
- * @note The implementation makes no guarantee that handlers posted or
- * dispatched through different @c strand objects will be invoked concurrently.
- *
- * @par Thread Safety
- * @e Distinct @e objects: Safe.@n
- * @e Shared @e objects: Safe.
- *
- * @par Concepts:
- * Dispatcher.
- */
-class io_service::strand
-{
-public:
-  /// Constructor.
-  /**
-   * Constructs the strand.
-   *
-   * @param io_service The io_service object that the strand will use to
-   * dispatch handlers that are ready to be run.
-   */
-  explicit strand(asio::io_service& io_service)
-    : service_(asio::use_service<
-        asio::detail::strand_service>(io_service))
-  {
-    service_.construct(impl_);
-  }
-
-  /// Destructor.
-  /**
-   * Destroys a strand.
-   *
-   * Handlers posted through the strand that have not yet been invoked will
-   * still be dispatched in a way that meets the guarantee of non-concurrency.
-   */
-  ~strand()
-  {
-  }
-
-  /// Get the io_service associated with the strand.
-  /**
-   * This function may be used to obtain the io_service object that the strand
-   * uses to dispatch handlers for asynchronous operations.
-   *
-   * @return A reference to the io_service object that the strand will use to
-   * dispatch handlers. Ownership is not transferred to the caller.
-   */
-  asio::io_service& get_io_service()
-  {
-    return service_.get_io_service();
-  }
-
-  /// Request the strand to invoke the given handler.
-  /**
-   * This function is used to ask the strand to execute the given handler.
-   *
-   * The strand object guarantees that handlers posted or dispatched through
-   * the strand will not be executed concurrently. The handler may be executed
-   * inside this function if the guarantee can be met. If this function is
-   * called from within a handler that was posted or dispatched through the same
-   * strand, then the new handler will be executed immediately.
-   *
-   * The strand's guarantee is in addition to the guarantee provided by the
-   * underlying io_service. The io_service guarantees that the handler will only
-   * be called in a thread in which the io_service's run member function is
-   * currently being invoked.
-   *
-   * @param handler The handler to be called. The strand will make a copy of the
-   * handler object as required. The function signature of the handler must be:
-   * @code void handler(); @endcode
-   */
-  template <typename CompletionHandler>
-  ASIO_INITFN_RESULT_TYPE(CompletionHandler, void ())
-  dispatch(ASIO_MOVE_ARG(CompletionHandler) handler)
-  {
-    // If you get an error on the following line it means that your handler does
-    // not meet the documented type requirements for a CompletionHandler.
-    ASIO_COMPLETION_HANDLER_CHECK(CompletionHandler, handler) type_check;
-
-    detail::async_result_init<
-      CompletionHandler, void ()> init(
-        ASIO_MOVE_CAST(CompletionHandler)(handler));
-
-    service_.dispatch(impl_, init.handler);
-
-    return init.result.get();
-  }
-
-  /// Request the strand to invoke the given handler and return
-  /// immediately.
-  /**
-   * This function is used to ask the strand to execute the given handler, but
-   * without allowing the strand to call the handler from inside this function.
-   *
-   * The strand object guarantees that handlers posted or dispatched through
-   * the strand will not be executed concurrently. The strand's guarantee is in
-   * addition to the guarantee provided by the underlying io_service. The
-   * io_service guarantees that the handler will only be called in a thread in
-   * which the io_service's run member function is currently being invoked.
-   *
-   * @param handler The handler to be called. The strand will make a copy of the
-   * handler object as required. The function signature of the handler must be:
-   * @code void handler(); @endcode
-   */
-  template <typename CompletionHandler>
-  ASIO_INITFN_RESULT_TYPE(CompletionHandler, void ())
-  post(ASIO_MOVE_ARG(CompletionHandler) handler)
-  {
-    // If you get an error on the following line it means that your handler does
-    // not meet the documented type requirements for a CompletionHandler.
-    ASIO_COMPLETION_HANDLER_CHECK(CompletionHandler, handler) type_check;
-
-    detail::async_result_init<
-      CompletionHandler, void ()> init(
-        ASIO_MOVE_CAST(CompletionHandler)(handler));
-
-    service_.post(impl_, init.handler);
-
-    return init.result.get();
-  }
-
-  /// Create a new handler that automatically dispatches the wrapped handler
-  /// on the strand.
-  /**
-   * This function is used to create a new handler function object that, when
-   * invoked, will automatically pass the wrapped handler to the strand's
-   * dispatch function.
-   *
-   * @param handler The handler to be wrapped. The strand will make a copy of
-   * the handler object as required. The function signature of the handler must
-   * be: @code void handler(A1 a1, ... An an); @endcode
-   *
-   * @return A function object that, when invoked, passes the wrapped handler to
-   * the strand's dispatch function. Given a function object with the signature:
-   * @code R f(A1 a1, ... An an); @endcode
-   * If this function object is passed to the wrap function like so:
-   * @code strand.wrap(f); @endcode
-   * then the return value is a function object with the signature
-   * @code void g(A1 a1, ... An an); @endcode
-   * that, when invoked, executes code equivalent to:
-   * @code strand.dispatch(boost::bind(f, a1, ... an)); @endcode
-   */
-  template <typename Handler>
-#if defined(GENERATING_DOCUMENTATION)
-  unspecified
-#else
-  detail::wrapped_handler<strand, Handler, detail::is_continuation_if_running>
-#endif
-  wrap(Handler handler)
-  {
-    return detail::wrapped_handler<io_service::strand, Handler,
-        detail::is_continuation_if_running>(*this, handler);
-  }
-
-  /// Determine whether the strand is running in the current thread.
-  /**
-   * @return @c true if the current thread is executing a handler that was
-   * submitted to the strand using post(), dispatch() or wrap(). Otherwise
-   * returns @c false.
-   */
-  bool running_in_this_thread() const
-  {
-    return service_.running_in_this_thread(impl_);
-  }
-
-private:
-  asio::detail::strand_service& service_;
-  asio::detail::strand_service::implementation_type impl_;
-};
-
-/// Typedef for backwards compatibility.
-typedef asio::io_service::strand strand;
-
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_STRAND_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/stream_socket_service.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/stream_socket_service.hpp
deleted file mode 100644
index 15bfa5be8b77..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/stream_socket_service.hpp
+++ /dev/null
@@ -1,376 +0,0 @@
-//
-// stream_socket_service.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_STREAM_SOCKET_SERVICE_HPP
-#define ASIO_STREAM_SOCKET_SERVICE_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include <cstddef>
-#include "asio/async_result.hpp"
-#include "asio/detail/type_traits.hpp"
-#include "asio/error.hpp"
-#include "asio/io_service.hpp"
-
-#if defined(ASIO_WINDOWS_RUNTIME)
-# include "asio/detail/winrt_ssocket_service.hpp"
-#elif defined(ASIO_HAS_IOCP)
-# include "asio/detail/win_iocp_socket_service.hpp"
-#else
-# include "asio/detail/reactive_socket_service.hpp"
-#endif
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-
-/// Default service implementation for a stream socket.
-template <typename Protocol>
-class stream_socket_service
-#if defined(GENERATING_DOCUMENTATION)
-  : public asio::io_service::service
-#else
-  : public asio::detail::service_base<stream_socket_service<Protocol> >
-#endif
-{
-public:
-#if defined(GENERATING_DOCUMENTATION)
-  /// The unique service identifier.
-  static asio::io_service::id id;
-#endif
-
-  /// The protocol type.
-  typedef Protocol protocol_type;
-
-  /// The endpoint type.
-  typedef typename Protocol::endpoint endpoint_type;
-
-private:
-  // The type of the platform-specific implementation.
-#if defined(ASIO_WINDOWS_RUNTIME)
-  typedef detail::winrt_ssocket_service<Protocol> service_impl_type;
-#elif defined(ASIO_HAS_IOCP)
-  typedef detail::win_iocp_socket_service<Protocol> service_impl_type;
-#else
-  typedef detail::reactive_socket_service<Protocol> service_impl_type;
-#endif
-
-public:
-  /// The type of a stream socket implementation.
-#if defined(GENERATING_DOCUMENTATION)
-  typedef implementation_defined implementation_type;
-#else
-  typedef typename service_impl_type::implementation_type implementation_type;
-#endif
-
-  /// (Deprecated: Use native_handle_type.) The native socket type.
-#if defined(GENERATING_DOCUMENTATION)
-  typedef implementation_defined native_type;
-#else
-  typedef typename service_impl_type::native_handle_type native_type;
-#endif
-
-  /// The native socket type.
-#if defined(GENERATING_DOCUMENTATION)
-  typedef implementation_defined native_handle_type;
-#else
-  typedef typename service_impl_type::native_handle_type native_handle_type;
-#endif
-
-  /// Construct a new stream socket service for the specified io_service.
-  explicit stream_socket_service(asio::io_service& io_service)
-    : asio::detail::service_base<
-        stream_socket_service<Protocol> >(io_service),
-      service_impl_(io_service)
-  {
-  }
-
-  /// Construct a new stream socket implementation.
-  void construct(implementation_type& impl)
-  {
-    service_impl_.construct(impl);
-  }
-
-#if defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
-  /// Move-construct a new stream socket implementation.
-  void move_construct(implementation_type& impl,
-      implementation_type& other_impl)
-  {
-    service_impl_.move_construct(impl, other_impl);
-  }
-
-  /// Move-assign from another stream socket implementation.
-  void move_assign(implementation_type& impl,
-      stream_socket_service& other_service,
-      implementation_type& other_impl)
-  {
-    service_impl_.move_assign(impl, other_service.service_impl_, other_impl);
-  }
-
-  /// Move-construct a new stream socket implementation from another protocol
-  /// type.
-  template <typename Protocol1>
-  void converting_move_construct(implementation_type& impl,
-      typename stream_socket_service<
-        Protocol1>::implementation_type& other_impl,
-      typename enable_if<is_convertible<
-        Protocol1, Protocol>::value>::type* = 0)
-  {
-    service_impl_.template converting_move_construct<Protocol1>(
-        impl, other_impl);
-  }
-#endif // defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
-
-  /// Destroy a stream socket implementation.
-  void destroy(implementation_type& impl)
-  {
-    service_impl_.destroy(impl);
-  }
-
-  /// Open a stream socket.
-  asio::error_code open(implementation_type& impl,
-      const protocol_type& protocol, asio::error_code& ec)
-  {
-    if (protocol.type() == ASIO_OS_DEF(SOCK_STREAM))
-      service_impl_.open(impl, protocol, ec);
-    else
-      ec = asio::error::invalid_argument;
-    return ec;
-  }
-
-  /// Assign an existing native socket to a stream socket.
-  asio::error_code assign(implementation_type& impl,
-      const protocol_type& protocol, const native_handle_type& native_socket,
-      asio::error_code& ec)
-  {
-    return service_impl_.assign(impl, protocol, native_socket, ec);
-  }
-
-  /// Determine whether the socket is open.
-  bool is_open(const implementation_type& impl) const
-  {
-    return service_impl_.is_open(impl);
-  }
-
-  /// Close a stream socket implementation.
-  asio::error_code close(implementation_type& impl,
-      asio::error_code& ec)
-  {
-    return service_impl_.close(impl, ec);
-  }
-
-  /// (Deprecated: Use native_handle().) Get the native socket implementation.
-  native_type native(implementation_type& impl)
-  {
-    return service_impl_.native_handle(impl);
-  }
-
-  /// Get the native socket implementation.
-  native_handle_type native_handle(implementation_type& impl)
-  {
-    return service_impl_.native_handle(impl);
-  }
-
-  /// Cancel all asynchronous operations associated with the socket.
-  asio::error_code cancel(implementation_type& impl,
-      asio::error_code& ec)
-  {
-    return service_impl_.cancel(impl, ec);
-  }
-
-  /// Determine whether the socket is at the out-of-band data mark.
-  bool at_mark(const implementation_type& impl,
-      asio::error_code& ec) const
-  {
-    return service_impl_.at_mark(impl, ec);
-  }
-
-  /// Determine the number of bytes available for reading.
-  std::size_t available(const implementation_type& impl,
-      asio::error_code& ec) const
-  {
-    return service_impl_.available(impl, ec);
-  }
-
-  /// Bind the stream socket to the specified local endpoint.
-  asio::error_code bind(implementation_type& impl,
-      const endpoint_type& endpoint, asio::error_code& ec)
-  {
-    return service_impl_.bind(impl, endpoint, ec);
-  }
-
-  /// Connect the stream socket to the specified endpoint.
-  asio::error_code connect(implementation_type& impl,
-      const endpoint_type& peer_endpoint, asio::error_code& ec)
-  {
-    return service_impl_.connect(impl, peer_endpoint, ec);
-  }
-
-  /// Start an asynchronous connect.
-  template <typename ConnectHandler>
-  ASIO_INITFN_RESULT_TYPE(ConnectHandler,
-      void (asio::error_code))
-  async_connect(implementation_type& impl,
-      const endpoint_type& peer_endpoint,
-      ASIO_MOVE_ARG(ConnectHandler) handler)
-  {
-    detail::async_result_init<
-      ConnectHandler, void (asio::error_code)> init(
-        ASIO_MOVE_CAST(ConnectHandler)(handler));
-
-    service_impl_.async_connect(impl, peer_endpoint, init.handler);
-
-    return init.result.get();
-  }
-
-  /// Set a socket option.
-  template <typename SettableSocketOption>
-  asio::error_code set_option(implementation_type& impl,
-      const SettableSocketOption& option, asio::error_code& ec)
-  {
-    return service_impl_.set_option(impl, option, ec);
-  }
-
-  /// Get a socket option.
-  template <typename GettableSocketOption>
-  asio::error_code get_option(const implementation_type& impl,
-      GettableSocketOption& option, asio::error_code& ec) const
-  {
-    return service_impl_.get_option(impl, option, ec);
-  }
-
-  /// Perform an IO control command on the socket.
-  template <typename IoControlCommand>
-  asio::error_code io_control(implementation_type& impl,
-      IoControlCommand& command, asio::error_code& ec)
-  {
-    return service_impl_.io_control(impl, command, ec);
-  }
-
-  /// Gets the non-blocking mode of the socket.
-  bool non_blocking(const implementation_type& impl) const
-  {
-    return service_impl_.non_blocking(impl);
-  }
-
-  /// Sets the non-blocking mode of the socket.
-  asio::error_code non_blocking(implementation_type& impl,
-      bool mode, asio::error_code& ec)
-  {
-    return service_impl_.non_blocking(impl, mode, ec);
-  }
-
-  /// Gets the non-blocking mode of the native socket implementation.
-  bool native_non_blocking(const implementation_type& impl) const
-  {
-    return service_impl_.native_non_blocking(impl);
-  }
-
-  /// Sets the non-blocking mode of the native socket implementation.
-  asio::error_code native_non_blocking(implementation_type& impl,
-      bool mode, asio::error_code& ec)
-  {
-    return service_impl_.native_non_blocking(impl, mode, ec);
-  }
-
-  /// Get the local endpoint.
-  endpoint_type local_endpoint(const implementation_type& impl,
-      asio::error_code& ec) const
-  {
-    return service_impl_.local_endpoint(impl, ec);
-  }
-
-  /// Get the remote endpoint.
-  endpoint_type remote_endpoint(const implementation_type& impl,
-      asio::error_code& ec) const
-  {
-    return service_impl_.remote_endpoint(impl, ec);
-  }
-
-  /// Disable sends or receives on the socket.
-  asio::error_code shutdown(implementation_type& impl,
-      socket_base::shutdown_type what, asio::error_code& ec)
-  {
-    return service_impl_.shutdown(impl, what, ec);
-  }
-
-  /// Send the given data to the peer.
-  template <typename ConstBufferSequence>
-  std::size_t send(implementation_type& impl,
-      const ConstBufferSequence& buffers,
-      socket_base::message_flags flags, asio::error_code& ec)
-  {
-    return service_impl_.send(impl, buffers, flags, ec);
-  }
-
-  /// Start an asynchronous send.
-  template <typename ConstBufferSequence, typename WriteHandler>
-  ASIO_INITFN_RESULT_TYPE(WriteHandler,
-      void (asio::error_code, std::size_t))
-  async_send(implementation_type& impl,
-      const ConstBufferSequence& buffers,
-      socket_base::message_flags flags,
-      ASIO_MOVE_ARG(WriteHandler) handler)
-  {
-    detail::async_result_init<
-      WriteHandler, void (asio::error_code, std::size_t)> init(
-        ASIO_MOVE_CAST(WriteHandler)(handler));
-
-    service_impl_.async_send(impl, buffers, flags, init.handler);
-
-    return init.result.get();
-  }
-
-  /// Receive some data from the peer.
-  template <typename MutableBufferSequence>
-  std::size_t receive(implementation_type& impl,
-      const MutableBufferSequence& buffers,
-      socket_base::message_flags flags, asio::error_code& ec)
-  {
-    return service_impl_.receive(impl, buffers, flags, ec);
-  }
-
-  /// Start an asynchronous receive.
-  template <typename MutableBufferSequence, typename ReadHandler>
-  ASIO_INITFN_RESULT_TYPE(ReadHandler,
-      void (asio::error_code, std::size_t))
-  async_receive(implementation_type& impl,
-      const MutableBufferSequence& buffers,
-      socket_base::message_flags flags,
-      ASIO_MOVE_ARG(ReadHandler) handler)
-  {
-    detail::async_result_init<
-      ReadHandler, void (asio::error_code, std::size_t)> init(
-        ASIO_MOVE_CAST(ReadHandler)(handler));
-
-    service_impl_.async_receive(impl, buffers, flags, init.handler);
-
-    return init.result.get();
-  }
-
-private:
-  // Destroy all user-defined handler objects owned by the service.
-  void shutdown_service()
-  {
-    service_impl_.shutdown_service();
-  }
-
-  // The platform-specific implementation.
-  service_impl_type service_impl_;
-};
-
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_STREAM_SOCKET_SERVICE_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/streambuf.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/streambuf.hpp
deleted file mode 100644
index 283c10a3e62a..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/streambuf.hpp
+++ /dev/null
@@ -1,33 +0,0 @@
-//
-// streambuf.hpp
-// ~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_STREAMBUF_HPP
-#define ASIO_STREAMBUF_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if !defined(ASIO_NO_IOSTREAM)
-
-#include "asio/basic_streambuf.hpp"
-
-namespace asio {
-
-/// Typedef for the typical usage of basic_streambuf.
-typedef basic_streambuf<> streambuf;
-
-} // namespace asio
-
-#endif // !defined(ASIO_NO_IOSTREAM)
-
-#endif // ASIO_STREAMBUF_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/system_error.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/system_error.hpp
deleted file mode 100644
index 319c24293c4d..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/system_error.hpp
+++ /dev/null
@@ -1,131 +0,0 @@
-//
-// system_error.hpp
-// ~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_SYSTEM_ERROR_HPP
-#define ASIO_SYSTEM_ERROR_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_HAS_STD_SYSTEM_ERROR)
-# include <system_error>
-#else // defined(ASIO_HAS_STD_SYSTEM_ERROR)
-# include <cerrno>
-# include <exception>
-# include <string>
-# include "asio/error_code.hpp"
-# include "asio/detail/scoped_ptr.hpp"
-#endif // defined(ASIO_HAS_STD_SYSTEM_ERROR)
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-
-#if defined(ASIO_HAS_STD_SYSTEM_ERROR)
-
-typedef std::system_error system_error;
-
-#else // defined(ASIO_HAS_STD_SYSTEM_ERROR)
-
-/// The system_error class is used to represent system conditions that
-/// prevent the library from operating correctly.
-class system_error
-  : public std::exception
-{
-public:
-  /// Construct with an error code.
-  system_error(const error_code& ec)
-    : code_(ec),
-      context_()
-  {
-  }
-
-  /// Construct with an error code and context.
-  system_error(const error_code& ec, const std::string& context)
-    : code_(ec),
-      context_(context)
-  {
-  }
-
-  /// Copy constructor.
-  system_error(const system_error& other)
-    : std::exception(other),
-      code_(other.code_),
-      context_(other.context_),
-      what_()
-  {
-  }
-
-  /// Destructor.
-  virtual ~system_error() throw ()
-  {
-  }
-
-  /// Assignment operator.
-  system_error& operator=(const system_error& e)
-  {
-    context_ = e.context_;
-    code_ = e.code_;
-    what_.reset();
-    return *this;
-  }
-
-  /// Get a string representation of the exception.
-  virtual const char* what() const throw ()
-  {
-#if !defined(ASIO_NO_EXCEPTIONS)
-    try
-#endif // !defined(ASIO_NO_EXCEPTIONS)
-    {
-      if (!what_.get())
-      {
-        std::string tmp(context_);
-        if (tmp.length())
-          tmp += ": ";
-        tmp += code_.message();
-        what_.reset(new std::string(tmp));
-      }
-      return what_->c_str();
-    }
-#if !defined(ASIO_NO_EXCEPTIONS)
-    catch (std::exception&)
-    {
-      return "system_error";
-    }
-#endif // !defined(ASIO_NO_EXCEPTIONS)
-  }
-
-  /// Get the error code associated with the exception.
-  error_code code() const
-  {
-    return code_;
-  }
-
-private:
-  // The code associated with the error.
-  error_code code_;
-
-  // The context associated with the error.
-  std::string context_;
-
-  // The string representation of the error.
-  mutable asio::detail::scoped_ptr<std::string> what_;
-};
-
-#endif // defined(ASIO_HAS_STD_SYSTEM_ERROR)
-
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_SYSTEM_ERROR_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/system_timer.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/system_timer.hpp
deleted file mode 100644
index 5a2a03811df3..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/system_timer.hpp
+++ /dev/null
@@ -1,57 +0,0 @@
-//
-// system_timer.hpp
-// ~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_SYSTEM_TIMER_HPP
-#define ASIO_SYSTEM_TIMER_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_HAS_STD_CHRONO) \
-  || defined(ASIO_HAS_BOOST_CHRONO) \
-  || defined(GENERATING_DOCUMENTATION)
-
-#if defined(ASIO_HAS_STD_CHRONO)
-# include <chrono>
-#elif defined(ASIO_HAS_BOOST_CHRONO)
-# include <boost/chrono/system_clocks.hpp>
-#endif
-
-#include "asio/basic_waitable_timer.hpp"
-
-namespace asio {
-
-#if defined(GENERATING_DOCUMENTATION)
-/// Typedef for a timer based on the system clock.
-/**
- * This typedef uses the C++11 @c &lt;chrono&gt; standard library facility, if
- * available. Otherwise, it may use the Boost.Chrono library. To explicitly
- * utilise Boost.Chrono, use the basic_waitable_timer template directly:
- * @code
- * typedef basic_waitable_timer<boost::chrono::system_clock> timer;
- * @endcode
- */
-typedef basic_waitable_timer<chrono::system_clock> system_timer;
-#elif defined(ASIO_HAS_STD_CHRONO)
-typedef basic_waitable_timer<std::chrono::system_clock> system_timer;
-#elif defined(ASIO_HAS_BOOST_CHRONO)
-typedef basic_waitable_timer<boost::chrono::system_clock> system_timer;
-#endif
-
-} // namespace asio
-
-#endif // defined(ASIO_HAS_STD_CHRONO) 
-       //   || defined(ASIO_HAS_BOOST_CHRONO)
-       //   || defined(GENERATING_DOCUMENTATION)
-
-#endif // ASIO_SYSTEM_TIMER_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/thread.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/thread.hpp
deleted file mode 100644
index c068bf04c9a9..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/thread.hpp
+++ /dev/null
@@ -1,92 +0,0 @@
-//
-// thread.hpp
-// ~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_THREAD_HPP
-#define ASIO_THREAD_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include "asio/detail/noncopyable.hpp"
-#include "asio/detail/thread.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-
-/// A simple abstraction for starting threads.
-/**
- * The asio::thread class implements the smallest possible subset of the
- * functionality of boost::thread. It is intended to be used only for starting
- * a thread and waiting for it to exit. If more extensive threading
- * capabilities are required, you are strongly advised to use something else.
- *
- * @par Thread Safety
- * @e Distinct @e objects: Safe.@n
- * @e Shared @e objects: Unsafe.
- *
- * @par Example
- * A typical use of asio::thread would be to launch a thread to run an
- * io_service's event processing loop:
- *
- * @par
- * @code asio::io_service io_service;
- * // ...
- * asio::thread t(boost::bind(&asio::io_service::run, &io_service));
- * // ...
- * t.join(); @endcode
- */
-class thread
-  : private noncopyable
-{
-public:
-  /// Start a new thread that executes the supplied function.
-  /**
-   * This constructor creates a new thread that will execute the given function
-   * or function object.
-   *
-   * @param f The function or function object to be run in the thread. The
-   * function signature must be: @code void f(); @endcode
-   */
-  template <typename Function>
-  explicit thread(Function f)
-    : impl_(f)
-  {
-  }
-
-  /// Destructor.
-  ~thread()
-  {
-  }
-
-  /// Wait for the thread to exit.
-  /**
-   * This function will block until the thread has exited.
-   *
-   * If this function is not called before the thread object is destroyed, the
-   * thread itself will continue to run until completion. You will, however,
-   * no longer have the ability to wait for it to exit.
-   */
-  void join()
-  {
-    impl_.join();
-  }
-
-private:
-  detail::thread impl_;
-};
-
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_THREAD_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/time_traits.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/time_traits.hpp
deleted file mode 100644
index 1a8c2df6ca1d..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/time_traits.hpp
+++ /dev/null
@@ -1,96 +0,0 @@
-//
-// time_traits.hpp
-// ~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_TIME_TRAITS_HPP
-#define ASIO_TIME_TRAITS_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/socket_types.hpp" // Must come before posix_time.
-
-#if defined(ASIO_HAS_BOOST_DATE_TIME) \
-  || defined(ASIO_CPP11_DATE_TIME) \
-  || defined(GENERATING_DOCUMENTATION)
-
-#if defined(ASIO_HAS_BOOST_DATE_TIME)
-#include "asio/detail/push_options.hpp"
-#include <boost/date_time/posix_time/posix_time_types.hpp>
-#include "asio/detail/pop_options.hpp"
-#endif // defined(ASIO_HAS_BOOST_DATE_TIME)
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-
-/// Time traits suitable for use with the deadline timer.
-template <typename Time>
-struct time_traits;
-
-#if defined(ASIO_HAS_BOOST_DATE_TIME)
-
-/// Time traits specialised for posix_time.
-template <>
-struct time_traits<boost::posix_time::ptime>
-{
-  /// The time type.
-  typedef boost::posix_time::ptime time_type;
-
-  /// The duration type.
-  typedef boost::posix_time::time_duration duration_type;
-
-  /// Get the current time.
-  static time_type now()
-  {
-#if defined(BOOST_DATE_TIME_HAS_HIGH_PRECISION_CLOCK)
-    return boost::posix_time::microsec_clock::universal_time();
-#else // defined(BOOST_DATE_TIME_HAS_HIGH_PRECISION_CLOCK)
-    return boost::posix_time::second_clock::universal_time();
-#endif // defined(BOOST_DATE_TIME_HAS_HIGH_PRECISION_CLOCK)
-  }
-
-  /// Add a duration to a time.
-  static time_type add(const time_type& t, const duration_type& d)
-  {
-    return t + d;
-  }
-
-  /// Subtract one time from another.
-  static duration_type subtract(const time_type& t1, const time_type& t2)
-  {
-    return t1 - t2;
-  }
-
-  /// Test whether one time is less than another.
-  static bool less_than(const time_type& t1, const time_type& t2)
-  {
-    return t1 < t2;
-  }
-
-  /// Convert to POSIX duration type.
-  static boost::posix_time::time_duration to_posix_duration(
-      const duration_type& d)
-  {
-    return d;
-  }
-};
-
-#endif // defined(ASIO_HAS_BOOST_DATE_TIME)
-
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // defined(ASIO_HAS_BOOST_DATE_TIME)
-       // || defined(ASIO_CPP11_DATE_TIME)
-       // || defined(GENERATING_DOCUMENTATION)
-
-#endif // ASIO_TIME_TRAITS_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/unyield.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/unyield.hpp
deleted file mode 100644
index 0be57acc9ad8..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/unyield.hpp
+++ /dev/null
@@ -1,21 +0,0 @@
-//
-// unyield.hpp
-// ~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifdef reenter
-# undef reenter
-#endif
-
-#ifdef yield
-# undef yield
-#endif
-
-#ifdef fork
-# undef fork
-#endif
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/use_future.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/use_future.hpp
deleted file mode 100644
index ae29bbcd3d39..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/use_future.hpp
+++ /dev/null
@@ -1,92 +0,0 @@
-//
-// use_future.hpp
-// ~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_USE_FUTURE_HPP
-#define ASIO_USE_FUTURE_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include <memory>
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-
-/// Class used to specify that an asynchronous operation should return a future.
-/**
- * The use_future_t class is used to indicate that an asynchronous operation
- * should return a std::future object. A use_future_t object may be passed as a
- * handler to an asynchronous operation, typically using the special value @c
- * asio::use_future. For example:
- *
- * @code std::future<std::size_t> my_future
- *   = my_socket.async_read_some(my_buffer, asio::use_future); @endcode
- *
- * The initiating function (async_read_some in the above example) returns a
- * future that will receive the result of the operation. If the operation
- * completes with an error_code indicating failure, it is converted into a
- * system_error and passed back to the caller via the future.
- */
-template <typename Allocator = std::allocator<void> >
-class use_future_t
-{
-public:
-  /// The allocator type. The allocator is used when constructing the
-  /// @c std::promise object for a given asynchronous operation.
-  typedef Allocator allocator_type;
-
-  /// Construct using default-constructed allocator.
-  ASIO_CONSTEXPR use_future_t()
-  {
-  }
-
-  /// Construct using specified allocator.
-  explicit use_future_t(const Allocator& allocator)
-    : allocator_(allocator)
-  {
-  }
-
-  /// Specify an alternate allocator.
-  template <typename OtherAllocator>
-  use_future_t<OtherAllocator> operator[](const OtherAllocator& allocator) const
-  {
-    return use_future_t<OtherAllocator>(allocator);
-  }
-
-  /// Obtain allocator.
-  allocator_type get_allocator() const
-  {
-    return allocator_;
-  }
-
-private:
-  Allocator allocator_;
-};
-
-/// A special value, similar to std::nothrow.
-/**
- * See the documentation for asio::use_future_t for a usage example.
- */
-#if defined(ASIO_HAS_CONSTEXPR) || defined(GENERATING_DOCUMENTATION)
-constexpr use_future_t<> use_future;
-#elif defined(ASIO_MSVC)
-__declspec(selectany) use_future_t<> use_future;
-#endif
-
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#include "asio/impl/use_future.hpp"
-
-#endif // ASIO_USE_FUTURE_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/version.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/version.hpp
deleted file mode 100644
index e8602e14bffd..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/version.hpp
+++ /dev/null
@@ -1,23 +0,0 @@
-//
-// version.hpp
-// ~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_VERSION_HPP
-#define ASIO_VERSION_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-// ASIO_VERSION % 100 is the sub-minor version
-// ASIO_VERSION / 100 % 1000 is the minor version
-// ASIO_VERSION / 100000 is the major version
-#define ASIO_VERSION 101002 // 1.10.2
-
-#endif // ASIO_VERSION_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/wait_traits.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/wait_traits.hpp
deleted file mode 100644
index 3b2218f77a66..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/wait_traits.hpp
+++ /dev/null
@@ -1,41 +0,0 @@
-//
-// wait_traits.hpp
-// ~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_WAIT_TRAITS_HPP
-#define ASIO_WAIT_TRAITS_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-
-/// Wait traits suitable for use with the basic_waitable_timer class template.
-template <typename Clock>
-struct wait_traits
-{
-  /// Convert a clock duration into a duration used for waiting.
-  /** 
-   * @returns @c d.
-   */
-  static typename Clock::duration to_wait_duration(
-      const typename Clock::duration& d)
-  {
-    return d;
-  }
-};
-
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_WAIT_TRAITS_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/waitable_timer_service.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/waitable_timer_service.hpp
deleted file mode 100644
index 0770360b2ff6..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/waitable_timer_service.hpp
+++ /dev/null
@@ -1,168 +0,0 @@
-//
-// waitable_timer_service.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_WAITABLE_TIMER_SERVICE_HPP
-#define ASIO_WAITABLE_TIMER_SERVICE_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include <cstddef>
-#include "asio/async_result.hpp"
-#include "asio/detail/chrono_time_traits.hpp"
-#include "asio/detail/deadline_timer_service.hpp"
-#include "asio/io_service.hpp"
-#include "asio/wait_traits.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-
-/// Default service implementation for a timer.
-template <typename Clock,
-    typename WaitTraits = asio::wait_traits<Clock> >
-class waitable_timer_service
-#if defined(GENERATING_DOCUMENTATION)
-  : public asio::io_service::service
-#else
-  : public asio::detail::service_base<
-      waitable_timer_service<Clock, WaitTraits> >
-#endif
-{
-public:
-#if defined(GENERATING_DOCUMENTATION)
-  /// The unique service identifier.
-  static asio::io_service::id id;
-#endif
-
-  /// The clock type.
-  typedef Clock clock_type;
-
-  /// The duration type of the clock.
-  typedef typename clock_type::duration duration;
-
-  /// The time point type of the clock.
-  typedef typename clock_type::time_point time_point;
-
-  /// The wait traits type.
-  typedef WaitTraits traits_type;
-
-private:
-  // The type of the platform-specific implementation.
-  typedef detail::deadline_timer_service<
-    detail::chrono_time_traits<Clock, WaitTraits> > service_impl_type;
-
-public:
-  /// The implementation type of the waitable timer.
-#if defined(GENERATING_DOCUMENTATION)
-  typedef implementation_defined implementation_type;
-#else
-  typedef typename service_impl_type::implementation_type implementation_type;
-#endif
-
-  /// Construct a new timer service for the specified io_service.
-  explicit waitable_timer_service(asio::io_service& io_service)
-    : asio::detail::service_base<
-        waitable_timer_service<Clock, WaitTraits> >(io_service),
-      service_impl_(io_service)
-  {
-  }
-
-  /// Construct a new timer implementation.
-  void construct(implementation_type& impl)
-  {
-    service_impl_.construct(impl);
-  }
-
-  /// Destroy a timer implementation.
-  void destroy(implementation_type& impl)
-  {
-    service_impl_.destroy(impl);
-  }
-
-  /// Cancel any asynchronous wait operations associated with the timer.
-  std::size_t cancel(implementation_type& impl, asio::error_code& ec)
-  {
-    return service_impl_.cancel(impl, ec);
-  }
-
-  /// Cancels one asynchronous wait operation associated with the timer.
-  std::size_t cancel_one(implementation_type& impl,
-      asio::error_code& ec)
-  {
-    return service_impl_.cancel_one(impl, ec);
-  }
-
-  /// Get the expiry time for the timer as an absolute time.
-  time_point expires_at(const implementation_type& impl) const
-  {
-    return service_impl_.expires_at(impl);
-  }
-
-  /// Set the expiry time for the timer as an absolute time.
-  std::size_t expires_at(implementation_type& impl,
-      const time_point& expiry_time, asio::error_code& ec)
-  {
-    return service_impl_.expires_at(impl, expiry_time, ec);
-  }
-
-  /// Get the expiry time for the timer relative to now.
-  duration expires_from_now(const implementation_type& impl) const
-  {
-    return service_impl_.expires_from_now(impl);
-  }
-
-  /// Set the expiry time for the timer relative to now.
-  std::size_t expires_from_now(implementation_type& impl,
-      const duration& expiry_time, asio::error_code& ec)
-  {
-    return service_impl_.expires_from_now(impl, expiry_time, ec);
-  }
-
-  // Perform a blocking wait on the timer.
-  void wait(implementation_type& impl, asio::error_code& ec)
-  {
-    service_impl_.wait(impl, ec);
-  }
-
-  // Start an asynchronous wait on the timer.
-  template <typename WaitHandler>
-  ASIO_INITFN_RESULT_TYPE(WaitHandler,
-      void (asio::error_code))
-  async_wait(implementation_type& impl,
-      ASIO_MOVE_ARG(WaitHandler) handler)
-  {
-    detail::async_result_init<
-      WaitHandler, void (asio::error_code)> init(
-        ASIO_MOVE_CAST(WaitHandler)(handler));
-
-    service_impl_.async_wait(impl, init.handler);
-
-    return init.result.get();
-  }
-
-private:
-  // Destroy all user-defined handler objects owned by the service.
-  void shutdown_service()
-  {
-    service_impl_.shutdown_service();
-  }
-
-  // The platform-specific implementation.
-  service_impl_type service_impl_;
-};
-
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // ASIO_WAITABLE_TIMER_SERVICE_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/windows/basic_handle.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/windows/basic_handle.hpp
deleted file mode 100644
index 82d7aba15006..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/windows/basic_handle.hpp
+++ /dev/null
@@ -1,281 +0,0 @@
-//
-// windows/basic_handle.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_WINDOWS_BASIC_HANDLE_HPP
-#define ASIO_WINDOWS_BASIC_HANDLE_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_HAS_WINDOWS_RANDOM_ACCESS_HANDLE) \
-  || defined(ASIO_HAS_WINDOWS_STREAM_HANDLE) \
-  || defined(ASIO_HAS_WINDOWS_OBJECT_HANDLE) \
-  || defined(GENERATING_DOCUMENTATION)
-
-#include "asio/basic_io_object.hpp"
-#include "asio/detail/throw_error.hpp"
-#include "asio/error.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace windows {
-
-/// Provides Windows handle functionality.
-/**
- * The windows::basic_handle class template provides the ability to wrap a
- * Windows handle.
- *
- * @par Thread Safety
- * @e Distinct @e objects: Safe.@n
- * @e Shared @e objects: Unsafe.
- */
-template <typename HandleService>
-class basic_handle
-  : public basic_io_object<HandleService>
-{
-public:
-  /// (Deprecated: Use native_handle_type.) The native representation of a
-  /// handle.
-  typedef typename HandleService::native_handle_type native_type;
-
-  /// The native representation of a handle.
-  typedef typename HandleService::native_handle_type native_handle_type;
-
-  /// A basic_handle is always the lowest layer.
-  typedef basic_handle<HandleService> lowest_layer_type;
-
-  /// Construct a basic_handle without opening it.
-  /**
-   * This constructor creates a handle without opening it.
-   *
-   * @param io_service The io_service object that the handle will use to
-   * dispatch handlers for any asynchronous operations performed on the handle.
-   */
-  explicit basic_handle(asio::io_service& io_service)
-    : basic_io_object<HandleService>(io_service)
-  {
-  }
-
-  /// Construct a basic_handle on an existing native handle.
-  /**
-   * This constructor creates a handle object to hold an existing native handle.
-   *
-   * @param io_service The io_service object that the handle will use to
-   * dispatch handlers for any asynchronous operations performed on the handle.
-   *
-   * @param handle A native handle.
-   *
-   * @throws asio::system_error Thrown on failure.
-   */
-  basic_handle(asio::io_service& io_service,
-      const native_handle_type& handle)
-    : basic_io_object<HandleService>(io_service)
-  {
-    asio::error_code ec;
-    this->get_service().assign(this->get_implementation(), handle, ec);
-    asio::detail::throw_error(ec, "assign");
-  }
-
-#if defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
-  /// Move-construct a basic_handle from another.
-  /**
-   * This constructor moves a handle from one object to another.
-   *
-   * @param other The other basic_handle object from which the move will occur.
-   *
-   * @note Following the move, the moved-from object is in the same state as if
-   * constructed using the @c basic_handle(io_service&) constructor.
-   */
-  basic_handle(basic_handle&& other)
-    : basic_io_object<HandleService>(
-        ASIO_MOVE_CAST(basic_handle)(other))
-  {
-  }
-
-  /// Move-assign a basic_handle from another.
-  /**
-   * This assignment operator moves a handle from one object to another.
-   *
-   * @param other The other basic_handle object from which the move will occur.
-   *
-   * @note Following the move, the moved-from object is in the same state as if
-   * constructed using the @c basic_handle(io_service&) constructor.
-   */
-  basic_handle& operator=(basic_handle&& other)
-  {
-    basic_io_object<HandleService>::operator=(
-        ASIO_MOVE_CAST(basic_handle)(other));
-    return *this;
-  }
-#endif // defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
-
-  /// Get a reference to the lowest layer.
-  /**
-   * This function returns a reference to the lowest layer in a stack of
-   * layers. Since a basic_handle cannot contain any further layers, it simply
-   * returns a reference to itself.
-   *
-   * @return A reference to the lowest layer in the stack of layers. Ownership
-   * is not transferred to the caller.
-   */
-  lowest_layer_type& lowest_layer()
-  {
-    return *this;
-  }
-
-  /// Get a const reference to the lowest layer.
-  /**
-   * This function returns a const reference to the lowest layer in a stack of
-   * layers. Since a basic_handle cannot contain any further layers, it simply
-   * returns a reference to itself.
-   *
-   * @return A const reference to the lowest layer in the stack of layers.
-   * Ownership is not transferred to the caller.
-   */
-  const lowest_layer_type& lowest_layer() const
-  {
-    return *this;
-  }
-
-  /// Assign an existing native handle to the handle.
-  /*
-   * This function opens the handle to hold an existing native handle.
-   *
-   * @param handle A native handle.
-   *
-   * @throws asio::system_error Thrown on failure.
-   */
-  void assign(const native_handle_type& handle)
-  {
-    asio::error_code ec;
-    this->get_service().assign(this->get_implementation(), handle, ec);
-    asio::detail::throw_error(ec, "assign");
-  }
-
-  /// Assign an existing native handle to the handle.
-  /*
-   * This function opens the handle to hold an existing native handle.
-   *
-   * @param handle A native handle.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   */
-  asio::error_code assign(const native_handle_type& handle,
-      asio::error_code& ec)
-  {
-    return this->get_service().assign(this->get_implementation(), handle, ec);
-  }
-
-  /// Determine whether the handle is open.
-  bool is_open() const
-  {
-    return this->get_service().is_open(this->get_implementation());
-  }
-
-  /// Close the handle.
-  /**
-   * This function is used to close the handle. Any asynchronous read or write
-   * operations will be cancelled immediately, and will complete with the
-   * asio::error::operation_aborted error.
-   *
-   * @throws asio::system_error Thrown on failure.
-   */
-  void close()
-  {
-    asio::error_code ec;
-    this->get_service().close(this->get_implementation(), ec);
-    asio::detail::throw_error(ec, "close");
-  }
-
-  /// Close the handle.
-  /**
-   * This function is used to close the handle. Any asynchronous read or write
-   * operations will be cancelled immediately, and will complete with the
-   * asio::error::operation_aborted error.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   */
-  asio::error_code close(asio::error_code& ec)
-  {
-    return this->get_service().close(this->get_implementation(), ec);
-  }
-
-  /// (Deprecated: Use native_handle().) Get the native handle representation.
-  /**
-   * This function may be used to obtain the underlying representation of the
-   * handle. This is intended to allow access to native handle functionality
-   * that is not otherwise provided.
-   */
-  native_type native()
-  {
-    return this->get_service().native_handle(this->get_implementation());
-  }
-
-  /// Get the native handle representation.
-  /**
-   * This function may be used to obtain the underlying representation of the
-   * handle. This is intended to allow access to native handle functionality
-   * that is not otherwise provided.
-   */
-  native_handle_type native_handle()
-  {
-    return this->get_service().native_handle(this->get_implementation());
-  }
-
-  /// Cancel all asynchronous operations associated with the handle.
-  /**
-   * This function causes all outstanding asynchronous read or write operations
-   * to finish immediately, and the handlers for cancelled operations will be
-   * passed the asio::error::operation_aborted error.
-   *
-   * @throws asio::system_error Thrown on failure.
-   */
-  void cancel()
-  {
-    asio::error_code ec;
-    this->get_service().cancel(this->get_implementation(), ec);
-    asio::detail::throw_error(ec, "cancel");
-  }
-
-  /// Cancel all asynchronous operations associated with the handle.
-  /**
-   * This function causes all outstanding asynchronous read or write operations
-   * to finish immediately, and the handlers for cancelled operations will be
-   * passed the asio::error::operation_aborted error.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   */
-  asio::error_code cancel(asio::error_code& ec)
-  {
-    return this->get_service().cancel(this->get_implementation(), ec);
-  }
-
-protected:
-  /// Protected destructor to prevent deletion through this type.
-  ~basic_handle()
-  {
-  }
-};
-
-} // namespace windows
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // defined(ASIO_HAS_WINDOWS_RANDOM_ACCESS_HANDLE)
-       //   || defined(ASIO_HAS_WINDOWS_STREAM_HANDLE)
-       //   || defined(ASIO_HAS_WINDOWS_OBJECT_HANDLE)
-       //   || defined(GENERATING_DOCUMENTATION)
-
-#endif // ASIO_WINDOWS_BASIC_HANDLE_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/windows/basic_object_handle.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/windows/basic_object_handle.hpp
deleted file mode 100644
index d8dcae7ba774..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/windows/basic_object_handle.hpp
+++ /dev/null
@@ -1,178 +0,0 @@
-//
-// windows/basic_object_handle.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-// Copyright (c) 2011 Boris Schaeling (boris@highscore.de)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_WINDOWS_BASIC_OBJECT_HANDLE_HPP
-#define ASIO_WINDOWS_BASIC_OBJECT_HANDLE_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_HAS_WINDOWS_OBJECT_HANDLE) \
-  || defined(GENERATING_DOCUMENTATION)
-
-#include "asio/detail/throw_error.hpp"
-#include "asio/error.hpp"
-#include "asio/windows/basic_handle.hpp"
-#include "asio/windows/object_handle_service.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace windows {
-
-/// Provides object-oriented handle functionality.
-/**
- * The windows::basic_object_handle class template provides asynchronous and
- * blocking object-oriented handle functionality.
- *
- * @par Thread Safety
- * @e Distinct @e objects: Safe.@n
- * @e Shared @e objects: Unsafe.
- */
-template <typename ObjectHandleService = object_handle_service>
-class basic_object_handle
-  : public basic_handle<ObjectHandleService>
-{
-public:
-  /// The native representation of a handle.
-  typedef typename ObjectHandleService::native_handle_type native_handle_type;
-
-  /// Construct a basic_object_handle without opening it.
-  /**
-   * This constructor creates an object handle without opening it.
-   *
-   * @param io_service The io_service object that the object handle will use to
-   * dispatch handlers for any asynchronous operations performed on the handle.
-   */
-  explicit basic_object_handle(asio::io_service& io_service)
-    : basic_handle<ObjectHandleService>(io_service)
-  {
-  }
-
-  /// Construct a basic_object_handle on an existing native handle.
-  /**
-   * This constructor creates an object handle object to hold an existing native
-   * handle.
-   *
-   * @param io_service The io_service object that the object handle will use to
-   * dispatch handlers for any asynchronous operations performed on the handle.
-   *
-   * @param native_handle The new underlying handle implementation.
-   *
-   * @throws asio::system_error Thrown on failure.
-   */
-  basic_object_handle(asio::io_service& io_service,
-      const native_handle_type& native_handle)
-    : basic_handle<ObjectHandleService>(io_service, native_handle)
-  {
-  }
-
-#if defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
-  /// Move-construct a basic_object_handle from another.
-  /**
-   * This constructor moves an object handle from one object to another.
-   *
-   * @param other The other basic_object_handle object from which the move will
-   * occur.
-   *
-   * @note Following the move, the moved-from object is in the same state as if
-   * constructed using the @c basic_object_handle(io_service&) constructor.
-   */
-  basic_object_handle(basic_object_handle&& other)
-    : basic_handle<ObjectHandleService>(
-        ASIO_MOVE_CAST(basic_object_handle)(other))
-  {
-  }
-
-  /// Move-assign a basic_object_handle from another.
-  /**
-   * This assignment operator moves an object handle from one object to another.
-   *
-   * @param other The other basic_object_handle object from which the move will
-   * occur.
-   *
-   * @note Following the move, the moved-from object is in the same state as if
-   * constructed using the @c basic_object_handle(io_service&) constructor.
-   */
-  basic_object_handle& operator=(basic_object_handle&& other)
-  {
-    basic_handle<ObjectHandleService>::operator=(
-        ASIO_MOVE_CAST(basic_object_handle)(other));
-    return *this;
-  }
-#endif // defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
-
-  /// Perform a blocking wait on the object handle.
-  /**
-   * This function is used to wait for the object handle to be set to the
-   * signalled state. This function blocks and does not return until the object
-   * handle has been set to the signalled state.
-   *
-   * @throws asio::system_error Thrown on failure.
-   */
-  void wait()
-  {
-    asio::error_code ec;
-    this->get_service().wait(this->get_implementation(), ec);
-    asio::detail::throw_error(ec, "wait");
-  }
-
-  /// Perform a blocking wait on the object handle.
-  /**
-   * This function is used to wait for the object handle to be set to the
-   * signalled state. This function blocks and does not return until the object
-   * handle has been set to the signalled state.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   */
-  void wait(asio::error_code& ec)
-  {
-    this->get_service().wait(this->get_implementation(), ec);
-  }
-
-  /// Start an asynchronous wait on the object handle.
-  /**
-   * This function is be used to initiate an asynchronous wait against the
-   * object handle. It always returns immediately.
-   *
-   * @param handler The handler to be called when the object handle is set to
-   * the signalled state. Copies will be made of the handler as required. The
-   * function signature of the handler must be:
-   * @code void handler(
-   *   const asio::error_code& error // Result of operation.
-   * ); @endcode
-   * Regardless of whether the asynchronous operation completes immediately or
-   * not, the handler will not be invoked from within this function. Invocation
-   * of the handler will be performed in a manner equivalent to using
-   * asio::io_service::post().
-   */
-  template <typename WaitHandler>
-  ASIO_INITFN_RESULT_TYPE(WaitHandler,
-      void (asio::error_code))
-  async_wait(ASIO_MOVE_ARG(WaitHandler) handler)
-  {
-    return this->get_service().async_wait(this->get_implementation(),
-        ASIO_MOVE_CAST(WaitHandler)(handler));
-  }
-};
-
-} // namespace windows
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // defined(ASIO_HAS_WINDOWS_OBJECT_HANDLE)
-       //   || defined(GENERATING_DOCUMENTATION)
-
-#endif // ASIO_WINDOWS_BASIC_OBJECT_HANDLE_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/windows/basic_random_access_handle.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/windows/basic_random_access_handle.hpp
deleted file mode 100644
index 4ef9874578b0..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/windows/basic_random_access_handle.hpp
+++ /dev/null
@@ -1,376 +0,0 @@
-//
-// windows/basic_random_access_handle.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_WINDOWS_BASIC_RANDOM_ACCESS_HANDLE_HPP
-#define ASIO_WINDOWS_BASIC_RANDOM_ACCESS_HANDLE_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_HAS_WINDOWS_RANDOM_ACCESS_HANDLE) \
-  || defined(GENERATING_DOCUMENTATION)
-
-#include <cstddef>
-#include "asio/detail/handler_type_requirements.hpp"
-#include "asio/detail/throw_error.hpp"
-#include "asio/error.hpp"
-#include "asio/windows/basic_handle.hpp"
-#include "asio/windows/random_access_handle_service.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace windows {
-
-/// Provides random-access handle functionality.
-/**
- * The windows::basic_random_access_handle class template provides asynchronous
- * and blocking random-access handle functionality.
- *
- * @par Thread Safety
- * @e Distinct @e objects: Safe.@n
- * @e Shared @e objects: Unsafe.
- */
-template <typename RandomAccessHandleService = random_access_handle_service>
-class basic_random_access_handle
-  : public basic_handle<RandomAccessHandleService>
-{
-public:
-  /// (Deprecated: Use native_handle_type.) The native representation of a
-  /// handle.
-  typedef typename RandomAccessHandleService::native_handle_type native_type;
-
-  /// The native representation of a handle.
-  typedef typename RandomAccessHandleService::native_handle_type
-    native_handle_type;
-
-  /// Construct a basic_random_access_handle without opening it.
-  /**
-   * This constructor creates a random-access handle without opening it. The
-   * handle needs to be opened before data can be written to or read from it.
-   *
-   * @param io_service The io_service object that the random-access handle will
-   * use to dispatch handlers for any asynchronous operations performed on the
-   * handle.
-   */
-  explicit basic_random_access_handle(asio::io_service& io_service)
-    : basic_handle<RandomAccessHandleService>(io_service)
-  {
-  }
-
-  /// Construct a basic_random_access_handle on an existing native handle.
-  /**
-   * This constructor creates a random-access handle object to hold an existing
-   * native handle.
-   *
-   * @param io_service The io_service object that the random-access handle will
-   * use to dispatch handlers for any asynchronous operations performed on the
-   * handle.
-   *
-   * @param handle The new underlying handle implementation.
-   *
-   * @throws asio::system_error Thrown on failure.
-   */
-  basic_random_access_handle(asio::io_service& io_service,
-      const native_handle_type& handle)
-    : basic_handle<RandomAccessHandleService>(io_service, handle)
-  {
-  }
-
-#if defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
-  /// Move-construct a basic_random_access_handle from another.
-  /**
-   * This constructor moves a random-access handle from one object to another.
-   *
-   * @param other The other basic_random_access_handle object from which the
-   * move will occur.
-   *
-   * @note Following the move, the moved-from object is in the same state as if
-   * constructed using the @c basic_random_access_handle(io_service&)
-   * constructor.
-   */
-  basic_random_access_handle(basic_random_access_handle&& other)
-    : basic_handle<RandomAccessHandleService>(
-        ASIO_MOVE_CAST(basic_random_access_handle)(other))
-  {
-  }
-
-  /// Move-assign a basic_random_access_handle from another.
-  /**
-   * This assignment operator moves a random-access handle from one object to
-   * another.
-   *
-   * @param other The other basic_random_access_handle object from which the
-   * move will occur.
-   *
-   * @note Following the move, the moved-from object is in the same state as if
-   * constructed using the @c basic_random_access_handle(io_service&)
-   * constructor.
-   */
-  basic_random_access_handle& operator=(basic_random_access_handle&& other)
-  {
-    basic_handle<RandomAccessHandleService>::operator=(
-        ASIO_MOVE_CAST(basic_random_access_handle)(other));
-    return *this;
-  }
-#endif // defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
-
-  /// Write some data to the handle at the specified offset.
-  /**
-   * This function is used to write data to the random-access handle. The
-   * function call will block until one or more bytes of the data has been
-   * written successfully, or until an error occurs.
-   *
-   * @param offset The offset at which the data will be written.
-   *
-   * @param buffers One or more data buffers to be written to the handle.
-   *
-   * @returns The number of bytes written.
-   *
-   * @throws asio::system_error Thrown on failure. An error code of
-   * asio::error::eof indicates that the connection was closed by the
-   * peer.
-   *
-   * @note The write_some_at operation may not write all of the data. Consider
-   * using the @ref write_at function if you need to ensure that all data is
-   * written before the blocking operation completes.
-   *
-   * @par Example
-   * To write a single data buffer use the @ref buffer function as follows:
-   * @code
-   * handle.write_some_at(42, asio::buffer(data, size));
-   * @endcode
-   * See the @ref buffer documentation for information on writing multiple
-   * buffers in one go, and how to use it with arrays, boost::array or
-   * std::vector.
-   */
-  template <typename ConstBufferSequence>
-  std::size_t write_some_at(uint64_t offset,
-      const ConstBufferSequence& buffers)
-  {
-    asio::error_code ec;
-    std::size_t s = this->get_service().write_some_at(
-        this->get_implementation(), offset, buffers, ec);
-    asio::detail::throw_error(ec, "write_some_at");
-    return s;
-  }
-
-  /// Write some data to the handle at the specified offset.
-  /**
-   * This function is used to write data to the random-access handle. The
-   * function call will block until one or more bytes of the data has been
-   * written successfully, or until an error occurs.
-   *
-   * @param offset The offset at which the data will be written.
-   *
-   * @param buffers One or more data buffers to be written to the handle.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   *
-   * @returns The number of bytes written. Returns 0 if an error occurred.
-   *
-   * @note The write_some operation may not transmit all of the data to the
-   * peer. Consider using the @ref write_at function if you need to ensure that
-   * all data is written before the blocking operation completes.
-   */
-  template <typename ConstBufferSequence>
-  std::size_t write_some_at(uint64_t offset,
-      const ConstBufferSequence& buffers, asio::error_code& ec)
-  {
-    return this->get_service().write_some_at(
-        this->get_implementation(), offset, buffers, ec);
-  }
-
-  /// Start an asynchronous write at the specified offset.
-  /**
-   * This function is used to asynchronously write data to the random-access
-   * handle. The function call always returns immediately.
-   *
-   * @param offset The offset at which the data will be written.
-   *
-   * @param buffers One or more data buffers to be written to the handle.
-   * Although the buffers object may be copied as necessary, ownership of the
-   * underlying memory blocks is retained by the caller, which must guarantee
-   * that they remain valid until the handler is called.
-   *
-   * @param handler The handler to be called when the write operation completes.
-   * Copies will be made of the handler as required. The function signature of
-   * the handler must be:
-   * @code void handler(
-   *   const asio::error_code& error, // Result of operation.
-   *   std::size_t bytes_transferred           // Number of bytes written.
-   * ); @endcode
-   * Regardless of whether the asynchronous operation completes immediately or
-   * not, the handler will not be invoked from within this function. Invocation
-   * of the handler will be performed in a manner equivalent to using
-   * asio::io_service::post().
-   *
-   * @note The write operation may not transmit all of the data to the peer.
-   * Consider using the @ref async_write_at function if you need to ensure that
-   * all data is written before the asynchronous operation completes.
-   *
-   * @par Example
-   * To write a single data buffer use the @ref buffer function as follows:
-   * @code
-   * handle.async_write_some_at(42, asio::buffer(data, size), handler);
-   * @endcode
-   * See the @ref buffer documentation for information on writing multiple
-   * buffers in one go, and how to use it with arrays, boost::array or
-   * std::vector.
-   */
-  template <typename ConstBufferSequence, typename WriteHandler>
-  ASIO_INITFN_RESULT_TYPE(WriteHandler,
-      void (asio::error_code, std::size_t))
-  async_write_some_at(uint64_t offset,
-      const ConstBufferSequence& buffers,
-      ASIO_MOVE_ARG(WriteHandler) handler)
-  {
-    // If you get an error on the following line it means that your handler does
-    // not meet the documented type requirements for a WriteHandler.
-    ASIO_WRITE_HANDLER_CHECK(WriteHandler, handler) type_check;
-
-    return this->get_service().async_write_some_at(this->get_implementation(),
-        offset, buffers, ASIO_MOVE_CAST(WriteHandler)(handler));
-  }
-
-  /// Read some data from the handle at the specified offset.
-  /**
-   * This function is used to read data from the random-access handle. The
-   * function call will block until one or more bytes of data has been read
-   * successfully, or until an error occurs.
-   *
-   * @param offset The offset at which the data will be read.
-   *
-   * @param buffers One or more buffers into which the data will be read.
-   *
-   * @returns The number of bytes read.
-   *
-   * @throws asio::system_error Thrown on failure. An error code of
-   * asio::error::eof indicates that the connection was closed by the
-   * peer.
-   *
-   * @note The read_some operation may not read all of the requested number of
-   * bytes. Consider using the @ref read_at function if you need to ensure that
-   * the requested amount of data is read before the blocking operation
-   * completes.
-   *
-   * @par Example
-   * To read into a single data buffer use the @ref buffer function as follows:
-   * @code
-   * handle.read_some_at(42, asio::buffer(data, size));
-   * @endcode
-   * See the @ref buffer documentation for information on reading into multiple
-   * buffers in one go, and how to use it with arrays, boost::array or
-   * std::vector.
-   */
-  template <typename MutableBufferSequence>
-  std::size_t read_some_at(uint64_t offset,
-      const MutableBufferSequence& buffers)
-  {
-    asio::error_code ec;
-    std::size_t s = this->get_service().read_some_at(
-        this->get_implementation(), offset, buffers, ec);
-    asio::detail::throw_error(ec, "read_some_at");
-    return s;
-  }
-
-  /// Read some data from the handle at the specified offset.
-  /**
-   * This function is used to read data from the random-access handle. The
-   * function call will block until one or more bytes of data has been read
-   * successfully, or until an error occurs.
-   *
-   * @param offset The offset at which the data will be read.
-   *
-   * @param buffers One or more buffers into which the data will be read.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   *
-   * @returns The number of bytes read. Returns 0 if an error occurred.
-   *
-   * @note The read_some operation may not read all of the requested number of
-   * bytes. Consider using the @ref read_at function if you need to ensure that
-   * the requested amount of data is read before the blocking operation
-   * completes.
-   */
-  template <typename MutableBufferSequence>
-  std::size_t read_some_at(uint64_t offset,
-      const MutableBufferSequence& buffers, asio::error_code& ec)
-  {
-    return this->get_service().read_some_at(
-        this->get_implementation(), offset, buffers, ec);
-  }
-
-  /// Start an asynchronous read at the specified offset.
-  /**
-   * This function is used to asynchronously read data from the random-access
-   * handle. The function call always returns immediately.
-   *
-   * @param offset The offset at which the data will be read.
-   *
-   * @param buffers One or more buffers into which the data will be read.
-   * Although the buffers object may be copied as necessary, ownership of the
-   * underlying memory blocks is retained by the caller, which must guarantee
-   * that they remain valid until the handler is called.
-   *
-   * @param handler The handler to be called when the read operation completes.
-   * Copies will be made of the handler as required. The function signature of
-   * the handler must be:
-   * @code void handler(
-   *   const asio::error_code& error, // Result of operation.
-   *   std::size_t bytes_transferred           // Number of bytes read.
-   * ); @endcode
-   * Regardless of whether the asynchronous operation completes immediately or
-   * not, the handler will not be invoked from within this function. Invocation
-   * of the handler will be performed in a manner equivalent to using
-   * asio::io_service::post().
-   *
-   * @note The read operation may not read all of the requested number of bytes.
-   * Consider using the @ref async_read_at function if you need to ensure that
-   * the requested amount of data is read before the asynchronous operation
-   * completes.
-   *
-   * @par Example
-   * To read into a single data buffer use the @ref buffer function as follows:
-   * @code
-   * handle.async_read_some_at(42, asio::buffer(data, size), handler);
-   * @endcode
-   * See the @ref buffer documentation for information on reading into multiple
-   * buffers in one go, and how to use it with arrays, boost::array or
-   * std::vector.
-   */
-  template <typename MutableBufferSequence, typename ReadHandler>
-  ASIO_INITFN_RESULT_TYPE(ReadHandler,
-      void (asio::error_code, std::size_t))
-  async_read_some_at(uint64_t offset,
-      const MutableBufferSequence& buffers,
-      ASIO_MOVE_ARG(ReadHandler) handler)
-  {
-    // If you get an error on the following line it means that your handler does
-    // not meet the documented type requirements for a ReadHandler.
-    ASIO_READ_HANDLER_CHECK(ReadHandler, handler) type_check;
-
-    return this->get_service().async_read_some_at(this->get_implementation(),
-        offset, buffers, ASIO_MOVE_CAST(ReadHandler)(handler));
-  }
-};
-
-} // namespace windows
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // defined(ASIO_HAS_WINDOWS_RANDOM_ACCESS_HANDLE)
-       //   || defined(GENERATING_DOCUMENTATION)
-
-#endif // ASIO_WINDOWS_BASIC_RANDOM_ACCESS_HANDLE_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/windows/basic_stream_handle.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/windows/basic_stream_handle.hpp
deleted file mode 100644
index 466b3077d4ef..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/windows/basic_stream_handle.hpp
+++ /dev/null
@@ -1,359 +0,0 @@
-//
-// windows/basic_stream_handle.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_WINDOWS_BASIC_STREAM_HANDLE_HPP
-#define ASIO_WINDOWS_BASIC_STREAM_HANDLE_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_HAS_WINDOWS_STREAM_HANDLE) \
-  || defined(GENERATING_DOCUMENTATION)
-
-#include <cstddef>
-#include "asio/detail/handler_type_requirements.hpp"
-#include "asio/detail/throw_error.hpp"
-#include "asio/error.hpp"
-#include "asio/windows/basic_handle.hpp"
-#include "asio/windows/stream_handle_service.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace windows {
-
-/// Provides stream-oriented handle functionality.
-/**
- * The windows::basic_stream_handle class template provides asynchronous and
- * blocking stream-oriented handle functionality.
- *
- * @par Thread Safety
- * @e Distinct @e objects: Safe.@n
- * @e Shared @e objects: Unsafe.
- *
- * @par Concepts:
- * AsyncReadStream, AsyncWriteStream, Stream, SyncReadStream, SyncWriteStream.
- */
-template <typename StreamHandleService = stream_handle_service>
-class basic_stream_handle
-  : public basic_handle<StreamHandleService>
-{
-public:
-  /// (Deprecated: Use native_handle_type.) The native representation of a
-  /// handle.
-  typedef typename StreamHandleService::native_handle_type native_type;
-
-  /// The native representation of a handle.
-  typedef typename StreamHandleService::native_handle_type native_handle_type;
-
-  /// Construct a basic_stream_handle without opening it.
-  /**
-   * This constructor creates a stream handle without opening it. The handle
-   * needs to be opened and then connected or accepted before data can be sent
-   * or received on it.
-   *
-   * @param io_service The io_service object that the stream handle will use to
-   * dispatch handlers for any asynchronous operations performed on the handle.
-   */
-  explicit basic_stream_handle(asio::io_service& io_service)
-    : basic_handle<StreamHandleService>(io_service)
-  {
-  }
-
-  /// Construct a basic_stream_handle on an existing native handle.
-  /**
-   * This constructor creates a stream handle object to hold an existing native
-   * handle.
-   *
-   * @param io_service The io_service object that the stream handle will use to
-   * dispatch handlers for any asynchronous operations performed on the handle.
-   *
-   * @param handle The new underlying handle implementation.
-   *
-   * @throws asio::system_error Thrown on failure.
-   */
-  basic_stream_handle(asio::io_service& io_service,
-      const native_handle_type& handle)
-    : basic_handle<StreamHandleService>(io_service, handle)
-  {
-  }
-
-#if defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
-  /// Move-construct a basic_stream_handle from another.
-  /**
-   * This constructor moves a stream handle from one object to another.
-   *
-   * @param other The other basic_stream_handle object from which the move
-   * will occur.
-   *
-   * @note Following the move, the moved-from object is in the same state as if
-   * constructed using the @c basic_stream_handle(io_service&) constructor.
-   */
-  basic_stream_handle(basic_stream_handle&& other)
-    : basic_handle<StreamHandleService>(
-        ASIO_MOVE_CAST(basic_stream_handle)(other))
-  {
-  }
-
-  /// Move-assign a basic_stream_handle from another.
-  /**
-   * This assignment operator moves a stream handle from one object to
-   * another.
-   *
-   * @param other The other basic_stream_handle object from which the move
-   * will occur.
-   *
-   * @note Following the move, the moved-from object is in the same state as if
-   * constructed using the @c basic_stream_handle(io_service&) constructor.
-   */
-  basic_stream_handle& operator=(basic_stream_handle&& other)
-  {
-    basic_handle<StreamHandleService>::operator=(
-        ASIO_MOVE_CAST(basic_stream_handle)(other));
-    return *this;
-  }
-#endif // defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
-
-  /// Write some data to the handle.
-  /**
-   * This function is used to write data to the stream handle. The function call
-   * will block until one or more bytes of the data has been written
-   * successfully, or until an error occurs.
-   *
-   * @param buffers One or more data buffers to be written to the handle.
-   *
-   * @returns The number of bytes written.
-   *
-   * @throws asio::system_error Thrown on failure. An error code of
-   * asio::error::eof indicates that the connection was closed by the
-   * peer.
-   *
-   * @note The write_some operation may not transmit all of the data to the
-   * peer. Consider using the @ref write function if you need to ensure that
-   * all data is written before the blocking operation completes.
-   *
-   * @par Example
-   * To write a single data buffer use the @ref buffer function as follows:
-   * @code
-   * handle.write_some(asio::buffer(data, size));
-   * @endcode
-   * See the @ref buffer documentation for information on writing multiple
-   * buffers in one go, and how to use it with arrays, boost::array or
-   * std::vector.
-   */
-  template <typename ConstBufferSequence>
-  std::size_t write_some(const ConstBufferSequence& buffers)
-  {
-    asio::error_code ec;
-    std::size_t s = this->get_service().write_some(
-        this->get_implementation(), buffers, ec);
-    asio::detail::throw_error(ec, "write_some");
-    return s;
-  }
-
-  /// Write some data to the handle.
-  /**
-   * This function is used to write data to the stream handle. The function call
-   * will block until one or more bytes of the data has been written
-   * successfully, or until an error occurs.
-   *
-   * @param buffers One or more data buffers to be written to the handle.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   *
-   * @returns The number of bytes written. Returns 0 if an error occurred.
-   *
-   * @note The write_some operation may not transmit all of the data to the
-   * peer. Consider using the @ref write function if you need to ensure that
-   * all data is written before the blocking operation completes.
-   */
-  template <typename ConstBufferSequence>
-  std::size_t write_some(const ConstBufferSequence& buffers,
-      asio::error_code& ec)
-  {
-    return this->get_service().write_some(
-        this->get_implementation(), buffers, ec);
-  }
-
-  /// Start an asynchronous write.
-  /**
-   * This function is used to asynchronously write data to the stream handle.
-   * The function call always returns immediately.
-   *
-   * @param buffers One or more data buffers to be written to the handle.
-   * Although the buffers object may be copied as necessary, ownership of the
-   * underlying memory blocks is retained by the caller, which must guarantee
-   * that they remain valid until the handler is called.
-   *
-   * @param handler The handler to be called when the write operation completes.
-   * Copies will be made of the handler as required. The function signature of
-   * the handler must be:
-   * @code void handler(
-   *   const asio::error_code& error, // Result of operation.
-   *   std::size_t bytes_transferred           // Number of bytes written.
-   * ); @endcode
-   * Regardless of whether the asynchronous operation completes immediately or
-   * not, the handler will not be invoked from within this function. Invocation
-   * of the handler will be performed in a manner equivalent to using
-   * asio::io_service::post().
-   *
-   * @note The write operation may not transmit all of the data to the peer.
-   * Consider using the @ref async_write function if you need to ensure that all
-   * data is written before the asynchronous operation completes.
-   *
-   * @par Example
-   * To write a single data buffer use the @ref buffer function as follows:
-   * @code
-   * handle.async_write_some(asio::buffer(data, size), handler);
-   * @endcode
-   * See the @ref buffer documentation for information on writing multiple
-   * buffers in one go, and how to use it with arrays, boost::array or
-   * std::vector.
-   */
-  template <typename ConstBufferSequence, typename WriteHandler>
-  ASIO_INITFN_RESULT_TYPE(WriteHandler,
-      void (asio::error_code, std::size_t))
-  async_write_some(const ConstBufferSequence& buffers,
-      ASIO_MOVE_ARG(WriteHandler) handler)
-  {
-    // If you get an error on the following line it means that your handler does
-    // not meet the documented type requirements for a WriteHandler.
-    ASIO_WRITE_HANDLER_CHECK(WriteHandler, handler) type_check;
-
-    return this->get_service().async_write_some(this->get_implementation(),
-        buffers, ASIO_MOVE_CAST(WriteHandler)(handler));
-  }
-
-  /// Read some data from the handle.
-  /**
-   * This function is used to read data from the stream handle. The function
-   * call will block until one or more bytes of data has been read successfully,
-   * or until an error occurs.
-   *
-   * @param buffers One or more buffers into which the data will be read.
-   *
-   * @returns The number of bytes read.
-   *
-   * @throws asio::system_error Thrown on failure. An error code of
-   * asio::error::eof indicates that the connection was closed by the
-   * peer.
-   *
-   * @note The read_some operation may not read all of the requested number of
-   * bytes. Consider using the @ref read function if you need to ensure that
-   * the requested amount of data is read before the blocking operation
-   * completes.
-   *
-   * @par Example
-   * To read into a single data buffer use the @ref buffer function as follows:
-   * @code
-   * handle.read_some(asio::buffer(data, size));
-   * @endcode
-   * See the @ref buffer documentation for information on reading into multiple
-   * buffers in one go, and how to use it with arrays, boost::array or
-   * std::vector.
-   */
-  template <typename MutableBufferSequence>
-  std::size_t read_some(const MutableBufferSequence& buffers)
-  {
-    asio::error_code ec;
-    std::size_t s = this->get_service().read_some(
-        this->get_implementation(), buffers, ec);
-    asio::detail::throw_error(ec, "read_some");
-    return s;
-  }
-
-  /// Read some data from the handle.
-  /**
-   * This function is used to read data from the stream handle. The function
-   * call will block until one or more bytes of data has been read successfully,
-   * or until an error occurs.
-   *
-   * @param buffers One or more buffers into which the data will be read.
-   *
-   * @param ec Set to indicate what error occurred, if any.
-   *
-   * @returns The number of bytes read. Returns 0 if an error occurred.
-   *
-   * @note The read_some operation may not read all of the requested number of
-   * bytes. Consider using the @ref read function if you need to ensure that
-   * the requested amount of data is read before the blocking operation
-   * completes.
-   */
-  template <typename MutableBufferSequence>
-  std::size_t read_some(const MutableBufferSequence& buffers,
-      asio::error_code& ec)
-  {
-    return this->get_service().read_some(
-        this->get_implementation(), buffers, ec);
-  }
-
-  /// Start an asynchronous read.
-  /**
-   * This function is used to asynchronously read data from the stream handle.
-   * The function call always returns immediately.
-   *
-   * @param buffers One or more buffers into which the data will be read.
-   * Although the buffers object may be copied as necessary, ownership of the
-   * underlying memory blocks is retained by the caller, which must guarantee
-   * that they remain valid until the handler is called.
-   *
-   * @param handler The handler to be called when the read operation completes.
-   * Copies will be made of the handler as required. The function signature of
-   * the handler must be:
-   * @code void handler(
-   *   const asio::error_code& error, // Result of operation.
-   *   std::size_t bytes_transferred           // Number of bytes read.
-   * ); @endcode
-   * Regardless of whether the asynchronous operation completes immediately or
-   * not, the handler will not be invoked from within this function. Invocation
-   * of the handler will be performed in a manner equivalent to using
-   * asio::io_service::post().
-   *
-   * @note The read operation may not read all of the requested number of bytes.
-   * Consider using the @ref async_read function if you need to ensure that the
-   * requested amount of data is read before the asynchronous operation
-   * completes.
-   *
-   * @par Example
-   * To read into a single data buffer use the @ref buffer function as follows:
-   * @code
-   * handle.async_read_some(asio::buffer(data, size), handler);
-   * @endcode
-   * See the @ref buffer documentation for information on reading into multiple
-   * buffers in one go, and how to use it with arrays, boost::array or
-   * std::vector.
-   */
-  template <typename MutableBufferSequence, typename ReadHandler>
-  ASIO_INITFN_RESULT_TYPE(ReadHandler,
-      void (asio::error_code, std::size_t))
-  async_read_some(const MutableBufferSequence& buffers,
-      ASIO_MOVE_ARG(ReadHandler) handler)
-  {
-    // If you get an error on the following line it means that your handler does
-    // not meet the documented type requirements for a ReadHandler.
-    ASIO_READ_HANDLER_CHECK(ReadHandler, handler) type_check;
-
-    return this->get_service().async_read_some(this->get_implementation(),
-        buffers, ASIO_MOVE_CAST(ReadHandler)(handler));
-  }
-};
-
-} // namespace windows
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // defined(ASIO_HAS_WINDOWS_STREAM_HANDLE)
-       //   || defined(GENERATING_DOCUMENTATION)
-
-#endif // ASIO_WINDOWS_BASIC_STREAM_HANDLE_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/windows/object_handle.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/windows/object_handle.hpp
deleted file mode 100644
index 8669ded820ff..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/windows/object_handle.hpp
+++ /dev/null
@@ -1,38 +0,0 @@
-//
-// windows/object_handle.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-// Copyright (c) 2011 Boris Schaeling (boris@highscore.de)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_WINDOWS_OBJECT_HANDLE_HPP
-#define ASIO_WINDOWS_OBJECT_HANDLE_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_HAS_WINDOWS_OBJECT_HANDLE) \
-  || defined(GENERATING_DOCUMENTATION)
-
-#include "asio/windows/basic_object_handle.hpp"
-
-namespace asio {
-namespace windows {
-
-/// Typedef for the typical usage of an object handle.
-typedef basic_object_handle<> object_handle;
-
-} // namespace windows
-} // namespace asio
-
-#endif // defined(ASIO_HAS_WINDOWS_OBJECT_HANDLE)
-       //   || defined(GENERATING_DOCUMENTATION)
-
-#endif // ASIO_WINDOWS_OBJECT_HANDLE_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/windows/object_handle_service.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/windows/object_handle_service.hpp
deleted file mode 100644
index 3a364582feb0..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/windows/object_handle_service.hpp
+++ /dev/null
@@ -1,177 +0,0 @@
-//
-// windows/object_handle_service.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-// Copyright (c) 2011 Boris Schaeling (boris@highscore.de)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_WINDOWS_OBJECT_HANDLE_SERVICE_HPP
-#define ASIO_WINDOWS_OBJECT_HANDLE_SERVICE_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_HAS_WINDOWS_OBJECT_HANDLE) \
-  || defined(GENERATING_DOCUMENTATION)
-
-#include "asio/async_result.hpp"
-#include "asio/detail/win_object_handle_service.hpp"
-#include "asio/error.hpp"
-#include "asio/io_service.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace windows {
-
-/// Default service implementation for an object handle.
-class object_handle_service
-#if defined(GENERATING_DOCUMENTATION)
-  : public asio::io_service::service
-#else
-  : public asio::detail::service_base<object_handle_service>
-#endif
-{
-public:
-#if defined(GENERATING_DOCUMENTATION)
-  /// The unique service identifier.
-  static asio::io_service::id id;
-#endif
-
-private:
-  // The type of the platform-specific implementation.
-  typedef detail::win_object_handle_service service_impl_type;
-
-public:
-  /// The type of an object handle implementation.
-#if defined(GENERATING_DOCUMENTATION)
-  typedef implementation_defined implementation_type;
-#else
-  typedef service_impl_type::implementation_type implementation_type;
-#endif
-
-  /// The native handle type.
-#if defined(GENERATING_DOCUMENTATION)
-  typedef implementation_defined native_handle_type;
-#else
-  typedef service_impl_type::native_handle_type native_handle_type;
-#endif
-
-  /// Construct a new object handle service for the specified io_service.
-  explicit object_handle_service(asio::io_service& io_service)
-    : asio::detail::service_base<object_handle_service>(io_service),
-      service_impl_(io_service)
-  {
-  }
-
-  /// Construct a new object handle implementation.
-  void construct(implementation_type& impl)
-  {
-    service_impl_.construct(impl);
-  }
-
-#if defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
-  /// Move-construct a new object handle implementation.
-  void move_construct(implementation_type& impl,
-      implementation_type& other_impl)
-  {
-    service_impl_.move_construct(impl, other_impl);
-  }
-
-  /// Move-assign from another object handle implementation.
-  void move_assign(implementation_type& impl,
-      object_handle_service& other_service,
-      implementation_type& other_impl)
-  {
-    service_impl_.move_assign(impl, other_service.service_impl_, other_impl);
-  }
-#endif // defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
-
-  /// Destroy an object handle implementation.
-  void destroy(implementation_type& impl)
-  {
-    service_impl_.destroy(impl);
-  }
-
-  /// Assign an existing native handle to an object handle.
-  asio::error_code assign(implementation_type& impl,
-      const native_handle_type& handle, asio::error_code& ec)
-  {
-    return service_impl_.assign(impl, handle, ec);
-  }
-
-  /// Determine whether the handle is open.
-  bool is_open(const implementation_type& impl) const
-  {
-    return service_impl_.is_open(impl);
-  }
-
-  /// Close an object handle implementation.
-  asio::error_code close(implementation_type& impl,
-      asio::error_code& ec)
-  {
-    return service_impl_.close(impl, ec);
-  }
-
-  /// Get the native handle implementation.
-  native_handle_type native_handle(implementation_type& impl)
-  {
-    return service_impl_.native_handle(impl);
-  }
-
-  /// Cancel all asynchronous operations associated with the handle.
-  asio::error_code cancel(implementation_type& impl,
-      asio::error_code& ec)
-  {
-    return service_impl_.cancel(impl, ec);
-  }
-
-  // Wait for a signaled state.
-  void wait(implementation_type& impl, asio::error_code& ec)
-  {
-    service_impl_.wait(impl, ec);
-  }
-
-  /// Start an asynchronous wait.
-  template <typename WaitHandler>
-  ASIO_INITFN_RESULT_TYPE(WaitHandler,
-      void (asio::error_code))
-  async_wait(implementation_type& impl,
-      ASIO_MOVE_ARG(WaitHandler) handler)
-  {
-    asio::detail::async_result_init<
-      WaitHandler, void (asio::error_code)> init(
-        ASIO_MOVE_CAST(WaitHandler)(handler));
-
-    service_impl_.async_wait(impl, init.handler);
-
-    return init.result.get();
-  }
-
-private:
-  // Destroy all user-defined handler objects owned by the service.
-  void shutdown_service()
-  {
-    service_impl_.shutdown_service();
-  }
-
-  // The platform-specific implementation.
-  service_impl_type service_impl_;
-};
-
-} // namespace windows
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // defined(ASIO_HAS_WINDOWS_OBJECT_HANDLE)
-       //   || defined(GENERATING_DOCUMENTATION)
-
-#endif // ASIO_WINDOWS_OBJECT_HANDLE_SERVICE_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/windows/overlapped_ptr.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/windows/overlapped_ptr.hpp
deleted file mode 100644
index 3879a5b1ef6d..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/windows/overlapped_ptr.hpp
+++ /dev/null
@@ -1,116 +0,0 @@
-//
-// windows/overlapped_ptr.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_WINDOWS_OVERLAPPED_PTR_HPP
-#define ASIO_WINDOWS_OVERLAPPED_PTR_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_HAS_WINDOWS_OVERLAPPED_PTR) \
-  || defined(GENERATING_DOCUMENTATION)
-
-#include "asio/detail/noncopyable.hpp"
-#include "asio/detail/win_iocp_overlapped_ptr.hpp"
-#include "asio/io_service.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace windows {
-
-/// Wraps a handler to create an OVERLAPPED object for use with overlapped I/O.
-/**
- * A special-purpose smart pointer used to wrap an application handler so that
- * it can be passed as the LPOVERLAPPED argument to overlapped I/O functions.
- *
- * @par Thread Safety
- * @e Distinct @e objects: Safe.@n
- * @e Shared @e objects: Unsafe.
- */
-class overlapped_ptr
-  : private noncopyable
-{
-public:
-  /// Construct an empty overlapped_ptr.
-  overlapped_ptr()
-    : impl_()
-  {
-  }
-
-  /// Construct an overlapped_ptr to contain the specified handler.
-  template <typename Handler>
-  explicit overlapped_ptr(asio::io_service& io_service,
-      ASIO_MOVE_ARG(Handler) handler)
-    : impl_(io_service, ASIO_MOVE_CAST(Handler)(handler))
-  {
-  }
-
-  /// Destructor automatically frees the OVERLAPPED object unless released.
-  ~overlapped_ptr()
-  {
-  }
-
-  /// Reset to empty.
-  void reset()
-  {
-    impl_.reset();
-  }
-
-  /// Reset to contain the specified handler, freeing any current OVERLAPPED
-  /// object.
-  template <typename Handler>
-  void reset(asio::io_service& io_service,
-      ASIO_MOVE_ARG(Handler) handler)
-  {
-    impl_.reset(io_service, ASIO_MOVE_CAST(Handler)(handler));
-  }
-
-  /// Get the contained OVERLAPPED object.
-  OVERLAPPED* get()
-  {
-    return impl_.get();
-  }
-
-  /// Get the contained OVERLAPPED object.
-  const OVERLAPPED* get() const
-  {
-    return impl_.get();
-  }
-
-  /// Release ownership of the OVERLAPPED object.
-  OVERLAPPED* release()
-  {
-    return impl_.release();
-  }
-
-  /// Post completion notification for overlapped operation. Releases ownership.
-  void complete(const asio::error_code& ec,
-      std::size_t bytes_transferred)
-  {
-    impl_.complete(ec, bytes_transferred);
-  }
-
-private:
-  detail::win_iocp_overlapped_ptr impl_;
-};
-
-} // namespace windows
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // defined(ASIO_HAS_WINDOWS_OVERLAPPED_PTR)
-       //   || defined(GENERATING_DOCUMENTATION)
-
-#endif // ASIO_WINDOWS_OVERLAPPED_PTR_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/windows/random_access_handle.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/windows/random_access_handle.hpp
deleted file mode 100644
index f49ad5b843dc..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/windows/random_access_handle.hpp
+++ /dev/null
@@ -1,37 +0,0 @@
-//
-// windows/random_access_handle.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_WINDOWS_RANDOM_ACCESS_HANDLE_HPP
-#define ASIO_WINDOWS_RANDOM_ACCESS_HANDLE_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_HAS_WINDOWS_RANDOM_ACCESS_HANDLE) \
-  || defined(GENERATING_DOCUMENTATION)
-
-#include "asio/windows/basic_random_access_handle.hpp"
-
-namespace asio {
-namespace windows {
-
-/// Typedef for the typical usage of a random-access handle.
-typedef basic_random_access_handle<> random_access_handle;
-
-} // namespace windows
-} // namespace asio
-
-#endif // defined(ASIO_HAS_WINDOWS_RANDOM_ACCESS_HANDLE)
-       //   || defined(GENERATING_DOCUMENTATION)
-
-#endif // ASIO_WINDOWS_RANDOM_ACCESS_HANDLE_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/windows/random_access_handle_service.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/windows/random_access_handle_service.hpp
deleted file mode 100644
index 10da9528d08f..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/windows/random_access_handle_service.hpp
+++ /dev/null
@@ -1,220 +0,0 @@
-//
-// windows/random_access_handle_service.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_WINDOWS_RANDOM_ACCESS_HANDLE_SERVICE_HPP
-#define ASIO_WINDOWS_RANDOM_ACCESS_HANDLE_SERVICE_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_HAS_WINDOWS_RANDOM_ACCESS_HANDLE) \
-  || defined(GENERATING_DOCUMENTATION)
-
-#include <cstddef>
-#include "asio/async_result.hpp"
-#include "asio/detail/cstdint.hpp"
-#include "asio/detail/win_iocp_handle_service.hpp"
-#include "asio/error.hpp"
-#include "asio/io_service.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace windows {
-
-/// Default service implementation for a random-access handle.
-class random_access_handle_service
-#if defined(GENERATING_DOCUMENTATION)
-  : public asio::io_service::service
-#else
-  : public asio::detail::service_base<random_access_handle_service>
-#endif
-{
-public:
-#if defined(GENERATING_DOCUMENTATION)
-  /// The unique service identifier.
-  static asio::io_service::id id;
-#endif
-
-private:
-  // The type of the platform-specific implementation.
-  typedef detail::win_iocp_handle_service service_impl_type;
-
-public:
-  /// The type of a random-access handle implementation.
-#if defined(GENERATING_DOCUMENTATION)
-  typedef implementation_defined implementation_type;
-#else
-  typedef service_impl_type::implementation_type implementation_type;
-#endif
-
-  /// (Deprecated: Use native_handle_type.) The native handle type.
-#if defined(GENERATING_DOCUMENTATION)
-  typedef implementation_defined native_type;
-#else
-  typedef service_impl_type::native_handle_type native_type;
-#endif
-
-  /// The native handle type.
-#if defined(GENERATING_DOCUMENTATION)
-  typedef implementation_defined native_handle_type;
-#else
-  typedef service_impl_type::native_handle_type native_handle_type;
-#endif
-
-  /// Construct a new random-access handle service for the specified io_service.
-  explicit random_access_handle_service(asio::io_service& io_service)
-    : asio::detail::service_base<
-        random_access_handle_service>(io_service),
-      service_impl_(io_service)
-  {
-  }
-
-  /// Construct a new random-access handle implementation.
-  void construct(implementation_type& impl)
-  {
-    service_impl_.construct(impl);
-  }
-
-#if defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
-  /// Move-construct a new random-access handle implementation.
-  void move_construct(implementation_type& impl,
-      implementation_type& other_impl)
-  {
-    service_impl_.move_construct(impl, other_impl);
-  }
-
-  /// Move-assign from another random-access handle implementation.
-  void move_assign(implementation_type& impl,
-      random_access_handle_service& other_service,
-      implementation_type& other_impl)
-  {
-    service_impl_.move_assign(impl, other_service.service_impl_, other_impl);
-  }
-#endif // defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
-
-  /// Destroy a random-access handle implementation.
-  void destroy(implementation_type& impl)
-  {
-    service_impl_.destroy(impl);
-  }
-
-  /// Assign an existing native handle to a random-access handle.
-  asio::error_code assign(implementation_type& impl,
-      const native_handle_type& handle, asio::error_code& ec)
-  {
-    return service_impl_.assign(impl, handle, ec);
-  }
-
-  /// Determine whether the handle is open.
-  bool is_open(const implementation_type& impl) const
-  {
-    return service_impl_.is_open(impl);
-  }
-
-  /// Close a random-access handle implementation.
-  asio::error_code close(implementation_type& impl,
-      asio::error_code& ec)
-  {
-    return service_impl_.close(impl, ec);
-  }
-
-  /// (Deprecated: Use native_handle().) Get the native handle implementation.
-  native_type native(implementation_type& impl)
-  {
-    return service_impl_.native_handle(impl);
-  }
-
-  /// Get the native handle implementation.
-  native_handle_type native_handle(implementation_type& impl)
-  {
-    return service_impl_.native_handle(impl);
-  }
-
-  /// Cancel all asynchronous operations associated with the handle.
-  asio::error_code cancel(implementation_type& impl,
-      asio::error_code& ec)
-  {
-    return service_impl_.cancel(impl, ec);
-  }
-
-  /// Write the given data at the specified offset.
-  template <typename ConstBufferSequence>
-  std::size_t write_some_at(implementation_type& impl, uint64_t offset,
-      const ConstBufferSequence& buffers, asio::error_code& ec)
-  {
-    return service_impl_.write_some_at(impl, offset, buffers, ec);
-  }
-
-  /// Start an asynchronous write at the specified offset.
-  template <typename ConstBufferSequence, typename WriteHandler>
-  ASIO_INITFN_RESULT_TYPE(WriteHandler,
-      void (asio::error_code, std::size_t))
-  async_write_some_at(implementation_type& impl,
-      uint64_t offset, const ConstBufferSequence& buffers,
-      ASIO_MOVE_ARG(WriteHandler) handler)
-  {
-    asio::detail::async_result_init<
-      WriteHandler, void (asio::error_code, std::size_t)> init(
-        ASIO_MOVE_CAST(WriteHandler)(handler));
-
-    service_impl_.async_write_some_at(impl, offset, buffers, init.handler);
-
-    return init.result.get();
-  }
-
-  /// Read some data from the specified offset.
-  template <typename MutableBufferSequence>
-  std::size_t read_some_at(implementation_type& impl, uint64_t offset,
-      const MutableBufferSequence& buffers, asio::error_code& ec)
-  {
-    return service_impl_.read_some_at(impl, offset, buffers, ec);
-  }
-
-  /// Start an asynchronous read at the specified offset.
-  template <typename MutableBufferSequence, typename ReadHandler>
-  ASIO_INITFN_RESULT_TYPE(ReadHandler,
-      void (asio::error_code, std::size_t))
-  async_read_some_at(implementation_type& impl,
-      uint64_t offset, const MutableBufferSequence& buffers,
-      ASIO_MOVE_ARG(ReadHandler) handler)
-  {
-    asio::detail::async_result_init<
-      ReadHandler, void (asio::error_code, std::size_t)> init(
-        ASIO_MOVE_CAST(ReadHandler)(handler));
-
-    service_impl_.async_read_some_at(impl, offset, buffers, init.handler);
-
-    return init.result.get();
-  }
-
-private:
-  // Destroy all user-defined handler objects owned by the service.
-  void shutdown_service()
-  {
-    service_impl_.shutdown_service();
-  }
-
-  // The platform-specific implementation.
-  service_impl_type service_impl_;
-};
-
-} // namespace windows
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // defined(ASIO_HAS_WINDOWS_RANDOM_ACCESS_HANDLE)
-       //   || defined(GENERATING_DOCUMENTATION)
-
-#endif // ASIO_WINDOWS_RANDOM_ACCESS_HANDLE_SERVICE_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/windows/stream_handle.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/windows/stream_handle.hpp
deleted file mode 100644
index d563b09b4b4b..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/windows/stream_handle.hpp
+++ /dev/null
@@ -1,37 +0,0 @@
-//
-// windows/stream_handle.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_WINDOWS_STREAM_HANDLE_HPP
-#define ASIO_WINDOWS_STREAM_HANDLE_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_HAS_WINDOWS_STREAM_HANDLE) \
-  || defined(GENERATING_DOCUMENTATION)
-
-#include "asio/windows/basic_stream_handle.hpp"
-
-namespace asio {
-namespace windows {
-
-/// Typedef for the typical usage of a stream-oriented handle.
-typedef basic_stream_handle<> stream_handle;
-
-} // namespace windows
-} // namespace asio
-
-#endif // defined(ASIO_HAS_WINDOWS_STREAM_HANDLE)
-       //   || defined(GENERATING_DOCUMENTATION)
-
-#endif // ASIO_WINDOWS_STREAM_HANDLE_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/windows/stream_handle_service.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/windows/stream_handle_service.hpp
deleted file mode 100644
index 9bebd6a9c813..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/windows/stream_handle_service.hpp
+++ /dev/null
@@ -1,218 +0,0 @@
-//
-// windows/stream_handle_service.hpp
-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_WINDOWS_STREAM_HANDLE_SERVICE_HPP
-#define ASIO_WINDOWS_STREAM_HANDLE_SERVICE_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-
-#if defined(ASIO_HAS_WINDOWS_STREAM_HANDLE) \
-  || defined(GENERATING_DOCUMENTATION)
-
-#include <cstddef>
-#include "asio/async_result.hpp"
-#include "asio/detail/win_iocp_handle_service.hpp"
-#include "asio/error.hpp"
-#include "asio/io_service.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-namespace windows {
-
-/// Default service implementation for a stream handle.
-class stream_handle_service
-#if defined(GENERATING_DOCUMENTATION)
-  : public asio::io_service::service
-#else
-  : public asio::detail::service_base<stream_handle_service>
-#endif
-{
-public:
-#if defined(GENERATING_DOCUMENTATION)
-  /// The unique service identifier.
-  static asio::io_service::id id;
-#endif
-
-private:
-  // The type of the platform-specific implementation.
-  typedef detail::win_iocp_handle_service service_impl_type;
-
-public:
-  /// The type of a stream handle implementation.
-#if defined(GENERATING_DOCUMENTATION)
-  typedef implementation_defined implementation_type;
-#else
-  typedef service_impl_type::implementation_type implementation_type;
-#endif
-
-  /// (Deprecated: Use native_handle_type.) The native handle type.
-#if defined(GENERATING_DOCUMENTATION)
-  typedef implementation_defined native_type;
-#else
-  typedef service_impl_type::native_handle_type native_type;
-#endif
-
-  /// The native handle type.
-#if defined(GENERATING_DOCUMENTATION)
-  typedef implementation_defined native_handle_type;
-#else
-  typedef service_impl_type::native_handle_type native_handle_type;
-#endif
-
-  /// Construct a new stream handle service for the specified io_service.
-  explicit stream_handle_service(asio::io_service& io_service)
-    : asio::detail::service_base<stream_handle_service>(io_service),
-      service_impl_(io_service)
-  {
-  }
-
-  /// Construct a new stream handle implementation.
-  void construct(implementation_type& impl)
-  {
-    service_impl_.construct(impl);
-  }
-
-#if defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
-  /// Move-construct a new stream handle implementation.
-  void move_construct(implementation_type& impl,
-      implementation_type& other_impl)
-  {
-    service_impl_.move_construct(impl, other_impl);
-  }
-
-  /// Move-assign from another stream handle implementation.
-  void move_assign(implementation_type& impl,
-      stream_handle_service& other_service,
-      implementation_type& other_impl)
-  {
-    service_impl_.move_assign(impl, other_service.service_impl_, other_impl);
-  }
-#endif // defined(ASIO_HAS_MOVE) || defined(GENERATING_DOCUMENTATION)
-
-  /// Destroy a stream handle implementation.
-  void destroy(implementation_type& impl)
-  {
-    service_impl_.destroy(impl);
-  }
-
-  /// Assign an existing native handle to a stream handle.
-  asio::error_code assign(implementation_type& impl,
-      const native_handle_type& handle, asio::error_code& ec)
-  {
-    return service_impl_.assign(impl, handle, ec);
-  }
-
-  /// Determine whether the handle is open.
-  bool is_open(const implementation_type& impl) const
-  {
-    return service_impl_.is_open(impl);
-  }
-
-  /// Close a stream handle implementation.
-  asio::error_code close(implementation_type& impl,
-      asio::error_code& ec)
-  {
-    return service_impl_.close(impl, ec);
-  }
-
-  /// (Deprecated: Use native_handle().) Get the native handle implementation.
-  native_type native(implementation_type& impl)
-  {
-    return service_impl_.native_handle(impl);
-  }
-
-  /// Get the native handle implementation.
-  native_handle_type native_handle(implementation_type& impl)
-  {
-    return service_impl_.native_handle(impl);
-  }
-
-  /// Cancel all asynchronous operations associated with the handle.
-  asio::error_code cancel(implementation_type& impl,
-      asio::error_code& ec)
-  {
-    return service_impl_.cancel(impl, ec);
-  }
-
-  /// Write the given data to the stream.
-  template <typename ConstBufferSequence>
-  std::size_t write_some(implementation_type& impl,
-      const ConstBufferSequence& buffers, asio::error_code& ec)
-  {
-    return service_impl_.write_some(impl, buffers, ec);
-  }
-
-  /// Start an asynchronous write.
-  template <typename ConstBufferSequence, typename WriteHandler>
-  ASIO_INITFN_RESULT_TYPE(WriteHandler,
-      void (asio::error_code, std::size_t))
-  async_write_some(implementation_type& impl,
-      const ConstBufferSequence& buffers,
-      ASIO_MOVE_ARG(WriteHandler) handler)
-  {
-    asio::detail::async_result_init<
-      WriteHandler, void (asio::error_code, std::size_t)> init(
-        ASIO_MOVE_CAST(WriteHandler)(handler));
-
-    service_impl_.async_write_some(impl, buffers, init.handler);
-
-    return init.result.get();
-  }
-
-  /// Read some data from the stream.
-  template <typename MutableBufferSequence>
-  std::size_t read_some(implementation_type& impl,
-      const MutableBufferSequence& buffers, asio::error_code& ec)
-  {
-    return service_impl_.read_some(impl, buffers, ec);
-  }
-
-  /// Start an asynchronous read.
-  template <typename MutableBufferSequence, typename ReadHandler>
-  ASIO_INITFN_RESULT_TYPE(ReadHandler,
-      void (asio::error_code, std::size_t))
-  async_read_some(implementation_type& impl,
-      const MutableBufferSequence& buffers,
-      ASIO_MOVE_ARG(ReadHandler) handler)
-  {
-    asio::detail::async_result_init<
-      ReadHandler, void (asio::error_code, std::size_t)> init(
-        ASIO_MOVE_CAST(ReadHandler)(handler));
-
-    service_impl_.async_read_some(impl, buffers, init.handler);
-
-    return init.result.get();
-  }
-
-private:
-  // Destroy all user-defined handler objects owned by the service.
-  void shutdown_service()
-  {
-    service_impl_.shutdown_service();
-  }
-
-  // The platform-specific implementation.
-  service_impl_type service_impl_;
-};
-
-} // namespace windows
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#endif // defined(ASIO_HAS_WINDOWS_STREAM_HANDLE)
-       //   || defined(GENERATING_DOCUMENTATION)
-
-#endif // ASIO_WINDOWS_STREAM_HANDLE_SERVICE_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/write.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/write.hpp
deleted file mode 100644
index 67991796062b..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/write.hpp
+++ /dev/null
@@ -1,618 +0,0 @@
-//
-// write.hpp
-// ~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_WRITE_HPP
-#define ASIO_WRITE_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include <cstddef>
-#include "asio/async_result.hpp"
-#include "asio/basic_streambuf_fwd.hpp"
-#include "asio/error.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-
-/**
- * @defgroup write asio::write
- *
- * @brief Write a certain amount of data to a stream before returning.
- */
-/*@{*/
-
-/// Write all of the supplied data to a stream before returning.
-/**
- * This function is used to write a certain number of bytes of data to a stream.
- * The call will block until one of the following conditions is true:
- *
- * @li All of the data in the supplied buffers has been written. That is, the
- * bytes transferred is equal to the sum of the buffer sizes.
- *
- * @li An error occurred.
- *
- * This operation is implemented in terms of zero or more calls to the stream's
- * write_some function.
- *
- * @param s The stream to which the data is to be written. The type must support
- * the SyncWriteStream concept.
- *
- * @param buffers One or more buffers containing the data to be written. The sum
- * of the buffer sizes indicates the maximum number of bytes to write to the
- * stream.
- *
- * @returns The number of bytes transferred.
- *
- * @throws asio::system_error Thrown on failure.
- *
- * @par Example
- * To write a single data buffer use the @ref buffer function as follows:
- * @code asio::write(s, asio::buffer(data, size)); @endcode
- * See the @ref buffer documentation for information on writing multiple
- * buffers in one go, and how to use it with arrays, boost::array or
- * std::vector.
- *
- * @note This overload is equivalent to calling:
- * @code asio::write(
- *     s, buffers,
- *     asio::transfer_all()); @endcode
- */
-template <typename SyncWriteStream, typename ConstBufferSequence>
-std::size_t write(SyncWriteStream& s, const ConstBufferSequence& buffers);
-
-/// Write all of the supplied data to a stream before returning.
-/**
- * This function is used to write a certain number of bytes of data to a stream.
- * The call will block until one of the following conditions is true:
- *
- * @li All of the data in the supplied buffers has been written. That is, the
- * bytes transferred is equal to the sum of the buffer sizes.
- *
- * @li An error occurred.
- *
- * This operation is implemented in terms of zero or more calls to the stream's
- * write_some function.
- *
- * @param s The stream to which the data is to be written. The type must support
- * the SyncWriteStream concept.
- *
- * @param buffers One or more buffers containing the data to be written. The sum
- * of the buffer sizes indicates the maximum number of bytes to write to the
- * stream.
- *
- * @param ec Set to indicate what error occurred, if any.
- *
- * @returns The number of bytes transferred.
- *
- * @par Example
- * To write a single data buffer use the @ref buffer function as follows:
- * @code asio::write(s, asio::buffer(data, size), ec); @endcode
- * See the @ref buffer documentation for information on writing multiple
- * buffers in one go, and how to use it with arrays, boost::array or
- * std::vector.
- *
- * @note This overload is equivalent to calling:
- * @code asio::write(
- *     s, buffers,
- *     asio::transfer_all(), ec); @endcode
- */
-template <typename SyncWriteStream, typename ConstBufferSequence>
-std::size_t write(SyncWriteStream& s, const ConstBufferSequence& buffers,
-    asio::error_code& ec);
-
-/// Write a certain amount of data to a stream before returning.
-/**
- * This function is used to write a certain number of bytes of data to a stream.
- * The call will block until one of the following conditions is true:
- *
- * @li All of the data in the supplied buffers has been written. That is, the
- * bytes transferred is equal to the sum of the buffer sizes.
- *
- * @li The completion_condition function object returns 0.
- *
- * This operation is implemented in terms of zero or more calls to the stream's
- * write_some function.
- *
- * @param s The stream to which the data is to be written. The type must support
- * the SyncWriteStream concept.
- *
- * @param buffers One or more buffers containing the data to be written. The sum
- * of the buffer sizes indicates the maximum number of bytes to write to the
- * stream.
- *
- * @param completion_condition The function object to be called to determine
- * whether the write operation is complete. The signature of the function object
- * must be:
- * @code std::size_t completion_condition(
- *   // Result of latest write_some operation.
- *   const asio::error_code& error,
- *
- *   // Number of bytes transferred so far.
- *   std::size_t bytes_transferred
- * ); @endcode
- * A return value of 0 indicates that the write operation is complete. A
- * non-zero return value indicates the maximum number of bytes to be written on
- * the next call to the stream's write_some function.
- *
- * @returns The number of bytes transferred.
- *
- * @throws asio::system_error Thrown on failure.
- *
- * @par Example
- * To write a single data buffer use the @ref buffer function as follows:
- * @code asio::write(s, asio::buffer(data, size),
- *     asio::transfer_at_least(32)); @endcode
- * See the @ref buffer documentation for information on writing multiple
- * buffers in one go, and how to use it with arrays, boost::array or
- * std::vector.
- */
-template <typename SyncWriteStream, typename ConstBufferSequence,
-    typename CompletionCondition>
-std::size_t write(SyncWriteStream& s, const ConstBufferSequence& buffers,
-    CompletionCondition completion_condition);
-
-/// Write a certain amount of data to a stream before returning.
-/**
- * This function is used to write a certain number of bytes of data to a stream.
- * The call will block until one of the following conditions is true:
- *
- * @li All of the data in the supplied buffers has been written. That is, the
- * bytes transferred is equal to the sum of the buffer sizes.
- *
- * @li The completion_condition function object returns 0.
- *
- * This operation is implemented in terms of zero or more calls to the stream's
- * write_some function.
- *
- * @param s The stream to which the data is to be written. The type must support
- * the SyncWriteStream concept.
- *
- * @param buffers One or more buffers containing the data to be written. The sum
- * of the buffer sizes indicates the maximum number of bytes to write to the
- * stream.
- *
- * @param completion_condition The function object to be called to determine
- * whether the write operation is complete. The signature of the function object
- * must be:
- * @code std::size_t completion_condition(
- *   // Result of latest write_some operation.
- *   const asio::error_code& error,
- *
- *   // Number of bytes transferred so far.
- *   std::size_t bytes_transferred
- * ); @endcode
- * A return value of 0 indicates that the write operation is complete. A
- * non-zero return value indicates the maximum number of bytes to be written on
- * the next call to the stream's write_some function.
- *
- * @param ec Set to indicate what error occurred, if any.
- *
- * @returns The number of bytes written. If an error occurs, returns the total
- * number of bytes successfully transferred prior to the error.
- */
-template <typename SyncWriteStream, typename ConstBufferSequence,
-    typename CompletionCondition>
-std::size_t write(SyncWriteStream& s, const ConstBufferSequence& buffers,
-    CompletionCondition completion_condition, asio::error_code& ec);
-
-#if !defined(ASIO_NO_IOSTREAM)
-
-/// Write all of the supplied data to a stream before returning.
-/**
- * This function is used to write a certain number of bytes of data to a stream.
- * The call will block until one of the following conditions is true:
- *
- * @li All of the data in the supplied basic_streambuf has been written.
- *
- * @li An error occurred.
- *
- * This operation is implemented in terms of zero or more calls to the stream's
- * write_some function.
- *
- * @param s The stream to which the data is to be written. The type must support
- * the SyncWriteStream concept.
- *
- * @param b The basic_streambuf object from which data will be written.
- *
- * @returns The number of bytes transferred.
- *
- * @throws asio::system_error Thrown on failure.
- *
- * @note This overload is equivalent to calling:
- * @code asio::write(
- *     s, b,
- *     asio::transfer_all()); @endcode
- */
-template <typename SyncWriteStream, typename Allocator>
-std::size_t write(SyncWriteStream& s, basic_streambuf<Allocator>& b);
-
-/// Write all of the supplied data to a stream before returning.
-/**
- * This function is used to write a certain number of bytes of data to a stream.
- * The call will block until one of the following conditions is true:
- *
- * @li All of the data in the supplied basic_streambuf has been written.
- *
- * @li An error occurred.
- *
- * This operation is implemented in terms of zero or more calls to the stream's
- * write_some function.
- *
- * @param s The stream to which the data is to be written. The type must support
- * the SyncWriteStream concept.
- *
- * @param b The basic_streambuf object from which data will be written.
- *
- * @param ec Set to indicate what error occurred, if any.
- *
- * @returns The number of bytes transferred.
- *
- * @note This overload is equivalent to calling:
- * @code asio::write(
- *     s, b,
- *     asio::transfer_all(), ec); @endcode
- */
-template <typename SyncWriteStream, typename Allocator>
-std::size_t write(SyncWriteStream& s, basic_streambuf<Allocator>& b,
-    asio::error_code& ec);
-
-/// Write a certain amount of data to a stream before returning.
-/**
- * This function is used to write a certain number of bytes of data to a stream.
- * The call will block until one of the following conditions is true:
- *
- * @li All of the data in the supplied basic_streambuf has been written.
- *
- * @li The completion_condition function object returns 0.
- *
- * This operation is implemented in terms of zero or more calls to the stream's
- * write_some function.
- *
- * @param s The stream to which the data is to be written. The type must support
- * the SyncWriteStream concept.
- *
- * @param b The basic_streambuf object from which data will be written.
- *
- * @param completion_condition The function object to be called to determine
- * whether the write operation is complete. The signature of the function object
- * must be:
- * @code std::size_t completion_condition(
- *   // Result of latest write_some operation.
- *   const asio::error_code& error,
- *
- *   // Number of bytes transferred so far.
- *   std::size_t bytes_transferred
- * ); @endcode
- * A return value of 0 indicates that the write operation is complete. A
- * non-zero return value indicates the maximum number of bytes to be written on
- * the next call to the stream's write_some function.
- *
- * @returns The number of bytes transferred.
- *
- * @throws asio::system_error Thrown on failure.
- */
-template <typename SyncWriteStream, typename Allocator,
-    typename CompletionCondition>
-std::size_t write(SyncWriteStream& s, basic_streambuf<Allocator>& b,
-    CompletionCondition completion_condition);
-
-/// Write a certain amount of data to a stream before returning.
-/**
- * This function is used to write a certain number of bytes of data to a stream.
- * The call will block until one of the following conditions is true:
- *
- * @li All of the data in the supplied basic_streambuf has been written.
- *
- * @li The completion_condition function object returns 0.
- *
- * This operation is implemented in terms of zero or more calls to the stream's
- * write_some function.
- *
- * @param s The stream to which the data is to be written. The type must support
- * the SyncWriteStream concept.
- *
- * @param b The basic_streambuf object from which data will be written.
- *
- * @param completion_condition The function object to be called to determine
- * whether the write operation is complete. The signature of the function object
- * must be:
- * @code std::size_t completion_condition(
- *   // Result of latest write_some operation.
- *   const asio::error_code& error,
- *
- *   // Number of bytes transferred so far.
- *   std::size_t bytes_transferred
- * ); @endcode
- * A return value of 0 indicates that the write operation is complete. A
- * non-zero return value indicates the maximum number of bytes to be written on
- * the next call to the stream's write_some function.
- *
- * @param ec Set to indicate what error occurred, if any.
- *
- * @returns The number of bytes written. If an error occurs, returns the total
- * number of bytes successfully transferred prior to the error.
- */
-template <typename SyncWriteStream, typename Allocator,
-    typename CompletionCondition>
-std::size_t write(SyncWriteStream& s, basic_streambuf<Allocator>& b,
-    CompletionCondition completion_condition, asio::error_code& ec);
-
-#endif // !defined(ASIO_NO_IOSTREAM)
-
-/*@}*/
-/**
- * @defgroup async_write asio::async_write
- *
- * @brief Start an asynchronous operation to write a certain amount of data to a
- * stream.
- */
-/*@{*/
-
-/// Start an asynchronous operation to write all of the supplied data to a
-/// stream.
-/**
- * This function is used to asynchronously write a certain number of bytes of
- * data to a stream. The function call always returns immediately. The
- * asynchronous operation will continue until one of the following conditions
- * is true:
- *
- * @li All of the data in the supplied buffers has been written. That is, the
- * bytes transferred is equal to the sum of the buffer sizes.
- *
- * @li An error occurred.
- *
- * This operation is implemented in terms of zero or more calls to the stream's
- * async_write_some function, and is known as a <em>composed operation</em>. The
- * program must ensure that the stream performs no other write operations (such
- * as async_write, the stream's async_write_some function, or any other composed
- * operations that perform writes) until this operation completes.
- *
- * @param s The stream to which the data is to be written. The type must support
- * the AsyncWriteStream concept.
- *
- * @param buffers One or more buffers containing the data to be written.
- * Although the buffers object may be copied as necessary, ownership of the
- * underlying memory blocks is retained by the caller, which must guarantee
- * that they remain valid until the handler is called.
- *
- * @param handler The handler to be called when the write operation completes.
- * Copies will be made of the handler as required. The function signature of
- * the handler must be:
- * @code void handler(
- *   const asio::error_code& error, // Result of operation.
- *
- *   std::size_t bytes_transferred           // Number of bytes written from the
- *                                           // buffers. If an error occurred,
- *                                           // this will be less than the sum
- *                                           // of the buffer sizes.
- * ); @endcode
- * Regardless of whether the asynchronous operation completes immediately or
- * not, the handler will not be invoked from within this function. Invocation of
- * the handler will be performed in a manner equivalent to using
- * asio::io_service::post().
- *
- * @par Example
- * To write a single data buffer use the @ref buffer function as follows:
- * @code
- * asio::async_write(s, asio::buffer(data, size), handler);
- * @endcode
- * See the @ref buffer documentation for information on writing multiple
- * buffers in one go, and how to use it with arrays, boost::array or
- * std::vector.
- */
-template <typename AsyncWriteStream, typename ConstBufferSequence,
-    typename WriteHandler>
-ASIO_INITFN_RESULT_TYPE(WriteHandler,
-    void (asio::error_code, std::size_t))
-async_write(AsyncWriteStream& s, const ConstBufferSequence& buffers,
-    ASIO_MOVE_ARG(WriteHandler) handler);
-
-/// Start an asynchronous operation to write a certain amount of data to a
-/// stream.
-/**
- * This function is used to asynchronously write a certain number of bytes of
- * data to a stream. The function call always returns immediately. The
- * asynchronous operation will continue until one of the following conditions
- * is true:
- *
- * @li All of the data in the supplied buffers has been written. That is, the
- * bytes transferred is equal to the sum of the buffer sizes.
- *
- * @li The completion_condition function object returns 0.
- *
- * This operation is implemented in terms of zero or more calls to the stream's
- * async_write_some function, and is known as a <em>composed operation</em>. The
- * program must ensure that the stream performs no other write operations (such
- * as async_write, the stream's async_write_some function, or any other composed
- * operations that perform writes) until this operation completes.
- *
- * @param s The stream to which the data is to be written. The type must support
- * the AsyncWriteStream concept.
- *
- * @param buffers One or more buffers containing the data to be written.
- * Although the buffers object may be copied as necessary, ownership of the
- * underlying memory blocks is retained by the caller, which must guarantee
- * that they remain valid until the handler is called.
- *
- * @param completion_condition The function object to be called to determine
- * whether the write operation is complete. The signature of the function object
- * must be:
- * @code std::size_t completion_condition(
- *   // Result of latest async_write_some operation.
- *   const asio::error_code& error,
- *
- *   // Number of bytes transferred so far.
- *   std::size_t bytes_transferred
- * ); @endcode
- * A return value of 0 indicates that the write operation is complete. A
- * non-zero return value indicates the maximum number of bytes to be written on
- * the next call to the stream's async_write_some function.
- *
- * @param handler The handler to be called when the write operation completes.
- * Copies will be made of the handler as required. The function signature of the
- * handler must be:
- * @code void handler(
- *   const asio::error_code& error, // Result of operation.
- *
- *   std::size_t bytes_transferred           // Number of bytes written from the
- *                                           // buffers. If an error occurred,
- *                                           // this will be less than the sum
- *                                           // of the buffer sizes.
- * ); @endcode
- * Regardless of whether the asynchronous operation completes immediately or
- * not, the handler will not be invoked from within this function. Invocation of
- * the handler will be performed in a manner equivalent to using
- * asio::io_service::post().
- *
- * @par Example
- * To write a single data buffer use the @ref buffer function as follows:
- * @code asio::async_write(s,
- *     asio::buffer(data, size),
- *     asio::transfer_at_least(32),
- *     handler); @endcode
- * See the @ref buffer documentation for information on writing multiple
- * buffers in one go, and how to use it with arrays, boost::array or
- * std::vector.
- */
-template <typename AsyncWriteStream, typename ConstBufferSequence,
-    typename CompletionCondition, typename WriteHandler>
-ASIO_INITFN_RESULT_TYPE(WriteHandler,
-    void (asio::error_code, std::size_t))
-async_write(AsyncWriteStream& s, const ConstBufferSequence& buffers,
-    CompletionCondition completion_condition,
-    ASIO_MOVE_ARG(WriteHandler) handler);
-
-#if !defined(ASIO_NO_IOSTREAM)
-
-/// Start an asynchronous operation to write all of the supplied data to a
-/// stream.
-/**
- * This function is used to asynchronously write a certain number of bytes of
- * data to a stream. The function call always returns immediately. The
- * asynchronous operation will continue until one of the following conditions
- * is true:
- *
- * @li All of the data in the supplied basic_streambuf has been written.
- *
- * @li An error occurred.
- *
- * This operation is implemented in terms of zero or more calls to the stream's
- * async_write_some function, and is known as a <em>composed operation</em>. The
- * program must ensure that the stream performs no other write operations (such
- * as async_write, the stream's async_write_some function, or any other composed
- * operations that perform writes) until this operation completes.
- *
- * @param s The stream to which the data is to be written. The type must support
- * the AsyncWriteStream concept.
- *
- * @param b A basic_streambuf object from which data will be written. Ownership
- * of the streambuf is retained by the caller, which must guarantee that it
- * remains valid until the handler is called.
- *
- * @param handler The handler to be called when the write operation completes.
- * Copies will be made of the handler as required. The function signature of the
- * handler must be:
- * @code void handler(
- *   const asio::error_code& error, // Result of operation.
- *
- *   std::size_t bytes_transferred           // Number of bytes written from the
- *                                           // buffers. If an error occurred,
- *                                           // this will be less than the sum
- *                                           // of the buffer sizes.
- * ); @endcode
- * Regardless of whether the asynchronous operation completes immediately or
- * not, the handler will not be invoked from within this function. Invocation of
- * the handler will be performed in a manner equivalent to using
- * asio::io_service::post().
- */
-template <typename AsyncWriteStream, typename Allocator, typename WriteHandler>
-ASIO_INITFN_RESULT_TYPE(WriteHandler,
-    void (asio::error_code, std::size_t))
-async_write(AsyncWriteStream& s, basic_streambuf<Allocator>& b,
-    ASIO_MOVE_ARG(WriteHandler) handler);
-
-/// Start an asynchronous operation to write a certain amount of data to a
-/// stream.
-/**
- * This function is used to asynchronously write a certain number of bytes of
- * data to a stream. The function call always returns immediately. The
- * asynchronous operation will continue until one of the following conditions
- * is true:
- *
- * @li All of the data in the supplied basic_streambuf has been written.
- *
- * @li The completion_condition function object returns 0.
- *
- * This operation is implemented in terms of zero or more calls to the stream's
- * async_write_some function, and is known as a <em>composed operation</em>. The
- * program must ensure that the stream performs no other write operations (such
- * as async_write, the stream's async_write_some function, or any other composed
- * operations that perform writes) until this operation completes.
- *
- * @param s The stream to which the data is to be written. The type must support
- * the AsyncWriteStream concept.
- *
- * @param b A basic_streambuf object from which data will be written. Ownership
- * of the streambuf is retained by the caller, which must guarantee that it
- * remains valid until the handler is called.
- *
- * @param completion_condition The function object to be called to determine
- * whether the write operation is complete. The signature of the function object
- * must be:
- * @code std::size_t completion_condition(
- *   // Result of latest async_write_some operation.
- *   const asio::error_code& error,
- *
- *   // Number of bytes transferred so far.
- *   std::size_t bytes_transferred
- * ); @endcode
- * A return value of 0 indicates that the write operation is complete. A
- * non-zero return value indicates the maximum number of bytes to be written on
- * the next call to the stream's async_write_some function.
- *
- * @param handler The handler to be called when the write operation completes.
- * Copies will be made of the handler as required. The function signature of the
- * handler must be:
- * @code void handler(
- *   const asio::error_code& error, // Result of operation.
- *
- *   std::size_t bytes_transferred           // Number of bytes written from the
- *                                           // buffers. If an error occurred,
- *                                           // this will be less than the sum
- *                                           // of the buffer sizes.
- * ); @endcode
- * Regardless of whether the asynchronous operation completes immediately or
- * not, the handler will not be invoked from within this function. Invocation of
- * the handler will be performed in a manner equivalent to using
- * asio::io_service::post().
- */
-template <typename AsyncWriteStream, typename Allocator,
-    typename CompletionCondition, typename WriteHandler>
-ASIO_INITFN_RESULT_TYPE(WriteHandler,
-    void (asio::error_code, std::size_t))
-async_write(AsyncWriteStream& s, basic_streambuf<Allocator>& b,
-    CompletionCondition completion_condition,
-    ASIO_MOVE_ARG(WriteHandler) handler);
-
-#endif // !defined(ASIO_NO_IOSTREAM)
-
-/*@}*/
-
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#include "asio/impl/write.hpp"
-
-#endif // ASIO_WRITE_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/write_at.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/write_at.hpp
deleted file mode 100644
index 103c7e2b7ace..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/write_at.hpp
+++ /dev/null
@@ -1,670 +0,0 @@
-//
-// write_at.hpp
-// ~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#ifndef ASIO_WRITE_AT_HPP
-#define ASIO_WRITE_AT_HPP
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1200)
-# pragma once
-#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
-
-#include "asio/detail/config.hpp"
-#include <cstddef>
-#include "asio/async_result.hpp"
-#include "asio/basic_streambuf_fwd.hpp"
-#include "asio/detail/cstdint.hpp"
-#include "asio/error.hpp"
-
-#include "asio/detail/push_options.hpp"
-
-namespace asio {
-
-/**
- * @defgroup write_at asio::write_at
- *
- * @brief Write a certain amount of data at a specified offset before returning.
- */
-/*@{*/
-
-/// Write all of the supplied data at the specified offset before returning.
-/**
- * This function is used to write a certain number of bytes of data to a random
- * access device at a specified offset. The call will block until one of the
- * following conditions is true:
- *
- * @li All of the data in the supplied buffers has been written. That is, the
- * bytes transferred is equal to the sum of the buffer sizes.
- *
- * @li An error occurred.
- *
- * This operation is implemented in terms of zero or more calls to the device's
- * write_some_at function.
- *
- * @param d The device to which the data is to be written. The type must support
- * the SyncRandomAccessWriteDevice concept.
- *
- * @param offset The offset at which the data will be written.
- *
- * @param buffers One or more buffers containing the data to be written. The sum
- * of the buffer sizes indicates the maximum number of bytes to write to the
- * device.
- *
- * @returns The number of bytes transferred.
- *
- * @throws asio::system_error Thrown on failure.
- *
- * @par Example
- * To write a single data buffer use the @ref buffer function as follows:
- * @code asio::write_at(d, 42, asio::buffer(data, size)); @endcode
- * See the @ref buffer documentation for information on writing multiple
- * buffers in one go, and how to use it with arrays, boost::array or
- * std::vector.
- *
- * @note This overload is equivalent to calling:
- * @code asio::write_at(
- *     d, offset, buffers,
- *     asio::transfer_all()); @endcode
- */
-template <typename SyncRandomAccessWriteDevice, typename ConstBufferSequence>
-std::size_t write_at(SyncRandomAccessWriteDevice& d,
-    uint64_t offset, const ConstBufferSequence& buffers);
-
-/// Write all of the supplied data at the specified offset before returning.
-/**
- * This function is used to write a certain number of bytes of data to a random
- * access device at a specified offset. The call will block until one of the
- * following conditions is true:
- *
- * @li All of the data in the supplied buffers has been written. That is, the
- * bytes transferred is equal to the sum of the buffer sizes.
- *
- * @li An error occurred.
- *
- * This operation is implemented in terms of zero or more calls to the device's
- * write_some_at function.
- *
- * @param d The device to which the data is to be written. The type must support
- * the SyncRandomAccessWriteDevice concept.
- *
- * @param offset The offset at which the data will be written.
- *
- * @param buffers One or more buffers containing the data to be written. The sum
- * of the buffer sizes indicates the maximum number of bytes to write to the
- * device.
- *
- * @param ec Set to indicate what error occurred, if any.
- *
- * @returns The number of bytes transferred.
- *
- * @par Example
- * To write a single data buffer use the @ref buffer function as follows:
- * @code asio::write_at(d, 42,
- *     asio::buffer(data, size), ec); @endcode
- * See the @ref buffer documentation for information on writing multiple
- * buffers in one go, and how to use it with arrays, boost::array or
- * std::vector.
- *
- * @note This overload is equivalent to calling:
- * @code asio::write_at(
- *     d, offset, buffers,
- *     asio::transfer_all(), ec); @endcode
- */
-template <typename SyncRandomAccessWriteDevice, typename ConstBufferSequence>
-std::size_t write_at(SyncRandomAccessWriteDevice& d,
-    uint64_t offset, const ConstBufferSequence& buffers,
-    asio::error_code& ec);
-
-/// Write a certain amount of data at a specified offset before returning.
-/**
- * This function is used to write a certain number of bytes of data to a random
- * access device at a specified offset. The call will block until one of the
- * following conditions is true:
- *
- * @li All of the data in the supplied buffers has been written. That is, the
- * bytes transferred is equal to the sum of the buffer sizes.
- *
- * @li The completion_condition function object returns 0.
- *
- * This operation is implemented in terms of zero or more calls to the device's
- * write_some_at function.
- *
- * @param d The device to which the data is to be written. The type must support
- * the SyncRandomAccessWriteDevice concept.
- *
- * @param offset The offset at which the data will be written.
- *
- * @param buffers One or more buffers containing the data to be written. The sum
- * of the buffer sizes indicates the maximum number of bytes to write to the
- * device.
- *
- * @param completion_condition The function object to be called to determine
- * whether the write operation is complete. The signature of the function object
- * must be:
- * @code std::size_t completion_condition(
- *   // Result of latest write_some_at operation.
- *   const asio::error_code& error,
- *
- *   // Number of bytes transferred so far.
- *   std::size_t bytes_transferred
- * ); @endcode
- * A return value of 0 indicates that the write operation is complete. A
- * non-zero return value indicates the maximum number of bytes to be written on
- * the next call to the device's write_some_at function.
- *
- * @returns The number of bytes transferred.
- *
- * @throws asio::system_error Thrown on failure.
- *
- * @par Example
- * To write a single data buffer use the @ref buffer function as follows:
- * @code asio::write_at(d, 42, asio::buffer(data, size),
- *     asio::transfer_at_least(32)); @endcode
- * See the @ref buffer documentation for information on writing multiple
- * buffers in one go, and how to use it with arrays, boost::array or
- * std::vector.
- */
-template <typename SyncRandomAccessWriteDevice, typename ConstBufferSequence,
-    typename CompletionCondition>
-std::size_t write_at(SyncRandomAccessWriteDevice& d,
-    uint64_t offset, const ConstBufferSequence& buffers,
-    CompletionCondition completion_condition);
-
-/// Write a certain amount of data at a specified offset before returning.
-/**
- * This function is used to write a certain number of bytes of data to a random
- * access device at a specified offset. The call will block until one of the
- * following conditions is true:
- *
- * @li All of the data in the supplied buffers has been written. That is, the
- * bytes transferred is equal to the sum of the buffer sizes.
- *
- * @li The completion_condition function object returns 0.
- *
- * This operation is implemented in terms of zero or more calls to the device's
- * write_some_at function.
- *
- * @param d The device to which the data is to be written. The type must support
- * the SyncRandomAccessWriteDevice concept.
- *
- * @param offset The offset at which the data will be written.
- *
- * @param buffers One or more buffers containing the data to be written. The sum
- * of the buffer sizes indicates the maximum number of bytes to write to the
- * device.
- *
- * @param completion_condition The function object to be called to determine
- * whether the write operation is complete. The signature of the function object
- * must be:
- * @code std::size_t completion_condition(
- *   // Result of latest write_some_at operation.
- *   const asio::error_code& error,
- *
- *   // Number of bytes transferred so far.
- *   std::size_t bytes_transferred
- * ); @endcode
- * A return value of 0 indicates that the write operation is complete. A
- * non-zero return value indicates the maximum number of bytes to be written on
- * the next call to the device's write_some_at function.
- *
- * @param ec Set to indicate what error occurred, if any.
- *
- * @returns The number of bytes written. If an error occurs, returns the total
- * number of bytes successfully transferred prior to the error.
- */
-template <typename SyncRandomAccessWriteDevice, typename ConstBufferSequence,
-    typename CompletionCondition>
-std::size_t write_at(SyncRandomAccessWriteDevice& d,
-    uint64_t offset, const ConstBufferSequence& buffers,
-    CompletionCondition completion_condition, asio::error_code& ec);
-
-#if !defined(ASIO_NO_IOSTREAM)
-
-/// Write all of the supplied data at the specified offset before returning.
-/**
- * This function is used to write a certain number of bytes of data to a random
- * access device at a specified offset. The call will block until one of the
- * following conditions is true:
- *
- * @li All of the data in the supplied basic_streambuf has been written.
- *
- * @li An error occurred.
- *
- * This operation is implemented in terms of zero or more calls to the device's
- * write_some_at function.
- *
- * @param d The device to which the data is to be written. The type must support
- * the SyncRandomAccessWriteDevice concept.
- *
- * @param offset The offset at which the data will be written.
- *
- * @param b The basic_streambuf object from which data will be written.
- *
- * @returns The number of bytes transferred.
- *
- * @throws asio::system_error Thrown on failure.
- *
- * @note This overload is equivalent to calling:
- * @code asio::write_at(
- *     d, 42, b,
- *     asio::transfer_all()); @endcode
- */
-template <typename SyncRandomAccessWriteDevice, typename Allocator>
-std::size_t write_at(SyncRandomAccessWriteDevice& d,
-    uint64_t offset, basic_streambuf<Allocator>& b);
-
-/// Write all of the supplied data at the specified offset before returning.
-/**
- * This function is used to write a certain number of bytes of data to a random
- * access device at a specified offset. The call will block until one of the
- * following conditions is true:
- *
- * @li All of the data in the supplied basic_streambuf has been written.
- *
- * @li An error occurred.
- *
- * This operation is implemented in terms of zero or more calls to the device's
- * write_some_at function.
- *
- * @param d The device to which the data is to be written. The type must support
- * the SyncRandomAccessWriteDevice concept.
- *
- * @param offset The offset at which the data will be written.
- *
- * @param b The basic_streambuf object from which data will be written.
- *
- * @param ec Set to indicate what error occurred, if any.
- *
- * @returns The number of bytes transferred.
- *
- * @note This overload is equivalent to calling:
- * @code asio::write_at(
- *     d, 42, b,
- *     asio::transfer_all(), ec); @endcode
- */
-template <typename SyncRandomAccessWriteDevice, typename Allocator>
-std::size_t write_at(SyncRandomAccessWriteDevice& d,
-    uint64_t offset, basic_streambuf<Allocator>& b,
-    asio::error_code& ec);
-
-/// Write a certain amount of data at a specified offset before returning.
-/**
- * This function is used to write a certain number of bytes of data to a random
- * access device at a specified offset. The call will block until one of the
- * following conditions is true:
- *
- * @li All of the data in the supplied basic_streambuf has been written.
- *
- * @li The completion_condition function object returns 0.
- *
- * This operation is implemented in terms of zero or more calls to the device's
- * write_some_at function.
- *
- * @param d The device to which the data is to be written. The type must support
- * the SyncRandomAccessWriteDevice concept.
- *
- * @param offset The offset at which the data will be written.
- *
- * @param b The basic_streambuf object from which data will be written.
- *
- * @param completion_condition The function object to be called to determine
- * whether the write operation is complete. The signature of the function object
- * must be:
- * @code std::size_t completion_condition(
- *   // Result of latest write_some_at operation.
- *   const asio::error_code& error,
- *
- *   // Number of bytes transferred so far.
- *   std::size_t bytes_transferred
- * ); @endcode
- * A return value of 0 indicates that the write operation is complete. A
- * non-zero return value indicates the maximum number of bytes to be written on
- * the next call to the device's write_some_at function.
- *
- * @returns The number of bytes transferred.
- *
- * @throws asio::system_error Thrown on failure.
- */
-template <typename SyncRandomAccessWriteDevice, typename Allocator,
-    typename CompletionCondition>
-std::size_t write_at(SyncRandomAccessWriteDevice& d, uint64_t offset,
-    basic_streambuf<Allocator>& b, CompletionCondition completion_condition);
-
-/// Write a certain amount of data at a specified offset before returning.
-/**
- * This function is used to write a certain number of bytes of data to a random
- * access device at a specified offset. The call will block until one of the
- * following conditions is true:
- *
- * @li All of the data in the supplied basic_streambuf has been written.
- *
- * @li The completion_condition function object returns 0.
- *
- * This operation is implemented in terms of zero or more calls to the device's
- * write_some_at function.
- *
- * @param d The device to which the data is to be written. The type must support
- * the SyncRandomAccessWriteDevice concept.
- *
- * @param offset The offset at which the data will be written.
- *
- * @param b The basic_streambuf object from which data will be written.
- *
- * @param completion_condition The function object to be called to determine
- * whether the write operation is complete. The signature of the function object
- * must be:
- * @code std::size_t completion_condition(
- *   // Result of latest write_some_at operation.
- *   const asio::error_code& error,
- *
- *   // Number of bytes transferred so far.
- *   std::size_t bytes_transferred
- * ); @endcode
- * A return value of 0 indicates that the write operation is complete. A
- * non-zero return value indicates the maximum number of bytes to be written on
- * the next call to the device's write_some_at function.
- *
- * @param ec Set to indicate what error occurred, if any.
- *
- * @returns The number of bytes written. If an error occurs, returns the total
- * number of bytes successfully transferred prior to the error.
- */
-template <typename SyncRandomAccessWriteDevice, typename Allocator,
-    typename CompletionCondition>
-std::size_t write_at(SyncRandomAccessWriteDevice& d, uint64_t offset,
-    basic_streambuf<Allocator>& b, CompletionCondition completion_condition,
-    asio::error_code& ec);
-
-#endif // !defined(ASIO_NO_IOSTREAM)
-
-/*@}*/
-/**
- * @defgroup async_write_at asio::async_write_at
- *
- * @brief Start an asynchronous operation to write a certain amount of data at
- * the specified offset.
- */
-/*@{*/
-
-/// Start an asynchronous operation to write all of the supplied data at the
-/// specified offset.
-/**
- * This function is used to asynchronously write a certain number of bytes of
- * data to a random access device at a specified offset. The function call
- * always returns immediately. The asynchronous operation will continue until
- * one of the following conditions is true:
- *
- * @li All of the data in the supplied buffers has been written. That is, the
- * bytes transferred is equal to the sum of the buffer sizes.
- *
- * @li An error occurred.
- *
- * This operation is implemented in terms of zero or more calls to the device's
- * async_write_some_at function, and is known as a <em>composed operation</em>.
- * The program must ensure that the device performs no <em>overlapping</em>
- * write operations (such as async_write_at, the device's async_write_some_at
- * function, or any other composed operations that perform writes) until this
- * operation completes. Operations are overlapping if the regions defined by
- * their offsets, and the numbers of bytes to write, intersect.
- *
- * @param d The device to which the data is to be written. The type must support
- * the AsyncRandomAccessWriteDevice concept.
- *
- * @param offset The offset at which the data will be written.
- *
- * @param buffers One or more buffers containing the data to be written.
- * Although the buffers object may be copied as necessary, ownership of the
- * underlying memory blocks is retained by the caller, which must guarantee
- * that they remain valid until the handler is called.
- *
- * @param handler The handler to be called when the write operation completes.
- * Copies will be made of the handler as required. The function signature of
- * the handler must be:
- * @code void handler(
- *   // Result of operation.
- *   const asio::error_code& error,
- *
- *   // Number of bytes written from the buffers. If an error
- *   // occurred, this will be less than the sum of the buffer sizes.
- *   std::size_t bytes_transferred
- * ); @endcode
- * Regardless of whether the asynchronous operation completes immediately or
- * not, the handler will not be invoked from within this function. Invocation of
- * the handler will be performed in a manner equivalent to using
- * asio::io_service::post().
- *
- * @par Example
- * To write a single data buffer use the @ref buffer function as follows:
- * @code
- * asio::async_write_at(d, 42, asio::buffer(data, size), handler);
- * @endcode
- * See the @ref buffer documentation for information on writing multiple
- * buffers in one go, and how to use it with arrays, boost::array or
- * std::vector.
- */
-template <typename AsyncRandomAccessWriteDevice, typename ConstBufferSequence,
-    typename WriteHandler>
-ASIO_INITFN_RESULT_TYPE(WriteHandler,
-    void (asio::error_code, std::size_t))
-async_write_at(AsyncRandomAccessWriteDevice& d, uint64_t offset,
-    const ConstBufferSequence& buffers,
-    ASIO_MOVE_ARG(WriteHandler) handler);
-
-/// Start an asynchronous operation to write a certain amount of data at the
-/// specified offset.
-/**
- * This function is used to asynchronously write a certain number of bytes of
- * data to a random access device at a specified offset. The function call
- * always returns immediately. The asynchronous operation will continue until
- * one of the following conditions is true:
- *
- * @li All of the data in the supplied buffers has been written. That is, the
- * bytes transferred is equal to the sum of the buffer sizes.
- *
- * @li The completion_condition function object returns 0.
- *
- * This operation is implemented in terms of zero or more calls to the device's
- * async_write_some_at function, and is known as a <em>composed operation</em>.
- * The program must ensure that the device performs no <em>overlapping</em>
- * write operations (such as async_write_at, the device's async_write_some_at
- * function, or any other composed operations that perform writes) until this
- * operation completes. Operations are overlapping if the regions defined by
- * their offsets, and the numbers of bytes to write, intersect.
- *
- * @param d The device to which the data is to be written. The type must support
- * the AsyncRandomAccessWriteDevice concept.
- *
- * @param offset The offset at which the data will be written.
- *
- * @param buffers One or more buffers containing the data to be written.
- * Although the buffers object may be copied as necessary, ownership of the
- * underlying memory blocks is retained by the caller, which must guarantee
- * that they remain valid until the handler is called.
- *
- * @param completion_condition The function object to be called to determine
- * whether the write operation is complete. The signature of the function object
- * must be:
- * @code std::size_t completion_condition(
- *   // Result of latest async_write_some_at operation.
- *   const asio::error_code& error,
- *
- *   // Number of bytes transferred so far.
- *   std::size_t bytes_transferred
- * ); @endcode
- * A return value of 0 indicates that the write operation is complete. A
- * non-zero return value indicates the maximum number of bytes to be written on
- * the next call to the device's async_write_some_at function.
- *
- * @param handler The handler to be called when the write operation completes.
- * Copies will be made of the handler as required. The function signature of the
- * handler must be:
- * @code void handler(
- *   // Result of operation.
- *   const asio::error_code& error,
- *
- *   // Number of bytes written from the buffers. If an error
- *   // occurred, this will be less than the sum of the buffer sizes.
- *   std::size_t bytes_transferred
- * ); @endcode
- * Regardless of whether the asynchronous operation completes immediately or
- * not, the handler will not be invoked from within this function. Invocation of
- * the handler will be performed in a manner equivalent to using
- * asio::io_service::post().
- *
- * @par Example
- * To write a single data buffer use the @ref buffer function as follows:
- * @code asio::async_write_at(d, 42,
- *     asio::buffer(data, size),
- *     asio::transfer_at_least(32),
- *     handler); @endcode
- * See the @ref buffer documentation for information on writing multiple
- * buffers in one go, and how to use it with arrays, boost::array or
- * std::vector.
- */
-template <typename AsyncRandomAccessWriteDevice, typename ConstBufferSequence,
-    typename CompletionCondition, typename WriteHandler>
-ASIO_INITFN_RESULT_TYPE(WriteHandler,
-    void (asio::error_code, std::size_t))
-async_write_at(AsyncRandomAccessWriteDevice& d,
-    uint64_t offset, const ConstBufferSequence& buffers,
-    CompletionCondition completion_condition,
-    ASIO_MOVE_ARG(WriteHandler) handler);
-
-#if !defined(ASIO_NO_IOSTREAM)
-
-/// Start an asynchronous operation to write all of the supplied data at the
-/// specified offset.
-/**
- * This function is used to asynchronously write a certain number of bytes of
- * data to a random access device at a specified offset. The function call
- * always returns immediately. The asynchronous operation will continue until
- * one of the following conditions is true:
- *
- * @li All of the data in the supplied basic_streambuf has been written.
- *
- * @li An error occurred.
- *
- * This operation is implemented in terms of zero or more calls to the device's
- * async_write_some_at function, and is known as a <em>composed operation</em>.
- * The program must ensure that the device performs no <em>overlapping</em>
- * write operations (such as async_write_at, the device's async_write_some_at
- * function, or any other composed operations that perform writes) until this
- * operation completes. Operations are overlapping if the regions defined by
- * their offsets, and the numbers of bytes to write, intersect.
- *
- * @param d The device to which the data is to be written. The type must support
- * the AsyncRandomAccessWriteDevice concept.
- *
- * @param offset The offset at which the data will be written.
- *
- * @param b A basic_streambuf object from which data will be written. Ownership
- * of the streambuf is retained by the caller, which must guarantee that it
- * remains valid until the handler is called.
- *
- * @param handler The handler to be called when the write operation completes.
- * Copies will be made of the handler as required. The function signature of the
- * handler must be:
- * @code void handler(
- *   // Result of operation.
- *   const asio::error_code& error,
- *
- *   // Number of bytes written from the buffers. If an error
- *   // occurred, this will be less than the sum of the buffer sizes.
- *   std::size_t bytes_transferred
- * ); @endcode
- * Regardless of whether the asynchronous operation completes immediately or
- * not, the handler will not be invoked from within this function. Invocation of
- * the handler will be performed in a manner equivalent to using
- * asio::io_service::post().
- */
-template <typename AsyncRandomAccessWriteDevice, typename Allocator,
-    typename WriteHandler>
-ASIO_INITFN_RESULT_TYPE(WriteHandler,
-    void (asio::error_code, std::size_t))
-async_write_at(AsyncRandomAccessWriteDevice& d, uint64_t offset,
-    basic_streambuf<Allocator>& b, ASIO_MOVE_ARG(WriteHandler) handler);
-
-/// Start an asynchronous operation to write a certain amount of data at the
-/// specified offset.
-/**
- * This function is used to asynchronously write a certain number of bytes of
- * data to a random access device at a specified offset. The function call
- * always returns immediately. The asynchronous operation will continue until
- * one of the following conditions is true:
- *
- * @li All of the data in the supplied basic_streambuf has been written.
- *
- * @li The completion_condition function object returns 0.
- *
- * This operation is implemented in terms of zero or more calls to the device's
- * async_write_some_at function, and is known as a <em>composed operation</em>.
- * The program must ensure that the device performs no <em>overlapping</em>
- * write operations (such as async_write_at, the device's async_write_some_at
- * function, or any other composed operations that perform writes) until this
- * operation completes. Operations are overlapping if the regions defined by
- * their offsets, and the numbers of bytes to write, intersect.
- *
- * @param d The device to which the data is to be written. The type must support
- * the AsyncRandomAccessWriteDevice concept.
- *
- * @param offset The offset at which the data will be written.
- *
- * @param b A basic_streambuf object from which data will be written. Ownership
- * of the streambuf is retained by the caller, which must guarantee that it
- * remains valid until the handler is called.
- *
- * @param completion_condition The function object to be called to determine
- * whether the write operation is complete. The signature of the function object
- * must be:
- * @code std::size_t completion_condition(
- *   // Result of latest async_write_some_at operation.
- *   const asio::error_code& error,
- *
- *   // Number of bytes transferred so far.
- *   std::size_t bytes_transferred
- * ); @endcode
- * A return value of 0 indicates that the write operation is complete. A
- * non-zero return value indicates the maximum number of bytes to be written on
- * the next call to the device's async_write_some_at function.
- *
- * @param handler The handler to be called when the write operation completes.
- * Copies will be made of the handler as required. The function signature of the
- * handler must be:
- * @code void handler(
- *   // Result of operation.
- *   const asio::error_code& error,
- *
- *   // Number of bytes written from the buffers. If an error
- *   // occurred, this will be less than the sum of the buffer sizes.
- *   std::size_t bytes_transferred
- * ); @endcode
- * Regardless of whether the asynchronous operation completes immediately or
- * not, the handler will not be invoked from within this function. Invocation of
- * the handler will be performed in a manner equivalent to using
- * asio::io_service::post().
- */
-template <typename AsyncRandomAccessWriteDevice, typename Allocator,
-    typename CompletionCondition, typename WriteHandler>
-ASIO_INITFN_RESULT_TYPE(WriteHandler,
-    void (asio::error_code, std::size_t))
-async_write_at(AsyncRandomAccessWriteDevice& d, uint64_t offset,
-    basic_streambuf<Allocator>& b, CompletionCondition completion_condition,
-    ASIO_MOVE_ARG(WriteHandler) handler);
-
-#endif // !defined(ASIO_NO_IOSTREAM)
-
-/*@}*/
-
-} // namespace asio
-
-#include "asio/detail/pop_options.hpp"
-
-#include "asio/impl/write_at.hpp"
-
-#endif // ASIO_WRITE_AT_HPP
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/yield.hpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/yield.hpp
deleted file mode 100644
index b8d2cc1f99fb..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/include/asio/yield.hpp
+++ /dev/null
@@ -1,23 +0,0 @@
-//
-// yield.hpp
-// ~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#include "coroutine.hpp"
-
-#ifndef reenter
-# define reenter(c) ASIO_CORO_REENTER(c)
-#endif
-
-#ifndef yield
-# define yield ASIO_CORO_YIELD
-#endif
-
-#ifndef fork
-# define fork ASIO_CORO_FORK
-#endif
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/src/asio.cpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/src/asio.cpp
deleted file mode 100644
index 35218a47c048..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/src/asio.cpp
+++ /dev/null
@@ -1,11 +0,0 @@
-//
-// asio.cpp
-// ~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#include "asio/impl/src.hpp"
diff --git a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/src/asio_ssl.cpp b/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/src/asio_ssl.cpp
deleted file mode 100644
index c45b03f2c033..000000000000
--- a/hadoop-hdfs-project/hadoop-hdfs-native-client/src/main/native/libhdfspp/third_party/asio-1.10.2/src/asio_ssl.cpp
+++ /dev/null
@@ -1,11 +0,0 @@
-//
-// asio_ssl.cpp
-// ~~~~~~~~~~~~
-//
-// Copyright (c) 2003-2014 Christopher M. Kohlhoff (chris at kohlhoff dot com)
-//
-// Distributed under the Boost Software License, Version 1.0. (See accompanying
-// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-#include "asio/ssl/impl/src.hpp"
